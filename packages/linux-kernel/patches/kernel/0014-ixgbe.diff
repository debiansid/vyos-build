diff --git a/drivers/net/ethernet/intel/ixgbe/Makefile b/drivers/net/ethernet/intel/ixgbe/Makefile
index 4fb0d9e3f2da..bca938c9d098 100644
--- a/drivers/net/ethernet/intel/ixgbe/Makefile
+++ b/drivers/net/ethernet/intel/ixgbe/Makefile
@@ -6,15 +6,29 @@
 
 obj-$(CONFIG_IXGBE) += ixgbe.o
 
-ixgbe-objs := ixgbe_main.o ixgbe_common.o ixgbe_ethtool.o \
-              ixgbe_82599.o ixgbe_82598.o ixgbe_phy.o ixgbe_sriov.o \
-              ixgbe_mbx.o ixgbe_x540.o ixgbe_x550.o ixgbe_lib.o ixgbe_ptp.o \
-              ixgbe_xsk.o
-
-ixgbe-$(CONFIG_IXGBE_DCB) +=  ixgbe_dcb.o ixgbe_dcb_82598.o \
-                              ixgbe_dcb_82599.o ixgbe_dcb_nl.o
-
-ixgbe-$(CONFIG_IXGBE_HWMON) += ixgbe_sysfs.o
-ixgbe-$(CONFIG_DEBUG_FS) += ixgbe_debugfs.o
-ixgbe-$(CONFIG_FCOE:m=y) += ixgbe_fcoe.o
-ixgbe-$(CONFIG_IXGBE_IPSEC) += ixgbe_ipsec.o
+define ixgbe-y
+	ixgbe_main.o
+	ixgbe_api.o
+	ixgbe_common.o
+	ixgbe_dcb.o
+	ixgbe_dcb_82598.o
+	ixgbe_dcb_82599.o
+	ixgbe_ethtool.o
+	ixgbe_lib.o
+	ixgbe_mbx.o
+	ixgbe_sriov.o
+	ixgbe_param.o
+	ixgbe_phy.o
+	ixgbe_procfs.o
+	ixgbe_xsk.o
+	ixgbe_82598.o
+	ixgbe_82599.o
+	ixgbe_x540.o
+	ixgbe_x550.o
+	ixgbe_dcb_nl.o
+	ixgbe_debugfs.o
+	ixgbe_fcoe.o
+	ixgbe_ptp.o
+	ixgbe_sysfs.o
+endef
+ixgbe-y += kcompat.o
diff --git a/drivers/net/ethernet/intel/ixgbe/Module.supported b/drivers/net/ethernet/intel/ixgbe/Module.supported
new file mode 100644
index 000000000000..af2479647951
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/Module.supported
@@ -0,0 +1 @@
+ixgbe.ko external
diff --git a/drivers/net/ethernet/intel/ixgbe/common.mk b/drivers/net/ethernet/intel/ixgbe/common.mk
new file mode 100644
index 000000000000..3232b25d3e29
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/common.mk
@@ -0,0 +1,348 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright(c) 1999 - 2020 Intel Corporation.
+
+#
+# common Makefile rules useful for out-of-tree Linux driver builds
+#
+# Usage: include common.mk
+#
+# After including, you probably want to add a minimum_kver_check call
+#
+# Required Variables:
+# DRIVER
+#   -- Set to the lowercase driver name
+
+#####################
+# Helpful functions #
+#####################
+
+readlink = $(shell readlink -f ${1})
+
+# helper functions for converting kernel version to version codes
+get_kver = $(or $(word ${2},$(subst ., ,${1})),0)
+get_kvercode = $(shell [ "${1}" -ge 0 -a "${1}" -le 255 2>/dev/null ] && \
+                       [ "${2}" -ge 0 -a "${2}" -le 255 2>/dev/null ] && \
+                       [ "${3}" -ge 0 -a "${3}" -le 255 2>/dev/null ] && \
+                       printf %d $$(( ( ${1} << 16 ) + ( ${2} << 8 ) + ( ${3} ) )) )
+
+################
+# depmod Macro #
+################
+
+cmd_depmod = /sbin/depmod $(if ${SYSTEM_MAP_FILE},-e -F ${SYSTEM_MAP_FILE}) \
+                          $(if $(strip ${INSTALL_MOD_PATH}),-b ${INSTALL_MOD_PATH}) \
+                          -a ${KVER}
+
+################
+# dracut Macro #
+################
+
+cmd_initrd := $(shell \
+                if which dracut > /dev/null 2>&1 ; then \
+                    echo "dracut --force"; \
+                elif which update-initramfs > /dev/null 2>&1 ; then \
+                    echo "update-initramfs -u"; \
+                fi )
+
+#####################
+# Environment tests #
+#####################
+
+DRIVER_UPPERCASE := $(shell echo ${DRIVER} | tr "[:lower:]" "[:upper:]")
+
+ifeq (,${BUILD_KERNEL})
+BUILD_KERNEL=$(shell uname -r)
+endif
+
+# Kernel Search Path
+# All the places we look for kernel source
+KSP :=  /lib/modules/${BUILD_KERNEL}/source \
+        /lib/modules/${BUILD_KERNEL}/build \
+        /usr/src/linux-${BUILD_KERNEL} \
+        /usr/src/linux-$(${BUILD_KERNEL} | sed 's/-.*//') \
+        /usr/src/kernel-headers-${BUILD_KERNEL} \
+        /usr/src/kernel-source-${BUILD_KERNEL} \
+        /usr/src/linux-$(${BUILD_KERNEL} | sed 's/\([0-9]*\.[0-9]*\)\..*/\1/') \
+        /usr/src/linux \
+        /usr/src/kernels/${BUILD_KERNEL} \
+        /usr/src/kernels
+
+# prune the list down to only values that exist and have an include/linux
+# sub-directory. We can't use include/config because some older kernels don't
+# have this.
+test_dir = $(shell [ -e ${dir}/include/linux ] && echo ${dir})
+KSP := $(foreach dir, ${KSP}, ${test_dir})
+
+# we will use this first valid entry in the search path
+ifeq (,${KSRC})
+  KSRC := $(firstword ${KSP})
+endif
+
+ifeq (,${KSRC})
+  $(warning *** Kernel header files not in any of the expected locations.)
+  $(warning *** Install the appropriate kernel development package, e.g.)
+  $(error kernel-devel, for building kernel modules and try again)
+else
+ifeq (/lib/modules/${BUILD_KERNEL}/source, ${KSRC})
+  KOBJ :=  /lib/modules/${BUILD_KERNEL}/build
+else
+  KOBJ :=  ${KSRC}
+endif
+endif
+
+# Version file Search Path
+VSP :=  ${KOBJ}/include/generated/utsrelease.h \
+        ${KOBJ}/include/linux/utsrelease.h \
+        ${KOBJ}/include/linux/version.h \
+        ${KOBJ}/include/generated/uapi/linux/version.h \
+        /boot/vmlinuz.version.h
+
+# Config file Search Path
+CSP :=  ${KOBJ}/include/generated/autoconf.h \
+        ${KOBJ}/include/linux/autoconf.h \
+        /boot/vmlinuz.autoconf.h
+
+# System.map Search Path (for depmod)
+MSP := ${KSRC}/System.map \
+       /boot/System.map-${BUILD_KERNEL}
+
+# prune the lists down to only files that exist
+test_file = $(shell [ -f ${file} ] && echo ${file})
+VSP := $(foreach file, ${VSP}, ${test_file})
+CSP := $(foreach file, ${CSP}, ${test_file})
+MSP := $(foreach file, ${MSP}, ${test_file})
+
+
+# and use the first valid entry in the Search Paths
+ifeq (,${VERSION_FILE})
+  VERSION_FILE := $(firstword ${VSP})
+endif
+
+ifeq (,${CONFIG_FILE})
+  CONFIG_FILE := $(firstword ${CSP})
+endif
+
+ifeq (,${SYSTEM_MAP_FILE})
+  SYSTEM_MAP_FILE := $(firstword ${MSP})
+endif
+
+ifeq (,$(wildcard ${VERSION_FILE}))
+  $(error Linux kernel source not configured - missing version header file)
+endif
+
+ifeq (,$(wildcard ${CONFIG_FILE}))
+  $(error Linux kernel source not configured - missing autoconf.h)
+endif
+
+ifeq (,$(wildcard ${SYSTEM_MAP_FILE}))
+  $(warning Missing System.map file - depmod will not check for missing symbols)
+endif
+
+ifneq ($(words $(subst :, ,$(CURDIR))), 1)
+  $(error Sources directory '$(CURDIR)' cannot contain spaces nor colons. Rename directory or move sources to another path)
+endif
+
+########################
+# Extract config value #
+########################
+
+get_config_value = $(shell ${CC} -E -dM ${CONFIG_FILE} 2> /dev/null |\
+                           grep -m 1 ${1} | awk '{ print $$3 }')
+
+########################
+# Check module signing #
+########################
+
+CONFIG_MODULE_SIG_ALL := $(call get_config_value,CONFIG_MODULE_SIG_ALL)
+CONFIG_MODULE_SIG_FORCE := $(call get_config_value,CONFIG_MODULE_SIG_FORCE)
+CONFIG_MODULE_SIG_KEY := $(call get_config_value,CONFIG_MODULE_SIG_KEY)
+
+SIG_KEY_SP := ${KOBJ}/${CONFIG_MODULE_SIG_KEY} \
+              ${KOBJ}/certs/signing_key.pem
+
+SIG_KEY_FILE := $(firstword $(foreach file, ${SIG_KEY_SP}, ${test_file}))
+
+# print a warning if the kernel configuration attempts to sign modules but
+# the signing key can't be found.
+ifneq (${SIG_KEY_FILE},)
+warn_signed_modules := : ;
+else
+warn_signed_modules :=
+ifeq (${CONFIG_MODULE_SIG_ALL},1)
+warn_signed_modules += \
+    echo "*** The target kernel has CONFIG_MODULE_SIG_ALL enabled, but" ; \
+    echo "*** the signing key cannot be found. Module signing has been" ; \
+    echo "*** disabled for this build." ;
+endif # CONFIG_MODULE_SIG_ALL=y
+ifeq (${CONFIG_MODULE_SIG_FORCE},1)
+    echo "warning: The target kernel has CONFIG_MODULE_SIG_FORCE enabled," ; \
+    echo "warning: but the signing key cannot be found. The module must" ; \
+    echo "warning: be signed manually using 'scripts/sign-file'." ;
+endif # CONFIG_MODULE_SIG_FORCE
+DISABLE_MODULE_SIGNING := Yes
+endif
+
+#######################
+# Linux Version Setup #
+#######################
+
+# The following command line parameter is intended for development of KCOMPAT
+# against upstream kernels such as net-next which have broken or non-updated
+# version codes in their Makefile. They are intended for debugging and
+# development purpose only so that we can easily test new KCOMPAT early. If you
+# don't know what this means, you do not need to set this flag. There is no
+# arcane magic here.
+
+# Convert LINUX_VERSION into LINUX_VERSION_CODE
+ifneq (${LINUX_VERSION},)
+  LINUX_VERSION_CODE=$(call get_kvercode,$(call get_kver,${LINUX_VERSION},1),$(call get_kver,${LINUX_VERSION},2),$(call get_kver,${LINUX_VERSION},3))
+endif
+
+# Honor LINUX_VERSION_CODE
+ifneq (${LINUX_VERSION_CODE},)
+  $(warning Forcing target kernel to build with LINUX_VERSION_CODE of ${LINUX_VERSION_CODE}$(if ${LINUX_VERSION}, from LINUX_VERSION=${LINUX_VERSION}). Do this at your own risk.)
+  KVER_CODE := ${LINUX_VERSION_CODE}
+  EXTRA_CFLAGS += -DLINUX_VERSION_CODE=${LINUX_VERSION_CODE}
+endif
+
+# Determine SLE_LOCALVERSION_CODE for SuSE SLE >= 11 (needed by kcompat)
+# This assumes SuSE will continue setting CONFIG_LOCALVERSION to the string
+# appended to the stable kernel version on which their kernel is based with
+# additional versioning information (up to 3 numbers), a possible abbreviated
+# git SHA1 commit id and a kernel type, e.g. CONFIG_LOCALVERSION=-1.2.3-default
+# or CONFIG_LOCALVERSION=-999.gdeadbee-default
+ifeq (1,$(call get_config_value,CONFIG_SUSE_KERNEL))
+
+ifneq (10,$(call get_config_value,CONFIG_SLE_VERSION))
+
+  CONFIG_LOCALVERSION := $(call get_config_value,CONFIG_LOCALVERSION)
+  LOCALVERSION := $(shell echo ${CONFIG_LOCALVERSION} | \
+                    cut -d'-' -f2 | sed 's/\.g[[:xdigit:]]\{7\}//')
+  LOCALVER_A := $(shell echo ${LOCALVERSION} | cut -d'.' -f1)
+  LOCALVER_B := $(shell echo ${LOCALVERSION} | cut -s -d'.' -f2)
+  LOCALVER_C := $(shell echo ${LOCALVERSION} | cut -s -d'.' -f3)
+  SLE_LOCALVERSION_CODE := $(shell expr ${LOCALVER_A} \* 65536 + \
+                                        0${LOCALVER_B} \* 256 + 0${LOCALVER_C})
+  EXTRA_CFLAGS += -DSLE_LOCALVERSION_CODE=${SLE_LOCALVERSION_CODE}
+endif
+endif
+
+EXTRA_CFLAGS += ${CFLAGS_EXTRA}
+
+# get the kernel version - we use this to find the correct install path
+KVER := $(shell ${CC} ${EXTRA_CFLAGS} -E -dM ${VERSION_FILE} | grep UTS_RELEASE | \
+        awk '{ print $$3 }' | sed 's/\"//g')
+
+# assume source symlink is the same as build, otherwise adjust KOBJ
+ifneq (,$(wildcard /lib/modules/${KVER}/build))
+  ifneq (${KSRC},$(call readlink,/lib/modules/${KVER}/build))
+    KOBJ=/lib/modules/${KVER}/build
+  endif
+endif
+
+ifeq (${KVER_CODE},)
+  KVER_CODE := $(shell ${CC} ${EXTRA_CFLAGS} -E -dM ${VSP} 2> /dev/null |\
+                 grep -m 1 LINUX_VERSION_CODE | awk '{ print $$3 }' | sed 's/\"//g')
+endif
+
+# minimum_kver_check
+#
+# helper function to provide uniform output for different drivers to abort the
+# build based on kernel version check. Usage: "$(call minimum_kver_check,2,6,XX)".
+define _minimum_kver_check
+ifeq (0,$(shell [ ${KVER_CODE} -lt $(call get_kvercode,${1},${2},${3}) ]; echo "$$?"))
+  $$(warning *** Aborting the build.)
+  $$(error This driver is not supported on kernel versions older than ${1}.${2}.${3})
+endif
+endef
+minimum_kver_check = $(eval $(call _minimum_kver_check,${1},${2},${3}))
+
+################
+# Manual Pages #
+################
+
+MANSECTION = 7
+
+ifeq (,${MANDIR})
+  # find the best place to install the man page
+  MANPATH := $(shell (manpath 2>/dev/null || echo $MANPATH) | sed 's/:/ /g')
+  ifneq (,${MANPATH})
+    # test based on inclusion in MANPATH
+    test_dir = $(findstring ${dir}, ${MANPATH})
+  else
+    # no MANPATH, test based on directory existence
+    test_dir = $(shell [ -e ${dir} ] && echo ${dir})
+  endif
+  # our preferred install path
+  # should /usr/local/man be in here ?
+  MANDIR := /usr/share/man /usr/man
+  MANDIR := $(foreach dir, ${MANDIR}, ${test_dir})
+  MANDIR := $(firstword ${MANDIR})
+endif
+ifeq (,${MANDIR})
+  # fallback to /usr/man
+  MANDIR := /usr/man
+endif
+
+####################
+# CCFLAGS variable #
+####################
+
+# set correct CCFLAGS variable for kernels older than 2.6.24
+ifeq (0,$(shell [ ${KVER_CODE} -lt $(call get_kvercode,2,6,24) ]; echo $$?))
+CCFLAGS_VAR := EXTRA_CFLAGS
+else
+CCFLAGS_VAR := ccflags-y
+endif
+
+#################
+# KBUILD_OUTPUT #
+#################
+
+# Only set KBUILD_OUTPUT if the real paths of KOBJ and KSRC differ
+ifneq ($(call readlink,${KSRC}),$(call readlink,${KOBJ}))
+export KBUILD_OUTPUT ?= ${KOBJ}
+endif
+
+############################
+# Module Install Directory #
+############################
+
+# Default to using updates/drivers/net/ethernet/intel/ path, since depmod since
+# v3.1 defaults to checking updates folder first, and only checking kernels/
+# and extra afterwards. We use updates instead of kernel/* due to desire to
+# prevent over-writing built-in modules files.
+export INSTALL_MOD_DIR ?= updates/drivers/net/ethernet/intel/${DRIVER}
+
+######################
+# Kernel Build Macro #
+######################
+
+# kernel build function
+# ${1} is the kernel build target
+# ${2} may contain any extra rules to pass directly to the sub-make process
+#
+# This function is expected to be executed by
+#   @+$(call kernelbuild,<target>,<extra parameters>)
+# from within a Makefile recipe.
+#
+# The following variables are expected to be defined for its use:
+# GCC_I_SYS -- if set it will enable use of gcc-i-sys.sh wrapper to use -isystem
+# CCFLAGS_VAR -- the CCFLAGS variable to set extra CFLAGS
+# EXTRA_CFLAGS -- a set of extra CFLAGS to pass into the ccflags-y variable
+# KSRC -- the location of the kernel source tree to build against
+# DRIVER_UPPERCASE -- the uppercase name of the kernel module, set from DRIVER
+# W -- if set, enables the W= kernel warnings options
+# C -- if set, enables the C= kernel sparse build options
+#
+kernelbuild = $(call warn_signed_modules) \
+              ${MAKE} $(if ${GCC_I_SYS},CC="${GCC_I_SYS}") \
+                      ${CCFLAGS_VAR}="${EXTRA_CFLAGS}" \
+                      -C "${KSRC}" \
+                      CONFIG_${DRIVER_UPPERCASE}=m \
+                      $(if ${DISABLE_MODULE_SIGNING},CONFIG_MODULE_SIG=n) \
+                      $(if ${DISABLE_MODULE_SIGNING},CONFIG_MODULE_SIG_ALL=) \
+                      M="${CURDIR}" \
+                      $(if ${W},W="${W}") \
+                      $(if ${C},C="${C}") \
+                      ${2} ${1}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
index de0fc6ecf491..a57e05b44c08 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe.h
@@ -1,71 +1,102 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_H_
 #define _IXGBE_H_
 
-#include <linux/bitops.h>
-#include <linux/types.h>
+#include <net/ip.h>
+
 #include <linux/pci.h>
 #include <linux/netdevice.h>
-#include <linux/cpumask.h>
-#include <linux/aer.h>
+#include <linux/vmalloc.h>
+
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#endif
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
 #include <linux/if_vlan.h>
-#include <linux/jiffies.h>
-#include <linux/phy.h>
+#endif
+/* Can't use IS_ENABLED until after kcompat is loaded */
+#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)
+#define IXGBE_DCA
+#include <linux/dca.h>
+#endif
+#include "ixgbe_dcb.h"
 
-#include <linux/timecounter.h>
-#include <linux/net_tstamp.h>
-#include <linux/ptp_clock_kernel.h>
+#include "kcompat.h"
+
+#ifdef HAVE_XDP_BUFF_RXQ
+#include <net/xdp.h>
+#endif
+
+#ifdef HAVE_NDO_BUSY_POLL
+#include <net/busy_poll.h>
+#define BP_EXTENDED_STATS
+#endif
+
+#ifdef HAVE_SCTP
+#include <linux/sctp.h>
+#endif
+
+#ifdef HAVE_INCLUDE_LINUX_MDIO_H
+#include <linux/mdio.h>
+#endif
 
-#include "ixgbe_type.h"
-#include "ixgbe_common.h"
-#include "ixgbe_dcb.h"
 #if IS_ENABLED(CONFIG_FCOE)
-#define IXGBE_FCOE
 #include "ixgbe_fcoe.h"
-#endif /* IS_ENABLED(CONFIG_FCOE) */
-#ifdef CONFIG_IXGBE_DCA
-#include <linux/dca.h>
-#endif
-#include "ixgbe_ipsec.h"
+#endif /* CONFIG_FCOE */
 
-#include <net/xdp.h>
+#include "ixgbe_api.h"
 
-/* common prefix used by pr_<> macros */
-#undef pr_fmt
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include "ixgbe_common.h"
 
-/* TX/RX descriptor defines */
-#define IXGBE_DEFAULT_TXD		    512
-#define IXGBE_DEFAULT_TX_WORK		    256
-#define IXGBE_MAX_TXD			   4096
-#define IXGBE_MIN_TXD			     64
+#define DPRINTK(nlevel, klevel, fmt, args...) \
+	((NETIF_MSG_##nlevel & adapter->msg_enable) ? \
+	(void)(netdev_printk(KERN_##klevel, adapter->netdev, \
+	"%s: " fmt, __func__, ## args)) : NULL)
 
-#if (PAGE_SIZE < 8192)
-#define IXGBE_DEFAULT_RXD		    512
-#else
-#define IXGBE_DEFAULT_RXD		    128
+#ifdef HAVE_PTP_1588_CLOCK
+#ifdef HAVE_INCLUDE_LINUX_TIMECOUNTER_H
+#include <linux/timecounter.h>
+#endif /* HAVE_INCLUDE_TIMECOUNTER_H */
+#include <linux/clocksource.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_clock_kernel.h>
 #endif
-#define IXGBE_MAX_RXD			   4096
-#define IXGBE_MIN_RXD			     64
+
+/* TX/RX descriptor defines */
+#define IXGBE_DEFAULT_TXD		512
+#define IXGBE_DEFAULT_TX_WORK		256
+#define IXGBE_MAX_TXD			4096
+#define IXGBE_MIN_TXD			64
+
+#define IXGBE_DEFAULT_RXD		512
+#define IXGBE_MAX_RXD			4096
+#define IXGBE_MIN_RXD			64
+
+#define IXGBE_ETH_P_LLDP		0x88CC
 
 /* flow control */
-#define IXGBE_MIN_FCRTL			   0x40
+#define IXGBE_MIN_FCRTL			0x40
 #define IXGBE_MAX_FCRTL			0x7FF80
-#define IXGBE_MIN_FCRTH			  0x600
+#define IXGBE_MIN_FCRTH			0x600
 #define IXGBE_MAX_FCRTH			0x7FFF0
-#define IXGBE_DEFAULT_FCPAUSE		 0xFFFF
-#define IXGBE_MIN_FCPAUSE		      0
-#define IXGBE_MAX_FCPAUSE		 0xFFFF
+#define IXGBE_DEFAULT_FCPAUSE		0xFFFF
+#define IXGBE_MIN_FCPAUSE		0
+#define IXGBE_MAX_FCPAUSE		0xFFFF
 
 /* Supported Rx Buffer Sizes */
-#define IXGBE_RXBUFFER_256    256  /* Used for skb receive header */
-#define IXGBE_RXBUFFER_1536  1536
-#define IXGBE_RXBUFFER_2K    2048
-#define IXGBE_RXBUFFER_3K    3072
-#define IXGBE_RXBUFFER_4K    4096
-#define IXGBE_MAX_RXBUFFER  16384  /* largest size for a single descriptor */
+#define IXGBE_RXBUFFER_256       256  /* Used for skb receive header */
+#define IXGBE_RXBUFFER_1536	1536
+#define IXGBE_RXBUFFER_2K	2048
+#define IXGBE_RXBUFFER_3K	3072
+#define IXGBE_RXBUFFER_4K	4096
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+#define IXGBE_RXBUFFER_7K	7168
+#define IXGBE_RXBUFFER_8K	8192
+#define IXGBE_RXBUFFER_15K	15360
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+#define IXGBE_MAX_RXBUFFER	16384  /* largest size for single descriptor */
 
 /* Attempt to maximize the headroom available for incoming frames.  We
  * use a 2K buffer for receives and need 1536/1534 to store the data for
@@ -127,13 +158,26 @@ static inline int ixgbe_skb_pad(void)
  * Since netdev_alloc_skb now allocates a page fragment we can use a value
  * of 256 and the resultant skb will have a truesize of 960 or less.
  */
-#define IXGBE_RX_HDR_SIZE IXGBE_RXBUFFER_256
+#define IXGBE_RX_HDR_SIZE	IXGBE_RXBUFFER_256
+
+#define MAXIMUM_ETHERNET_VLAN_SIZE	(VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)
 
 /* How many Rx Buffers do we bundle into one write to the hardware ? */
 #define IXGBE_RX_BUFFER_WRITE	16	/* Must be power of 2 */
 
+#ifdef HAVE_STRUCT_DMA_ATTRS
+#define IXGBE_RX_DMA_ATTR NULL
+#else
 #define IXGBE_RX_DMA_ATTR \
 	(DMA_ATTR_SKIP_CPU_SYNC | DMA_ATTR_WEAK_ORDERING)
+#endif
+
+/* assume the kernel supports 8021p to avoid stripping vlan tags */
+#ifdef IXGBE_DISABLE_8021P_SUPPORT
+#ifndef HAVE_8021P_SUPPORT
+#define HAVE_8021P_SUPPORT
+#endif
+#endif /* IXGBE_DISABLE_8021P_SUPPORT */
 
 enum ixgbe_tx_flags {
 	/* cmd_type flags */
@@ -145,52 +189,85 @@ enum ixgbe_tx_flags {
 	IXGBE_TX_FLAGS_CC	= 0x08,
 	IXGBE_TX_FLAGS_IPV4	= 0x10,
 	IXGBE_TX_FLAGS_CSUM	= 0x20,
-	IXGBE_TX_FLAGS_IPSEC	= 0x40,
 
 	/* software defined flags */
-	IXGBE_TX_FLAGS_SW_VLAN	= 0x80,
-	IXGBE_TX_FLAGS_FCOE	= 0x100,
+	IXGBE_TX_FLAGS_SW_VLAN	= 0x40,
+	IXGBE_TX_FLAGS_FCOE	= 0x80,
 };
 
 /* VLAN info */
 #define IXGBE_TX_FLAGS_VLAN_MASK	0xffff0000
 #define IXGBE_TX_FLAGS_VLAN_PRIO_MASK	0xe0000000
-#define IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT  29
+#define IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT	29
 #define IXGBE_TX_FLAGS_VLAN_SHIFT	16
 
-#define IXGBE_MAX_VF_MC_ENTRIES         30
-#define IXGBE_MAX_VF_FUNCTIONS          64
-#define IXGBE_MAX_VFTA_ENTRIES          128
-#define MAX_EMULATION_MAC_ADDRS         16
-#define IXGBE_MAX_PF_MACVLANS           15
-#define VMDQ_P(p)   ((p) + adapter->ring_feature[RING_F_VMDQ].offset)
-#define IXGBE_82599_VF_DEVICE_ID        0x10ED
-#define IXGBE_X540_VF_DEVICE_ID         0x1515
+#define IXGBE_MAX_RX_DESC_POLL		10
+
+#define IXGBE_MAX_VF_MC_ENTRIES		30
+#define IXGBE_MAX_VF_FUNCTIONS		64
+#define IXGBE_MAX_VFTA_ENTRIES		128
+#define MAX_EMULATION_MAC_ADDRS		16
+#define IXGBE_MAX_PF_MACVLANS		15
+
+/* must account for pools assigned to VFs. */
+#ifdef CONFIG_PCI_IOV
+#define VMDQ_P(p)	((p) + adapter->ring_feature[RING_F_VMDQ].offset)
+#else
+#define VMDQ_P(p)	(p)
+#endif
+
+#define UPDATE_VF_COUNTER_32bit(reg, last_counter, counter)	\
+	{							\
+		u32 current_counter = IXGBE_READ_REG(hw, reg);	\
+		if (current_counter < last_counter)		\
+			counter += 0x100000000LL;		\
+		last_counter = current_counter;			\
+		counter &= 0xFFFFFFFF00000000LL;		\
+		counter |= current_counter;			\
+	}
+
+#define UPDATE_VF_COUNTER_36bit(reg_lsb, reg_msb, last_counter, counter) \
+	{								 \
+		u64 current_counter_lsb = IXGBE_READ_REG(hw, reg_lsb);	 \
+		u64 current_counter_msb = IXGBE_READ_REG(hw, reg_msb);	 \
+		u64 current_counter = (current_counter_msb << 32) |	 \
+			current_counter_lsb;				 \
+		if (current_counter < last_counter)			 \
+			counter += 0x1000000000LL;			 \
+		last_counter = current_counter;				 \
+		counter &= 0xFFFFFFF000000000LL;			 \
+		counter |= current_counter;				 \
+	}
 
+struct vf_stats {
+	u64 gprc;
+	u64 gorc;
+	u64 gptc;
+	u64 gotc;
+	u64 mprc;
+};
 struct vf_data_storage {
 	struct pci_dev *vfdev;
 	unsigned char vf_mac_addresses[ETH_ALEN];
 	u16 vf_mc_hashes[IXGBE_MAX_VF_MC_ENTRIES];
 	u16 num_vf_mc_hashes;
 	bool clear_to_send;
+	struct vf_stats vfstats;
+	struct vf_stats last_vfstats;
+	struct vf_stats saved_rst_vfstats;
 	bool pf_set_mac;
 	u16 pf_vlan; /* When set, guest VLAN config not allowed. */
 	u16 pf_qos;
 	u16 tx_rate;
 	u8 spoofchk_enabled;
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 	bool rss_query_enabled;
+#endif
 	u8 trusted;
 	int xcast_mode;
 	unsigned int vf_api;
 };
 
-enum ixgbevf_xcast_modes {
-	IXGBEVF_XCAST_MODE_NONE = 0,
-	IXGBEVF_XCAST_MODE_MULTI,
-	IXGBEVF_XCAST_MODE_ALLMULTI,
-	IXGBEVF_XCAST_MODE_PROMISC,
-};
-
 struct vf_macvlans {
 	struct list_head l;
 	int vf;
@@ -200,11 +277,17 @@ struct vf_macvlans {
 };
 
 #define IXGBE_MAX_TXD_PWR	14
-#define IXGBE_MAX_DATA_PER_TXD	(1u << IXGBE_MAX_TXD_PWR)
+#define IXGBE_MAX_DATA_PER_TXD	(1 << IXGBE_MAX_TXD_PWR)
 
 /* Tx Descriptors needed, worst case */
-#define TXD_USE_COUNT(S) DIV_ROUND_UP((S), IXGBE_MAX_DATA_PER_TXD)
-#define DESC_NEEDED (MAX_SKB_FRAGS + 4)
+#define TXD_USE_COUNT(S)	DIV_ROUND_UP((S), IXGBE_MAX_DATA_PER_TXD)
+#ifndef MAX_SKB_FRAGS
+#define DESC_NEEDED	4
+#elif (MAX_SKB_FRAGS < 16)
+#define DESC_NEEDED	((MAX_SKB_FRAGS * TXD_USE_COUNT(PAGE_SIZE)) + 4)
+#else
+#define DESC_NEEDED	(MAX_SKB_FRAGS + 4)
+#endif
 
 /* wrapper around a pointer to a socket buffer,
  * so a DMA handle can be stored along with the buffer */
@@ -213,7 +296,12 @@ struct ixgbe_tx_buffer {
 	unsigned long time_stamp;
 	union {
 		struct sk_buff *skb;
+#ifdef HAVE_XDP_FRAME_STRUCT
 		struct xdp_frame *xdpf;
+#else
+		/* XDP uses address ptr on irq_clean */
+		void *data;
+#endif
 	};
 	unsigned int bytecount;
 	unsigned short gso_segs;
@@ -224,24 +312,33 @@ struct ixgbe_tx_buffer {
 };
 
 struct ixgbe_rx_buffer {
+	struct sk_buff *skb;
+	dma_addr_t dma;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	union {
 		struct {
-			struct sk_buff *skb;
-			dma_addr_t dma;
 			struct page *page;
 			__u32 page_offset;
 			__u16 pagecnt_bias;
 		};
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 		struct {
-			bool discard;
-			struct xdp_buff *xdp;
+			void *addr;
+			u64 handle;
 		};
+#endif
 	};
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 };
 
 struct ixgbe_queue_stats {
 	u64 packets;
 	u64 bytes;
+#ifdef BP_EXTENDED_STATS
+	u64 yields;
+	u64 misses;
+	u64 cleaned;
+#endif  /* BP_EXTENDED_STATS */
 };
 
 struct ixgbe_tx_queue_stats {
@@ -261,31 +358,30 @@ struct ixgbe_rx_queue_stats {
 };
 
 #define IXGBE_TS_HDR_LEN 8
-
 enum ixgbe_ring_state_t {
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	__IXGBE_RX_3K_BUFFER,
 	__IXGBE_RX_BUILD_SKB_ENABLED,
+#endif
 	__IXGBE_RX_RSC_ENABLED,
 	__IXGBE_RX_CSUM_UDP_ZERO_ERR,
+#if IS_ENABLED(CONFIG_FCOE)
 	__IXGBE_RX_FCOE,
+#endif
 	__IXGBE_TX_FDIR_INIT_DONE,
 	__IXGBE_TX_XPS_INIT_DONE,
 	__IXGBE_TX_DETECT_HANG,
 	__IXGBE_HANG_CHECK_ARMED,
 	__IXGBE_TX_XDP_RING,
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 	__IXGBE_TX_DISABLED,
+#endif
 };
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 
 #define ring_uses_build_skb(ring) \
 	test_bit(__IXGBE_RX_BUILD_SKB_ENABLED, &(ring)->state)
-
-struct ixgbe_fwd_adapter {
-	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
-	struct net_device *netdev;
-	unsigned int tx_base_queue;
-	unsigned int rx_base_queue;
-	int pool;
-};
+#endif
 
 #define check_for_tx_hang(ring) \
 	test_bit(__IXGBE_TX_DETECT_HANG, &(ring)->state)
@@ -305,6 +401,10 @@ struct ixgbe_fwd_adapter {
 	set_bit(__IXGBE_TX_XDP_RING, &(ring)->state)
 #define clear_ring_xdp(ring) \
 	clear_bit(__IXGBE_TX_XDP_RING, &(ring)->state)
+#define netdev_ring(ring) (ring->netdev)
+#define ring_queue_index(ring) (ring->queue_index)
+
+
 struct ixgbe_ring {
 	struct ixgbe_ring *next;	/* pointer to next ring in q_vector */
 	struct ixgbe_q_vector *q_vector; /* backpointer to host q_vector */
@@ -332,10 +432,16 @@ struct ixgbe_ring {
 	u16 next_to_use;
 	u16 next_to_clean;
 
+#ifdef HAVE_PTP_1588_CLOCK
 	unsigned long last_rx_timestamp;
 
+#endif
 	union {
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+		u16 rx_buf_len;
+#else
 		u16 next_to_alloc;
+#endif
 		struct {
 			u8 atr_sample_rate;
 			u8 atr_count;
@@ -344,15 +450,22 @@ struct ixgbe_ring {
 
 	u8 dcb_tc;
 	struct ixgbe_queue_stats stats;
+#ifdef HAVE_NDO_GET_STATS64
 	struct u64_stats_sync syncp;
+#endif
 	union {
 		struct ixgbe_tx_queue_stats tx_stats;
 		struct ixgbe_rx_queue_stats rx_stats;
 	};
+#ifdef HAVE_XDP_BUFF_RXQ
 	struct xdp_rxq_info xdp_rxq;
-	struct xsk_buff_pool *xsk_pool;
-	u16 ring_idx;		/* {rx,tx,xdp}_ring back reference idx */
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	struct xdp_umem *xsk_umem;
+	struct zero_copy_allocator zca; /* ZC allocator anchor */
+	u16 ring_idx;           /* {rx,tx,xdp}_ring back reference idx */
 	u16 rx_buf_len;
+#endif
+#endif
 } ____cacheline_internodealigned_in_smp;
 
 enum ixgbe_ring_f_enum {
@@ -360,43 +473,49 @@ enum ixgbe_ring_f_enum {
 	RING_F_VMDQ,  /* SR-IOV uses the same ring feature */
 	RING_F_RSS,
 	RING_F_FDIR,
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	RING_F_FCOE,
-#endif /* IXGBE_FCOE */
-
-	RING_F_ARRAY_SIZE      /* must be last in enum set */
+#endif /* CONFIG_FCOE */
+	RING_F_ARRAY_SIZE  /* must be last in enum set */
 };
 
+#define IXGBE_MAX_DCB_INDICES		8
 #define IXGBE_MAX_RSS_INDICES		16
 #define IXGBE_MAX_RSS_INDICES_X550	63
 #define IXGBE_MAX_VMDQ_INDICES		64
-#define IXGBE_MAX_FDIR_INDICES		63	/* based on q_vector limit */
-#define IXGBE_MAX_FCOE_INDICES		8
-#define MAX_RX_QUEUES			(IXGBE_MAX_FDIR_INDICES + 1)
-#define MAX_TX_QUEUES			(IXGBE_MAX_FDIR_INDICES + 1)
-#define MAX_XDP_QUEUES			(IXGBE_MAX_FDIR_INDICES + 1)
-#define IXGBE_MAX_L2A_QUEUES		4
-#define IXGBE_BAD_L2A_QUEUE		3
-#define IXGBE_MAX_MACVLANS		63
+#define IXGBE_MAX_FDIR_INDICES		63
+#if IS_ENABLED(CONFIG_FCOE)
+#define IXGBE_MAX_FCOE_INDICES	8
+#define MAX_RX_QUEUES	(IXGBE_MAX_FDIR_INDICES + IXGBE_MAX_FCOE_INDICES)
+#define MAX_TX_QUEUES	(IXGBE_MAX_FDIR_INDICES + IXGBE_MAX_FCOE_INDICES)
+#else
+#define MAX_RX_QUEUES	(IXGBE_MAX_FDIR_INDICES + 1)
+#define MAX_TX_QUEUES	(IXGBE_MAX_FDIR_INDICES + 1)
+#endif /* CONFIG_FCOE */
+#define MAX_XDP_QUEUES  (IXGBE_MAX_FDIR_INDICES + 1)
 
 struct ixgbe_ring_feature {
 	u16 limit;	/* upper limit on feature indices */
 	u16 indices;	/* current value of indices */
 	u16 mask;	/* Mask used for feature to ring mapping */
 	u16 offset;	/* offset to start of feature */
-} ____cacheline_internodealigned_in_smp;
+};
 
 #define IXGBE_82599_VMDQ_8Q_MASK 0x78
 #define IXGBE_82599_VMDQ_4Q_MASK 0x7C
 #define IXGBE_82599_VMDQ_2Q_MASK 0x7E
 
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 /*
  * FCoE requires that all Rx buffers be over 2200 bytes in length.  Since
  * this is twice the size of a half page we need to double the page order
  * for FCoE enabled Rx queues.
  */
-static inline unsigned int ixgbe_rx_bufsz(struct ixgbe_ring *ring)
+static inline unsigned int ixgbe_rx_bufsz(struct ixgbe_ring __maybe_unused *ring)
 {
+#if MAX_SKB_FRAGS < 8
+	return ALIGN(IXGBE_MAX_RXBUFFER / MAX_SKB_FRAGS, 1024);
+#else
 	if (test_bit(__IXGBE_RX_3K_BUFFER, &ring->state))
 		return IXGBE_RXBUFFER_3K;
 #if (PAGE_SIZE < 8192)
@@ -404,9 +523,10 @@ static inline unsigned int ixgbe_rx_bufsz(struct ixgbe_ring *ring)
 		return IXGBE_MAX_2K_FRAME_BUILD_SKB;
 #endif
 	return IXGBE_RXBUFFER_2K;
+#endif
 }
 
-static inline unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring)
+static inline unsigned int ixgbe_rx_pg_order(struct ixgbe_ring __maybe_unused *ring)
 {
 #if (PAGE_SIZE < 8192)
 	if (test_bit(__IXGBE_RX_3K_BUFFER, &ring->state))
@@ -416,11 +536,14 @@ static inline unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring)
 }
 #define ixgbe_rx_pg_size(_ring) (PAGE_SIZE << ixgbe_rx_pg_order(_ring))
 
+#endif
 #define IXGBE_ITR_ADAPTIVE_MIN_INC	2
 #define IXGBE_ITR_ADAPTIVE_MIN_USECS	10
-#define IXGBE_ITR_ADAPTIVE_MAX_USECS	126
+#define IXGBE_ITR_ADAPTIVE_MAX_USECS	84
 #define IXGBE_ITR_ADAPTIVE_LATENCY	0x80
 #define IXGBE_ITR_ADAPTIVE_BULK		0x00
+#define IXGBE_ITR_ADAPTIVE_MASK_USECS	(IXGBE_ITR_ADAPTIVE_LATENCY - \
+					 IXGBE_ITR_ADAPTIVE_MIN_INC)
 
 struct ixgbe_ring_container {
 	struct ixgbe_ring *ring;	/* pointer to linked list of rings */
@@ -436,35 +559,122 @@ struct ixgbe_ring_container {
 #define ixgbe_for_each_ring(pos, head) \
 	for (pos = (head).ring; pos != NULL; pos = pos->next)
 
-#define MAX_RX_PACKET_BUFFERS ((adapter->flags & IXGBE_FLAG_DCB_ENABLED) \
-			      ? 8 : 1)
-#define MAX_TX_PACKET_BUFFERS MAX_RX_PACKET_BUFFERS
+#define MAX_RX_PACKET_BUFFERS	((adapter->flags & IXGBE_FLAG_DCB_ENABLED) \
+				 ? 8 : 1)
+#define MAX_TX_PACKET_BUFFERS	MAX_RX_PACKET_BUFFERS
 
-/* MAX_Q_VECTORS of these are allocated,
+#define IXGBE_IFNAMSIZ (IFNAMSIZ + 9)
+
+/* MAX_MSIX_Q_VECTORS of these are allocated,
  * but we only use one per queue-specific vector.
  */
 struct ixgbe_q_vector {
 	struct ixgbe_adapter *adapter;
-#ifdef CONFIG_IXGBE_DCA
-	int cpu;	    /* CPU for DCA */
-#endif
-	u16 v_idx;		/* index of q_vector within array, also used for
-				 * finding the bit in EICR and friends that
-				 * represents the vector for this ring */
-	u16 itr;		/* Interrupt throttle rate written to EITR */
+	int cpu;	/* CPU for DCA */
+	u16 v_idx;	/* index of q_vector within array, also used for
+			 * finding the bit in EICR and friends that
+			 * represents the vector for this ring */
+	u16 itr;	/* Interrupt throttle rate written to EITR */
 	struct ixgbe_ring_container rx, tx;
 
 	struct napi_struct napi;
+#ifndef HAVE_NETDEV_NAPI_LIST
+	struct net_device poll_dev;
+#endif
+#ifdef HAVE_IRQ_AFFINITY_HINT
 	cpumask_t affinity_mask;
-	int numa_node;
+#endif
+	int node;
 	struct rcu_head rcu;	/* to avoid race with update stats on free */
-	char name[IFNAMSIZ + 9];
+	char name[IXGBE_IFNAMSIZ];
+	bool netpoll_rx;
+
+#ifdef HAVE_NDO_BUSY_POLL
+	atomic_t state;
+#endif  /* HAVE_NDO_BUSY_POLL */
 
 	/* for dynamic allocation of rings associated with this q_vector */
-	struct ixgbe_ring ring[] ____cacheline_internodealigned_in_smp;
+	struct ixgbe_ring ring[0] ____cacheline_internodealigned_in_smp;
 };
 
-#ifdef CONFIG_IXGBE_HWMON
+#ifdef HAVE_NDO_BUSY_POLL
+enum ixgbe_qv_state_t {
+	IXGBE_QV_STATE_IDLE = 0,
+	IXGBE_QV_STATE_NAPI,
+	IXGBE_QV_STATE_POLL,
+	IXGBE_QV_STATE_DISABLE
+};
+
+static inline void ixgbe_qv_init_lock(struct ixgbe_q_vector *q_vector)
+{
+	/* reset state to idle */
+	atomic_set(&q_vector->state, IXGBE_QV_STATE_IDLE);
+}
+
+/* called from the device poll routine to get ownership of a q_vector */
+static inline bool ixgbe_qv_lock_napi(struct ixgbe_q_vector *q_vector)
+{
+	int rc = atomic_cmpxchg(&q_vector->state, IXGBE_QV_STATE_IDLE,
+				IXGBE_QV_STATE_NAPI);
+#ifdef BP_EXTENDED_STATS
+	if (rc != IXGBE_QV_STATE_IDLE)
+		q_vector->tx.ring->stats.yields++;
+#endif
+
+	return rc == IXGBE_QV_STATE_IDLE;
+}
+
+/* returns true is someone tried to get the qv while napi had it */
+static inline void ixgbe_qv_unlock_napi(struct ixgbe_q_vector *q_vector)
+{
+	WARN_ON(atomic_read(&q_vector->state) != IXGBE_QV_STATE_NAPI);
+
+	/* flush any outstanding Rx frames */
+	if (q_vector->napi.gro_list)
+		napi_gro_flush(&q_vector->napi, false);
+
+	/* reset state to idle */
+	atomic_set(&q_vector->state, IXGBE_QV_STATE_IDLE);
+}
+
+/* called from ixgbe_low_latency_poll() */
+static inline bool ixgbe_qv_lock_poll(struct ixgbe_q_vector *q_vector)
+{
+	int rc = atomic_cmpxchg(&q_vector->state, IXGBE_QV_STATE_IDLE,
+				IXGBE_QV_STATE_POLL);
+#ifdef BP_EXTENDED_STATS
+	if (rc != IXGBE_QV_STATE_IDLE)
+		q_vector->rx.ring->stats.yields++;
+#endif
+	return rc == IXGBE_QV_STATE_IDLE;
+}
+
+/* returns true if someone tried to get the qv while it was locked */
+static inline void ixgbe_qv_unlock_poll(struct ixgbe_q_vector *q_vector)
+{
+	WARN_ON(atomic_read(&q_vector->state) != IXGBE_QV_STATE_POLL);
+
+	/* reset state to idle */
+	atomic_set(&q_vector->state, IXGBE_QV_STATE_IDLE);
+}
+
+/* true if a socket is polling, even if it did not get the lock */
+static inline bool ixgbe_qv_busy_polling(struct ixgbe_q_vector *q_vector)
+{
+	return atomic_read(&q_vector->state) == IXGBE_QV_STATE_POLL;
+}
+
+/* false if QV is currently owned */
+static inline bool ixgbe_qv_disable(struct ixgbe_q_vector *q_vector)
+{
+	int rc = atomic_cmpxchg(&q_vector->state, IXGBE_QV_STATE_IDLE,
+				IXGBE_QV_STATE_DISABLE);
+
+	return rc == IXGBE_QV_STATE_IDLE;
+}
+
+#endif /* HAVE_NDO_BUSY_POLL */
+#ifdef IXGBE_HWMON
 
 #define IXGBE_HWMON_TYPE_LOC		0
 #define IXGBE_HWMON_TYPE_TEMP		1
@@ -479,13 +689,18 @@ struct hwmon_attr {
 };
 
 struct hwmon_buff {
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	struct attribute_group group;
 	const struct attribute_group *groups[2];
 	struct attribute *attrs[IXGBE_MAX_SENSORS * 4 + 1];
 	struct hwmon_attr hwmon_list[IXGBE_MAX_SENSORS * 4];
+#else
+	struct device *device;
+	struct hwmon_attr *hwmon_list;
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
 	unsigned int n_hwmon;
 };
-#endif /* CONFIG_IXGBE_HWMON */
+#endif /* IXGBE_HWMON */
 
 /*
  * microsecond values for various ITR rates shifted by 2 to fit itr register
@@ -494,6 +709,7 @@ struct hwmon_buff {
 #define IXGBE_MIN_RSC_ITR	24
 #define IXGBE_100K_ITR		40
 #define IXGBE_20K_ITR		200
+#define IXGBE_16K_ITR		248
 #define IXGBE_12K_ITR		336
 
 /* ixgbe_test_staterr - tests bits in Rx descriptor status and error fields */
@@ -503,6 +719,7 @@ static inline __le32 ixgbe_test_staterr(union ixgbe_adv_rx_desc *rx_desc,
 	return rx_desc->wb.upper.status_error & cpu_to_le32(stat_err_bits);
 }
 
+/* ixgbe_desc_unused - calculate if we have unused descriptors */
 static inline u16 ixgbe_desc_unused(struct ixgbe_ring *ring)
 {
 	u16 ntc = ring->next_to_clean;
@@ -511,26 +728,25 @@ static inline u16 ixgbe_desc_unused(struct ixgbe_ring *ring)
 	return ((ntc > ntu) ? 0 : ring->count) + ntc - ntu - 1;
 }
 
-#define IXGBE_RX_DESC(R, i)	    \
+#define IXGBE_RX_DESC(R, i)	\
 	(&(((union ixgbe_adv_rx_desc *)((R)->desc))[i]))
-#define IXGBE_TX_DESC(R, i)	    \
+#define IXGBE_TX_DESC(R, i)	\
 	(&(((union ixgbe_adv_tx_desc *)((R)->desc))[i]))
-#define IXGBE_TX_CTXTDESC(R, i)	    \
+#define IXGBE_TX_CTXTDESC(R, i)	\
 	(&(((struct ixgbe_adv_tx_context_desc *)((R)->desc))[i]))
 
-#define IXGBE_MAX_JUMBO_FRAME_SIZE	9728 /* Maximum Supported Size 9.5KB */
-#ifdef IXGBE_FCOE
-/* Use 3K as the baby jumbo frame size for FCoE */
-#define IXGBE_FCOE_JUMBO_FRAME_SIZE       3072
-#endif /* IXGBE_FCOE */
+#define IXGBE_MAX_JUMBO_FRAME_SIZE	9728
+#if IS_ENABLED(CONFIG_FCOE)
+/* use 3K as the baby jumbo frame size for FCoE */
+#define IXGBE_FCOE_JUMBO_FRAME_SIZE	3072
+#endif /* CONFIG_FCOE */
 
-#define OTHER_VECTOR 1
-#define NON_Q_VECTORS (OTHER_VECTOR)
+#define TCP_TIMER_VECTOR	0
+#define OTHER_VECTOR	1
+#define NON_Q_VECTORS	(OTHER_VECTOR + TCP_TIMER_VECTOR)
 
-#define MAX_MSIX_VECTORS_82599 64
-#define MAX_Q_VECTORS_82599 64
-#define MAX_MSIX_VECTORS_82598 18
-#define MAX_Q_VECTORS_82598 16
+#define IXGBE_MAX_MSIX_Q_VECTORS_82599	64
+#define IXGBE_MAX_MSIX_Q_VECTORS_82598	16
 
 struct ixgbe_mac_addr {
 	u8 addr[ETH_ALEN];
@@ -542,24 +758,42 @@ struct ixgbe_mac_addr {
 #define IXGBE_MAC_STATE_MODIFIED	0x2
 #define IXGBE_MAC_STATE_IN_USE		0x4
 
-#define MAX_Q_VECTORS MAX_Q_VECTORS_82599
-#define MAX_MSIX_COUNT MAX_MSIX_VECTORS_82599
+#ifdef IXGBE_PROCFS
+struct ixgbe_therm_proc_data {
+	struct ixgbe_hw *hw;
+	struct ixgbe_thermal_diode_data *sensor_data;
+};
+
+#endif /* IXGBE_PROCFS */
+/*
+ * Only for array allocations in our adapter struct.  On 82598, there will be
+ * unused entries in the array, but that's not a big deal.  Also, in 82599,
+ * we can actually assign 64 queue vectors based on our extended-extended
+ * interrupt registers.  This is different than 82598, which is limited to 16.
+ */
+#define MAX_MSIX_Q_VECTORS	IXGBE_MAX_MSIX_Q_VECTORS_82599
+#define MAX_MSIX_COUNT		IXGBE_MAX_MSIX_VECTORS_82599
 
-#define MIN_MSIX_Q_VECTORS 1
-#define MIN_MSIX_COUNT (MIN_MSIX_Q_VECTORS + NON_Q_VECTORS)
+#define MIN_MSIX_Q_VECTORS	1
+#define MIN_MSIX_COUNT		(MIN_MSIX_Q_VECTORS + NON_Q_VECTORS)
 
 /* default to trying for four seconds */
-#define IXGBE_TRY_LINK_TIMEOUT (4 * HZ)
-#define IXGBE_SFP_POLL_JIFFIES (2 * HZ)	/* SFP poll every 2 seconds */
+#define IXGBE_TRY_LINK_TIMEOUT	(4 * HZ)
+#define IXGBE_SFP_POLL_JIFFIES	(2 * HZ)	/* SFP poll every 2 seconds */
 
 /* board specific private data structure */
 struct ixgbe_adapter {
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+#ifdef HAVE_VLAN_RX_REGISTER
+	struct vlan_group *vlgrp; /* must be first, see ixgbe_receive_skb */
+#else
 	unsigned long active_vlans[BITS_TO_LONGS(VLAN_N_VID)];
+#endif
+#endif /* NETIF_F_HW_VLAN_TX || NETIF_F_HW_VLAN_CTAG_TX */
 	/* OS defined structs */
 	struct net_device *netdev;
 	struct bpf_prog *xdp_prog;
 	struct pci_dev *pdev;
-	struct mii_bus *mii_bus;
 
 	unsigned long state;
 
@@ -567,69 +801,98 @@ struct ixgbe_adapter {
 	 * thus the additional *_CAPABLE flags.
 	 */
 	u32 flags;
-#define IXGBE_FLAG_MSI_ENABLED			BIT(1)
-#define IXGBE_FLAG_MSIX_ENABLED			BIT(3)
-#define IXGBE_FLAG_RX_1BUF_CAPABLE		BIT(4)
-#define IXGBE_FLAG_RX_PS_CAPABLE		BIT(5)
-#define IXGBE_FLAG_RX_PS_ENABLED		BIT(6)
-#define IXGBE_FLAG_DCA_ENABLED			BIT(8)
-#define IXGBE_FLAG_DCA_CAPABLE			BIT(9)
-#define IXGBE_FLAG_IMIR_ENABLED			BIT(10)
-#define IXGBE_FLAG_MQ_CAPABLE			BIT(11)
-#define IXGBE_FLAG_DCB_ENABLED			BIT(12)
-#define IXGBE_FLAG_VMDQ_CAPABLE			BIT(13)
-#define IXGBE_FLAG_VMDQ_ENABLED			BIT(14)
-#define IXGBE_FLAG_FAN_FAIL_CAPABLE		BIT(15)
-#define IXGBE_FLAG_NEED_LINK_UPDATE		BIT(16)
-#define IXGBE_FLAG_NEED_LINK_CONFIG		BIT(17)
-#define IXGBE_FLAG_FDIR_HASH_CAPABLE		BIT(18)
-#define IXGBE_FLAG_FDIR_PERFECT_CAPABLE		BIT(19)
-#define IXGBE_FLAG_FCOE_CAPABLE			BIT(20)
-#define IXGBE_FLAG_FCOE_ENABLED			BIT(21)
-#define IXGBE_FLAG_SRIOV_CAPABLE		BIT(22)
-#define IXGBE_FLAG_SRIOV_ENABLED		BIT(23)
-#define IXGBE_FLAG_RX_HWTSTAMP_ENABLED		BIT(25)
-#define IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER	BIT(26)
-#define IXGBE_FLAG_DCB_CAPABLE			BIT(27)
+#define IXGBE_FLAG_MSI_CAPABLE			(u32)(1 << 0)
+#define IXGBE_FLAG_MSI_ENABLED			(u32)(1 << 1)
+#define IXGBE_FLAG_MSIX_CAPABLE			(u32)(1 << 2)
+#define IXGBE_FLAG_MSIX_ENABLED			(u32)(1 << 3)
+#ifndef IXGBE_NO_LLI
+#define IXGBE_FLAG_LLI_PUSH			(u32)(1 << 4)
+#endif
+
+#if defined(CONFIG_DCA) || defined(CONFIG_DCA_MODULE)
+#define IXGBE_FLAG_DCA_ENABLED			(u32)(1 << 6)
+#define IXGBE_FLAG_DCA_CAPABLE			(u32)(1 << 7)
+#define IXGBE_FLAG_DCA_ENABLED_DATA		(u32)(1 << 8)
+#else
+#define IXGBE_FLAG_DCA_ENABLED			(u32)0
+#define IXGBE_FLAG_DCA_CAPABLE			(u32)0
+#define IXGBE_FLAG_DCA_ENABLED_DATA             (u32)0
+#endif
+#define IXGBE_FLAG_MQ_CAPABLE			(u32)(1 << 9)
+#define IXGBE_FLAG_DCB_ENABLED			(u32)(1 << 10)
+#define IXGBE_FLAG_VMDQ_ENABLED			(u32)(1 << 11)
+#define IXGBE_FLAG_FAN_FAIL_CAPABLE		(u32)(1 << 12)
+#define IXGBE_FLAG_NEED_LINK_UPDATE		(u32)(1 << 13)
+#define IXGBE_FLAG_NEED_LINK_CONFIG		(u32)(1 << 14)
+#define IXGBE_FLAG_FDIR_HASH_CAPABLE		(u32)(1 << 15)
+#define IXGBE_FLAG_FDIR_PERFECT_CAPABLE		(u32)(1 << 16)
+#if IS_ENABLED(CONFIG_FCOE)
+#define IXGBE_FLAG_FCOE_CAPABLE			(u32)(1 << 17)
+#define IXGBE_FLAG_FCOE_ENABLED			(u32)(1 << 18)
+#endif /* CONFIG_FCOE */
+#define IXGBE_FLAG_SRIOV_CAPABLE		(u32)(1 << 19)
+#define IXGBE_FLAG_SRIOV_ENABLED		(u32)(1 << 20)
+#define IXGBE_FLAG_SRIOV_REPLICATION_ENABLE	(u32)(1 << 21)
+#define IXGBE_FLAG_SRIOV_L2SWITCH_ENABLE	(u32)(1 << 22)
+#define IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE	(u32)(1 << 23)
+#define IXGBE_FLAG_RX_HWTSTAMP_ENABLED          (u32)(1 << 24)
+#define IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE	(u32)(1 << 25)
+#define IXGBE_FLAG_VXLAN_OFFLOAD_ENABLE		(u32)(1 << 26)
+#define IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER	(u32)(1 << 27)
+#define IXGBE_FLAG_MDD_ENABLED			(u32)(1 << 29)
+#define IXGBE_FLAG_DCB_CAPABLE			(u32)(1 << 30)
+#define IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE	BIT(31)
+
+/* preset defaults */
+#define IXGBE_FLAGS_82598_INIT		(IXGBE_FLAG_MSI_CAPABLE |	\
+					 IXGBE_FLAG_MSIX_CAPABLE |	\
+					 IXGBE_FLAG_MQ_CAPABLE)
+
+#define IXGBE_FLAGS_82599_INIT		(IXGBE_FLAGS_82598_INIT |	\
+					 IXGBE_FLAG_SRIOV_CAPABLE)
+
+#define IXGBE_FLAGS_X540_INIT		IXGBE_FLAGS_82599_INIT
+
+#define IXGBE_FLAGS_X550_INIT		(IXGBE_FLAGS_82599_INIT |	\
+					 IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE)
 
 	u32 flags2;
-#define IXGBE_FLAG2_RSC_CAPABLE			BIT(0)
-#define IXGBE_FLAG2_RSC_ENABLED			BIT(1)
-#define IXGBE_FLAG2_TEMP_SENSOR_CAPABLE		BIT(2)
-#define IXGBE_FLAG2_TEMP_SENSOR_EVENT		BIT(3)
-#define IXGBE_FLAG2_SEARCH_FOR_SFP		BIT(4)
-#define IXGBE_FLAG2_SFP_NEEDS_RESET		BIT(5)
-#define IXGBE_FLAG2_FDIR_REQUIRES_REINIT	BIT(7)
-#define IXGBE_FLAG2_RSS_FIELD_IPV4_UDP		BIT(8)
-#define IXGBE_FLAG2_RSS_FIELD_IPV6_UDP		BIT(9)
-#define IXGBE_FLAG2_PTP_PPS_ENABLED		BIT(10)
-#define IXGBE_FLAG2_PHY_INTERRUPT		BIT(11)
-#define IXGBE_FLAG2_VLAN_PROMISC		BIT(13)
-#define IXGBE_FLAG2_EEE_CAPABLE			BIT(14)
-#define IXGBE_FLAG2_EEE_ENABLED			BIT(15)
-#define IXGBE_FLAG2_RX_LEGACY			BIT(16)
-#define IXGBE_FLAG2_IPSEC_ENABLED		BIT(17)
-#define IXGBE_FLAG2_VF_IPSEC_ENABLED		BIT(18)
+#define IXGBE_FLAG2_RSC_CAPABLE			(u32)(1 << 0)
+#define IXGBE_FLAG2_RSC_ENABLED			(u32)(1 << 1)
+#define IXGBE_FLAG2_TEMP_SENSOR_CAPABLE		(u32)(1 << 3)
+#define IXGBE_FLAG2_TEMP_SENSOR_EVENT		(u32)(1 << 4)
+#define IXGBE_FLAG2_SEARCH_FOR_SFP		(u32)(1 << 5)
+#define IXGBE_FLAG2_SFP_NEEDS_RESET		(u32)(1 << 6)
+#define IXGBE_FLAG2_FDIR_REQUIRES_REINIT	(u32)(1 << 8)
+#define IXGBE_FLAG2_RSS_FIELD_IPV4_UDP		(u32)(1 << 9)
+#define IXGBE_FLAG2_RSS_FIELD_IPV6_UDP		(u32)(1 << 10)
+#define IXGBE_FLAG2_PTP_PPS_ENABLED		(u32)(1 << 11)
+#define IXGBE_FLAG2_EEE_CAPABLE			(u32)(1 << 14)
+#define IXGBE_FLAG2_EEE_ENABLED			(u32)(1 << 15)
+#define IXGBE_FLAG2_UDP_TUN_REREG_NEEDED	(u32)(1 << 16)
+#define IXGBE_FLAG2_PHY_INTERRUPT		(u32)(1 << 17)
+#define IXGBE_FLAG2_VLAN_PROMISC		(u32)(1 << 18)
+#define IXGBE_FLAG2_RX_LEGACY			(u32)(1 << 19)
 
 	/* Tx fast path data */
 	int num_tx_queues;
 	u16 tx_itr_setting;
 	u16 tx_work_limit;
-	u64 tx_ipsec;
+
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+	__be16 vxlan_port;
+#endif /* HAVE_UDP_ENC_RX_OFFLAD || HAVE_VXLAN_RX_OFFLOAD */
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+	__be16 geneve_port;
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
 
 	/* Rx fast path data */
 	int num_rx_queues;
 	u16 rx_itr_setting;
-	u64 rx_ipsec;
-
-	/* Port number used to identify VXLAN traffic */
-	__be16 vxlan_port;
-	__be16 geneve_port;
 
 	/* XDP */
 	int num_xdp_queues;
 	struct ixgbe_ring *xdp_ring[MAX_XDP_QUEUES];
-	unsigned long *af_xdp_zc_qps; /* tracks AF_XDP ZC enabled rings */
 
 	/* TX */
 	struct ixgbe_ring *tx_ring[MAX_TX_QUEUES] ____cacheline_aligned_in_smp;
@@ -640,8 +903,8 @@ struct ixgbe_adapter {
 
 	/* RX */
 	struct ixgbe_ring *rx_ring[MAX_RX_QUEUES];
-	int num_rx_pools;		/* == num_rx_queues in 82598 */
-	int num_rx_queues_per_pool;	/* 1 if 82598, can be many if 82599 */
+	int num_rx_pools; /* does not include pools assigned to VFs */
+	int num_rx_queues_per_pool;
 	u64 hw_csum_rx_error;
 	u64 hw_rx_no_dma_resources;
 	u64 rsc_total_count;
@@ -651,32 +914,48 @@ struct ixgbe_adapter {
 	u32 alloc_rx_page_failed;
 	u32 alloc_rx_buff_failed;
 
-	struct ixgbe_q_vector *q_vector[MAX_Q_VECTORS];
+	struct ixgbe_q_vector *q_vector[MAX_MSIX_Q_VECTORS];
 
-	/* DCB parameters */
+#ifdef HAVE_DCBNL_IEEE
 	struct ieee_pfc *ixgbe_ieee_pfc;
 	struct ieee_ets *ixgbe_ieee_ets;
+#endif
 	struct ixgbe_dcb_config dcb_cfg;
 	struct ixgbe_dcb_config temp_dcb_cfg;
-	u8 hw_tcs;
 	u8 dcb_set_bitmap;
 	u8 dcbx_cap;
+#ifndef HAVE_MQPRIO
+	u8 dcb_tc;
+#endif
 	enum ixgbe_fc_mode last_lfc_mode;
 
 	int num_q_vectors;	/* current number of q_vectors for device */
-	int max_q_vectors;	/* true count of q_vectors for device */
+	int max_q_vectors;	/* upper limit of q_vectors for device */
 	struct ixgbe_ring_feature ring_feature[RING_F_ARRAY_SIZE];
 	struct msix_entry *msix_entries;
 
+#ifndef HAVE_NETDEV_STATS_IN_NETDEV
+	struct net_device_stats net_stats;
+#endif
+
+#ifdef ETHTOOL_TEST
 	u32 test_icr;
 	struct ixgbe_ring test_tx_ring;
 	struct ixgbe_ring test_rx_ring;
+#endif
 
 	/* structs defined in ixgbe_hw.h */
 	struct ixgbe_hw hw;
 	u16 msg_enable;
 	struct ixgbe_hw_stats stats;
-
+#ifndef IXGBE_NO_LLI
+	u32 lli_port;
+	u32 lli_size;
+	u32 lli_etype;
+	u32 lli_vlan_pri;
+#endif /* IXGBE_NO_LLI */
+
+	u32 *config_space;
 	u64 tx_busy;
 	unsigned int tx_ring_count;
 	unsigned int xdp_ring_count;
@@ -684,6 +963,9 @@ struct ixgbe_adapter {
 
 	u32 link_speed;
 	bool link_up;
+
+	bool cloud_mode;
+
 	unsigned long sfp_poll_time;
 	unsigned long link_check_timeout;
 
@@ -698,20 +980,27 @@ struct ixgbe_adapter {
 	u32 atr_sample_rate;
 	spinlock_t fdir_perfect_lock;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	struct ixgbe_fcoe fcoe;
-#endif /* IXGBE_FCOE */
-	u8 __iomem *io_addr; /* Mainly for iounmap use */
+#endif /* CONFIG_FCOE */
+	u8 __iomem *io_addr;	/* Mainly for iounmap use */
 	u32 wol;
 
+	u16 bd_number;
+
+#ifdef HAVE_BRIDGE_ATTRIBS
 	u16 bridge_mode;
+#endif
 
-	char eeprom_id[NVM_VER_SIZE];
+	char eeprom_id[32];
 	u16 eeprom_cap;
-
+	bool netdev_registered;
 	u32 interrupt_event;
+#ifdef HAVE_ETHTOOL_SET_PHYS_ID
 	u32 led_reg;
+#endif
 
+#ifdef HAVE_PTP_1588_CLOCK
 	struct ptp_clock *ptp_clock;
 	struct ptp_clock_info ptp_caps;
 	struct work_struct ptp_tx_work;
@@ -720,7 +1009,6 @@ struct ixgbe_adapter {
 	unsigned long ptp_tx_start;
 	unsigned long last_overflow_check;
 	unsigned long last_rx_ptp_check;
-	unsigned long last_rx_timestamp;
 	spinlock_t tmreg_lock;
 	struct cyclecounter hw_cc;
 	struct timecounter hw_tc;
@@ -728,34 +1016,48 @@ struct ixgbe_adapter {
 	u32 tx_hwtstamp_timeouts;
 	u32 tx_hwtstamp_skipped;
 	u32 rx_hwtstamp_cleared;
-	void (*ptp_setup_sdp)(struct ixgbe_adapter *);
+	void (*ptp_setup_sdp) (struct ixgbe_adapter *);
+#endif /* HAVE_PTP_1588_CLOCK */
 
-	/* SR-IOV */
 	DECLARE_BITMAP(active_vfs, IXGBE_MAX_VF_FUNCTIONS);
 	unsigned int num_vfs;
+	unsigned int max_vfs;
 	struct vf_data_storage *vfinfo;
 	int vf_rate_link_speed;
 	struct vf_macvlans vf_mvs;
 	struct vf_macvlans *mv_list;
-
+#ifdef CONFIG_PCI_IOV
 	u32 timer_event_accumulator;
 	u32 vferr_refcount;
+#endif
 	struct ixgbe_mac_addr *mac_table;
-	struct kobject *info_kobj;
-#ifdef CONFIG_IXGBE_HWMON
+#ifdef IXGBE_SYSFS
+#ifdef IXGBE_HWMON
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	struct hwmon_buff *ixgbe_hwmon_buff;
-#endif /* CONFIG_IXGBE_HWMON */
-#ifdef CONFIG_DEBUG_FS
+#else
+	struct hwmon_buff ixgbe_hwmon_buff;
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
+#endif /* IXGBE_HWMON */
+#else /* IXGBE_SYSFS */
+#ifdef IXGBE_PROCFS
+	struct proc_dir_entry *eth_dir;
+	struct proc_dir_entry *info_dir;
+	u64 old_lsc;
+	struct proc_dir_entry *therm_dir[IXGBE_MAX_SENSORS];
+	struct ixgbe_therm_proc_data therm_data[IXGBE_MAX_SENSORS];
+#endif /* IXGBE_PROCFS */
+#endif /* IXGBE_SYSFS */
+
+#ifdef HAVE_IXGBE_DEBUG_FS
 	struct dentry *ixgbe_dbg_adapter;
-#endif /*CONFIG_DEBUG_FS*/
-
+#endif /*HAVE_IXGBE_DEBUG_FS*/
 	u8 default_up;
-	/* Bitmask indicating in use pools */
-	DECLARE_BITMAP(fwd_bitmask, IXGBE_MAX_MACVLANS + 1);
-
+#ifdef HAVE_TC_SETUP_CLSU32
 #define IXGBE_MAX_LINK_HANDLE 10
 	struct ixgbe_jump_table *jump_tables[IXGBE_MAX_LINK_HANDLE];
 	unsigned long tables;
+#endif /* NETIF_F_HW_TC */
 
 /* maximum number of RETA entries among all devices supported by ixgbe
  * driver: currently it's x550 device in non-SRIOV mode
@@ -766,9 +1068,17 @@ struct ixgbe_adapter {
 #define IXGBE_RSS_KEY_SIZE     40  /* size of RSS Hash Key in bytes */
 	u32 *rss_key;
 
-#ifdef CONFIG_IXGBE_IPSEC
-	struct ixgbe_ipsec *ipsec;
-#endif /* CONFIG_IXGBE_IPSEC */
+#ifdef HAVE_TX_MQ
+#ifndef HAVE_NETDEV_SELECT_QUEUE
+	unsigned int indices;
+#endif
+#endif
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	/* AF_XDP zero-copy */
+	struct xdp_umem **xsk_umems;
+	u16 num_xsk_umems_used;
+	u16 num_xsk_umems;
+#endif
 };
 
 static inline u8 ixgbe_max_rss_indices(struct ixgbe_adapter *adapter)
@@ -778,17 +1088,20 @@ static inline u8 ixgbe_max_rss_indices(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 		return IXGBE_MAX_RSS_INDICES;
+		break;
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		return IXGBE_MAX_RSS_INDICES_X550;
+		break;
 	default:
 		return 0;
+		break;
 	}
 }
 
 struct ixgbe_fdir_filter {
-	struct hlist_node fdir_node;
+	struct  hlist_node fdir_node;
 	union ixgbe_atr_input filter;
 	u16 sw_idx;
 	u64 action;
@@ -803,49 +1116,61 @@ enum ixgbe_state_t {
 	__IXGBE_SERVICE_SCHED,
 	__IXGBE_SERVICE_INITED,
 	__IXGBE_IN_SFP_INIT,
+#ifdef HAVE_PTP_1588_CLOCK
 	__IXGBE_PTP_RUNNING,
 	__IXGBE_PTP_TX_IN_PROGRESS,
+#endif
 	__IXGBE_RESET_REQUESTED,
 };
 
 struct ixgbe_cb {
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	union {				/* Union defining head/tail partner */
 		struct sk_buff *head;
 		struct sk_buff *tail;
 	};
+#endif
 	dma_addr_t dma;
-	u16 append_cnt;
-	bool page_released;
+#ifdef HAVE_VLAN_RX_REGISTER
+	u16	vid;			/* VLAN tag */
+#endif
+	u16	append_cnt;		/* number of skb's appended */
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	bool	page_released;
+#endif
 };
 #define IXGBE_CB(skb) ((struct ixgbe_cb *)(skb)->cb)
 
-enum ixgbe_boards {
-	board_82598,
-	board_82599,
-	board_X540,
-	board_X550,
-	board_X550EM_x,
-	board_x550em_x_fw,
-	board_x550em_a,
-	board_x550em_a_fw,
-};
-
-extern const struct ixgbe_info ixgbe_82598_info;
-extern const struct ixgbe_info ixgbe_82599_info;
-extern const struct ixgbe_info ixgbe_X540_info;
-extern const struct ixgbe_info ixgbe_X550_info;
-extern const struct ixgbe_info ixgbe_X550EM_x_info;
-extern const struct ixgbe_info ixgbe_x550em_x_fw_info;
-extern const struct ixgbe_info ixgbe_x550em_a_info;
-extern const struct ixgbe_info ixgbe_x550em_a_fw_info;
-#ifdef CONFIG_IXGBE_DCB
-extern const struct dcbnl_rtnl_ops ixgbe_dcbnl_ops;
-#endif
+/* ESX ixgbe CIM IOCTL definition */
 
+#ifdef IXGBE_SYSFS
+void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter);
+int ixgbe_sysfs_init(struct ixgbe_adapter *adapter);
+#endif /* IXGBE_SYSFS */
+#ifdef IXGBE_PROCFS
+void ixgbe_procfs_exit(struct ixgbe_adapter *adapter);
+int ixgbe_procfs_init(struct ixgbe_adapter *adapter);
+int ixgbe_procfs_topdir_init(void);
+void ixgbe_procfs_topdir_exit(void);
+#endif /* IXGBE_PROCFS */
+
+extern struct dcbnl_rtnl_ops ixgbe_dcbnl_ops;
+int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max);
+
+u8 ixgbe_dcb_txq_to_tc(struct ixgbe_adapter *adapter, u8 index);
+
+/* needed by ixgbe_main.c */
+int ixgbe_validate_mac_addr(u8 *mc_addr);
+void ixgbe_check_options(struct ixgbe_adapter *adapter);
+void ixgbe_assign_netdev_ops(struct net_device *netdev);
+
+/* needed by ixgbe_ethtool.c */
+#ifdef HAVE_NON_CONST_PCI_DRIVER_NAME
 extern char ixgbe_driver_name[];
-#ifdef IXGBE_FCOE
-extern char ixgbe_default_device_descr[];
-#endif /* IXGBE_FCOE */
+#else
+extern const char ixgbe_driver_name[];
+#endif
+extern const char ixgbe_driver_version[];
 
 int ixgbe_open(struct net_device *netdev);
 int ixgbe_close(struct net_device *netdev);
@@ -858,110 +1183,129 @@ int ixgbe_setup_rx_resources(struct ixgbe_adapter *, struct ixgbe_ring *);
 int ixgbe_setup_tx_resources(struct ixgbe_ring *);
 void ixgbe_free_rx_resources(struct ixgbe_ring *);
 void ixgbe_free_tx_resources(struct ixgbe_ring *);
-void ixgbe_configure_rx_ring(struct ixgbe_adapter *, struct ixgbe_ring *);
-void ixgbe_configure_tx_ring(struct ixgbe_adapter *, struct ixgbe_ring *);
-void ixgbe_disable_rx(struct ixgbe_adapter *adapter);
-void ixgbe_disable_tx(struct ixgbe_adapter *adapter);
+void ixgbe_configure_rx_ring(struct ixgbe_adapter *,
+				    struct ixgbe_ring *);
+void ixgbe_configure_tx_ring(struct ixgbe_adapter *,
+				    struct ixgbe_ring *);
 void ixgbe_update_stats(struct ixgbe_adapter *adapter);
 int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter);
-bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id,
-			 u16 subdevice_id);
-#ifdef CONFIG_PCI_IOV
-void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter);
-#endif
-int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter,
-			 const u8 *addr, u16 queue);
-int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
-			 const u8 *addr, u16 queue);
-void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid);
+void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter);
+void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter);
 void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter);
-netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *, struct ixgbe_adapter *,
-				  struct ixgbe_ring *);
+bool ixgbe_is_ixgbe(struct pci_dev *pcidev);
+netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *,
+					 struct ixgbe_adapter *,
+					 struct ixgbe_ring *);
 void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *,
-				      struct ixgbe_tx_buffer *);
+					     struct ixgbe_tx_buffer *);
 void ixgbe_alloc_rx_buffers(struct ixgbe_ring *, u16);
-void ixgbe_write_eitr(struct ixgbe_q_vector *);
-int ixgbe_poll(struct napi_struct *napi, int budget);
-int ethtool_ioctl(struct ifreq *ifr);
-s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
-s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl);
-s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl);
-s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
-					  union ixgbe_atr_hash_dword input,
-					  union ixgbe_atr_hash_dword common,
-					  u8 queue);
-s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
-				    union ixgbe_atr_input *input_mask);
-s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
-					  union ixgbe_atr_input *input,
-					  u16 soft_id, u8 queue);
-s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
-					  union ixgbe_atr_input *input,
-					  u16 soft_id);
-void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
-					  union ixgbe_atr_input *mask);
+void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter,
+				   struct ixgbe_ring *);
+void ixgbe_clear_rscctl(struct ixgbe_adapter *adapter,
+			       struct ixgbe_ring *);
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+void ixgbe_clear_udp_tunnel_port(struct ixgbe_adapter *, u32);
+#endif
 int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 				    struct ixgbe_fdir_filter *input,
 				    u16 sw_idx);
 void ixgbe_set_rx_mode(struct net_device *netdev);
-#ifdef CONFIG_IXGBE_DCB
-void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter);
-#endif
+int ixgbe_write_mc_addr_list(struct net_device *netdev);
 int ixgbe_setup_tc(struct net_device *dev, u8 tc);
 void ixgbe_tx_ctxtdesc(struct ixgbe_ring *, u32, u32, u32, u32);
 void ixgbe_do_reset(struct net_device *netdev);
-#ifdef CONFIG_IXGBE_HWMON
-void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter);
-int ixgbe_sysfs_init(struct ixgbe_adapter *adapter);
-#endif /* CONFIG_IXGBE_HWMON */
-#ifdef IXGBE_FCOE
+void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector);
+int ixgbe_poll(struct napi_struct *napi, int budget);
+void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter);
+void ixgbe_disable_tx_queue(struct ixgbe_adapter *adapter);
+void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter);
+void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter);
+#ifdef ETHTOOL_OPS_COMPAT
+int ethtool_ioctl(struct ifreq *ifr);
+#endif
+
+#if IS_ENABLED(CONFIG_FCOE)
 void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter);
-int ixgbe_fso(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first,
-	      u8 *hdr_len);
+int ixgbe_fso(struct ixgbe_ring *tx_ring,
+		     struct ixgbe_tx_buffer *first,
+		     u8 *hdr_len);
 int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
-		   union ixgbe_adv_rx_desc *rx_desc, struct sk_buff *skb);
+			  union ixgbe_adv_rx_desc *rx_desc,
+			  struct sk_buff *skb);
 int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,
-		       struct scatterlist *sgl, unsigned int sgc);
+			      struct scatterlist *sgl, unsigned int sgc);
+#ifdef HAVE_NETDEV_OPS_FCOE_DDP_TARGET
 int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,
-			  struct scatterlist *sgl, unsigned int sgc);
+				 struct scatterlist *sgl, unsigned int sgc);
+#endif /* HAVE_NETDEV_OPS_FCOE_DDP_TARGET */
 int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid);
 int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter);
 void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter);
+#ifdef HAVE_NETDEV_OPS_FCOE_ENABLE
 int ixgbe_fcoe_enable(struct net_device *netdev);
 int ixgbe_fcoe_disable(struct net_device *netdev);
-#ifdef CONFIG_IXGBE_DCB
-u8 ixgbe_fcoe_getapp(struct ixgbe_adapter *adapter);
+#else
+int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter);
+void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter);
+#endif /* HAVE_NETDEV_OPS_FCOE_ENABLE */
+#if IS_ENABLED(CONFIG_DCB)
+#ifdef HAVE_DCBNL_OPS_GETAPP
+u8 ixgbe_fcoe_getapp(struct net_device *netdev);
+#endif /* HAVE_DCBNL_OPS_GETAPP */
 u8 ixgbe_fcoe_setapp(struct ixgbe_adapter *adapter, u8 up);
-#endif /* CONFIG_IXGBE_DCB */
-int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
-int ixgbe_fcoe_get_hbainfo(struct net_device *netdev,
-			   struct netdev_fcoe_hbainfo *info);
+#endif /* CONFIG_DCB */
 u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter);
-#endif /* IXGBE_FCOE */
-#ifdef CONFIG_DEBUG_FS
+#ifdef HAVE_NETDEV_OPS_FCOE_GETWWN
+int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
+#endif
+#endif /* CONFIG_FCOE */
+
+#ifdef HAVE_IXGBE_DEBUG_FS
 void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter);
 void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter);
 void ixgbe_dbg_init(void);
 void ixgbe_dbg_exit(void);
-#else
-static inline void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter) {}
-static inline void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter) {}
-static inline void ixgbe_dbg_init(void) {}
-static inline void ixgbe_dbg_exit(void) {}
-#endif /* CONFIG_DEBUG_FS */
+#endif /* HAVE_IXGBE_DEBUG_FS */
+
 static inline struct netdev_queue *txring_txq(const struct ixgbe_ring *ring)
 {
 	return netdev_get_tx_queue(ring->netdev, ring->queue_index);
 }
 
+#if IS_ENABLED(CONFIG_DCB)
+#ifdef HAVE_DCBNL_IEEE
+s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame);
+#endif /* HAVE_DCBNL_IEEE */
+#endif /* CONFIG_DCB */
+
+bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id,
+			 u16 subdevice_id);
+void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter);
+int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter,
+				const u8 *addr, u16 queue);
+int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
+				const u8 *addr, u16 queue);
+int ixgbe_available_rars(struct ixgbe_adapter *adapter, u16 pool);
+void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid);
+#ifndef HAVE_VLAN_RX_REGISTER
+void ixgbe_vlan_mode(struct net_device *, u32);
+#else
+#ifdef CONFIG_PCI_IOV
+int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw, u32 vlan);
+#endif
+#endif
+
+#ifdef HAVE_PTP_1588_CLOCK
 void ixgbe_ptp_init(struct ixgbe_adapter *adapter);
-void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_stop(struct ixgbe_adapter *adapter);
+void ixgbe_ptp_suspend(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_tx_hang(struct ixgbe_adapter *adapter);
-void ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *, struct sk_buff *);
-void ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *, struct sk_buff *skb);
+void ixgbe_ptp_rx_pktstamp(struct ixgbe_q_vector *q_vector,
+				  struct sk_buff *skb);
+void ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector,
+				  struct sk_buff *skb);
 static inline void ixgbe_ptp_rx_hwtstamp(struct ixgbe_ring *rx_ring,
 					 union ixgbe_adv_rx_desc *rx_desc,
 					 struct sk_buff *skb)
@@ -982,56 +1326,18 @@ static inline void ixgbe_ptp_rx_hwtstamp(struct ixgbe_ring *rx_ring,
 	rx_ring->last_rx_timestamp = jiffies;
 }
 
-int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr);
 int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr);
+int ixgbe_ptp_set_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr);
 void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_reset(struct ixgbe_adapter *adapter);
 void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter);
+#endif /* HAVE_PTP_1588_CLOCK */
 #ifdef CONFIG_PCI_IOV
 void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter);
 #endif
-
-netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
-				  struct ixgbe_adapter *adapter,
-				  struct ixgbe_ring *tx_ring);
 u32 ixgbe_rss_indir_tbl_entries(struct ixgbe_adapter *adapter);
 void ixgbe_store_key(struct ixgbe_adapter *adapter);
 void ixgbe_store_reta(struct ixgbe_adapter *adapter);
-s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,
-		       u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm);
-#ifdef CONFIG_IXGBE_IPSEC
-void ixgbe_init_ipsec_offload(struct ixgbe_adapter *adapter);
-void ixgbe_stop_ipsec_offload(struct ixgbe_adapter *adapter);
-void ixgbe_ipsec_restore(struct ixgbe_adapter *adapter);
-void ixgbe_ipsec_rx(struct ixgbe_ring *rx_ring,
-		    union ixgbe_adv_rx_desc *rx_desc,
-		    struct sk_buff *skb);
-int ixgbe_ipsec_tx(struct ixgbe_ring *tx_ring, struct ixgbe_tx_buffer *first,
-		   struct ixgbe_ipsec_tx_data *itd);
-void ixgbe_ipsec_vf_clear(struct ixgbe_adapter *adapter, u32 vf);
-int ixgbe_ipsec_vf_add_sa(struct ixgbe_adapter *adapter, u32 *mbuf, u32 vf);
-int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter, u32 *mbuf, u32 vf);
-#else
-static inline void ixgbe_init_ipsec_offload(struct ixgbe_adapter *adapter) { }
-static inline void ixgbe_stop_ipsec_offload(struct ixgbe_adapter *adapter) { }
-static inline void ixgbe_ipsec_restore(struct ixgbe_adapter *adapter) { }
-static inline void ixgbe_ipsec_rx(struct ixgbe_ring *rx_ring,
-				  union ixgbe_adv_rx_desc *rx_desc,
-				  struct sk_buff *skb) { }
-static inline int ixgbe_ipsec_tx(struct ixgbe_ring *tx_ring,
-				 struct ixgbe_tx_buffer *first,
-				 struct ixgbe_ipsec_tx_data *itd) { return 0; }
-static inline void ixgbe_ipsec_vf_clear(struct ixgbe_adapter *adapter,
-					u32 vf) { }
-static inline int ixgbe_ipsec_vf_add_sa(struct ixgbe_adapter *adapter,
-					u32 *mbuf, u32 vf) { return -EACCES; }
-static inline int ixgbe_ipsec_vf_del_sa(struct ixgbe_adapter *adapter,
-					u32 *mbuf, u32 vf) { return -EACCES; }
-#endif /* CONFIG_IXGBE_IPSEC */
-
-static inline bool ixgbe_enabled_xdp_adapter(struct ixgbe_adapter *adapter)
-{
-	return !!adapter->xdp_prog;
-}
 
+void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter);
 #endif /* _IXGBE_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
index 95c92fe890a1..60695063ca57 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.c
@@ -1,11 +1,10 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include "ixgbe.h"
+#include "ixgbe_type.h"
+#include "ixgbe_82598.h"
+#include "ixgbe_api.h"
+#include "ixgbe_common.h"
 #include "ixgbe_phy.h"
 
 #define IXGBE_82598_MAX_TX_QUEUES 32
@@ -13,32 +12,45 @@
 #define IXGBE_82598_RAR_ENTRIES   16
 #define IXGBE_82598_MC_TBL_SIZE  128
 #define IXGBE_82598_VFT_TBL_SIZE 128
-#define IXGBE_82598_RX_PB_SIZE	 512
+#define IXGBE_82598_RX_PB_SIZE   512
 
-static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
+					     ixgbe_link_speed *speed,
+					     bool *autoneg);
+STATIC enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
+				      bool autoneg_wait_to_complete);
+STATIC s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
+				      ixgbe_link_speed *speed, bool *link_up,
+				      bool link_up_wait_to_complete);
+STATIC s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
+				      ixgbe_link_speed speed,
+				      bool autoneg_wait_to_complete);
+STATIC s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
 					 ixgbe_link_speed speed,
 					 bool autoneg_wait_to_complete);
-static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
-				       u8 *eeprom_data);
-
+STATIC s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
+STATIC s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw);
+STATIC void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
+				  u32 headroom, int strategy);
+STATIC s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset,
+					u8 *sff8472_data);
 /**
- *  ixgbe_set_pcie_completion_timeout - set pci-e completion timeout
- *  @hw: pointer to the HW structure
+ * ixgbe_set_pcie_completion_timeout - set pci-e completion timeout
+ * @hw: pointer to the HW structure
  *
- *  The defaults for 82598 should be in the range of 50us to 50ms,
- *  however the hardware default for these parts is 500us to 1ms which is less
- *  than the 10ms recommended by the pci-e spec.  To address this we need to
- *  increase the value to either 10ms to 250ms for capability version 1 config,
- *  or 16ms to 55ms for version 2.
+ * The defaults for 82598 should be in the range of 50us to 50ms,
+ * however the hardware default for these parts is 500us to 1ms which is less
+ * than the 10ms recommended by the pci-e spec.  To address this we need to
+ * increase the value to either 10ms to 250ms for capability version 1 config,
+ * or 16ms to 55ms for version 2.
  **/
-static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
+void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
 {
 	u32 gcr = IXGBE_READ_REG(hw, IXGBE_GCR);
 	u16 pcie_devctl2;
 
-	if (ixgbe_removed(hw->hw_addr))
-		return;
-
 	/* only take action if timeout value is defaulted to 0 */
 	if (gcr & IXGBE_GCR_CMPL_TMOUT_MASK)
 		goto out;
@@ -57,125 +69,207 @@ static void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
 	 * directly in order to set the completion timeout value for
 	 * 16ms to 55ms
 	 */
-	pcie_devctl2 = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2);
+	pcie_devctl2 = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2);
 	pcie_devctl2 |= IXGBE_PCI_DEVICE_CONTROL2_16ms;
-	ixgbe_write_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2, pcie_devctl2);
+	IXGBE_WRITE_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2, pcie_devctl2);
 out:
 	/* disable completion timeout resend */
 	gcr &= ~IXGBE_GCR_CMPL_TMOUT_RESEND;
 	IXGBE_WRITE_REG(hw, IXGBE_GCR, gcr);
 }
 
-static s32 ixgbe_get_invariants_82598(struct ixgbe_hw *hw)
+/**
+ * ixgbe_init_ops_82598 - Inits func ptrs and MAC type
+ * @hw: pointer to hardware structure
+ *
+ * Initialize the function pointers and assign the MAC type for 82598.
+ * Does not touch the hardware.
+ **/
+s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
+	struct ixgbe_phy_info *phy = &hw->phy;
+	s32 ret_val;
 
-	/* Call PHY identify routine to get the phy type */
-	ixgbe_identify_phy_generic(hw);
-
-	mac->mcft_size = IXGBE_82598_MC_TBL_SIZE;
-	mac->vft_size = IXGBE_82598_VFT_TBL_SIZE;
-	mac->num_rar_entries = IXGBE_82598_RAR_ENTRIES;
-	mac->rx_pb_size = IXGBE_82598_RX_PB_SIZE;
-	mac->max_rx_queues = IXGBE_82598_MAX_RX_QUEUES;
-	mac->max_tx_queues = IXGBE_82598_MAX_TX_QUEUES;
-	mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
-
-	return 0;
+	DEBUGFUNC("ixgbe_init_ops_82598");
+
+	ret_val = ixgbe_init_phy_ops_generic(hw);
+	ret_val = ixgbe_init_ops_generic(hw);
+
+	/* PHY */
+	phy->ops.init = ixgbe_init_phy_ops_82598;
+
+	/* MAC */
+	mac->ops.start_hw = ixgbe_start_hw_82598;
+	mac->ops.reset_hw = ixgbe_reset_hw_82598;
+	mac->ops.get_media_type = ixgbe_get_media_type_82598;
+	mac->ops.get_supported_physical_layer =
+				ixgbe_get_supported_physical_layer_82598;
+	mac->ops.read_analog_reg8 = ixgbe_read_analog_reg8_82598;
+	mac->ops.write_analog_reg8 = ixgbe_write_analog_reg8_82598;
+	mac->ops.set_lan_id = ixgbe_set_lan_id_multi_port_pcie_82598;
+	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_82598;
+
+	/* RAR, Multicast, VLAN */
+	mac->ops.set_vmdq = ixgbe_set_vmdq_82598;
+	mac->ops.clear_vmdq = ixgbe_clear_vmdq_82598;
+	mac->ops.set_vfta = ixgbe_set_vfta_82598;
+	mac->ops.set_vlvf = NULL;
+	mac->ops.clear_vfta = ixgbe_clear_vfta_82598;
+
+	/* Flow Control */
+	mac->ops.fc_enable = ixgbe_fc_enable_82598;
+
+	mac->mcft_size		= IXGBE_82598_MC_TBL_SIZE;
+	mac->vft_size		= IXGBE_82598_VFT_TBL_SIZE;
+	mac->num_rar_entries	= IXGBE_82598_RAR_ENTRIES;
+	mac->rx_pb_size		= IXGBE_82598_RX_PB_SIZE;
+	mac->max_rx_queues	= IXGBE_82598_MAX_RX_QUEUES;
+	mac->max_tx_queues	= IXGBE_82598_MAX_TX_QUEUES;
+	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
+
+	/* SFP+ Module */
+	phy->ops.read_i2c_eeprom = ixgbe_read_i2c_eeprom_82598;
+	phy->ops.read_i2c_sff8472 = ixgbe_read_i2c_sff8472_82598;
+
+	/* Link */
+	mac->ops.check_link = ixgbe_check_mac_link_82598;
+	mac->ops.setup_link = ixgbe_setup_mac_link_82598;
+	mac->ops.flap_tx_laser = NULL;
+	mac->ops.get_link_capabilities = ixgbe_get_link_capabilities_82598;
+	mac->ops.setup_rxpba = ixgbe_set_rxpba_82598;
+
+	/* Manageability interface */
+	mac->ops.set_fw_drv_ver = NULL;
+
+	mac->ops.get_rtrup2tc = NULL;
+
+	return ret_val;
 }
 
 /**
- *  ixgbe_init_phy_ops_82598 - PHY/SFP specific init
- *  @hw: pointer to hardware structure
+ * ixgbe_init_phy_ops_82598 - PHY/SFP specific init
+ * @hw: pointer to hardware structure
  *
- *  Initialize any function pointers that were not able to be
- *  set during get_invariants because the PHY/SFP type was
- *  not known.  Perform the SFP init if necessary.
+ * Initialize any function pointers that were not able to be
+ * set during init_shared_code because the PHY/SFP type was
+ * not known.  Perform the SFP init if necessary.
  *
  **/
-static s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)
+s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 	struct ixgbe_phy_info *phy = &hw->phy;
-	s32 ret_val;
+	s32 ret_val = IXGBE_SUCCESS;
 	u16 list_offset, data_offset;
 
+	DEBUGFUNC("ixgbe_init_phy_ops_82598");
+
 	/* Identify the PHY */
 	phy->ops.identify(hw);
 
 	/* Overwrite the link function pointers if copper PHY */
 	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
-		mac->ops.setup_link = &ixgbe_setup_copper_link_82598;
+		mac->ops.setup_link = ixgbe_setup_copper_link_82598;
 		mac->ops.get_link_capabilities =
-			&ixgbe_get_copper_link_capabilities_generic;
+				ixgbe_get_copper_link_capabilities_generic;
 	}
 
 	switch (hw->phy.type) {
 	case ixgbe_phy_tn:
-		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
-		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
+		phy->ops.setup_link = ixgbe_setup_phy_link_tnx;
+		phy->ops.check_link = ixgbe_check_phy_link_tnx;
+		phy->ops.get_firmware_version =
+					ixgbe_get_phy_firmware_version_tnx;
 		break;
 	case ixgbe_phy_nl:
-		phy->ops.reset = &ixgbe_reset_phy_nl;
+		phy->ops.reset = ixgbe_reset_phy_nl;
 
 		/* Call SFP+ identify routine to get the SFP+ module type */
 		ret_val = phy->ops.identify_sfp(hw);
-		if (ret_val)
-			return ret_val;
-		if (hw->phy.sfp_type == ixgbe_sfp_type_unknown)
-			return IXGBE_ERR_SFP_NOT_SUPPORTED;
+		if (ret_val != IXGBE_SUCCESS)
+			goto out;
+		else if (hw->phy.sfp_type == ixgbe_sfp_type_unknown) {
+			ret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;
+			goto out;
+		}
 
 		/* Check to see if SFP+ module is supported */
 		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,
-							    &list_offset,
-							    &data_offset);
-		if (ret_val)
-			return IXGBE_ERR_SFP_NOT_SUPPORTED;
+							      &list_offset,
+							      &data_offset);
+		if (ret_val != IXGBE_SUCCESS) {
+			ret_val = IXGBE_ERR_SFP_NOT_SUPPORTED;
+			goto out;
+		}
 		break;
 	default:
 		break;
 	}
 
-	return 0;
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_start_hw_82598 - Prepare hardware for Tx/Rx
- *  @hw: pointer to hardware structure
+ * ixgbe_start_hw_82598 - Prepare hardware for Tx/Rx
+ * @hw: pointer to hardware structure
  *
- *  Starts the hardware using the generic start_hw function.
- *  Disables relaxed ordering for archs other than SPARC
- *  Then set pcie completion timeout
+ * Starts the hardware using the generic start_hw function.
+ * Disables relaxed ordering Then set pcie completion timeout
  *
  **/
-static s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)
+s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)
 {
-	s32 ret_val;
+	u32 regval;
+	u32 i;
+	s32 ret_val = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_start_hw_82598");
 
 	ret_val = ixgbe_start_hw_generic(hw);
 	if (ret_val)
 		return ret_val;
 
+	/* Disable relaxed ordering */
+	for (i = 0; ((i < hw->mac.max_tx_queues) &&
+	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
+		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
+		regval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;
+		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL(i), regval);
+	}
+
+	for (i = 0; ((i < hw->mac.max_rx_queues) &&
+	     (i < IXGBE_DCA_MAX_QUEUES_82598)); i++) {
+		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
+		regval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |
+			    IXGBE_DCA_RXCTRL_HEAD_WRO_EN);
+		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
+	}
+
 	/* set the completion timeout for interface */
 	ixgbe_set_pcie_completion_timeout(hw);
 
-	return 0;
+	return ret_val;
 }
 
 /**
- *  ixgbe_get_link_capabilities_82598 - Determines link capabilities
- *  @hw: pointer to hardware structure
- *  @speed: pointer to link speed
- *  @autoneg: boolean auto-negotiation value
+ * ixgbe_get_link_capabilities_82598 - Determines link capabilities
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @autoneg: boolean auto-negotiation value
  *
- *  Determines the link capabilities by reading the AUTOC register.
+ * Determines the link capabilities by reading the AUTOC register.
  **/
-static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
 					     ixgbe_link_speed *speed,
 					     bool *autoneg)
 {
+	s32 status = IXGBE_SUCCESS;
 	u32 autoc = 0;
 
+	DEBUGFUNC("ixgbe_get_link_capabilities_82598");
+
 	/*
 	 * Determine link capabilities based on the stored value of AUTOC,
 	 * which represents EEPROM defaults.  If AUTOC value has not been
@@ -213,26 +307,31 @@ static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
 		break;
 
 	default:
-		return IXGBE_ERR_LINK_SETUP;
+		status = IXGBE_ERR_LINK_SETUP;
+		break;
 	}
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_get_media_type_82598 - Determines media type
- *  @hw: pointer to hardware structure
+ * ixgbe_get_media_type_82598 - Determines media type
+ * @hw: pointer to hardware structure
  *
- *  Returns the media type (fiber, copper, backplane)
+ * Returns the media type (fiber, copper, backplane)
  **/
-static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
+STATIC enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
 {
+	enum ixgbe_media_type media_type;
+
+	DEBUGFUNC("ixgbe_get_media_type_82598");
+
 	/* Detect if there is a copper PHY attached. */
 	switch (hw->phy.type) {
 	case ixgbe_phy_cu_unknown:
 	case ixgbe_phy_tn:
-		return ixgbe_media_type_copper;
-
+		media_type = ixgbe_media_type_copper;
+		goto out;
 	default:
 		break;
 	}
@@ -242,37 +341,41 @@ static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
 	case IXGBE_DEV_ID_82598:
 	case IXGBE_DEV_ID_82598_BX:
 		/* Default device ID is mezzanine card KX/KX4 */
-		return ixgbe_media_type_backplane;
-
+		media_type = ixgbe_media_type_backplane;
+		break;
 	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
 	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
 	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
 	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
 	case IXGBE_DEV_ID_82598EB_XF_LR:
 	case IXGBE_DEV_ID_82598EB_SFP_LOM:
-		return ixgbe_media_type_fiber;
-
+		media_type = ixgbe_media_type_fiber;
+		break;
 	case IXGBE_DEV_ID_82598EB_CX4:
 	case IXGBE_DEV_ID_82598_CX4_DUAL_PORT:
-		return ixgbe_media_type_cx4;
-
+		media_type = ixgbe_media_type_cx4;
+		break;
 	case IXGBE_DEV_ID_82598AT:
 	case IXGBE_DEV_ID_82598AT2:
-		return ixgbe_media_type_copper;
-
+		media_type = ixgbe_media_type_copper;
+		break;
 	default:
-		return ixgbe_media_type_unknown;
+		media_type = ixgbe_media_type_unknown;
+		break;
 	}
+out:
+	return media_type;
 }
 
 /**
- *  ixgbe_fc_enable_82598 - Enable flow control
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_enable_82598 - Enable flow control
+ * @hw: pointer to hardware structure
  *
- *  Enable flow control according to the current settings.
+ * Enable flow control according to the current settings.
  **/
-static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
+s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 {
+	s32 ret_val = IXGBE_SUCCESS;
 	u32 fctrl_reg;
 	u32 rmcs_reg;
 	u32 reg;
@@ -281,18 +384,23 @@ static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 	int i;
 	bool link_up;
 
+	DEBUGFUNC("ixgbe_fc_enable_82598");
+
 	/* Validate the water mark configuration */
-	if (!hw->fc.pause_time)
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
+	if (!hw->fc.pause_time) {
+		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+		goto out;
+	}
 
 	/* Low water mark of zero causes XOFF floods */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
 		    hw->fc.high_water[i]) {
 			if (!hw->fc.low_water[i] ||
 			    hw->fc.low_water[i] >= hw->fc.high_water[i]) {
 				hw_dbg(hw, "Invalid water mark configuration\n");
-				return IXGBE_ERR_INVALID_LINK_SETTINGS;
+				ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+				goto out;
 			}
 		}
 	}
@@ -318,7 +426,7 @@ static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 	}
 
 	/* Negotiate the fc mode to use */
-	hw->mac.ops.fc_autoneg(hw);
+	ixgbe_fc_autoneg(hw);
 
 	/* Disable any previous flow control settings */
 	fctrl_reg = IXGBE_READ_REG(hw, IXGBE_FCTRL);
@@ -369,7 +477,9 @@ static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 		break;
 	default:
 		hw_dbg(hw, "Flow control param set incorrectly\n");
-		return IXGBE_ERR_CONFIG;
+		ret_val = IXGBE_ERR_CONFIG;
+		goto out;
+		break;
 	}
 
 	/* Set 802.3x based flow control settings. */
@@ -378,7 +488,7 @@ static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 	IXGBE_WRITE_REG(hw, IXGBE_RMCS, rmcs_reg);
 
 	/* Set up and enable Rx high/low water mark thresholds, enable XON. */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
 		    hw->fc.high_water[i]) {
 			fcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;
@@ -394,30 +504,33 @@ static s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
 
 	/* Configure pause time (2 TCs per register) */
 	reg = hw->fc.pause_time * 0x00010001;
-	for (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)
+	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
 		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);
 
 	/* Configure flow control refresh threshold value */
 	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);
 
-	return 0;
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_start_mac_link_82598 - Configures MAC link settings
- *  @hw: pointer to hardware structure
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_start_mac_link_82598 - Configures MAC link settings
+ * @hw: pointer to hardware structure
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  *
- *  Configures link settings based on values in the ixgbe_hw struct.
- *  Restarts the link.  Performs autonegotiation if needed.
+ * Configures link settings based on values in the ixgbe_hw struct.
+ * Restarts the link.  Performs autonegotiation if needed.
  **/
-static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
 				      bool autoneg_wait_to_complete)
 {
 	u32 autoc_reg;
 	u32 links_reg;
 	u32 i;
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_start_mac_link_82598");
 
 	/* Restart link */
 	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
@@ -435,7 +548,7 @@ static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
 				links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
 				if (links_reg & IXGBE_LINKS_KX_AN_COMP)
 					break;
-				msleep(100);
+				msec_delay(100);
 			}
 			if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
 				status = IXGBE_ERR_AUTONEG_NOT_COMPLETE;
@@ -445,35 +558,36 @@ static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
 	}
 
 	/* Add delay to filter out noises during initial link setup */
-	msleep(50);
+	msec_delay(50);
 
 	return status;
 }
 
 /**
- *  ixgbe_validate_link_ready - Function looks for phy link
- *  @hw: pointer to hardware structure
+ * ixgbe_validate_link_ready - Function looks for phy link
+ * @hw: pointer to hardware structure
  *
- *  Function indicates success when phy link is available. If phy is not ready
- *  within 5 seconds of MAC indicating link, the function returns error.
+ * Function indicates success when phy link is available. If phy is not ready
+ * within 5 seconds of MAC indicating link, the function returns error.
  **/
-static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)
 {
 	u32 timeout;
 	u16 an_reg;
 
 	if (hw->device_id != IXGBE_DEV_ID_82598AT2)
-		return 0;
+		return IXGBE_SUCCESS;
 
 	for (timeout = 0;
 	     timeout < IXGBE_VALIDATE_LINK_READY_TIMEOUT; timeout++) {
-		hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN, &an_reg);
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
+				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &an_reg);
 
-		if ((an_reg & MDIO_AN_STAT1_COMPLETE) &&
-		    (an_reg & MDIO_STAT1_LSTATUS))
+		if ((an_reg & IXGBE_MII_AUTONEG_COMPLETE) &&
+		    (an_reg & IXGBE_MII_AUTONEG_LINK_UP))
 			break;
 
-		msleep(100);
+		msec_delay(100);
 	}
 
 	if (timeout == IXGBE_VALIDATE_LINK_READY_TIMEOUT) {
@@ -481,19 +595,19 @@ static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)
 		return IXGBE_ERR_LINK_SETUP;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_check_mac_link_82598 - Get link/speed status
- *  @hw: pointer to hardware structure
- *  @speed: pointer to link speed
- *  @link_up: true is link is up, false otherwise
- *  @link_up_wait_to_complete: bool used to wait for link up or not
+ * ixgbe_check_mac_link_82598 - Get link/speed status
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @link_up: true is link is up, false otherwise
+ * @link_up_wait_to_complete: bool used to wait for link up or not
  *
- *  Reads the links register to determine if link is up and the current speed
+ * Reads the links register to determine if link is up and the current speed
  **/
-static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
 				      ixgbe_link_speed *speed, bool *link_up,
 				      bool link_up_wait_to_complete)
 {
@@ -501,19 +615,21 @@ static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
 	u32 i;
 	u16 link_reg, adapt_comp_reg;
 
+	DEBUGFUNC("ixgbe_check_mac_link_82598");
+
 	/*
-	 * SERDES PHY requires us to read link status from register 0xC79F.
-	 * Bit 0 set indicates link is up/ready; clear indicates link down.
-	 * 0xC00C is read to check that the XAUI lanes are active.  Bit 0
-	 * clear indicates active; set indicates inactive.
+	 * SERDES PHY requires us to read link status from undocumented
+	 * register 0xC79F.  Bit 0 set indicates link is up/ready; clear
+	 * indicates link down.  OxC00C is read to check that the XAUI lanes
+	 * are active.  Bit 0 clear indicates active; set indicates inactive.
 	 */
 	if (hw->phy.type == ixgbe_phy_nl) {
-		hw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);
-		hw->phy.ops.read_reg(hw, 0xC79F, MDIO_MMD_PMAPMD, &link_reg);
-		hw->phy.ops.read_reg(hw, 0xC00C, MDIO_MMD_PMAPMD,
+		hw->phy.ops.read_reg(hw, 0xC79F, IXGBE_TWINAX_DEV, &link_reg);
+		hw->phy.ops.read_reg(hw, 0xC79F, IXGBE_TWINAX_DEV, &link_reg);
+		hw->phy.ops.read_reg(hw, 0xC00C, IXGBE_TWINAX_DEV,
 				     &adapt_comp_reg);
 		if (link_up_wait_to_complete) {
-			for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
+			for (i = 0; i < hw->mac.max_link_up_time; i++) {
 				if ((link_reg & 1) &&
 				    ((adapt_comp_reg & 1) == 0)) {
 					*link_up = true;
@@ -521,12 +637,12 @@ static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
 				} else {
 					*link_up = false;
 				}
-				msleep(100);
+				msec_delay(100);
 				hw->phy.ops.read_reg(hw, 0xC79F,
-						     MDIO_MMD_PMAPMD,
+						     IXGBE_TWINAX_DEV,
 						     &link_reg);
 				hw->phy.ops.read_reg(hw, 0xC00C,
-						     MDIO_MMD_PMAPMD,
+						     IXGBE_TWINAX_DEV,
 						     &adapt_comp_reg);
 			}
 		} else {
@@ -536,20 +652,20 @@ static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
 				*link_up = false;
 		}
 
-		if (!*link_up)
-			return 0;
+		if (*link_up == false)
+			goto out;
 	}
 
 	links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
 	if (link_up_wait_to_complete) {
-		for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
+		for (i = 0; i < hw->mac.max_link_up_time; i++) {
 			if (links_reg & IXGBE_LINKS_UP) {
 				*link_up = true;
 				break;
 			} else {
 				*link_up = false;
 			}
-			msleep(100);
+			msec_delay(100);
 			links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
 		}
 	} else {
@@ -564,37 +680,41 @@ static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
 	else
 		*speed = IXGBE_LINK_SPEED_1GB_FULL;
 
-	if ((hw->device_id == IXGBE_DEV_ID_82598AT2) && *link_up &&
-	    (ixgbe_validate_link_ready(hw) != 0))
+	if ((hw->device_id == IXGBE_DEV_ID_82598AT2) && (*link_up == true) &&
+	    (ixgbe_validate_link_ready(hw) != IXGBE_SUCCESS))
 		*link_up = false;
 
-	return 0;
+out:
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_setup_mac_link_82598 - Set MAC link speed
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_setup_mac_link_82598 - Set MAC link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  *
- *  Set the link speed in the AUTOC register and restarts link.
+ * Set the link speed in the AUTOC register and restarts link.
  **/
-static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
 				      ixgbe_link_speed speed,
 				      bool autoneg_wait_to_complete)
 {
-	bool		 autoneg	   = false;
+	bool autoneg = false;
+	s32 status = IXGBE_SUCCESS;
 	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
-	u32              curr_autoc        = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	u32              autoc             = curr_autoc;
-	u32              link_mode         = autoc & IXGBE_AUTOC_LMS_MASK;
+	u32 curr_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	u32 autoc = curr_autoc;
+	u32 link_mode = autoc & IXGBE_AUTOC_LMS_MASK;
+
+	DEBUGFUNC("ixgbe_setup_mac_link_82598");
 
 	/* Check to see if speed passed in is supported. */
-	ixgbe_get_link_capabilities_82598(hw, &link_capabilities, &autoneg);
+	ixgbe_get_link_capabilities(hw, &link_capabilities, &autoneg);
 	speed &= link_capabilities;
 
 	if (speed == IXGBE_LINK_SPEED_UNKNOWN)
-		return IXGBE_ERR_LINK_SETUP;
+		status = IXGBE_ERR_LINK_SETUP;
 
 	/* Set KX4/KX support according to speed requested */
 	else if (link_mode == IXGBE_AUTOC_LMS_KX4_AN ||
@@ -608,28 +728,36 @@ static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
 			IXGBE_WRITE_REG(hw, IXGBE_AUTOC, autoc);
 	}
 
-	/* Setup and restart the link based on the new values in
-	 * ixgbe_hw This will write the AUTOC register based on the new
-	 * stored values
-	 */
-	return ixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);
+	if (status == IXGBE_SUCCESS) {
+		/*
+		 * Setup and restart the link based on the new values in
+		 * ixgbe_hw This will write the AUTOC register based on the new
+		 * stored values
+		 */
+		status = ixgbe_start_mac_link_82598(hw,
+						    autoneg_wait_to_complete);
+	}
+
+	return status;
 }
 
 
 /**
- *  ixgbe_setup_copper_link_82598 - Set the PHY autoneg advertised field
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true if waiting is needed to complete
+ * ixgbe_setup_copper_link_82598 - Set the PHY autoneg advertised field
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true if waiting is needed to complete
  *
- *  Sets the link speed in the AUTOC register in the MAC and restarts link.
+ * Sets the link speed in the AUTOC register in the MAC and restarts link.
  **/
-static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
-					       ixgbe_link_speed speed,
-					       bool autoneg_wait_to_complete)
+STATIC s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
+					 ixgbe_link_speed speed,
+					 bool autoneg_wait_to_complete)
 {
 	s32 status;
 
+	DEBUGFUNC("ixgbe_setup_copper_link_82598");
+
 	/* Setup the PHY according to input speed */
 	status = hw->phy.ops.setup_link_speed(hw, speed,
 					      autoneg_wait_to_complete);
@@ -640,27 +768,29 @@ static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_reset_hw_82598 - Performs hardware reset
- *  @hw: pointer to hardware structure
+ * ixgbe_reset_hw_82598 - Performs hardware reset
+ * @hw: pointer to hardware structure
  *
- *  Resets the hardware by resetting the transmit and receive units, masks and
- *  clears all interrupts, performing a PHY reset, and performing a link (MAC)
- *  reset.
+ * Resets the hardware by resetting the transmit and receive units, masks and
+ * clears all interrupts, performing a PHY reset, and performing a link (MAC)
+ * reset.
  **/
-static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
 {
-	s32 status;
-	s32 phy_status = 0;
+	s32 status = IXGBE_SUCCESS;
+	s32 phy_status = IXGBE_SUCCESS;
 	u32 ctrl;
 	u32 gheccr;
 	u32 i;
 	u32 autoc;
 	u8  analog_val;
 
+	DEBUGFUNC("ixgbe_reset_hw_82598");
+
 	/* Call adapter stop to disable tx/rx and clear interrupts */
 	status = hw->mac.ops.stop_adapter(hw);
-	if (status)
-		return status;
+	if (status != IXGBE_SUCCESS)
+		goto reset_hw_out;
 
 	/*
 	 * Power up the Atlas Tx lanes if they are currently powered down.
@@ -702,7 +832,7 @@ static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
 		/* Init PHY and function pointers, perform SFP setup */
 		phy_status = hw->phy.ops.init(hw);
 		if (phy_status == IXGBE_ERR_SFP_NOT_SUPPORTED)
-			return phy_status;
+			goto reset_hw_out;
 		if (phy_status == IXGBE_ERR_SFP_NOT_PRESENT)
 			goto mac_reset_top;
 
@@ -717,21 +847,20 @@ static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
 	ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL) | IXGBE_CTRL_RST;
 	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
 	IXGBE_WRITE_FLUSH(hw);
-	usleep_range(1000, 1200);
 
 	/* Poll for reset bit to self-clear indicating reset is complete */
 	for (i = 0; i < 10; i++) {
+		usec_delay(1);
 		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
 		if (!(ctrl & IXGBE_CTRL_RST))
 			break;
-		udelay(1);
 	}
 	if (ctrl & IXGBE_CTRL_RST) {
 		status = IXGBE_ERR_RESET_FAILED;
 		hw_dbg(hw, "Reset polling failed to complete.\n");
 	}
 
-	msleep(50);
+	msec_delay(50);
 
 	/*
 	 * Double resets are required for recovery from certain error
@@ -744,7 +873,7 @@ static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
 	}
 
 	gheccr = IXGBE_READ_REG(hw, IXGBE_GHECCR);
-	gheccr &= ~(BIT(21) | BIT(18) | BIT(9) | BIT(6));
+	gheccr &= ~((1 << 21) | (1 << 18) | (1 << 9) | (1 << 6));
 	IXGBE_WRITE_REG(hw, IXGBE_GHECCR, gheccr);
 
 	/*
@@ -769,23 +898,26 @@ static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
 	 */
 	hw->mac.ops.init_rx_addrs(hw);
 
-	if (phy_status)
+reset_hw_out:
+	if (phy_status != IXGBE_SUCCESS)
 		status = phy_status;
 
 	return status;
 }
 
 /**
- *  ixgbe_set_vmdq_82598 - Associate a VMDq set index with a rx address
- *  @hw: pointer to hardware struct
- *  @rar: receive address register index to associate with a VMDq index
- *  @vmdq: VMDq set index
+ * ixgbe_set_vmdq_82598 - Associate a VMDq set index with a rx address
+ * @hw: pointer to hardware struct
+ * @rar: receive address register index to associate with a VMDq index
+ * @vmdq: VMDq set index
  **/
-static s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
+s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 {
 	u32 rar_high;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_set_vmdq_82598");
+
 	/* Make sure we are using a valid rar index range */
 	if (rar >= rar_entries) {
 		hw_dbg(hw, "RAR index %d is out of range.\n", rar);
@@ -796,20 +928,21 @@ static s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 	rar_high &= ~IXGBE_RAH_VIND_MASK;
 	rar_high |= ((vmdq << IXGBE_RAH_VIND_SHIFT) & IXGBE_RAH_VIND_MASK);
 	IXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_clear_vmdq_82598 - Disassociate a VMDq set index from an rx address
- *  @hw: pointer to hardware struct
- *  @rar: receive address register index to associate with a VMDq index
- *  @vmdq: VMDq clear index (not used in 82598, but elsewhere)
+ * ixgbe_clear_vmdq_82598 - Disassociate a VMDq set index from an rx address
+ * @hw: pointer to hardware struct
+ * @rar: receive address register index to associate with a VMDq index
+ * @vmdq: VMDq clear index (not used in 82598, but elsewhere)
  **/
-static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
+STATIC s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 {
 	u32 rar_high;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	UNREFERENCED_1PARAMETER(vmdq);
 
 	/* Make sure we are using a valid rar index range */
 	if (rar >= rar_entries) {
@@ -823,27 +956,31 @@ static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 		IXGBE_WRITE_REG(hw, IXGBE_RAH(rar), rar_high);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_set_vfta_82598 - Set VLAN filter table
- *  @hw: pointer to hardware structure
- *  @vlan: VLAN id to write to VLAN filter
- *  @vind: VMDq output index that maps queue to VLAN id in VFTA
- *  @vlan_on: boolean flag to turn on/off VLAN in VFTA
- *  @vlvf_bypass: boolean flag - unused
+ * ixgbe_set_vfta_82598 - Set VLAN filter table
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vind: VMDq output index that maps queue to VLAN id in VFTA
+ * @vlan_on: boolean flag to turn on/off VLAN in VFTA
+ * @vlvf_bypass: boolean flag - unused
  *
- *  Turn on/off specified VLAN in the VLAN filter table.
+ * Turn on/off specified VLAN in the VLAN filter table.
  **/
-static s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,
-				bool vlan_on, bool vlvf_bypass)
+s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+			 bool vlan_on, bool vlvf_bypass)
 {
 	u32 regindex;
 	u32 bitindex;
 	u32 bits;
 	u32 vftabyte;
 
+	UNREFERENCED_1PARAMETER(vlvf_bypass);
+
+	DEBUGFUNC("ixgbe_set_vfta_82598");
+
 	if (vlan > 4095)
 		return IXGBE_ERR_PARAM;
 
@@ -866,26 +1003,28 @@ static s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 	bits = IXGBE_READ_REG(hw, IXGBE_VFTA(regindex));
 	if (vlan_on)
 		/* Turn on this VLAN id */
-		bits |= BIT(bitindex);
+		bits |= (1 << bitindex);
 	else
 		/* Turn off this VLAN id */
-		bits &= ~BIT(bitindex);
+		bits &= ~(1 << bitindex);
 	IXGBE_WRITE_REG(hw, IXGBE_VFTA(regindex), bits);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_clear_vfta_82598 - Clear VLAN filter table
- *  @hw: pointer to hardware structure
+ * ixgbe_clear_vfta_82598 - Clear VLAN filter table
+ * @hw: pointer to hardware structure
  *
- *  Clears the VLAN filer table, and the VMDq index associated with the filter
+ * Clears the VLAN filer table, and the VMDq index associated with the filter
  **/
-static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
 {
 	u32 offset;
 	u32 vlanbyte;
 
+	DEBUGFUNC("ixgbe_clear_vfta_82598");
+
 	for (offset = 0; offset < hw->mac.vft_size; offset++)
 		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);
 
@@ -894,101 +1033,107 @@ static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
 			IXGBE_WRITE_REG(hw, IXGBE_VFTAVIND(vlanbyte, offset),
 					0);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register
- *  @hw: pointer to hardware structure
- *  @reg: analog register to read
- *  @val: read value
+ * ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register
+ * @hw: pointer to hardware structure
+ * @reg: analog register to read
+ * @val: read value
  *
- *  Performs read operation to Atlas analog register specified.
+ * Performs read operation to Atlas analog register specified.
  **/
-static s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)
+s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)
 {
 	u32  atlas_ctl;
 
+	DEBUGFUNC("ixgbe_read_analog_reg8_82598");
+
 	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL,
 			IXGBE_ATLASCTL_WRITE_CMD | (reg << 8));
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(10);
+	usec_delay(10);
 	atlas_ctl = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
 	*val = (u8)atlas_ctl;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_write_analog_reg8_82598 - Writes 8 bit Atlas analog register
- *  @hw: pointer to hardware structure
- *  @reg: atlas register to write
- *  @val: value to write
+ * ixgbe_write_analog_reg8_82598 - Writes 8 bit Atlas analog register
+ * @hw: pointer to hardware structure
+ * @reg: atlas register to write
+ * @val: value to write
  *
- *  Performs write operation to Atlas analog register specified.
+ * Performs write operation to Atlas analog register specified.
  **/
-static s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)
+s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)
 {
 	u32  atlas_ctl;
 
+	DEBUGFUNC("ixgbe_write_analog_reg8_82598");
+
 	atlas_ctl = (reg << 8) | val;
 	IXGBE_WRITE_REG(hw, IXGBE_ATLASCTL, atlas_ctl);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(10);
+	usec_delay(10);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_i2c_phy_82598 - Reads 8 bit word over I2C interface.
- *  @hw: pointer to hardware structure
- *  @dev_addr: address to read from
- *  @byte_offset: byte offset to read from dev_addr
- *  @eeprom_data: value read
+ * ixgbe_read_i2c_phy_82598 - Reads 8 bit word over I2C interface.
+ * @hw: pointer to hardware structure
+ * @dev_addr: address to read from
+ * @byte_offset: byte offset to read from dev_addr
+ * @eeprom_data: value read
  *
- *  Performs 8 byte read operation to SFP module's data over I2C interface.
+ * Performs 8 byte read operation to SFP module's EEPROM over I2C interface.
  **/
-static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,
+STATIC s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,
 				    u8 byte_offset, u8 *eeprom_data)
 {
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	u16 sfp_addr = 0;
 	u16 sfp_data = 0;
 	u16 sfp_stat = 0;
 	u16 gssr;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_read_i2c_phy_82598");
+
 	if (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)
 		gssr = IXGBE_GSSR_PHY1_SM;
 	else
 		gssr = IXGBE_GSSR_PHY0_SM;
 
-	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) != 0)
+	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) != IXGBE_SUCCESS)
 		return IXGBE_ERR_SWFW_SYNC;
 
 	if (hw->phy.type == ixgbe_phy_nl) {
 		/*
-		 * phy SDA/SCL registers are at addresses 0xC30A to
-		 * 0xC30D.  These registers are used to talk to the SFP+
+		 * NetLogic phy SDA/SCL registers are at addresses 0xC30A to
+		 * 0xC30D. These registers are used to talk to the SFP+
 		 * module's EEPROM through the SDA/SCL (I2C) interface.
 		 */
 		sfp_addr = (dev_addr << 8) + byte_offset;
 		sfp_addr = (sfp_addr | IXGBE_I2C_EEPROM_READ_MASK);
 		hw->phy.ops.write_reg_mdi(hw,
 					  IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR,
-					  MDIO_MMD_PMAPMD,
+					  IXGBE_MDIO_PMA_PMD_DEV_TYPE,
 					  sfp_addr);
 
 		/* Poll status */
 		for (i = 0; i < 100; i++) {
 			hw->phy.ops.read_reg_mdi(hw,
 						IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT,
-						MDIO_MMD_PMAPMD,
+						IXGBE_MDIO_PMA_PMD_DEV_TYPE,
 						&sfp_stat);
 			sfp_stat = sfp_stat & IXGBE_I2C_EEPROM_STATUS_MASK;
 			if (sfp_stat != IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS)
 				break;
-			usleep_range(10000, 20000);
+			msec_delay(10);
 		}
 
 		if (sfp_stat != IXGBE_I2C_EEPROM_STATUS_PASS) {
@@ -999,7 +1144,7 @@ static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,
 
 		/* Read data */
 		hw->phy.ops.read_reg_mdi(hw, IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA,
-					MDIO_MMD_PMAPMD, &sfp_data);
+					IXGBE_MDIO_PMA_PMD_DEV_TYPE, &sfp_data);
 
 		*eeprom_data = (u8)(sfp_data >> 8);
 	} else {
@@ -1012,49 +1157,153 @@ static s32 ixgbe_read_i2c_phy_82598(struct ixgbe_hw *hw, u8 dev_addr,
 }
 
 /**
- *  ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.
- *  @hw: pointer to hardware structure
- *  @byte_offset: EEPROM byte offset to read
- *  @eeprom_data: value read
+ * ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.
+ * @hw: pointer to hardware structure
+ * @byte_offset: EEPROM byte offset to read
+ * @eeprom_data: value read
  *
- *  Performs 8 byte read operation to SFP module's EEPROM over I2C interface.
+ * Performs 8 byte read operation to SFP module's EEPROM over I2C interface.
  **/
-static s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
-				       u8 *eeprom_data)
+s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
+				u8 *eeprom_data)
 {
 	return ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR,
 					byte_offset, eeprom_data);
 }
 
 /**
- *  ixgbe_read_i2c_sff8472_82598 - Reads 8 bit word over I2C interface.
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset at address 0xA2
- *  @sff8472_data: value read
+ * ixgbe_read_i2c_sff8472_82598 - Reads 8 bit word over I2C interface.
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset at address 0xA2
+ * @sff8472_data: value read
  *
- *  Performs 8 byte read operation to SFP module's SFF-8472 data over I2C
+ * Performs 8 byte read operation to SFP module's SFF-8472 data over I2C
  **/
-static s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset,
-				       u8 *sff8472_data)
+STATIC s32 ixgbe_read_i2c_sff8472_82598(struct ixgbe_hw *hw, u8 byte_offset,
+					u8 *sff8472_data)
 {
 	return ixgbe_read_i2c_phy_82598(hw, IXGBE_I2C_EEPROM_DEV_ADDR2,
 					byte_offset, sff8472_data);
 }
 
 /**
- *  ixgbe_set_lan_id_multi_port_pcie_82598 - Set LAN id for PCIe multiple
- *  port devices.
- *  @hw: pointer to the HW structure
+ * ixgbe_get_supported_physical_layer_82598 - Returns physical layer type
+ * @hw: pointer to hardware structure
  *
- *  Calls common function and corrects issue with some single port devices
- *  that enable LAN1 but not LAN0.
+ * Determines physical layer capabilities of the current configuration.
  **/
-static void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
+u64 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw)
+{
+	u64 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+	u32 autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	u32 pma_pmd_10g = autoc & IXGBE_AUTOC_10G_PMA_PMD_MASK;
+	u32 pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
+	u16 ext_ability = 0;
+
+	DEBUGFUNC("ixgbe_get_supported_physical_layer_82598");
+
+	hw->phy.ops.identify(hw);
+
+	/* Copper PHY must be checked before AUTOC LMS to determine correct
+	 * physical layer because 10GBase-T PHYs use LMS = KX4/KX */
+	switch (hw->phy.type) {
+	case ixgbe_phy_tn:
+	case ixgbe_phy_cu_unknown:
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
+		IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
+		if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
+		if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
+		if (ext_ability & IXGBE_MDIO_PHY_100BASETX_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
+		goto out;
+	default:
+		break;
+	}
+
+	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
+	case IXGBE_AUTOC_LMS_1G_AN:
+	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
+		if (pma_pmd_1g == IXGBE_AUTOC_1G_KX)
+			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX;
+		else
+			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_BX;
+		break;
+	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
+		if (pma_pmd_10g == IXGBE_AUTOC_10G_CX4)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_CX4;
+		else if (pma_pmd_10g == IXGBE_AUTOC_10G_KX4)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
+		else /* XAUI */
+			physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+		break;
+	case IXGBE_AUTOC_LMS_KX4_AN:
+	case IXGBE_AUTOC_LMS_KX4_AN_1G_AN:
+		if (autoc & IXGBE_AUTOC_KX_SUPP)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_KX;
+		if (autoc & IXGBE_AUTOC_KX4_SUPP)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
+		break;
+	default:
+		break;
+	}
+
+	if (hw->phy.type == ixgbe_phy_nl) {
+		hw->phy.ops.identify_sfp(hw);
+
+		switch (hw->phy.sfp_type) {
+		case ixgbe_sfp_type_da_cu:
+			physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
+			break;
+		case ixgbe_sfp_type_sr:
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
+			break;
+		case ixgbe_sfp_type_lr:
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
+			break;
+		default:
+			physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+			break;
+		}
+	}
+
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
+		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
+		break;
+	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
+	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
+	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
+		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
+		break;
+	case IXGBE_DEV_ID_82598EB_XF_LR:
+		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
+		break;
+	default:
+		break;
+	}
+
+out:
+	return physical_layer;
+}
+
+/**
+ * ixgbe_set_lan_id_multi_port_pcie_82598 - Set LAN id for PCIe multiple
+ * port devices.
+ * @hw: pointer to the HW structure
+ *
+ * Calls common function and corrects issue with some single port devices
+ * that enable LAN1 but not LAN0.
+ **/
+void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
 {
 	struct ixgbe_bus_info *bus = &hw->bus;
 	u16 pci_gen = 0;
 	u16 pci_ctrl2 = 0;
 
+	DEBUGFUNC("ixgbe_set_lan_id_multi_port_pcie_82598");
+
 	ixgbe_set_lan_id_multi_port_pcie(hw);
 
 	/* check if LAN0 is disabled */
@@ -1080,11 +1329,12 @@ static void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
  * @headroom: reserve n KB of headroom
  * @strategy: packet buffer allocation strategy
  **/
-static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
+STATIC void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
 				  u32 headroom, int strategy)
 {
 	u32 rxpktsize = IXGBE_RXPBSIZE_64KB;
-	u8  i = 0;
+	u8 i = 0;
+	UNREFERENCED_1PARAMETER(headroom);
 
 	if (!num_pb)
 		return;
@@ -1098,7 +1348,7 @@ static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
 			IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);
 		/* Setup the last four at 48KB...don't re-init i */
 		rxpktsize = IXGBE_RXPBSIZE_48KB;
-		fallthrough;
+		/* Fall Through */
 	case PBA_STRATEGY_EQUAL:
 	default:
 		/* Divide the remaining Rx packet buffer evenly among the TCs */
@@ -1112,85 +1362,18 @@ static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
 		IXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), IXGBE_TXPBSIZE_40KB);
 }
 
-static const struct ixgbe_mac_operations mac_ops_82598 = {
-	.init_hw		= &ixgbe_init_hw_generic,
-	.reset_hw		= &ixgbe_reset_hw_82598,
-	.start_hw		= &ixgbe_start_hw_82598,
-	.clear_hw_cntrs		= &ixgbe_clear_hw_cntrs_generic,
-	.get_media_type		= &ixgbe_get_media_type_82598,
-	.enable_rx_dma          = &ixgbe_enable_rx_dma_generic,
-	.get_mac_addr		= &ixgbe_get_mac_addr_generic,
-	.stop_adapter		= &ixgbe_stop_adapter_generic,
-	.get_bus_info           = &ixgbe_get_bus_info_generic,
-	.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie_82598,
-	.read_analog_reg8	= &ixgbe_read_analog_reg8_82598,
-	.write_analog_reg8	= &ixgbe_write_analog_reg8_82598,
-	.setup_link		= &ixgbe_setup_mac_link_82598,
-	.set_rxpba		= &ixgbe_set_rxpba_82598,
-	.check_link		= &ixgbe_check_mac_link_82598,
-	.get_link_capabilities	= &ixgbe_get_link_capabilities_82598,
-	.led_on			= &ixgbe_led_on_generic,
-	.led_off		= &ixgbe_led_off_generic,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.blink_led_start	= &ixgbe_blink_led_start_generic,
-	.blink_led_stop		= &ixgbe_blink_led_stop_generic,
-	.set_rar		= &ixgbe_set_rar_generic,
-	.clear_rar		= &ixgbe_clear_rar_generic,
-	.set_vmdq		= &ixgbe_set_vmdq_82598,
-	.clear_vmdq		= &ixgbe_clear_vmdq_82598,
-	.init_rx_addrs		= &ixgbe_init_rx_addrs_generic,
-	.update_mc_addr_list	= &ixgbe_update_mc_addr_list_generic,
-	.enable_mc		= &ixgbe_enable_mc_generic,
-	.disable_mc		= &ixgbe_disable_mc_generic,
-	.clear_vfta		= &ixgbe_clear_vfta_82598,
-	.set_vfta		= &ixgbe_set_vfta_82598,
-	.fc_enable		= &ixgbe_fc_enable_82598,
-	.setup_fc		= ixgbe_setup_fc_generic,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.set_fw_drv_ver         = NULL,
-	.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync,
-	.release_swfw_sync      = &ixgbe_release_swfw_sync,
-	.init_swfw_sync		= NULL,
-	.get_thermal_sensor_data = NULL,
-	.init_thermal_sensor_thresh = NULL,
-	.prot_autoc_read	= &prot_autoc_read_generic,
-	.prot_autoc_write	= &prot_autoc_write_generic,
-	.enable_rx		= &ixgbe_enable_rx_generic,
-	.disable_rx		= &ixgbe_disable_rx_generic,
-};
-
-static const struct ixgbe_eeprom_operations eeprom_ops_82598 = {
-	.init_params		= &ixgbe_init_eeprom_params_generic,
-	.read			= &ixgbe_read_eerd_generic,
-	.write			= &ixgbe_write_eeprom_generic,
-	.write_buffer		= &ixgbe_write_eeprom_buffer_bit_bang_generic,
-	.read_buffer		= &ixgbe_read_eerd_buffer_generic,
-	.calc_checksum          = &ixgbe_calc_eeprom_checksum_generic,
-	.validate_checksum	= &ixgbe_validate_eeprom_checksum_generic,
-	.update_checksum	= &ixgbe_update_eeprom_checksum_generic,
-};
-
-static const struct ixgbe_phy_operations phy_ops_82598 = {
-	.identify		= &ixgbe_identify_phy_generic,
-	.identify_sfp		= &ixgbe_identify_module_generic,
-	.init			= &ixgbe_init_phy_ops_82598,
-	.reset			= &ixgbe_reset_phy_generic,
-	.read_reg		= &ixgbe_read_phy_reg_generic,
-	.write_reg		= &ixgbe_write_phy_reg_generic,
-	.read_reg_mdi		= &ixgbe_read_phy_reg_mdi,
-	.write_reg_mdi		= &ixgbe_write_phy_reg_mdi,
-	.setup_link		= &ixgbe_setup_phy_link_generic,
-	.setup_link_speed	= &ixgbe_setup_phy_link_speed_generic,
-	.read_i2c_sff8472	= &ixgbe_read_i2c_sff8472_82598,
-	.read_i2c_eeprom	= &ixgbe_read_i2c_eeprom_82598,
-	.check_overtemp		= &ixgbe_tn_check_overtemp,
-};
-
-const struct ixgbe_info ixgbe_82598_info = {
-	.mac			= ixgbe_mac_82598EB,
-	.get_invariants		= &ixgbe_get_invariants_82598,
-	.mac_ops		= &mac_ops_82598,
-	.eeprom_ops		= &eeprom_ops_82598,
-	.phy_ops		= &phy_ops_82598,
-	.mvals			= ixgbe_mvals_8259X,
-};
+/**
+ * ixgbe_enable_rx_dma_82598 - Enable the Rx DMA unit
+ * @hw: pointer to hardware structure
+ * @regval: register value to write to RXCTRL
+ *
+ * Enables the Rx DMA unit
+ **/
+s32 ixgbe_enable_rx_dma_82598(struct ixgbe_hw *hw, u32 regval)
+{
+	DEBUGFUNC("ixgbe_enable_rx_dma_82598");
+
+	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, regval);
+
+	return IXGBE_SUCCESS;
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.h
new file mode 100644
index 000000000000..61c0de3c4916
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82598.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_82598_H_
+#define _IXGBE_82598_H_
+
+u32 ixgbe_get_pcie_msix_count_82598(struct ixgbe_hw *hw);
+s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw);
+s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw);
+s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
+s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on,
+			 bool vlvf_bypass);
+s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val);
+s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val);
+s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
+				u8 *eeprom_data);
+u64 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw);
+s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw);
+void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw);
+void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw);
+s32 ixgbe_enable_rx_dma_82598(struct ixgbe_hw *hw, u32 regval);
+#endif /* _IXGBE_82598_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
index 8d3798a32f0e..dad058ab4701 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.c
@@ -1,13 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include "ixgbe.h"
+#include "ixgbe_type.h"
+#include "ixgbe_82599.h"
+#include "ixgbe_api.h"
+#include "ixgbe_common.h"
 #include "ixgbe_phy.h"
-#include "ixgbe_mbx.h"
 
 #define IXGBE_82599_MAX_TX_QUEUES 128
 #define IXGBE_82599_MAX_RX_QUEUES 128
@@ -16,64 +14,37 @@
 #define IXGBE_82599_VFT_TBL_SIZE  128
 #define IXGBE_82599_RX_PB_SIZE	  512
 
-static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
-static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
-static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
-static void
-ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *, ixgbe_link_speed);
-static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
-					   ixgbe_link_speed speed,
-					   bool autoneg_wait_to_complete);
-static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);
-static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
-				      bool autoneg_wait_to_complete);
-static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
-			       ixgbe_link_speed speed,
-			       bool autoneg_wait_to_complete);
-static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
 					 ixgbe_link_speed speed,
 					 bool autoneg_wait_to_complete);
-static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);
-static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
-				     u8 dev_addr, u8 *data);
-static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
-				      u8 dev_addr, u8 data);
-static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);
-static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
-
-bool ixgbe_mng_enabled(struct ixgbe_hw *hw)
-{
-	u32 fwsm, manc, factps;
-
-	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));
-	if ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)
-		return false;
-
-	manc = IXGBE_READ_REG(hw, IXGBE_MANC);
-	if (!(manc & IXGBE_MANC_RCV_TCO_EN))
-		return false;
-
-	factps = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));
-	if (factps & IXGBE_FACTPS_MNGCG)
-		return false;
-
-	return true;
-}
-
-static void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
+				   u16 offset, u16 *data);
+STATIC s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,
+					  u16 words, u16 *data);
+STATIC s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
+					u8 dev_addr, u8 *data);
+STATIC s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
+					u8 dev_addr, u8 data);
+
+void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 
-	/* enable the laser control functions for SFP+ fiber
+	DEBUGFUNC("ixgbe_init_mac_link_ops_82599");
+
+	/*
+	 * enable the laser control functions for SFP+ fiber
 	 * and MNG not enabled
 	 */
 	if ((mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) &&
 	    !ixgbe_mng_enabled(hw)) {
 		mac->ops.disable_tx_laser =
-				       &ixgbe_disable_tx_laser_multispeed_fiber;
+				       ixgbe_disable_tx_laser_multispeed_fiber;
 		mac->ops.enable_tx_laser =
-					&ixgbe_enable_tx_laser_multispeed_fiber;
-		mac->ops.flap_tx_laser = &ixgbe_flap_tx_laser_multispeed_fiber;
+					ixgbe_enable_tx_laser_multispeed_fiber;
+		mac->ops.flap_tx_laser = ixgbe_flap_tx_laser_multispeed_fiber;
+
 	} else {
 		mac->ops.disable_tx_laser = NULL;
 		mac->ops.enable_tx_laser = NULL;
@@ -82,27 +53,96 @@ static void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
 
 	if (hw->phy.multispeed_fiber) {
 		/* Set up dual speed SFP+ support */
-		mac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;
+		mac->ops.setup_link = ixgbe_setup_mac_link_multispeed_fiber;
 		mac->ops.setup_mac_link = ixgbe_setup_mac_link_82599;
 		mac->ops.set_rate_select_speed =
 					       ixgbe_set_hard_rate_select_speed;
 	} else {
-		if ((mac->ops.get_media_type(hw) ==
-		     ixgbe_media_type_backplane) &&
-		    (hw->phy.smart_speed == ixgbe_smart_speed_auto ||
-		     hw->phy.smart_speed == ixgbe_smart_speed_on) &&
-		     !ixgbe_verify_lesm_fw_enabled_82599(hw))
-			mac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;
-		else
-			mac->ops.setup_link = &ixgbe_setup_mac_link_82599;
+		if ((ixgbe_get_media_type(hw) == ixgbe_media_type_backplane) &&
+		     (hw->phy.smart_speed == ixgbe_smart_speed_auto ||
+		      hw->phy.smart_speed == ixgbe_smart_speed_on) &&
+		      !ixgbe_verify_lesm_fw_enabled_82599(hw)) {
+			mac->ops.setup_link = ixgbe_setup_mac_link_smartspeed;
+		} else {
+			mac->ops.setup_link = ixgbe_setup_mac_link_82599;
+		}
 	}
 }
 
-static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
+/**
+ * ixgbe_init_phy_ops_82599 - PHY/SFP specific init
+ * @hw: pointer to hardware structure
+ *
+ * Initialize any function pointers that were not able to be
+ * set during init_shared_code because the PHY/SFP type was
+ * not known.  Perform the SFP init if necessary.
+ *
+ **/
+s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)
 {
-	s32 ret_val;
+	struct ixgbe_mac_info *mac = &hw->mac;
+	struct ixgbe_phy_info *phy = &hw->phy;
+	s32 ret_val = IXGBE_SUCCESS;
+	u32 esdp;
+
+	DEBUGFUNC("ixgbe_init_phy_ops_82599");
+
+	if (hw->device_id == IXGBE_DEV_ID_82599_QSFP_SF_QP) {
+		/* Store flag indicating I2C bus access control unit. */
+		hw->phy.qsfp_shared_i2c_bus = TRUE;
+
+		/* Initialize access to QSFP+ I2C bus */
+		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
+		esdp |= IXGBE_ESDP_SDP0_DIR;
+		esdp &= ~IXGBE_ESDP_SDP1_DIR;
+		esdp &= ~IXGBE_ESDP_SDP0;
+		esdp &= ~IXGBE_ESDP_SDP0_NATIVE;
+		esdp &= ~IXGBE_ESDP_SDP1_NATIVE;
+		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
+		IXGBE_WRITE_FLUSH(hw);
+
+		phy->ops.read_i2c_byte = ixgbe_read_i2c_byte_82599;
+		phy->ops.write_i2c_byte = ixgbe_write_i2c_byte_82599;
+	}
+	/* Identify the PHY or SFP module */
+	ret_val = phy->ops.identify(hw);
+	if (ret_val == IXGBE_ERR_SFP_NOT_SUPPORTED)
+		goto init_phy_ops_out;
+
+	/* Setup function pointers based on detected SFP module and speeds */
+	ixgbe_init_mac_link_ops_82599(hw);
+	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown)
+		hw->phy.ops.reset = NULL;
+
+	/* If copper media, overwrite with copper function pointers */
+	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
+		mac->ops.setup_link = ixgbe_setup_copper_link_82599;
+		mac->ops.get_link_capabilities =
+				  ixgbe_get_copper_link_capabilities_generic;
+	}
+
+	/* Set necessary function pointers based on PHY type */
+	switch (hw->phy.type) {
+	case ixgbe_phy_tn:
+		phy->ops.setup_link = ixgbe_setup_phy_link_tnx;
+		phy->ops.check_link = ixgbe_check_phy_link_tnx;
+		phy->ops.get_firmware_version =
+			     ixgbe_get_phy_firmware_version_tnx;
+		break;
+	default:
+		break;
+	}
+init_phy_ops_out:
+	return ret_val;
+}
+
+s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
+{
+	s32 ret_val = IXGBE_SUCCESS;
 	u16 list_offset, data_offset, data_value;
 
+	DEBUGFUNC("ixgbe_setup_sfp_modules_82599");
+
 	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {
 		ixgbe_init_mac_link_ops_82599(hw);
 
@@ -110,14 +150,16 @@ static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
 
 		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
 							      &data_offset);
-		if (ret_val)
-			return ret_val;
+		if (ret_val != IXGBE_SUCCESS)
+			goto setup_sfp_out;
 
 		/* PHY config will finish before releasing the semaphore */
 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
 							IXGBE_GSSR_MAC_CSR_SM);
-		if (ret_val)
-			return IXGBE_ERR_SWFW_SYNC;
+		if (ret_val != IXGBE_SUCCESS) {
+			ret_val = IXGBE_ERR_SWFW_SYNC;
+			goto setup_sfp_out;
+		}
 
 		if (hw->eeprom.ops.read(hw, ++data_offset, &data_value))
 			goto setup_sfp_err;
@@ -130,12 +172,10 @@ static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
 
 		/* Release the semaphore */
 		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
-		/*
-		 * Delay obtaining semaphore again to allow FW access,
-		 * semaphore_delay is in ms usleep_range needs us.
+		/* Delay obtaining semaphore again to allow FW access
+		 * prot_autoc_write uses the semaphore too.
 		 */
-		usleep_range(hw->eeprom.semaphore_delay * 1000,
-			     hw->eeprom.semaphore_delay * 2000);
+		msec_delay(hw->eeprom.semaphore_delay);
 
 		/* Restart DSP and set SFI mode */
 		ret_val = hw->mac.ops.prot_autoc_write(hw,
@@ -143,54 +183,53 @@ static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
 			false);
 
 		if (ret_val) {
-			hw_dbg(hw, " sfp module setup not complete\n");
-			return IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
+			hw_dbg(hw, "sfp module setup not complete\n");
+			ret_val = IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
+			goto setup_sfp_out;
 		}
+
 	}
 
-	return 0;
+setup_sfp_out:
+	return ret_val;
 
 setup_sfp_err:
 	/* Release the semaphore */
 	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
-	/* Delay obtaining semaphore again to allow FW access,
-	 * semaphore_delay is in ms usleep_range needs us.
-	 */
-	usleep_range(hw->eeprom.semaphore_delay * 1000,
-		     hw->eeprom.semaphore_delay * 2000);
-	hw_err(hw, "eeprom read at offset %d failed\n", data_offset);
-	return IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
+	/* Delay obtaining semaphore again to allow FW access */
+	msec_delay(hw->eeprom.semaphore_delay);
+	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+		      "eeprom read at offset %d failed", data_offset);
+	return IXGBE_ERR_PHY;
 }
 
 /**
- *  prot_autoc_read_82599 - Hides MAC differences needed for AUTOC read
- *  @hw: pointer to hardware structure
- *  @locked: Return the if we locked for this read.
- *  @reg_val: Value we read from AUTOC
+ * prot_autoc_read_82599 - Hides MAC differences needed for AUTOC read
+ * @hw: pointer to hardware structure
+ * @locked: Return the if we locked for this read.
+ * @reg_val: Value we read from AUTOC
  *
- *  For this part (82599) we need to wrap read-modify-writes with a possible
- *  FW/SW lock.  It is assumed this lock will be freed with the next
- *  prot_autoc_write_82599().  Note, that locked can only be true in cases
- *  where this function doesn't return an error.
- **/
-static s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,
-				 u32 *reg_val)
+ * For this part (82599) we need to wrap read-modify-writes with a possible
+ * FW/SW lock.  It is assumed this lock will be freed with the next
+ * prot_autoc_write_82599().
+ */
+s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)
 {
 	s32 ret_val;
 
 	*locked = false;
-	/* If LESM is on then we need to hold the SW/FW semaphore. */
+	 /* If LESM is on then we need to hold the SW/FW semaphore. */
 	if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
 					IXGBE_GSSR_MAC_CSR_SM);
-		if (ret_val)
+		if (ret_val != IXGBE_SUCCESS)
 			return IXGBE_ERR_SWFW_SYNC;
 
 		*locked = true;
 	}
 
 	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -198,14 +237,14 @@ static s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked,
  * @hw: pointer to hardware structure
  * @autoc: value to write to AUTOC
  * @locked: bool to indicate whether the SW/FW lock was already taken by
- *	     previous proc_autoc_read_82599.
+ *          previous proc_autoc_read_82599.
  *
- * This part (82599) may need to hold a the SW/FW lock around all writes to
+ * This part (82599) may need to hold the SW/FW lock around all writes to
  * AUTOC. Likewise after a write we need to do a pipeline reset.
- **/
-static s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
+ */
+s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
 {
-	s32 ret_val = 0;
+	s32 ret_val = IXGBE_SUCCESS;
 
 	/* Blocked by MNG FW so bail */
 	if (ixgbe_check_reset_blocked(hw))
@@ -218,7 +257,7 @@ static s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
 	if (!locked && ixgbe_verify_lesm_fw_enabled_82599(hw)) {
 		ret_val = hw->mac.ops.acquire_swfw_sync(hw,
 					IXGBE_GSSR_MAC_CSR_SM);
-		if (ret_val)
+		if (ret_val != IXGBE_SUCCESS)
 			return IXGBE_ERR_SWFW_SYNC;
 
 		locked = true;
@@ -237,98 +276,120 @@ static s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 autoc, bool locked)
 	return ret_val;
 }
 
-static s32 ixgbe_get_invariants_82599(struct ixgbe_hw *hw)
-{
-	struct ixgbe_mac_info *mac = &hw->mac;
-
-	ixgbe_init_mac_link_ops_82599(hw);
-
-	mac->mcft_size = IXGBE_82599_MC_TBL_SIZE;
-	mac->vft_size = IXGBE_82599_VFT_TBL_SIZE;
-	mac->num_rar_entries = IXGBE_82599_RAR_ENTRIES;
-	mac->rx_pb_size = IXGBE_82599_RX_PB_SIZE;
-	mac->max_rx_queues = IXGBE_82599_MAX_RX_QUEUES;
-	mac->max_tx_queues = IXGBE_82599_MAX_TX_QUEUES;
-	mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
-
-	return 0;
-}
-
 /**
- *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init
- *  @hw: pointer to hardware structure
- *
- *  Initialize any function pointers that were not able to be
- *  set during get_invariants because the PHY/SFP type was
- *  not known.  Perform the SFP init if necessary.
+ * ixgbe_init_ops_82599 - Inits func ptrs and MAC type
+ * @hw: pointer to hardware structure
  *
+ * Initialize the function pointers and assign the MAC type for 82599.
+ * Does not touch the hardware.
  **/
-static s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)
+
+s32 ixgbe_init_ops_82599(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 	struct ixgbe_phy_info *phy = &hw->phy;
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
 	s32 ret_val;
-	u32 esdp;
+	u16 i;
+
+	DEBUGFUNC("ixgbe_init_ops_82599");
+
+	ixgbe_init_phy_ops_generic(hw);
+	ret_val = ixgbe_init_ops_generic(hw);
+
+	/* PHY */
+	phy->ops.identify = ixgbe_identify_phy_82599;
+	phy->ops.init = ixgbe_init_phy_ops_82599;
+
+	/* MAC */
+	mac->ops.reset_hw = ixgbe_reset_hw_82599;
+	mac->ops.get_media_type = ixgbe_get_media_type_82599;
+	mac->ops.get_supported_physical_layer =
+				    ixgbe_get_supported_physical_layer_82599;
+	mac->ops.disable_sec_rx_path = ixgbe_disable_sec_rx_path_generic;
+	mac->ops.enable_sec_rx_path = ixgbe_enable_sec_rx_path_generic;
+	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_82599;
+	mac->ops.read_analog_reg8 = ixgbe_read_analog_reg8_82599;
+	mac->ops.write_analog_reg8 = ixgbe_write_analog_reg8_82599;
+	mac->ops.start_hw = ixgbe_start_hw_82599;
+	mac->ops.get_san_mac_addr = ixgbe_get_san_mac_addr_generic;
+	mac->ops.set_san_mac_addr = ixgbe_set_san_mac_addr_generic;
+	mac->ops.get_device_caps = ixgbe_get_device_caps_generic;
+	mac->ops.get_wwn_prefix = ixgbe_get_wwn_prefix_generic;
+	mac->ops.get_fcoe_boot_status = ixgbe_get_fcoe_boot_status_generic;
+	mac->ops.prot_autoc_read = prot_autoc_read_82599;
+	mac->ops.prot_autoc_write = prot_autoc_write_82599;
+
+	/* RAR, Multicast, VLAN */
+	mac->ops.set_vmdq = ixgbe_set_vmdq_generic;
+	mac->ops.set_vmdq_san_mac = ixgbe_set_vmdq_san_mac_generic;
+	mac->ops.clear_vmdq = ixgbe_clear_vmdq_generic;
+	mac->ops.insert_mac_addr = ixgbe_insert_mac_addr_generic;
+	mac->rar_highwater = 1;
+	mac->ops.set_vfta = ixgbe_set_vfta_generic;
+	mac->ops.set_vlvf = ixgbe_set_vlvf_generic;
+	mac->ops.clear_vfta = ixgbe_clear_vfta_generic;
+	mac->ops.init_uta_tables = ixgbe_init_uta_tables_generic;
+	mac->ops.setup_sfp = ixgbe_setup_sfp_modules_82599;
+	mac->ops.set_mac_anti_spoofing = ixgbe_set_mac_anti_spoofing;
+	mac->ops.set_vlan_anti_spoofing = ixgbe_set_vlan_anti_spoofing;
+
+	/* Link */
+	mac->ops.get_link_capabilities = ixgbe_get_link_capabilities_82599;
+	mac->ops.check_link = ixgbe_check_mac_link_generic;
+	mac->ops.setup_rxpba = ixgbe_set_rxpba_generic;
+	ixgbe_init_mac_link_ops_82599(hw);
 
-	if (hw->device_id == IXGBE_DEV_ID_82599_QSFP_SF_QP) {
-		/* Store flag indicating I2C bus access control unit. */
-		hw->phy.qsfp_shared_i2c_bus = true;
+	mac->mcft_size		= IXGBE_82599_MC_TBL_SIZE;
+	mac->vft_size		= IXGBE_82599_VFT_TBL_SIZE;
+	mac->num_rar_entries	= IXGBE_82599_RAR_ENTRIES;
+	mac->rx_pb_size		= IXGBE_82599_RX_PB_SIZE;
+	mac->max_rx_queues	= IXGBE_82599_MAX_RX_QUEUES;
+	mac->max_tx_queues	= IXGBE_82599_MAX_TX_QUEUES;
+	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
 
-		/* Initialize access to QSFP+ I2C bus */
-		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
-		esdp |= IXGBE_ESDP_SDP0_DIR;
-		esdp &= ~IXGBE_ESDP_SDP1_DIR;
-		esdp &= ~IXGBE_ESDP_SDP0;
-		esdp &= ~IXGBE_ESDP_SDP0_NATIVE;
-		esdp &= ~IXGBE_ESDP_SDP1_NATIVE;
-		IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
-		IXGBE_WRITE_FLUSH(hw);
+	mac->arc_subsystem_valid = !!(IXGBE_READ_REG(hw, IXGBE_FWSM_BY_MAC(hw))
+				      & IXGBE_FWSM_MODE_MASK);
 
-		phy->ops.read_i2c_byte = &ixgbe_read_i2c_byte_82599;
-		phy->ops.write_i2c_byte = &ixgbe_write_i2c_byte_82599;
-	}
+	for (i = 0; i < 64; i++)
+		hw->mbx.ops[i].init_params = ixgbe_init_mbx_params_pf;
 
-	/* Identify the PHY or SFP module */
-	ret_val = phy->ops.identify(hw);
+	/* EEPROM */
+	eeprom->ops.read = ixgbe_read_eeprom_82599;
+	eeprom->ops.read_buffer = ixgbe_read_eeprom_buffer_82599;
 
-	/* Setup function pointers based on detected SFP module and speeds */
-	ixgbe_init_mac_link_ops_82599(hw);
+	/* Manageability interface */
+	mac->ops.set_fw_drv_ver = ixgbe_set_fw_drv_ver_generic;
 
-	/* If copper media, overwrite with copper function pointers */
-	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
-		mac->ops.setup_link = &ixgbe_setup_copper_link_82599;
-		mac->ops.get_link_capabilities =
-			&ixgbe_get_copper_link_capabilities_generic;
-	}
+	mac->ops.get_thermal_sensor_data =
+					 ixgbe_get_thermal_sensor_data_generic;
+	mac->ops.init_thermal_sensor_thresh =
+				      ixgbe_init_thermal_sensor_thresh_generic;
 
-	/* Set necessary function pointers based on phy type */
-	switch (hw->phy.type) {
-	case ixgbe_phy_tn:
-		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
-		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
-		break;
-	default:
-		break;
-	}
+	mac->ops.get_rtrup2tc = ixgbe_dcb_get_rtrup2tc_generic;
 
 	return ret_val;
 }
 
 /**
- *  ixgbe_get_link_capabilities_82599 - Determines link capabilities
- *  @hw: pointer to hardware structure
- *  @speed: pointer to link speed
- *  @autoneg: true when autoneg or autotry is enabled
+ * ixgbe_get_link_capabilities_82599 - Determines link capabilities
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @autoneg: true when autoneg or autotry is enabled
  *
- *  Determines the link capabilities by reading the AUTOC register.
+ * Determines the link capabilities by reading the AUTOC register.
  **/
-static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
-					     ixgbe_link_speed *speed,
-					     bool *autoneg)
+s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
+				      ixgbe_link_speed *speed,
+				      bool *autoneg)
 {
+	s32 status = IXGBE_SUCCESS;
 	u32 autoc = 0;
 
-	/* Determine 1G link capabilities off of SFP+ type */
+	DEBUGFUNC("ixgbe_get_link_capabilities_82599");
+
+
+	/* Check if 1G SFP module. */
 	if (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
 	    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
 	    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
@@ -337,13 +398,13 @@ static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
 	    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {
 		*speed = IXGBE_LINK_SPEED_1GB_FULL;
 		*autoneg = true;
-		return 0;
+		goto out;
 	}
 
 	/*
 	 * Determine link capabilities based on the stored value of AUTOC,
-	 * which represents EEPROM defaults.  If AUTOC value has not been
-	 * stored, use the current register value.
+	 * which represents EEPROM defaults.  If AUTOC value has not
+	 * been stored, use the current register values.
 	 */
 	if (hw->mac.orig_link_settings_stored)
 		autoc = hw->mac.orig_autoc;
@@ -400,37 +461,46 @@ static s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
 		break;
 
 	default:
-		return IXGBE_ERR_LINK_SETUP;
+		status = IXGBE_ERR_LINK_SETUP;
+		goto out;
+		break;
 	}
 
 	if (hw->phy.multispeed_fiber) {
 		*speed |= IXGBE_LINK_SPEED_10GB_FULL |
 			  IXGBE_LINK_SPEED_1GB_FULL;
 
-		/* QSFP must not enable auto-negotiation */
+		/* QSFP must not enable full auto-negotiation
+		 * Limited autoneg is enabled at 1G
+		 */
 		if (hw->phy.media_type == ixgbe_media_type_fiber_qsfp)
 			*autoneg = false;
 		else
 			*autoneg = true;
 	}
 
-	return 0;
+out:
+	return status;
 }
 
 /**
- *  ixgbe_get_media_type_82599 - Get media type
- *  @hw: pointer to hardware structure
+ * ixgbe_get_media_type_82599 - Get media type
+ * @hw: pointer to hardware structure
  *
- *  Returns the media type (fiber, copper, backplane)
+ * Returns the media type (fiber, copper, backplane)
  **/
-static enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
+enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
 {
+	enum ixgbe_media_type media_type;
+
+	DEBUGFUNC("ixgbe_get_media_type_82599");
+
 	/* Detect if there is a copper PHY attached. */
 	switch (hw->phy.type) {
 	case ixgbe_phy_cu_unknown:
 	case ixgbe_phy_tn:
-		return ixgbe_media_type_copper;
-
+		media_type = ixgbe_media_type_copper;
+		goto out;
 	default:
 		break;
 	}
@@ -443,46 +513,47 @@ static enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
 	case IXGBE_DEV_ID_82599_BACKPLANE_FCOE:
 	case IXGBE_DEV_ID_82599_XAUI_LOM:
 		/* Default device ID is mezzanine card KX/KX4 */
-		return ixgbe_media_type_backplane;
-
+		media_type = ixgbe_media_type_backplane;
+		break;
 	case IXGBE_DEV_ID_82599_SFP:
 	case IXGBE_DEV_ID_82599_SFP_FCOE:
 	case IXGBE_DEV_ID_82599_SFP_EM:
 	case IXGBE_DEV_ID_82599_SFP_SF2:
 	case IXGBE_DEV_ID_82599_SFP_SF_QP:
 	case IXGBE_DEV_ID_82599EN_SFP:
-		return ixgbe_media_type_fiber;
-
+		media_type = ixgbe_media_type_fiber;
+		break;
 	case IXGBE_DEV_ID_82599_CX4:
-		return ixgbe_media_type_cx4;
-
+		media_type = ixgbe_media_type_cx4;
+		break;
 	case IXGBE_DEV_ID_82599_T3_LOM:
-		return ixgbe_media_type_copper;
-
-	case IXGBE_DEV_ID_82599_LS:
-		return ixgbe_media_type_fiber_lco;
-
+		media_type = ixgbe_media_type_copper;
+		break;
 	case IXGBE_DEV_ID_82599_QSFP_SF_QP:
-		return ixgbe_media_type_fiber_qsfp;
-
+		media_type = ixgbe_media_type_fiber_qsfp;
+		break;
 	default:
-		return ixgbe_media_type_unknown;
+		media_type = ixgbe_media_type_unknown;
+		break;
 	}
+out:
+	return media_type;
 }
 
 /**
  * ixgbe_stop_mac_link_on_d3_82599 - Disables link on D3
  * @hw: pointer to hardware structure
  *
- * Disables link, should be called during D3 power down sequence.
+ * Disables link during D3 power down sequence.
  *
  **/
-static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
+void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
 {
 	u32 autoc2_reg;
 	u16 ee_ctrl_2 = 0;
 
-	hw->eeprom.ops.read(hw, IXGBE_EEPROM_CTRL_2, &ee_ctrl_2);
+	DEBUGFUNC("ixgbe_stop_mac_link_on_d3_82599");
+	ixgbe_read_eeprom(hw, IXGBE_EEPROM_CTRL_2, &ee_ctrl_2);
 
 	if (!ixgbe_mng_present(hw) && !hw->wol_enabled &&
 	    ee_ctrl_2 & IXGBE_EEPROM_CCD_BIT) {
@@ -493,27 +564,32 @@ static void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_start_mac_link_82599 - Setup MAC link settings
- *  @hw: pointer to hardware structure
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_start_mac_link_82599 - Setup MAC link settings
+ * @hw: pointer to hardware structure
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  *
- *  Configures link settings based on values in the ixgbe_hw struct.
- *  Restarts the link.  Performs autonegotiation if needed.
+ * Configures link settings based on values in the ixgbe_hw struct.
+ * Restarts the link.  Performs autonegotiation if needed.
  **/
-static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
+s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
 			       bool autoneg_wait_to_complete)
 {
 	u32 autoc_reg;
 	u32 links_reg;
 	u32 i;
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	bool got_lock = false;
 
+	DEBUGFUNC("ixgbe_start_mac_link_82599");
+
+	/*  reset_pipeline requires us to hold this lock as it writes to
+	 *  AUTOC.
+	 */
 	if (ixgbe_verify_lesm_fw_enabled_82599(hw)) {
 		status = hw->mac.ops.acquire_swfw_sync(hw,
-						IXGBE_GSSR_MAC_CSR_SM);
-		if (status)
-			return status;
+						       IXGBE_GSSR_MAC_CSR_SM);
+		if (status != IXGBE_SUCCESS)
+			goto out;
 
 		got_lock = true;
 	}
@@ -538,7 +614,7 @@ static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
 				links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
 				if (links_reg & IXGBE_LINKS_KX_AN_COMP)
 					break;
-				msleep(100);
+				msec_delay(100);
 			}
 			if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
 				status = IXGBE_ERR_AUTONEG_NOT_COMPLETE;
@@ -548,20 +624,21 @@ static s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
 	}
 
 	/* Add delay to filter out noises during initial link setup */
-	msleep(50);
+	msec_delay(50);
 
+out:
 	return status;
 }
 
 /**
- *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser
- *  @hw: pointer to hardware structure
+ * ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser
+ * @hw: pointer to hardware structure
  *
- *  The base drivers may require better control over SFP+ module
- *  PHY states.  This includes selectively shutting down the Tx
- *  laser on the PHY, effectively halting physical link.
+ * The base drivers may require better control over SFP+ module
+ * PHY states.  This includes selectively shutting down the Tx
+ * laser on the PHY, effectively halting physical link.
  **/
-static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
+void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
 {
 	u32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);
 
@@ -569,46 +646,48 @@ static void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
 	if (ixgbe_check_reset_blocked(hw))
 		return;
 
-	/* Disable tx laser; allow 100us to go dark per spec */
+	/* Disable Tx laser; allow 100us to go dark per spec */
 	esdp_reg |= IXGBE_ESDP_SDP3;
 	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(100);
+	usec_delay(100);
 }
 
 /**
- *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser
- *  @hw: pointer to hardware structure
+ * ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser
+ * @hw: pointer to hardware structure
  *
- *  The base drivers may require better control over SFP+ module
- *  PHY states.  This includes selectively turning on the Tx
- *  laser on the PHY, effectively starting physical link.
+ * The base drivers may require better control over SFP+ module
+ * PHY states.  This includes selectively turning on the Tx
+ * laser on the PHY, effectively starting physical link.
  **/
-static void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
+void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
 {
 	u32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);
 
-	/* Enable tx laser; allow 100ms to light up */
+	/* Enable Tx laser; allow 100ms to light up */
 	esdp_reg &= ~IXGBE_ESDP_SDP3;
 	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp_reg);
 	IXGBE_WRITE_FLUSH(hw);
-	msleep(100);
+	msec_delay(100);
 }
 
 /**
- *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser
- *  @hw: pointer to hardware structure
+ * ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser
+ * @hw: pointer to hardware structure
  *
- *  When the driver changes the link speeds that it can support,
- *  it sets autotry_restart to true to indicate that we need to
- *  initiate a new autotry session with the link partner.  To do
- *  so, we set the speed then disable and re-enable the tx laser, to
- *  alert the link partner that it also needs to restart autotry on its
- *  end.  This is consistent with true clause 37 autoneg, which also
- *  involves a loss of signal.
+ * When the driver changes the link speeds that it can support,
+ * it sets autotry_restart to true to indicate that we need to
+ * initiate a new autotry session with the link partner.  To do
+ * so, we set the speed then disable and re-enable the Tx laser, to
+ * alert the link partner that it also needs to restart autotry on its
+ * end.  This is consistent with true clause 37 autoneg, which also
+ * involves a loss of signal.
  **/
-static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
+void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
 {
+	DEBUGFUNC("ixgbe_flap_tx_laser_multispeed_fiber");
+
 	/* Blocked by MNG FW so bail */
 	if (ixgbe_check_reset_blocked(hw))
 		return;
@@ -627,8 +706,8 @@ static void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
  *
  * Set module link speed via RS0/RS1 rate select pins.
  */
-static void
-ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)
+void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw,
+					ixgbe_link_speed speed)
 {
 	u32 esdp_reg = IXGBE_READ_REG(hw, IXGBE_ESDP);
 
@@ -650,23 +729,25 @@ ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)
 }
 
 /**
- *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  *
- *  Implements the Intel SmartSpeed algorithm.
+ * Implements the Intel SmartSpeed algorithm.
  **/
-static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
-				     ixgbe_link_speed speed,
-				     bool autoneg_wait_to_complete)
+s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete)
 {
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
 	s32 i, j;
 	bool link_up = false;
 	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
 
+	DEBUGFUNC("ixgbe_setup_mac_link_smartspeed");
+
 	 /* Set autoneg_advertised value based on input link speed */
 	hw->phy.autoneg_advertised = 0;
 
@@ -691,7 +772,7 @@ static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
 	for (j = 0; j < IXGBE_SMARTSPEED_MAX_RETRIES; j++) {
 		status = ixgbe_setup_mac_link_82599(hw, speed,
 						    autoneg_wait_to_complete);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto out;
 
 		/*
@@ -701,12 +782,12 @@ static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
 		 * Table 9 in the AN MAS.
 		 */
 		for (i = 0; i < 5; i++) {
-			mdelay(100);
+			msec_delay(100);
 
 			/* If we have link, just jump out */
-			status = hw->mac.ops.check_link(hw, &link_speed,
-							&link_up, false);
-			if (status != 0)
+			status = ixgbe_check_link(hw, &link_speed, &link_up,
+						  false);
+			if (status != IXGBE_SUCCESS)
 				goto out;
 
 			if (link_up)
@@ -726,7 +807,7 @@ static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
 	hw->phy.smart_speed_active = true;
 	status = ixgbe_setup_mac_link_82599(hw, speed,
 					    autoneg_wait_to_complete);
-	if (status != 0)
+	if (status != IXGBE_SUCCESS)
 		goto out;
 
 	/*
@@ -736,12 +817,11 @@ static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
 	 * connect attempts as defined in the AN MAS table 73-7.
 	 */
 	for (i = 0; i < 6; i++) {
-		mdelay(100);
+		msec_delay(100);
 
 		/* If we have link, just jump out */
-		status = hw->mac.ops.check_link(hw, &link_speed,
-						&link_up, false);
-		if (status != 0)
+		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
+		if (status != IXGBE_SUCCESS)
 			goto out;
 
 		if (link_up)
@@ -755,46 +835,48 @@ static s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
 
 out:
 	if (link_up && (link_speed == IXGBE_LINK_SPEED_1GB_FULL))
-		hw_dbg(hw, "Smartspeed has downgraded the link speed from the maximum advertised\n");
+		hw_dbg(hw, "Smartspeed has downgraded the link speed "
+		"from the maximum advertised\n");
 	return status;
 }
 
 /**
- *  ixgbe_setup_mac_link_82599 - Set MAC link speed
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_setup_mac_link_82599 - Set MAC link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  *
- *  Set the link speed in the AUTOC register and restarts link.
+ * Set the link speed in the AUTOC register and restarts link.
  **/
-static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
-				      ixgbe_link_speed speed,
-				      bool autoneg_wait_to_complete)
+s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
+			       ixgbe_link_speed speed,
+			       bool autoneg_wait_to_complete)
 {
 	bool autoneg = false;
-	s32 status;
-	u32 pma_pmd_1g, link_mode, links_reg, i;
+	s32 status = IXGBE_SUCCESS;
+	u32 pma_pmd_1g, link_mode;
+	u32 current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC); /* holds the value of AUTOC register at this current point in time */
+	u32 orig_autoc = 0; /* holds the cached value of AUTOC register */
+	u32 autoc = current_autoc; /* Temporary variable used for comparison purposes */
 	u32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
 	u32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
+	u32 links_reg;
+	u32 i;
 	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
 
-	/* holds the value of AUTOC register at this current point in time */
-	u32 current_autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	/* holds the cached value of AUTOC register */
-	u32 orig_autoc = 0;
-	/* temporary variable used for comparison purposes */
-	u32 autoc = current_autoc;
+	DEBUGFUNC("ixgbe_setup_mac_link_82599");
 
 	/* Check to see if speed passed in is supported. */
-	status = hw->mac.ops.get_link_capabilities(hw, &link_capabilities,
-						   &autoneg);
+	status = ixgbe_get_link_capabilities(hw, &link_capabilities, &autoneg);
 	if (status)
-		return status;
+		goto out;
 
 	speed &= link_capabilities;
 
-	if (speed == IXGBE_LINK_SPEED_UNKNOWN)
-		return IXGBE_ERR_LINK_SETUP;
+	if (speed == IXGBE_LINK_SPEED_UNKNOWN) {
+		status = IXGBE_ERR_LINK_SETUP;
+		goto out;
+	}
 
 	/* Use stored value (EEPROM defaults) of AUTOC to find KR/KX4 support*/
 	if (hw->mac.orig_link_settings_stored)
@@ -834,7 +916,7 @@ static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
 		if ((speed == IXGBE_LINK_SPEED_1GB_FULL) &&
 		    (pma_pmd_1g == IXGBE_AUTOC_1G_SFI)) {
 			autoc &= ~IXGBE_AUTOC_LMS_MASK;
-			if (autoneg)
+			if (autoneg || hw->phy.type == ixgbe_phy_qsfp_intel)
 				autoc |= IXGBE_AUTOC_LMS_1G_AN;
 			else
 				autoc |= IXGBE_AUTOC_LMS_1G_LINK_NO_AN;
@@ -844,8 +926,8 @@ static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
 	if (autoc != current_autoc) {
 		/* Restart link */
 		status = hw->mac.ops.prot_autoc_write(hw, autoc, false);
-		if (status)
-			return status;
+		if (status != IXGBE_SUCCESS)
+			goto out;
 
 		/* Only poll for autoneg to complete if specified to do so */
 		if (autoneg_wait_to_complete) {
@@ -858,7 +940,7 @@ static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
 					       IXGBE_READ_REG(hw, IXGBE_LINKS);
 					if (links_reg & IXGBE_LINKS_KX_AN_COMP)
 						break;
-					msleep(100);
+					msec_delay(100);
 				}
 				if (!(links_reg & IXGBE_LINKS_KX_AN_COMP)) {
 					status =
@@ -869,26 +951,29 @@ static s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
 		}
 
 		/* Add delay to filter out noises during initial link setup */
-		msleep(50);
+		msec_delay(50);
 	}
 
+out:
 	return status;
 }
 
 /**
- *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true if waiting is needed to complete
+ * ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true if waiting is needed to complete
  *
- *  Restarts link on PHY and MAC based on settings passed in.
+ * Restarts link on PHY and MAC based on settings passed in.
  **/
-static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
 					 ixgbe_link_speed speed,
 					 bool autoneg_wait_to_complete)
 {
 	s32 status;
 
+	DEBUGFUNC("ixgbe_setup_copper_link_82599");
+
 	/* Setup the PHY according to input speed */
 	status = hw->phy.ops.setup_link_speed(hw, speed,
 					      autoneg_wait_to_complete);
@@ -899,25 +984,28 @@ static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_reset_hw_82599 - Perform hardware reset
- *  @hw: pointer to hardware structure
+ * ixgbe_reset_hw_82599 - Perform hardware reset
+ * @hw: pointer to hardware structure
  *
- *  Resets the hardware by resetting the transmit and receive units, masks
- *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)
- *  reset.
+ * Resets the hardware by resetting the transmit and receive units, masks
+ * and clears all interrupts, perform a PHY reset, and perform a link (MAC)
+ * reset.
  **/
-static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
+s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 {
 	ixgbe_link_speed link_speed;
 	s32 status;
-	u32 ctrl, i, autoc, autoc2;
+	u32 ctrl = 0;
+	u32 i, autoc, autoc2;
 	u32 curr_lms;
 	bool link_up = false;
 
+	DEBUGFUNC("ixgbe_reset_hw_82599");
+
 	/* Call adapter stop to disable tx/rx and clear interrupts */
 	status = hw->mac.ops.stop_adapter(hw);
-	if (status)
-		return status;
+	if (status != IXGBE_SUCCESS)
+		goto reset_hw_out;
 
 	/* flush pending Tx transactions */
 	ixgbe_clear_tx_pending(hw);
@@ -928,7 +1016,7 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 	status = hw->phy.ops.init(hw);
 
 	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
-		return status;
+		goto reset_hw_out;
 
 	/* Setup SFP module if there is one present. */
 	if (hw->phy.sfp_setup_needed) {
@@ -937,7 +1025,7 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 	}
 
 	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
-		return status;
+		goto reset_hw_out;
 
 	/* Reset PHY */
 	if (hw->phy.reset_disable == false && hw->phy.ops.reset != NULL)
@@ -948,7 +1036,7 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 
 mac_reset_top:
 	/*
-	 * Issue global reset to the MAC. Needs to be SW reset if link is up.
+	 * Issue global reset to the MAC.  Needs to be SW reset if link is up.
 	 * If link reset is used when link is up, it might reset the PHY when
 	 * mng is using it.  If link is down or the flag to force full link
 	 * reset is set, then perform link reset.
@@ -963,14 +1051,13 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 	ctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);
 	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
 	IXGBE_WRITE_FLUSH(hw);
-	usleep_range(1000, 1200);
 
-	/* Poll for reset bit to self-clear indicating reset is complete */
+	/* Poll for reset bit to self-clear meaning reset is complete */
 	for (i = 0; i < 10; i++) {
+		usec_delay(1);
 		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
 		if (!(ctrl & IXGBE_CTRL_RST_MASK))
 			break;
-		udelay(1);
 	}
 
 	if (ctrl & IXGBE_CTRL_RST_MASK) {
@@ -978,12 +1065,12 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 		hw_dbg(hw, "Reset polling failed to complete.\n");
 	}
 
-	msleep(50);
+	msec_delay(50);
 
 	/*
 	 * Double resets are required for recovery from certain error
-	 * conditions.  Between resets, it is necessary to stall to allow time
-	 * for any pending HW events to complete.
+	 * conditions.  Between resets, it is necessary to stall to
+	 * allow time for any pending HW events to complete.
 	 */
 	if (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {
 		hw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
@@ -1015,7 +1102,7 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 		 * doesn't autoneg with out driver support we need to
 		 * leave LMS in the state it was before we MAC reset.
 		 * Likewise if we support WoL we don't want change the
-		 * LMS state either.
+		 * LMS state.
 		 */
 		if ((hw->phy.multispeed_fiber && ixgbe_mng_enabled(hw)) ||
 		    hw->wol_enabled)
@@ -1027,8 +1114,8 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 			status = hw->mac.ops.prot_autoc_write(hw,
 							hw->mac.orig_autoc,
 							false);
-			if (status)
-				return status;
+			if (status != IXGBE_SUCCESS)
+				goto reset_hw_out;
 		}
 
 		if ((autoc2 & IXGBE_AUTOC2_UPPER_MASK) !=
@@ -1048,14 +1135,14 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 	 * clear the multicast table.  Also reset num_rar_entries to 128,
 	 * since we modify this value when programming the SAN MAC address.
 	 */
-	hw->mac.num_rar_entries = IXGBE_82599_RAR_ENTRIES;
+	hw->mac.num_rar_entries = 128;
 	hw->mac.ops.init_rx_addrs(hw);
 
 	/* Store the permanent SAN mac address */
 	hw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);
 
 	/* Add the SAN MAC address to the RAR only if it's a valid address */
-	if (is_valid_ether_addr(hw->mac.san_addr)) {
+	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
 		/* Save the SAN MAC RAR index */
 		hw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;
 
@@ -1072,8 +1159,9 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
 
 	/* Store the alternative WWNN/WWPN prefix */
 	hw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,
-				       &hw->mac.wwpn_prefix);
+				   &hw->mac.wwpn_prefix);
 
+reset_hw_out:
 	return status;
 }
 
@@ -1082,33 +1170,34 @@ static s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
  * @hw: pointer to hardware structure
  * @fdircmd: current value of FDIRCMD register
  */
-static s32 ixgbe_fdir_check_cmd_complete(struct ixgbe_hw *hw, u32 *fdircmd)
+STATIC s32 ixgbe_fdir_check_cmd_complete(struct ixgbe_hw *hw, u32 *fdircmd)
 {
 	int i;
 
 	for (i = 0; i < IXGBE_FDIRCMD_CMD_POLL; i++) {
 		*fdircmd = IXGBE_READ_REG(hw, IXGBE_FDIRCMD);
 		if (!(*fdircmd & IXGBE_FDIRCMD_CMD_MASK))
-			return 0;
-		udelay(10);
+			return IXGBE_SUCCESS;
+		usec_delay(10);
 	}
 
 	return IXGBE_ERR_FDIR_CMD_INCOMPLETE;
 }
 
 /**
- *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.
- *  @hw: pointer to hardware structure
+ * ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.
+ * @hw: pointer to hardware structure
  **/
 s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
 {
+	s32 err;
 	int i;
 	u32 fdirctrl = IXGBE_READ_REG(hw, IXGBE_FDIRCTRL);
 	u32 fdircmd;
-	s32 err;
-
 	fdirctrl &= ~IXGBE_FDIRCTRL_INIT_DONE;
 
+	DEBUGFUNC("ixgbe_reinit_fdir_tables_82599");
+
 	/*
 	 * Before starting reinitialization process,
 	 * FDIRCMD.CMD must be zero.
@@ -1151,7 +1240,7 @@ s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
 		if (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &
 				   IXGBE_FDIRCTRL_INIT_DONE)
 			break;
-		usleep_range(1000, 2000);
+		msec_delay(1);
 	}
 	if (i >= IXGBE_FDIR_INIT_DONE_POLL) {
 		hw_dbg(hw, "Flow Director Signature poll time exceeded!\n");
@@ -1165,18 +1254,20 @@ s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
 	IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
 	IXGBE_READ_REG(hw, IXGBE_FDIRLEN);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_fdir_enable_82599 - Initialize Flow Director control registers
- *  @hw: pointer to hardware structure
- *  @fdirctrl: value to write to flow director control register
+ * ixgbe_fdir_enable_82599 - Initialize Flow Director control registers
+ * @hw: pointer to hardware structure
+ * @fdirctrl: value to write to flow director control register
  **/
-static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
+STATIC void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 {
 	int i;
 
+	DEBUGFUNC("ixgbe_fdir_enable_82599");
+
 	/* Prime the keys for hashing */
 	IXGBE_WRITE_REG(hw, IXGBE_FDIRHKEY, IXGBE_ATR_BUCKET_HASH_KEY);
 	IXGBE_WRITE_REG(hw, IXGBE_FDIRSKEY, IXGBE_ATR_SIGNATURE_HASH_KEY);
@@ -1200,7 +1291,7 @@ static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 		if (IXGBE_READ_REG(hw, IXGBE_FDIRCTRL) &
 				   IXGBE_FDIRCTRL_INIT_DONE)
 			break;
-		usleep_range(1000, 2000);
+		msec_delay(1);
 	}
 
 	if (i >= IXGBE_FDIR_INIT_DONE_POLL)
@@ -1208,13 +1299,15 @@ static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 }
 
 /**
- *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters
- *  @hw: pointer to hardware structure
- *  @fdirctrl: value to write to flow director control register, initially
- *             contains just the value of the Rx packet buffer allocation
+ * ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters
+ * @hw: pointer to hardware structure
+ * @fdirctrl: value to write to flow director control register, initially
+ *	     contains just the value of the Rx packet buffer allocation
  **/
 s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 {
+	DEBUGFUNC("ixgbe_init_fdir_signature_82599");
+
 	/*
 	 * Continue setup of fdirctrl register bits:
 	 *  Move the flexible bytes to use the ethertype - shift 6 words
@@ -1228,35 +1321,80 @@ s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 	/* write hashes and fdirctrl register, poll for completion */
 	ixgbe_fdir_enable_82599(hw, fdirctrl);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters
- *  @hw: pointer to hardware structure
- *  @fdirctrl: value to write to flow director control register, initially
- *             contains just the value of the Rx packet buffer allocation
+ * ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters
+ * @hw: pointer to hardware structure
+ * @fdirctrl: value to write to flow director control register, initially
+ *	     contains just the value of the Rx packet buffer allocation
+ * @cloud_mode: true - cloud mode, false - other mode
  **/
-s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)
+s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl,
+			bool cloud_mode)
 {
+	UNREFERENCED_1PARAMETER(cloud_mode);
+	DEBUGFUNC("ixgbe_init_fdir_perfect_82599");
+
 	/*
 	 * Continue setup of fdirctrl register bits:
 	 *  Turn perfect match filtering on
-	 *  Initialize the drop queue
+	 *  Report hash in RSS field of Rx wb descriptor
+	 *  Initialize the drop queue to queue 127
 	 *  Move the flexible bytes to use the ethertype - shift 6 words
 	 *  Set the maximum length per hash bucket to 0xA filters
 	 *  Send interrupt when 64 (0x4 * 16) filters are left
 	 */
 	fdirctrl |= IXGBE_FDIRCTRL_PERFECT_MATCH |
+		    IXGBE_FDIRCTRL_REPORT_STATUS |
 		    (IXGBE_FDIR_DROP_QUEUE << IXGBE_FDIRCTRL_DROP_Q_SHIFT) |
 		    (0x6 << IXGBE_FDIRCTRL_FLEX_SHIFT) |
 		    (0xA << IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT) |
 		    (4 << IXGBE_FDIRCTRL_FULL_THRESH_SHIFT);
 
+	if (cloud_mode)
+		fdirctrl |=(IXGBE_FDIRCTRL_FILTERMODE_CLOUD <<
+					IXGBE_FDIRCTRL_FILTERMODE_SHIFT);
+
 	/* write hashes and fdirctrl register, poll for completion */
 	ixgbe_fdir_enable_82599(hw, fdirctrl);
 
-	return 0;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_set_fdir_drop_queue_82599 - Set Flow Director drop queue
+ * @hw: pointer to hardware structure
+ * @dropqueue: Rx queue index used for the dropped packets
+ **/
+void ixgbe_set_fdir_drop_queue_82599(struct ixgbe_hw *hw, u8 dropqueue)
+{
+	u32 fdirctrl;
+
+	DEBUGFUNC("ixgbe_set_fdir_drop_queue_82599");
+	/* Clear init done bit and drop queue field */
+	fdirctrl = IXGBE_READ_REG(hw, IXGBE_FDIRCTRL);
+	fdirctrl &= ~(IXGBE_FDIRCTRL_DROP_Q_MASK | IXGBE_FDIRCTRL_INIT_DONE);
+
+	/* Set drop queue */
+	fdirctrl |= (dropqueue << IXGBE_FDIRCTRL_DROP_Q_SHIFT);
+	if ((hw->mac.type == ixgbe_mac_X550) ||
+	    (hw->mac.type == ixgbe_mac_X550EM_x) ||
+	    (hw->mac.type == ixgbe_mac_X550EM_a))
+		fdirctrl |= IXGBE_FDIRCTRL_DROP_NO_MATCH;
+
+	IXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,
+			(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) |
+			 IXGBE_FDIRCMD_CLEARHT));
+	IXGBE_WRITE_FLUSH(hw);
+	IXGBE_WRITE_REG(hw, IXGBE_FDIRCMD,
+			(IXGBE_READ_REG(hw, IXGBE_FDIRCMD) &
+			 ~IXGBE_FDIRCMD_CLEARHT));
+	IXGBE_WRITE_FLUSH(hw);
+
+	/* write hashes and fdirctrl register, poll for completion */
+	ixgbe_fdir_enable_82599(hw, fdirctrl);
 }
 
 /*
@@ -1269,42 +1407,42 @@ s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)
 #define IXGBE_COMPUTE_SIG_HASH_ITERATION(_n) \
 do { \
 	u32 n = (_n); \
-	if (IXGBE_ATR_COMMON_HASH_KEY & BIT(n)) \
+	if (IXGBE_ATR_COMMON_HASH_KEY & (0x01 << n)) \
 		common_hash ^= lo_hash_dword >> n; \
-	else if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n)) \
+	else if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << n)) \
 		bucket_hash ^= lo_hash_dword >> n; \
-	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & BIT(n)) \
+	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & (0x01 << n)) \
 		sig_hash ^= lo_hash_dword << (16 - n); \
-	if (IXGBE_ATR_COMMON_HASH_KEY & BIT(n + 16)) \
+	if (IXGBE_ATR_COMMON_HASH_KEY & (0x01 << (n + 16))) \
 		common_hash ^= hi_hash_dword >> n; \
-	else if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n + 16)) \
+	else if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << (n + 16))) \
 		bucket_hash ^= hi_hash_dword >> n; \
-	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & BIT(n + 16)) \
+	else if (IXGBE_ATR_SIGNATURE_HASH_KEY & (0x01 << (n + 16))) \
 		sig_hash ^= hi_hash_dword << (16 - n); \
 } while (0)
 
 /**
- *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash
- *  @input: input bitstream to compute the hash on
- *  @common: compressed common input dword
+ * ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash
+ * @input: input bitstream to compute the hash on
+ * @common: compressed common input dword
  *
- *  This function is almost identical to the function above but contains
- *  several optimizations such as unwinding all of the loops, letting the
- *  compiler work out all of the conditional ifs since the keys are static
- *  defines, and computing two keys at once since the hashed dword stream
- *  will be the same for both keys.
+ * This function is almost identical to the function above but contains
+ * several optimizations such as unwinding all of the loops, letting the
+ * compiler work out all of the conditional ifs since the keys are static
+ * defines, and computing two keys at once since the hashed dword stream
+ * will be the same for both keys.
  **/
-static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
-					    union ixgbe_atr_hash_dword common)
+u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
+				     union ixgbe_atr_hash_dword common)
 {
 	u32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;
 	u32 sig_hash = 0, bucket_hash = 0, common_hash = 0;
 
 	/* record the flow_vm_vlan bits as they are a key part to the hash */
-	flow_vm_vlan = ntohl(input.dword);
+	flow_vm_vlan = IXGBE_NTOHL(input.dword);
 
 	/* generate common hash dword */
-	hi_hash_dword = ntohl(common.dword);
+	hi_hash_dword = IXGBE_NTOHL(common.dword);
 
 	/* low dword is word swapped version of common */
 	lo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);
@@ -1318,7 +1456,7 @@ static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
 	/*
 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to
 	 * delay this because bit 0 of the stream should not be processed
-	 * so we do not add the vlan until after bit 0 was processed
+	 * so we do not add the VLAN until after bit 0 was processed
 	 */
 	lo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);
 
@@ -1351,28 +1489,31 @@ static u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
 }
 
 /**
- *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter
- *  @hw: pointer to hardware structure
- *  @input: unique input dword
- *  @common: compressed common input dword
- *  @queue: queue index to direct traffic to
+ * ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter
+ * @hw: pointer to hardware structure
+ * @input: unique input dword
+ * @common: compressed common input dword
+ * @queue: queue index to direct traffic to
  *
  * Note that the tunnel bit in input must not be set when the hardware
  * tunneling support does not exist.
  **/
-s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
-					  union ixgbe_atr_hash_dword input,
-					  union ixgbe_atr_hash_dword common,
-					  u8 queue)
+void ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
+					   union ixgbe_atr_hash_dword input,
+					   union ixgbe_atr_hash_dword common,
+					   u8 queue)
 {
 	u64 fdirhashcmd;
 	u8 flow_type;
 	bool tunnel;
 	u32 fdircmd;
 
+	DEBUGFUNC("ixgbe_fdir_add_signature_filter_82599");
+
 	/*
 	 * Get the flow_type in order to program FDIRCMD properly
 	 * lowest 2 bits are FDIRCMD.L4TYPE, third lowest bit is FDIRCMD.IPV6
+	 * fifth is FDIRCMD.TUNNEL_FILTER
 	 */
 	tunnel = !!(input.formatted.flow_type & IXGBE_ATR_L4TYPE_TUNNEL_MASK);
 	flow_type = input.formatted.flow_type &
@@ -1387,7 +1528,7 @@ s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
 		break;
 	default:
 		hw_dbg(hw, " Error on flow type input\n");
-		return IXGBE_ERR_CONFIG;
+		return;
 	}
 
 	/* configure FDIRCMD register */
@@ -1403,33 +1544,33 @@ s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
 	 * is for FDIRCMD.  Then do a 64-bit register write from FDIRHASH.
 	 */
 	fdirhashcmd = (u64)fdircmd << 32;
-	fdirhashcmd |= ixgbe_atr_compute_sig_hash_82599(input, common);
+	fdirhashcmd |= (u64)ixgbe_atr_compute_sig_hash_82599(input, common);
 	IXGBE_WRITE_REG64(hw, IXGBE_FDIRHASH, fdirhashcmd);
 
 	hw_dbg(hw, "Tx Queue=%x hash=%x\n", queue, (u32)fdirhashcmd);
 
-	return 0;
+	return;
 }
 
 #define IXGBE_COMPUTE_BKT_HASH_ITERATION(_n) \
 do { \
 	u32 n = (_n); \
-	if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n)) \
+	if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << n)) \
 		bucket_hash ^= lo_hash_dword >> n; \
-	if (IXGBE_ATR_BUCKET_HASH_KEY & BIT(n + 16)) \
+	if (IXGBE_ATR_BUCKET_HASH_KEY & (0x01 << (n + 16))) \
 		bucket_hash ^= hi_hash_dword >> n; \
 } while (0)
 
 /**
- *  ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash
- *  @input: input bitstream to compute the hash on
- *  @input_mask: mask for the input bitstream
+ * ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash
+ * @input: input bitstream to compute the hash on
+ * @input_mask: mask for the input bitstream
  *
- *  This function serves two main purposes.  First it applies the input_mask
- *  to the atr_input resulting in a cleaned up atr_input data stream.
- *  Secondly it computes the hash and stores it in the bkt_hash field at
- *  the end of the input byte stream.  This way it will be available for
- *  future use without needing to recompute the hash.
+ * This function serves two main purposes.  First it applies the input_mask
+ * to the atr_input resulting in a cleaned up atr_input data stream.
+ * Secondly it computes the hash and stores it in the bkt_hash field at
+ * the end of the input byte stream.  This way it will be available for
+ * future use without needing to recompute the hash.
  **/
 void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
 					  union ixgbe_atr_input *input_mask)
@@ -1437,20 +1578,20 @@ void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
 
 	u32 hi_hash_dword, lo_hash_dword, flow_vm_vlan;
 	u32 bucket_hash = 0;
-	__be32 hi_dword = 0;
-	int i;
+	u32 hi_dword = 0;
+	u32 i = 0;
 
 	/* Apply masks to input data */
-	for (i = 0; i <= 10; i++)
-		input->dword_stream[i] &= input_mask->dword_stream[i];
+	for (i = 0; i < 14; i++)
+		input->dword_stream[i]  &= input_mask->dword_stream[i];
 
 	/* record the flow_vm_vlan bits as they are a key part to the hash */
-	flow_vm_vlan = ntohl(input->dword_stream[0]);
+	flow_vm_vlan = IXGBE_NTOHL(input->dword_stream[0]);
 
 	/* generate common hash dword */
-	for (i = 1; i <= 10; i++)
+	for (i = 1; i <= 13; i++)
 		hi_dword ^= input->dword_stream[i];
-	hi_hash_dword = ntohl(hi_dword);
+	hi_hash_dword = IXGBE_NTOHL(hi_dword);
 
 	/* low dword is word swapped version of common */
 	lo_hash_dword = (hi_hash_dword >> 16) | (hi_hash_dword << 16);
@@ -1464,7 +1605,7 @@ void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
 	/*
 	 * apply flow ID/VM pool/VLAN ID bits to lo hash dword, we had to
 	 * delay this because bit 0 of the stream should not be processed
-	 * so we do not add the vlan until after bit 0 was processed
+	 * so we do not add the VLAN until after bit 0 was processed
 	 */
 	lo_hash_dword ^= flow_vm_vlan ^ (flow_vm_vlan << 16);
 
@@ -1476,24 +1617,23 @@ void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
 	 * Limit hash to 13 bits since max bucket count is 8K.
 	 * Store result at the end of the input stream.
 	 */
-	input->formatted.bkt_hash = (__force __be16)(bucket_hash & 0x1FFF);
+	input->formatted.bkt_hash = bucket_hash & 0x1FFF;
 }
 
 /**
- *  ixgbe_get_fdirtcpm_82599 - generate a tcp port from atr_input_masks
- *  @input_mask: mask to be bit swapped
+ * ixgbe_get_fdirtcpm_82599 - generate a TCP port from atr_input_masks
+ * @input_mask: mask to be bit swapped
  *
- *  The source and destination port masks for flow director are bit swapped
- *  in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to
- *  generate a correctly swapped value we need to bit swap the mask and that
- *  is what is accomplished by this function.
+ * The source and destination port masks for flow director are bit swapped
+ * in that bit 15 effects bit 0, 14 effects 1, 13, 2 etc.  In order to
+ * generate a correctly swapped value we need to bit swap the mask and that
+ * is what is accomplished by this function.
  **/
-static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)
+STATIC u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)
 {
-	u32 mask = ntohs(input_mask->formatted.dst_port);
-
+	u32 mask = IXGBE_NTOHS(input_mask->formatted.dst_port);
 	mask <<= IXGBE_FDIRTCPM_DPORTM_SHIFT;
-	mask |= ntohs(input_mask->formatted.src_port);
+	mask |= (u32)IXGBE_NTOHS(input_mask->formatted.src_port);
 	mask = ((mask & 0x55555555) << 1) | ((mask & 0xAAAAAAAA) >> 1);
 	mask = ((mask & 0x33333333) << 2) | ((mask & 0xCCCCCCCC) >> 2);
 	mask = ((mask & 0x0F0F0F0F) << 4) | ((mask & 0xF0F0F0F0) >> 4);
@@ -1512,17 +1652,20 @@ static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)
 	 (((u32)(_value) & 0x0000FF00) << 8) | ((u32)(_value) << 24))
 
 #define IXGBE_WRITE_REG_BE32(a, reg, value) \
-	IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(ntohl(value)))
+	IXGBE_WRITE_REG((a), (reg), IXGBE_STORE_AS_BE32(IXGBE_NTOHL(value)))
 
 #define IXGBE_STORE_AS_BE16(_value) \
-	ntohs(((u16)(_value) >> 8) | ((u16)(_value) << 8))
+	IXGBE_NTOHS(((u16)(_value) >> 8) | ((u16)(_value) << 8))
 
 s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
-				    union ixgbe_atr_input *input_mask)
+				    union ixgbe_atr_input *input_mask, bool cloud_mode)
 {
 	/* mask IPv6 since it is currently not supported */
 	u32 fdirm = IXGBE_FDIRM_DIPv6;
 	u32 fdirtcpm;
+	u32 fdirip6m;
+	UNREFERENCED_1PARAMETER(cloud_mode);
+	DEBUGFUNC("ixgbe_fdir_set_atr_input_mask_82599");
 
 	/*
 	 * Program the relevant mask registers.  If src/dst_port or src/dst_addr
@@ -1564,11 +1707,11 @@ s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
 		return IXGBE_ERR_CONFIG;
 	}
 
-	switch (ntohs(input_mask->formatted.vlan_id) & 0xEFFF) {
+	switch (IXGBE_NTOHS(input_mask->formatted.vlan_id) & 0xEFFF) {
 	case 0x0000:
 		/* mask VLAN ID */
 		fdirm |= IXGBE_FDIRM_VLANID;
-		fallthrough;
+		/* fall through */
 	case 0x0FFF:
 		/* mask VLAN priority */
 		fdirm |= IXGBE_FDIRM_VLANP;
@@ -1576,7 +1719,7 @@ s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
 	case 0xE000:
 		/* mask VLAN ID only */
 		fdirm |= IXGBE_FDIRM_VLANID;
-		fallthrough;
+		/* fall through */
 	case 0xEFFF:
 		/* no VLAN fields masked */
 		break;
@@ -1585,11 +1728,11 @@ s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
 		return IXGBE_ERR_CONFIG;
 	}
 
-	switch ((__force u16)input_mask->formatted.flex_bytes & 0xFFFF) {
+	switch (input_mask->formatted.flex_bytes & 0xFFFF) {
 	case 0x0000:
 		/* Mask Flex Bytes */
 		fdirm |= IXGBE_FDIRM_FLEX;
-		fallthrough;
+		/* fall through */
 	case 0xFFFF:
 		break;
 	default:
@@ -1597,71 +1740,160 @@ s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
 		return IXGBE_ERR_CONFIG;
 	}
 
-	/* Now mask VM pool and destination IPv6 - bits 5 and 2 */
-	IXGBE_WRITE_REG(hw, IXGBE_FDIRM, fdirm);
+	if (cloud_mode) {
+		fdirm |= IXGBE_FDIRM_L3P;
+		fdirip6m = ((u32) 0xFFFFU << IXGBE_FDIRIP6M_DIPM_SHIFT);
+		fdirip6m |= IXGBE_FDIRIP6M_ALWAYS_MASK;
 
-	/* store the TCP/UDP port masks, bit reversed from port layout */
-	fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
+		switch (input_mask->formatted.inner_mac[0] & 0xFF) {
+		case 0x00:
+			/* Mask inner MAC, fall through */
+			fdirip6m |= IXGBE_FDIRIP6M_INNER_MAC;
+		case 0xFF:
+			break;
+		default:
+			hw_dbg(hw, " Error on inner_mac byte mask\n");
+			return IXGBE_ERR_CONFIG;
+		}
 
-	/* write both the same so that UDP and TCP use the same mask */
-	IXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, ~fdirtcpm);
-	IXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, ~fdirtcpm);
+		switch (input_mask->formatted.tni_vni & 0xFFFFFFFF) {
+		case 0x0:
+			/* Mask vxlan id */
+			fdirip6m |= IXGBE_FDIRIP6M_TNI_VNI;
+			break;
+		case 0x00FFFFFF:
+			fdirip6m |= IXGBE_FDIRIP6M_TNI_VNI_24;
+			break;
+		case 0xFFFFFFFF:
+			break;
+		default:
+			hw_dbg(hw, " Error on TNI/VNI byte mask\n");
+			return IXGBE_ERR_CONFIG;
+		}
 
-	/* also use it for SCTP */
-	switch (hw->mac.type) {
-	case ixgbe_mac_X550:
-	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		IXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, ~fdirtcpm);
-		break;
-	default:
-		break;
+		switch (input_mask->formatted.tunnel_type & 0xFFFF) {
+		case 0x0:
+			/* Mask turnnel type, fall through */
+			fdirip6m |= IXGBE_FDIRIP6M_TUNNEL_TYPE;
+		case 0xFFFF:
+			break;
+		default:
+			hw_dbg(hw, " Error on tunnel type byte mask\n");
+			return IXGBE_ERR_CONFIG;
+		}
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIP6M, fdirip6m);
+
+		/* Set all bits in FDIRTCPM, FDIRUDPM, FDIRSCTPM,
+		 * FDIRSIP4M and FDIRDIP4M in cloud mode to allow
+		 * L3/L3 packets to tunnel.
+		 */
+		IXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, 0xFFFFFFFF);
+		IXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, 0xFFFFFFFF);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M, 0xFFFFFFFF);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M, 0xFFFFFFFF);
+		switch (hw->mac.type) {
+		case ixgbe_mac_X550:
+		case ixgbe_mac_X550EM_x:
+		case ixgbe_mac_X550EM_a:
+			IXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, 0xFFFFFFFF);
+			break;
+		default:
+			break;
+		}
 	}
 
-	/* store source and destination IP masks (big-enian) */
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M,
-			     ~input_mask->formatted.src_ip[0]);
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M,
-			     ~input_mask->formatted.dst_ip[0]);
+	/* Now mask VM pool and destination IPv6 - bits 5 and 2 */
+	IXGBE_WRITE_REG(hw, IXGBE_FDIRM, fdirm);
+
+	if (!cloud_mode) {
+		/* store the TCP/UDP port masks, bit reversed from port
+		 * layout */
+		fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
+
+		/* write both the same so that UDP and TCP use the same mask */
+		IXGBE_WRITE_REG(hw, IXGBE_FDIRTCPM, ~fdirtcpm);
+		IXGBE_WRITE_REG(hw, IXGBE_FDIRUDPM, ~fdirtcpm);
+		/* also use it for SCTP */
+		switch (hw->mac.type) {
+		case ixgbe_mac_X550:
+		case ixgbe_mac_X550EM_x:
+		case ixgbe_mac_X550EM_a:
+			IXGBE_WRITE_REG(hw, IXGBE_FDIRSCTPM, ~fdirtcpm);
+			break;
+		default:
+			break;
+		}
 
-	return 0;
+		/* store source and destination IP masks (big-enian) */
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIP4M,
+				     ~input_mask->formatted.src_ip[0]);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRDIP4M,
+				     ~input_mask->formatted.dst_ip[0]);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIP6M, 0xFFFFFFFF);
+	}
+	return IXGBE_SUCCESS;
 }
 
 s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
 					  union ixgbe_atr_input *input,
-					  u16 soft_id, u8 queue)
+					  u16 soft_id, u8 queue, bool cloud_mode)
 {
 	u32 fdirport, fdirvlan, fdirhash, fdircmd;
+	u32 addr_low, addr_high;
+	u32 cloud_type = 0;
 	s32 err;
+	UNREFERENCED_1PARAMETER(cloud_mode);
+
+	DEBUGFUNC("ixgbe_fdir_write_perfect_filter_82599");
+	if (!cloud_mode) {
+		/* currently IPv6 is not supported, must be programmed with 0 */
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(0),
+				     input->formatted.src_ip[0]);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(1),
+				     input->formatted.src_ip[1]);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(2),
+				     input->formatted.src_ip[2]);
+
+		/* record the source address (big-endian) */
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPSA,
+			input->formatted.src_ip[0]);
+
+		/* record the first 32 bits of the destination address
+		 * (big-endian) */
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPDA,
+			input->formatted.dst_ip[0]);
+
+		/* record source and destination port (little-endian)*/
+		fdirport = IXGBE_NTOHS(input->formatted.dst_port);
+		fdirport <<= IXGBE_FDIRPORT_DESTINATION_SHIFT;
+		fdirport |= (u32)IXGBE_NTOHS(input->formatted.src_port);
+		IXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, fdirport);
+	}
 
-	/* currently IPv6 is not supported, must be programmed with 0 */
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(0),
-			     input->formatted.src_ip[0]);
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(1),
-			     input->formatted.src_ip[1]);
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(2),
-			     input->formatted.src_ip[2]);
-
-	/* record the source address (big-endian) */
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPSA, input->formatted.src_ip[0]);
-
-	/* record the first 32 bits of the destination address (big-endian) */
-	IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRIPDA, input->formatted.dst_ip[0]);
-
-	/* record source and destination port (little-endian)*/
-	fdirport = ntohs(input->formatted.dst_port);
-	fdirport <<= IXGBE_FDIRPORT_DESTINATION_SHIFT;
-	fdirport |= ntohs(input->formatted.src_port);
-	IXGBE_WRITE_REG(hw, IXGBE_FDIRPORT, fdirport);
-
-	/* record vlan (little-endian) and flex_bytes(big-endian) */
-	fdirvlan = IXGBE_STORE_AS_BE16((__force u16)input->formatted.flex_bytes);
+	/* record VLAN (little-endian) and flex_bytes(big-endian) */
+	fdirvlan = IXGBE_STORE_AS_BE16(input->formatted.flex_bytes);
 	fdirvlan <<= IXGBE_FDIRVLAN_FLEX_SHIFT;
-	fdirvlan |= ntohs(input->formatted.vlan_id);
+	fdirvlan |= (u32)IXGBE_NTOHS(input->formatted.vlan_id);
 	IXGBE_WRITE_REG(hw, IXGBE_FDIRVLAN, fdirvlan);
 
+	if (cloud_mode) {
+		if (input->formatted.tunnel_type != 0)
+			cloud_type = 0x80000000;
+
+		addr_low = ((u32)input->formatted.inner_mac[0] |
+				((u32)input->formatted.inner_mac[1] << 8) |
+				((u32)input->formatted.inner_mac[2] << 16) |
+				((u32)input->formatted.inner_mac[3] << 24));
+		addr_high = ((u32)input->formatted.inner_mac[4] |
+				((u32)input->formatted.inner_mac[5] << 8));
+		cloud_type |= addr_high;
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(0), addr_low);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(1), cloud_type);
+		IXGBE_WRITE_REG_BE32(hw, IXGBE_FDIRSIPv6(2), input->formatted.tni_vni);
+	}
+
 	/* configure FDIRHASH register */
-	fdirhash = (__force u32)input->formatted.bkt_hash;
+	fdirhash = input->formatted.bkt_hash;
 	fdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;
 	IXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);
 
@@ -1676,6 +1908,8 @@ s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
 		  IXGBE_FDIRCMD_LAST | IXGBE_FDIRCMD_QUEUE_EN;
 	if (queue == IXGBE_FDIR_DROP_QUEUE)
 		fdircmd |= IXGBE_FDIRCMD_DROP;
+	if (input->formatted.flow_type & IXGBE_ATR_L4TYPE_TUNNEL_MASK)
+		fdircmd |= IXGBE_FDIRCMD_TUNNEL_FILTER;
 	fdircmd |= input->formatted.flow_type << IXGBE_FDIRCMD_FLOW_TYPE_SHIFT;
 	fdircmd |= (u32)queue << IXGBE_FDIRCMD_RX_QUEUE_SHIFT;
 	fdircmd |= (u32)input->formatted.vm_pool << IXGBE_FDIRCMD_VT_POOL_SHIFT;
@@ -1687,7 +1921,7 @@ s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
 		return err;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
@@ -1699,7 +1933,7 @@ s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
 	s32 err;
 
 	/* configure FDIRHASH register */
-	fdirhash = (__force u32)input->formatted.bkt_hash;
+	fdirhash = input->formatted.bkt_hash;
 	fdirhash |= soft_id << IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT;
 	IXGBE_WRITE_REG(hw, IXGBE_FDIRHASH, fdirhash);
 
@@ -1723,102 +1957,179 @@ s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
 				IXGBE_FDIRCMD_CMD_REMOVE_FLOW);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter
+ * @hw: pointer to hardware structure
+ * @input: input bitstream
+ * @input_mask: mask for the input bitstream
+ * @soft_id: software index for the filters
+ * @queue: queue index to direct traffic to
+ * @cloud_mode: unused
+ *
+ * Note that the caller to this function must lock before calling, since the
+ * hardware writes must be protected from one another.
+ **/
+s32 ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
+					union ixgbe_atr_input *input,
+					union ixgbe_atr_input *input_mask,
+					u16 soft_id, u8 queue, bool cloud_mode)
+{
+	s32 err = IXGBE_ERR_CONFIG;
+	UNREFERENCED_1PARAMETER(cloud_mode);
+
+	DEBUGFUNC("ixgbe_fdir_add_perfect_filter_82599");
+
+	/*
+	 * Check flow_type formatting, and bail out before we touch the hardware
+	 * if there's a configuration issue
+	 */
+	switch (input->formatted.flow_type) {
+	case IXGBE_ATR_FLOW_TYPE_IPV4:
+	case IXGBE_ATR_FLOW_TYPE_TUNNELED_IPV4:
+		input_mask->formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK;
+		if (input->formatted.dst_port || input->formatted.src_port) {
+			hw_dbg(hw, " Error on src/dst port\n");
+			return IXGBE_ERR_CONFIG;
+		}
+		break;
+	case IXGBE_ATR_FLOW_TYPE_SCTPV4:
+	case IXGBE_ATR_FLOW_TYPE_TUNNELED_SCTPV4:
+		if (input->formatted.dst_port || input->formatted.src_port) {
+			hw_dbg(hw, " Error on src/dst port\n");
+			return IXGBE_ERR_CONFIG;
+		}
+		/* fall through */
+	case IXGBE_ATR_FLOW_TYPE_TCPV4:
+	case IXGBE_ATR_FLOW_TYPE_TUNNELED_TCPV4:
+	case IXGBE_ATR_FLOW_TYPE_UDPV4:
+	case IXGBE_ATR_FLOW_TYPE_TUNNELED_UDPV4:
+		input_mask->formatted.flow_type = IXGBE_ATR_L4TYPE_IPV6_MASK |
+						  IXGBE_ATR_L4TYPE_MASK;
+		break;
+	default:
+		hw_dbg(hw, " Error on flow type input\n");
+		return err;
+	}
+
+	/* program input mask into the HW */
+	err = ixgbe_fdir_set_input_mask_82599(hw, input_mask, cloud_mode);
+	if (err)
+		return err;
+
+	/* apply mask and compute/store hash */
+	ixgbe_atr_compute_perfect_hash_82599(input, input_mask);
+
+	/* program filters to filter memory */
+	return ixgbe_fdir_write_perfect_filter_82599(hw, input,
+						     soft_id, queue, cloud_mode);
 }
 
 /**
- *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register
- *  @hw: pointer to hardware structure
- *  @reg: analog register to read
- *  @val: read value
+ * ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register
+ * @hw: pointer to hardware structure
+ * @reg: analog register to read
+ * @val: read value
  *
- *  Performs read operation to Omer analog register specified.
+ * Performs read operation to Omer analog register specified.
  **/
-static s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)
+s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)
 {
 	u32  core_ctl;
 
+	DEBUGFUNC("ixgbe_read_analog_reg8_82599");
+
 	IXGBE_WRITE_REG(hw, IXGBE_CORECTL, IXGBE_CORECTL_WRITE_CMD |
 			(reg << 8));
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(10);
+	usec_delay(10);
 	core_ctl = IXGBE_READ_REG(hw, IXGBE_CORECTL);
 	*val = (u8)core_ctl;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register
- *  @hw: pointer to hardware structure
- *  @reg: atlas register to write
- *  @val: value to write
+ * ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register
+ * @hw: pointer to hardware structure
+ * @reg: atlas register to write
+ * @val: value to write
  *
- *  Performs write operation to Omer analog register specified.
+ * Performs write operation to Omer analog register specified.
  **/
-static s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)
+s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)
 {
 	u32  core_ctl;
 
+	DEBUGFUNC("ixgbe_write_analog_reg8_82599");
+
 	core_ctl = (reg << 8) | val;
 	IXGBE_WRITE_REG(hw, IXGBE_CORECTL, core_ctl);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(10);
+	usec_delay(10);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx
- *  @hw: pointer to hardware structure
+ * ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx
+ * @hw: pointer to hardware structure
  *
- *  Starts the hardware using the generic start_hw function
- *  and the generation start_hw function.
- *  Then performs revision-specific operations, if any.
+ * Starts the hardware using the generic start_hw function
+ * and the generation start_hw function.
+ * Then performs revision-specific operations, if any.
  **/
-static s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)
+s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)
 {
-	s32 ret_val = 0;
+	s32 ret_val = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_start_hw_82599");
 
 	ret_val = ixgbe_start_hw_generic(hw);
-	if (ret_val)
-		return ret_val;
+	if (ret_val != IXGBE_SUCCESS)
+		goto out;
 
-	ret_val = ixgbe_start_hw_gen2(hw);
-	if (ret_val)
-		return ret_val;
+	ixgbe_start_hw_gen2(hw);
 
 	/* We need to run link autotry after the driver loads */
 	hw->mac.autotry_restart = true;
 
-	return ixgbe_verify_fw_version_82599(hw);
+	if (ret_val == IXGBE_SUCCESS)
+		ret_val = ixgbe_verify_fw_version_82599(hw);
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_identify_phy_82599 - Get physical layer module
- *  @hw: pointer to hardware structure
+ * ixgbe_identify_phy_82599 - Get physical layer module
+ * @hw: pointer to hardware structure
  *
- *  Determines the physical layer module found on the current adapter.
- *  If PHY already detected, maintains current PHY type in hw struct,
- *  otherwise executes the PHY detection routine.
+ * Determines the physical layer module found on the current adapter.
+ * If PHY already detected, maintains current PHY type in hw struct,
+ * otherwise executes the PHY detection routine.
  **/
-static s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
+s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
 {
 	s32 status;
 
+	DEBUGFUNC("ixgbe_identify_phy_82599");
+
 	/* Detect PHY if not unknown - returns success if already detected. */
 	status = ixgbe_identify_phy_generic(hw);
-	if (status) {
+	if (status != IXGBE_SUCCESS) {
 		/* 82599 10GBASE-T requires an external PHY */
 		if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper)
 			return status;
-		status = ixgbe_identify_module_generic(hw);
+		else
+			status = ixgbe_identify_module_generic(hw);
 	}
 
 	/* Set PHY type none if no PHY detected */
 	if (hw->phy.type == ixgbe_phy_unknown) {
 		hw->phy.type = ixgbe_phy_none;
-		status = 0;
+		return IXGBE_SUCCESS;
 	}
 
 	/* Return error if SFP module has been detected but is not supported */
@@ -1829,172 +2140,295 @@ static s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599
- *  @hw: pointer to hardware structure
- *  @regval: register value to write to RXCTRL
+ * ixgbe_get_supported_physical_layer_82599 - Returns physical layer type
+ * @hw: pointer to hardware structure
+ *
+ * Determines physical layer capabilities of the current configuration.
+ **/
+u64 ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw)
+{
+	u64 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+	u32 autoc = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	u32 autoc2 = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
+	u32 pma_pmd_10g_serial = autoc2 & IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK;
+	u32 pma_pmd_10g_parallel = autoc & IXGBE_AUTOC_10G_PMA_PMD_MASK;
+	u32 pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
+	u16 ext_ability = 0;
+
+	DEBUGFUNC("ixgbe_get_support_physical_layer_82599");
+
+	hw->phy.ops.identify(hw);
+
+	switch (hw->phy.type) {
+	case ixgbe_phy_tn:
+	case ixgbe_phy_cu_unknown:
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
+		IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
+		if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
+		if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
+		if (ext_ability & IXGBE_MDIO_PHY_100BASETX_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
+		goto out;
+	default:
+		break;
+	}
+
+	switch (autoc & IXGBE_AUTOC_LMS_MASK) {
+	case IXGBE_AUTOC_LMS_1G_AN:
+	case IXGBE_AUTOC_LMS_1G_LINK_NO_AN:
+		if (pma_pmd_1g == IXGBE_AUTOC_1G_KX_BX) {
+			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX |
+			    IXGBE_PHYSICAL_LAYER_1000BASE_BX;
+			goto out;
+		} else
+			/* SFI mode so read SFP module */
+			goto sfp_check;
+		break;
+	case IXGBE_AUTOC_LMS_10G_LINK_NO_AN:
+		if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_CX4)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_CX4;
+		else if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_KX4)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
+		else if (pma_pmd_10g_parallel == IXGBE_AUTOC_10G_XAUI)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_XAUI;
+		goto out;
+		break;
+	case IXGBE_AUTOC_LMS_10G_SERIAL:
+		if (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_KR) {
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KR;
+			goto out;
+		} else if (pma_pmd_10g_serial == IXGBE_AUTOC2_10G_SFI)
+			goto sfp_check;
+		break;
+	case IXGBE_AUTOC_LMS_KX4_KX_KR:
+	case IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN:
+		if (autoc & IXGBE_AUTOC_KX_SUPP)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_KX;
+		if (autoc & IXGBE_AUTOC_KX4_SUPP)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KX4;
+		if (autoc & IXGBE_AUTOC_KR_SUPP)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_KR;
+		goto out;
+		break;
+	default:
+		goto out;
+		break;
+	}
+
+sfp_check:
+	/* SFP check must be done last since DA modules are sometimes used to
+	 * test KR mode -  we need to id KR mode correctly before SFP module.
+	 * Call identify_sfp because the pluggable module may have changed */
+	physical_layer = ixgbe_get_supported_phy_sfp_layer_generic(hw);
+out:
+	return physical_layer;
+}
+
+/**
+ * ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599
+ * @hw: pointer to hardware structure
+ * @regval: register value to write to RXCTRL
  *
- *  Enables the Rx DMA unit for 82599
+ * Enables the Rx DMA unit for 82599
  **/
-static s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)
+s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)
 {
+
+	DEBUGFUNC("ixgbe_enable_rx_dma_82599");
+
 	/*
 	 * Workaround for 82599 silicon errata when enabling the Rx datapath.
 	 * If traffic is incoming before we enable the Rx unit, it could hang
 	 * the Rx DMA unit.  Therefore, make sure the security engine is
 	 * completely disabled prior to enabling the Rx unit.
 	 */
-	hw->mac.ops.disable_rx_buff(hw);
+
+	hw->mac.ops.disable_sec_rx_path(hw);
 
 	if (regval & IXGBE_RXCTRL_RXEN)
-		hw->mac.ops.enable_rx(hw);
+		ixgbe_enable_rx(hw);
 	else
-		hw->mac.ops.disable_rx(hw);
+		ixgbe_disable_rx(hw);
 
-	hw->mac.ops.enable_rx_buff(hw);
+	hw->mac.ops.enable_sec_rx_path(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_verify_fw_version_82599 - verify fw version for 82599
- *  @hw: pointer to hardware structure
+ * ixgbe_verify_fw_version_82599 - verify FW version for 82599
+ * @hw: pointer to hardware structure
  *
- *  Verifies that installed the firmware version is 0.6 or higher
- *  for SFI devices. All 82599 SFI devices should have version 0.6 or higher.
+ * Verifies that installed the firmware version is 0.6 or higher
+ * for SFI devices. All 82599 SFI devices should have version 0.6 or higher.
  *
- *  Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or
- *  if the FW version is not supported.
+ * Returns IXGBE_ERR_EEPROM_VERSION if the FW is not present or
+ * if the FW version is not supported.
  **/
-static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)
 {
 	s32 status = IXGBE_ERR_EEPROM_VERSION;
 	u16 fw_offset, fw_ptp_cfg_offset;
-	u16 offset;
-	u16 fw_version = 0;
+	u16 fw_version;
+
+	DEBUGFUNC("ixgbe_verify_fw_version_82599");
 
 	/* firmware check is only necessary for SFI devices */
-	if (hw->phy.media_type != ixgbe_media_type_fiber)
-		return 0;
+	if (hw->phy.media_type != ixgbe_media_type_fiber) {
+		status = IXGBE_SUCCESS;
+		goto fw_version_out;
+	}
 
 	/* get the offset to the Firmware Module block */
-	offset = IXGBE_FW_PTR;
-	if (hw->eeprom.ops.read(hw, offset, &fw_offset))
-		goto fw_version_err;
-
-	if (fw_offset == 0 || fw_offset == 0xFFFF)
+	if (hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset)) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom read at offset %d failed", IXGBE_FW_PTR);
 		return IXGBE_ERR_EEPROM_VERSION;
+	}
 
-	/* get the offset to the Pass Through Patch Configuration block */
-	offset = fw_offset + IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR;
-	if (hw->eeprom.ops.read(hw, offset, &fw_ptp_cfg_offset))
-		goto fw_version_err;
+	if ((fw_offset == 0) || (fw_offset == 0xFFFF))
+		goto fw_version_out;
 
-	if (fw_ptp_cfg_offset == 0 || fw_ptp_cfg_offset == 0xFFFF)
+	/* get the offset to the Pass Through Patch Configuration block */
+	if (hw->eeprom.ops.read(hw, (fw_offset +
+				 IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR),
+				 &fw_ptp_cfg_offset)) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom read at offset %d failed",
+			      fw_offset +
+			      IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR);
 		return IXGBE_ERR_EEPROM_VERSION;
+	}
+
+	if ((fw_ptp_cfg_offset == 0) || (fw_ptp_cfg_offset == 0xFFFF))
+		goto fw_version_out;
 
 	/* get the firmware version */
-	offset = fw_ptp_cfg_offset + IXGBE_FW_PATCH_VERSION_4;
-	if (hw->eeprom.ops.read(hw, offset, &fw_version))
-		goto fw_version_err;
+	if (hw->eeprom.ops.read(hw, (fw_ptp_cfg_offset +
+			    IXGBE_FW_PATCH_VERSION_4), &fw_version)) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom read at offset %d failed",
+			      fw_ptp_cfg_offset + IXGBE_FW_PATCH_VERSION_4);
+		return IXGBE_ERR_EEPROM_VERSION;
+	}
 
 	if (fw_version > 0x5)
-		status = 0;
+		status = IXGBE_SUCCESS;
 
+fw_version_out:
 	return status;
-
-fw_version_err:
-	hw_err(hw, "eeprom read at offset %d failed\n", offset);
-	return IXGBE_ERR_EEPROM_VERSION;
 }
 
 /**
- *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.
- *  @hw: pointer to hardware structure
+ * ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.
+ * @hw: pointer to hardware structure
  *
- *  Returns true if the LESM FW module is present and enabled. Otherwise
- *  returns false. Smart Speed must be disabled if LESM FW module is enabled.
+ * Returns true if the LESM FW module is present and enabled. Otherwise
+ * returns false. Smart Speed must be disabled if LESM FW module is enabled.
  **/
-static bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
+bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
 {
+	bool lesm_enabled = false;
 	u16 fw_offset, fw_lesm_param_offset, fw_lesm_state;
 	s32 status;
 
+	DEBUGFUNC("ixgbe_verify_lesm_fw_enabled_82599");
+
 	/* get the offset to the Firmware Module block */
 	status = hw->eeprom.ops.read(hw, IXGBE_FW_PTR, &fw_offset);
 
-	if (status || fw_offset == 0 || fw_offset == 0xFFFF)
-		return false;
+	if ((status != IXGBE_SUCCESS) ||
+	    (fw_offset == 0) || (fw_offset == 0xFFFF))
+		goto out;
 
 	/* get the offset to the LESM Parameters block */
 	status = hw->eeprom.ops.read(hw, (fw_offset +
 				     IXGBE_FW_LESM_PARAMETERS_PTR),
 				     &fw_lesm_param_offset);
 
-	if (status ||
-	    fw_lesm_param_offset == 0 || fw_lesm_param_offset == 0xFFFF)
-		return false;
+	if ((status != IXGBE_SUCCESS) ||
+	    (fw_lesm_param_offset == 0) || (fw_lesm_param_offset == 0xFFFF))
+		goto out;
 
-	/* get the lesm state word */
+	/* get the LESM state word */
 	status = hw->eeprom.ops.read(hw, (fw_lesm_param_offset +
 				     IXGBE_FW_LESM_STATE_1),
 				     &fw_lesm_state);
 
-	if (!status && (fw_lesm_state & IXGBE_FW_LESM_STATE_ENABLED))
-		return true;
+	if ((status == IXGBE_SUCCESS) &&
+	    (fw_lesm_state & IXGBE_FW_LESM_STATE_ENABLED))
+		lesm_enabled = true;
 
-	return false;
+out:
+	return lesm_enabled;
 }
 
 /**
- *  ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using
- *  fastest available method
+ * ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using
+ * fastest available method
  *
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in EEPROM to read
- *  @words: number of words
- *  @data: word(s) read from the EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in EEPROM to read
+ * @words: number of words
+ * @data: word(s) read from the EEPROM
  *
- *  Retrieves 16 bit word(s) read from EEPROM
+ * Retrieves 16 bit word(s) read from EEPROM
  **/
-static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,
+STATIC s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,
 					  u16 words, u16 *data)
 {
 	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	s32 ret_val = IXGBE_ERR_CONFIG;
 
-	/* If EEPROM is detected and can be addressed using 14 bits,
+	DEBUGFUNC("ixgbe_read_eeprom_buffer_82599");
+
+	/*
+	 * If EEPROM is detected and can be addressed using 14 bits,
 	 * use EERD otherwise use bit bang
 	 */
-	if (eeprom->type == ixgbe_eeprom_spi &&
-	    offset + (words - 1) <= IXGBE_EERD_MAX_ADDR)
-		return ixgbe_read_eerd_buffer_generic(hw, offset, words, data);
-
-	return ixgbe_read_eeprom_buffer_bit_bang_generic(hw, offset, words,
+	if ((eeprom->type == ixgbe_eeprom_spi) &&
+	    (offset + (words - 1) <= IXGBE_EERD_MAX_ADDR))
+		ret_val = ixgbe_read_eerd_buffer_generic(hw, offset, words,
 							 data);
+	else
+		ret_val = ixgbe_read_eeprom_buffer_bit_bang_generic(hw, offset,
+								    words,
+								    data);
+
+	return ret_val;
 }
 
 /**
- *  ixgbe_read_eeprom_82599 - Read EEPROM word using
- *  fastest available method
+ * ixgbe_read_eeprom_82599 - Read EEPROM word using
+ * fastest available method
  *
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @data: word read from the EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @data: word read from the EEPROM
  *
- *  Reads a 16 bit word from the EEPROM
+ * Reads a 16 bit word from the EEPROM
  **/
-static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
 				   u16 offset, u16 *data)
 {
 	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	s32 ret_val = IXGBE_ERR_CONFIG;
+
+	DEBUGFUNC("ixgbe_read_eeprom_82599");
 
 	/*
 	 * If EEPROM is detected and can be addressed using 14 bits,
 	 * use EERD otherwise use bit bang
 	 */
-	if (eeprom->type == ixgbe_eeprom_spi && offset <= IXGBE_EERD_MAX_ADDR)
-		return ixgbe_read_eerd_generic(hw, offset, data);
+	if ((eeprom->type == ixgbe_eeprom_spi) &&
+	    (offset <= IXGBE_EERD_MAX_ADDR))
+		ret_val = ixgbe_read_eerd_generic(hw, offset, data);
+	else
+		ret_val = ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);
 
-	return ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);
+	return ret_val;
 }
 
 /**
@@ -2003,10 +2437,9 @@ static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
  * @hw: pointer to hardware structure
  *
  * Reset pipeline by asserting Restart_AN together with LMS change to ensure
- * full pipeline reset.  Note - We must hold the SW/FW semaphore before writing
- * to AUTOC, so this function assumes the semaphore is held.
+ * full pipeline reset.  This function assumes the SW/FW lock is held.
  **/
-static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
+s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
 {
 	s32 ret_val;
 	u32 anlp1_reg = 0;
@@ -2022,14 +2455,12 @@ static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
 
 	autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
 	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
-
 	/* Write AUTOC register with toggled LMS[2] bit and Restart_AN */
 	IXGBE_WRITE_REG(hw, IXGBE_AUTOC,
 			autoc_reg ^ (0x4 << IXGBE_AUTOC_LMS_SHIFT));
-
 	/* Wait for AN to leave state 0 */
 	for (i = 0; i < 10; i++) {
-		usleep_range(4000, 8000);
+		msec_delay(4);
 		anlp1_reg = IXGBE_READ_REG(hw, IXGBE_ANLP1);
 		if (anlp1_reg & IXGBE_ANLP1_AN_STATE_MASK)
 			break;
@@ -2041,7 +2472,7 @@ static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
 		goto reset_pipeline_out;
 	}
 
-	ret_val = 0;
+	ret_val = IXGBE_SUCCESS;
 
 reset_pipeline_out:
 	/* Write AUTOC register with original LMS field and Restart_AN */
@@ -2052,23 +2483,25 @@ static s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_read_i2c_byte_82599 - Reads 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to read
- *  @dev_addr: address to read from
- *  @data: value read
+ * ixgbe_read_i2c_byte_82599 - Reads 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: address to read from
+ * @data: value read
  *
- *  Performs byte read operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
+ * Performs byte read operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
  **/
-static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
-				     u8 dev_addr, u8 *data)
+STATIC s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
+				u8 dev_addr, u8 *data)
 {
 	u32 esdp;
 	s32 status;
 	s32 timeout = 200;
 
-	if (hw->phy.qsfp_shared_i2c_bus == true) {
+	DEBUGFUNC("ixgbe_read_i2c_byte_82599");
+
+	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
 		/* Acquire I2C bus ownership. */
 		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
 		esdp |= IXGBE_ESDP_SDP0;
@@ -2080,12 +2513,13 @@ static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 			if (esdp & IXGBE_ESDP_SDP1)
 				break;
 
-			usleep_range(5000, 10000);
+			msec_delay(5);
 			timeout--;
 		}
 
 		if (!timeout) {
-			hw_dbg(hw, "Driver can't access resource, acquiring I2C bus timeout.\n");
+			hw_dbg(hw, "Driver can't access resource,"
+				 " acquiring I2C bus timeout.\n");
 			status = IXGBE_ERR_I2C;
 			goto release_i2c_access;
 		}
@@ -2094,7 +2528,8 @@ static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 	status = ixgbe_read_i2c_byte_generic(hw, byte_offset, dev_addr, data);
 
 release_i2c_access:
-	if (hw->phy.qsfp_shared_i2c_bus == true) {
+
+	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
 		/* Release I2C bus ownership. */
 		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
 		esdp &= ~IXGBE_ESDP_SDP0;
@@ -2106,23 +2541,25 @@ static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_write_i2c_byte_82599 - Writes 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to write
- *  @dev_addr: address to write to
- *  @data: value to write
+ * ixgbe_write_i2c_byte_82599 - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: address to read from
+ * @data: value to write
  *
- *  Performs byte write operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
+ * Performs byte write operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
  **/
-static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
-				      u8 dev_addr, u8 data)
+STATIC s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
+				 u8 dev_addr, u8 data)
 {
 	u32 esdp;
 	s32 status;
 	s32 timeout = 200;
 
-	if (hw->phy.qsfp_shared_i2c_bus == true) {
+	DEBUGFUNC("ixgbe_write_i2c_byte_82599");
+
+	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
 		/* Acquire I2C bus ownership. */
 		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
 		esdp |= IXGBE_ESDP_SDP0;
@@ -2134,12 +2571,13 @@ static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 			if (esdp & IXGBE_ESDP_SDP1)
 				break;
 
-			usleep_range(5000, 10000);
+			msec_delay(5);
 			timeout--;
 		}
 
 		if (!timeout) {
-			hw_dbg(hw, "Driver can't access resource, acquiring I2C bus timeout.\n");
+			hw_dbg(hw, "Driver can't access resource,"
+				 " acquiring I2C bus timeout.\n");
 			status = IXGBE_ERR_I2C;
 			goto release_i2c_access;
 		}
@@ -2148,7 +2586,8 @@ static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 	status = ixgbe_write_i2c_byte_generic(hw, byte_offset, dev_addr, data);
 
 release_i2c_access:
-	if (hw->phy.qsfp_shared_i2c_bus == true) {
+
+	if (hw->phy.qsfp_shared_i2c_bus == TRUE) {
 		/* Release I2C bus ownership. */
 		esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
 		esdp &= ~IXGBE_ESDP_SDP0;
@@ -2158,99 +2597,3 @@ static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
 
 	return status;
 }
-
-static const struct ixgbe_mac_operations mac_ops_82599 = {
-	.init_hw                = &ixgbe_init_hw_generic,
-	.reset_hw               = &ixgbe_reset_hw_82599,
-	.start_hw               = &ixgbe_start_hw_82599,
-	.clear_hw_cntrs         = &ixgbe_clear_hw_cntrs_generic,
-	.get_media_type         = &ixgbe_get_media_type_82599,
-	.enable_rx_dma          = &ixgbe_enable_rx_dma_82599,
-	.disable_rx_buff	= &ixgbe_disable_rx_buff_generic,
-	.enable_rx_buff		= &ixgbe_enable_rx_buff_generic,
-	.get_mac_addr           = &ixgbe_get_mac_addr_generic,
-	.get_san_mac_addr       = &ixgbe_get_san_mac_addr_generic,
-	.get_device_caps        = &ixgbe_get_device_caps_generic,
-	.get_wwn_prefix         = &ixgbe_get_wwn_prefix_generic,
-	.stop_adapter           = &ixgbe_stop_adapter_generic,
-	.get_bus_info           = &ixgbe_get_bus_info_generic,
-	.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie,
-	.read_analog_reg8       = &ixgbe_read_analog_reg8_82599,
-	.write_analog_reg8      = &ixgbe_write_analog_reg8_82599,
-	.stop_link_on_d3	= &ixgbe_stop_mac_link_on_d3_82599,
-	.setup_link             = &ixgbe_setup_mac_link_82599,
-	.set_rxpba		= &ixgbe_set_rxpba_generic,
-	.check_link             = &ixgbe_check_mac_link_generic,
-	.get_link_capabilities  = &ixgbe_get_link_capabilities_82599,
-	.led_on                 = &ixgbe_led_on_generic,
-	.led_off                = &ixgbe_led_off_generic,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.blink_led_start        = &ixgbe_blink_led_start_generic,
-	.blink_led_stop         = &ixgbe_blink_led_stop_generic,
-	.set_rar                = &ixgbe_set_rar_generic,
-	.clear_rar              = &ixgbe_clear_rar_generic,
-	.set_vmdq               = &ixgbe_set_vmdq_generic,
-	.set_vmdq_san_mac	= &ixgbe_set_vmdq_san_mac_generic,
-	.clear_vmdq             = &ixgbe_clear_vmdq_generic,
-	.init_rx_addrs          = &ixgbe_init_rx_addrs_generic,
-	.update_mc_addr_list    = &ixgbe_update_mc_addr_list_generic,
-	.enable_mc              = &ixgbe_enable_mc_generic,
-	.disable_mc             = &ixgbe_disable_mc_generic,
-	.clear_vfta             = &ixgbe_clear_vfta_generic,
-	.set_vfta               = &ixgbe_set_vfta_generic,
-	.fc_enable              = &ixgbe_fc_enable_generic,
-	.setup_fc		= ixgbe_setup_fc_generic,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.set_fw_drv_ver         = &ixgbe_set_fw_drv_ver_generic,
-	.init_uta_tables        = &ixgbe_init_uta_tables_generic,
-	.setup_sfp              = &ixgbe_setup_sfp_modules_82599,
-	.set_mac_anti_spoofing  = &ixgbe_set_mac_anti_spoofing,
-	.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing,
-	.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync,
-	.release_swfw_sync      = &ixgbe_release_swfw_sync,
-	.init_swfw_sync		= NULL,
-	.get_thermal_sensor_data = &ixgbe_get_thermal_sensor_data_generic,
-	.init_thermal_sensor_thresh = &ixgbe_init_thermal_sensor_thresh_generic,
-	.prot_autoc_read	= &prot_autoc_read_82599,
-	.prot_autoc_write	= &prot_autoc_write_82599,
-	.enable_rx		= &ixgbe_enable_rx_generic,
-	.disable_rx		= &ixgbe_disable_rx_generic,
-};
-
-static const struct ixgbe_eeprom_operations eeprom_ops_82599 = {
-	.init_params		= &ixgbe_init_eeprom_params_generic,
-	.read			= &ixgbe_read_eeprom_82599,
-	.read_buffer		= &ixgbe_read_eeprom_buffer_82599,
-	.write			= &ixgbe_write_eeprom_generic,
-	.write_buffer		= &ixgbe_write_eeprom_buffer_bit_bang_generic,
-	.calc_checksum		= &ixgbe_calc_eeprom_checksum_generic,
-	.validate_checksum	= &ixgbe_validate_eeprom_checksum_generic,
-	.update_checksum	= &ixgbe_update_eeprom_checksum_generic,
-};
-
-static const struct ixgbe_phy_operations phy_ops_82599 = {
-	.identify		= &ixgbe_identify_phy_82599,
-	.identify_sfp		= &ixgbe_identify_module_generic,
-	.init			= &ixgbe_init_phy_ops_82599,
-	.reset			= &ixgbe_reset_phy_generic,
-	.read_reg		= &ixgbe_read_phy_reg_generic,
-	.write_reg		= &ixgbe_write_phy_reg_generic,
-	.setup_link		= &ixgbe_setup_phy_link_generic,
-	.setup_link_speed	= &ixgbe_setup_phy_link_speed_generic,
-	.read_i2c_byte		= &ixgbe_read_i2c_byte_generic,
-	.write_i2c_byte		= &ixgbe_write_i2c_byte_generic,
-	.read_i2c_sff8472	= &ixgbe_read_i2c_sff8472_generic,
-	.read_i2c_eeprom	= &ixgbe_read_i2c_eeprom_generic,
-	.write_i2c_eeprom	= &ixgbe_write_i2c_eeprom_generic,
-	.check_overtemp		= &ixgbe_tn_check_overtemp,
-};
-
-const struct ixgbe_info ixgbe_82599_info = {
-	.mac                    = ixgbe_mac_82599EB,
-	.get_invariants         = &ixgbe_get_invariants_82599,
-	.mac_ops                = &mac_ops_82599,
-	.eeprom_ops             = &eeprom_ops_82599,
-	.phy_ops                = &phy_ops_82599,
-	.mbx_ops                = &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_8259X,
-};
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.h
new file mode 100644
index 000000000000..5219f0721df8
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_82599.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_82599_H_
+#define _IXGBE_82599_H_
+
+s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
+				      ixgbe_link_speed *speed, bool *autoneg);
+enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw);
+void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
+void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
+void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
+void ixgbe_set_hard_rate_select_speed(struct ixgbe_hw *hw,
+					ixgbe_link_speed speed);
+s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete);
+s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
+			       bool autoneg_wait_to_complete);
+s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+			       bool autoneg_wait_to_complete);
+s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw);
+void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw);
+s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw);
+s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val);
+s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val);
+s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw);
+s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw);
+s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw);
+u64 ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw);
+s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval);
+s32 prot_autoc_read_82599(struct ixgbe_hw *hw, bool *locked, u32 *reg_val);
+s32 prot_autoc_write_82599(struct ixgbe_hw *hw, u32 reg_val, bool locked);
+#endif /* _IXGBE_82599_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_api.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_api.c
new file mode 100644
index 000000000000..689bc8585933
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_api.c
@@ -0,0 +1,1652 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#include "ixgbe_api.h"
+#include "ixgbe_common.h"
+
+#define IXGBE_EMPTY_PARAM
+
+static const u32 ixgbe_mvals_base[IXGBE_MVALS_IDX_LIMIT] = {
+	IXGBE_MVALS_INIT(IXGBE_EMPTY_PARAM)
+};
+
+static const u32 ixgbe_mvals_X540[IXGBE_MVALS_IDX_LIMIT] = {
+	IXGBE_MVALS_INIT(_X540)
+};
+
+static const u32 ixgbe_mvals_X550[IXGBE_MVALS_IDX_LIMIT] = {
+	IXGBE_MVALS_INIT(_X550)
+};
+
+static const u32 ixgbe_mvals_X550EM_x[IXGBE_MVALS_IDX_LIMIT] = {
+	IXGBE_MVALS_INIT(_X550EM_x)
+};
+
+static const u32 ixgbe_mvals_X550EM_a[IXGBE_MVALS_IDX_LIMIT] = {
+	IXGBE_MVALS_INIT(_X550EM_a)
+};
+
+/**
+ * ixgbe_dcb_get_rtrup2tc - read rtrup2tc reg
+ * @hw: pointer to hardware structure
+ * @map: pointer to u8 arr for returning map
+ *
+ * Read the rtrup2tc HW register and resolve its content into map
+ **/
+void ixgbe_dcb_get_rtrup2tc(struct ixgbe_hw *hw, u8 *map)
+{
+	if (hw->mac.ops.get_rtrup2tc)
+		hw->mac.ops.get_rtrup2tc(hw, map);
+}
+
+/**
+ * ixgbe_init_shared_code - Initialize the shared code
+ * @hw: pointer to hardware structure
+ *
+ * This will assign function pointers and assign the MAC type and PHY code.
+ * Does not touch the hardware. This function must be called prior to any
+ * other function in the shared code. The ixgbe_hw structure should be
+ * memset to 0 prior to calling this function.  The following fields in
+ * hw structure should be filled in prior to calling this function:
+ * hw_addr, back, device_id, vendor_id, subsystem_device_id,
+ * subsystem_vendor_id, and revision_id
+ **/
+s32 ixgbe_init_shared_code(struct ixgbe_hw *hw)
+{
+	s32 status;
+
+	DEBUGFUNC("ixgbe_init_shared_code");
+
+	/*
+	 * Set the mac type
+	 */
+	ixgbe_set_mac_type(hw);
+
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		status = ixgbe_init_ops_82598(hw);
+		break;
+	case ixgbe_mac_82599EB:
+		status = ixgbe_init_ops_82599(hw);
+		break;
+	case ixgbe_mac_X540:
+		status = ixgbe_init_ops_X540(hw);
+		break;
+	case ixgbe_mac_X550:
+		status = ixgbe_init_ops_X550(hw);
+		break;
+	case ixgbe_mac_X550EM_x:
+		status = ixgbe_init_ops_X550EM_x(hw);
+		break;
+	case ixgbe_mac_X550EM_a:
+		status = ixgbe_init_ops_X550EM_a(hw);
+		break;
+	default:
+		status = IXGBE_ERR_DEVICE_NOT_SUPPORTED;
+		break;
+	}
+	hw->mac.max_link_up_time = IXGBE_LINK_UP_TIME;
+
+	/* NVM Update features structure initialization */
+	hw->nvmupd_features.major = IXGBE_NVMUPD_FEATURES_API_VER_MAJOR;
+	hw->nvmupd_features.minor = IXGBE_NVMUPD_FEATURES_API_VER_MINOR;
+	hw->nvmupd_features.size = sizeof(hw->nvmupd_features);
+	memset(hw->nvmupd_features.features, 0x0,
+	       IXGBE_NVMUPD_FEATURES_API_FEATURES_ARRAY_LEN *
+	       sizeof(*hw->nvmupd_features.features));
+
+	hw->nvmupd_features.features[0] =
+		IXGBE_NVMUPD_FEATURE_REGISTER_ACCESS_SUPPORT;
+
+	return status;
+}
+
+/**
+ * ixgbe_set_mac_type - Sets MAC type
+ * @hw: pointer to the HW structure
+ *
+ * This function sets the mac type of the adapter based on the
+ * vendor ID and device ID stored in the hw structure.
+ **/
+s32 ixgbe_set_mac_type(struct ixgbe_hw *hw)
+{
+	s32 ret_val = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_set_mac_type\n");
+
+	if (hw->vendor_id != IXGBE_INTEL_VENDOR_ID) {
+		ERROR_REPORT2(IXGBE_ERROR_UNSUPPORTED,
+			     "Unsupported vendor id: %x", hw->vendor_id);
+		return IXGBE_ERR_DEVICE_NOT_SUPPORTED;
+	}
+
+	hw->mvals = ixgbe_mvals_base;
+
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_82598:
+	case IXGBE_DEV_ID_82598_BX:
+	case IXGBE_DEV_ID_82598AF_SINGLE_PORT:
+	case IXGBE_DEV_ID_82598AF_DUAL_PORT:
+	case IXGBE_DEV_ID_82598AT:
+	case IXGBE_DEV_ID_82598AT2:
+	case IXGBE_DEV_ID_82598EB_CX4:
+	case IXGBE_DEV_ID_82598_CX4_DUAL_PORT:
+	case IXGBE_DEV_ID_82598_DA_DUAL_PORT:
+	case IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM:
+	case IXGBE_DEV_ID_82598EB_XF_LR:
+	case IXGBE_DEV_ID_82598EB_SFP_LOM:
+		hw->mac.type = ixgbe_mac_82598EB;
+		break;
+	case IXGBE_DEV_ID_82599_KX4:
+	case IXGBE_DEV_ID_82599_KX4_MEZZ:
+	case IXGBE_DEV_ID_82599_XAUI_LOM:
+	case IXGBE_DEV_ID_82599_COMBO_BACKPLANE:
+	case IXGBE_DEV_ID_82599_KR:
+	case IXGBE_DEV_ID_82599_SFP:
+	case IXGBE_DEV_ID_82599_BACKPLANE_FCOE:
+	case IXGBE_DEV_ID_82599_SFP_FCOE:
+	case IXGBE_DEV_ID_82599_SFP_EM:
+	case IXGBE_DEV_ID_82599_SFP_SF2:
+	case IXGBE_DEV_ID_82599_SFP_SF_QP:
+	case IXGBE_DEV_ID_82599_QSFP_SF_QP:
+	case IXGBE_DEV_ID_82599EN_SFP:
+	case IXGBE_DEV_ID_82599_CX4:
+	case IXGBE_DEV_ID_82599_T3_LOM:
+		hw->mac.type = ixgbe_mac_82599EB;
+		break;
+	case IXGBE_DEV_ID_X540T:
+	case IXGBE_DEV_ID_X540T1:
+		hw->mac.type = ixgbe_mac_X540;
+		hw->mvals = ixgbe_mvals_X540;
+		break;
+	case IXGBE_DEV_ID_X550T:
+	case IXGBE_DEV_ID_X550T1:
+		hw->mac.type = ixgbe_mac_X550;
+		hw->mvals = ixgbe_mvals_X550;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_KX4:
+	case IXGBE_DEV_ID_X550EM_X_KR:
+	case IXGBE_DEV_ID_X550EM_X_10G_T:
+	case IXGBE_DEV_ID_X550EM_X_1G_T:
+	case IXGBE_DEV_ID_X550EM_X_SFP:
+	case IXGBE_DEV_ID_X550EM_X_XFI:
+		hw->mac.type = ixgbe_mac_X550EM_x;
+		hw->mvals = ixgbe_mvals_X550EM_x;
+		break;
+	case IXGBE_DEV_ID_X550EM_A_KR:
+	case IXGBE_DEV_ID_X550EM_A_KR_L:
+	case IXGBE_DEV_ID_X550EM_A_SFP_N:
+	case IXGBE_DEV_ID_X550EM_A_SGMII:
+	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+	case IXGBE_DEV_ID_X550EM_A_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_QSFP:
+	case IXGBE_DEV_ID_X550EM_A_QSFP_N:
+	case IXGBE_DEV_ID_X550EM_A_SFP:
+		hw->mac.type = ixgbe_mac_X550EM_a;
+		hw->mvals = ixgbe_mvals_X550EM_a;
+		break;
+	default:
+		ret_val = IXGBE_ERR_DEVICE_NOT_SUPPORTED;
+		ERROR_REPORT2(IXGBE_ERROR_UNSUPPORTED,
+			     "Unsupported device id: %x",
+			     hw->device_id);
+		break;
+	}
+
+	hw_dbg(hw, "ixgbe_set_mac_type found mac: %d, returns: %d\n",
+		  hw->mac.type, ret_val);
+	return ret_val;
+}
+
+/**
+ * ixgbe_init_hw - Initialize the hardware
+ * @hw: pointer to hardware structure
+ *
+ * Initialize the hardware by resetting and then starting the hardware
+ **/
+s32 ixgbe_init_hw(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.init_hw, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_reset_hw - Performs a hardware reset
+ * @hw: pointer to hardware structure
+ *
+ * Resets the hardware by resetting the transmit and receive units, masks and
+ * clears all interrupts, performs a PHY reset, and performs a MAC reset
+ **/
+s32 ixgbe_reset_hw(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.reset_hw, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_start_hw - Prepares hardware for Rx/Tx
+ * @hw: pointer to hardware structure
+ *
+ * Starts the hardware by filling the bus info structure and media type,
+ * clears all on chip counters, initializes receive address registers,
+ * multicast table, VLAN filter table, calls routine to setup link and
+ * flow control settings, and leaves transmit and receive units disabled
+ * and uninitialized.
+ **/
+s32 ixgbe_start_hw(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.start_hw, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_clear_hw_cntrs - Clear hardware counters
+ * @hw: pointer to hardware structure
+ *
+ * Clears all hardware statistics counters by reading them from the hardware
+ * Statistics counters are clear on read.
+ **/
+s32 ixgbe_clear_hw_cntrs(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.clear_hw_cntrs, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_media_type - Get media type
+ * @hw: pointer to hardware structure
+ *
+ * Returns the media type (fiber, copper, backplane)
+ **/
+enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_media_type, (hw),
+			       ixgbe_media_type_unknown);
+}
+
+/**
+ * ixgbe_get_mac_addr - Get MAC address
+ * @hw: pointer to hardware structure
+ * @mac_addr: Adapter MAC address
+ *
+ * Reads the adapter's MAC address from the first Receive Address Register
+ * (RAR0) A reset of the adapter must have been performed prior to calling
+ * this function in order for the MAC address to have been loaded from the
+ * EEPROM into RAR0
+ **/
+s32 ixgbe_get_mac_addr(struct ixgbe_hw *hw, u8 *mac_addr)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_mac_addr,
+			       (hw, mac_addr), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_san_mac_addr - Get SAN MAC address
+ * @hw: pointer to hardware structure
+ * @san_mac_addr: SAN MAC address
+ *
+ * Reads the SAN MAC address from the EEPROM, if it's available.  This is
+ * per-port, so set_lan_id() must be called before reading the addresses.
+ **/
+s32 ixgbe_get_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_san_mac_addr,
+			       (hw, san_mac_addr), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_san_mac_addr - Write a SAN MAC address
+ * @hw: pointer to hardware structure
+ * @san_mac_addr: SAN MAC address
+ *
+ * Writes A SAN MAC address to the EEPROM.
+ **/
+s32 ixgbe_set_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_san_mac_addr,
+			       (hw, san_mac_addr), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_device_caps - Get additional device capabilities
+ * @hw: pointer to hardware structure
+ * @device_caps: the EEPROM word for device capabilities
+ *
+ * Reads the extra device capabilities from the EEPROM
+ **/
+s32 ixgbe_get_device_caps(struct ixgbe_hw *hw, u16 *device_caps)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_device_caps,
+			       (hw, device_caps), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_wwn_prefix - Get alternative WWNN/WWPN prefix from the EEPROM
+ * @hw: pointer to hardware structure
+ * @wwnn_prefix: the alternative WWNN prefix
+ * @wwpn_prefix: the alternative WWPN prefix
+ *
+ * This function will read the EEPROM from the alternative SAN MAC address
+ * block to check the support for the alternative WWNN/WWPN prefix support.
+ **/
+s32 ixgbe_get_wwn_prefix(struct ixgbe_hw *hw, u16 *wwnn_prefix,
+			 u16 *wwpn_prefix)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_wwn_prefix,
+			       (hw, wwnn_prefix, wwpn_prefix),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_fcoe_boot_status -  Get FCOE boot status from EEPROM
+ * @hw: pointer to hardware structure
+ * @bs: the fcoe boot status
+ *
+ * This function will read the FCOE boot status from the iSCSI FCOE block
+ **/
+s32 ixgbe_get_fcoe_boot_status(struct ixgbe_hw *hw, u16 *bs)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_fcoe_boot_status,
+			       (hw, bs),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_bus_info - Set PCI bus info
+ * @hw: pointer to hardware structure
+ *
+ * Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
+ **/
+s32 ixgbe_get_bus_info(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_bus_info, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_num_of_tx_queues - Get Tx queues
+ * @hw: pointer to hardware structure
+ *
+ * Returns the number of transmit queues for the given adapter.
+ **/
+u32 ixgbe_get_num_of_tx_queues(struct ixgbe_hw *hw)
+{
+	return hw->mac.max_tx_queues;
+}
+
+/**
+ * ixgbe_get_num_of_rx_queues - Get Rx queues
+ * @hw: pointer to hardware structure
+ *
+ * Returns the number of receive queues for the given adapter.
+ **/
+u32 ixgbe_get_num_of_rx_queues(struct ixgbe_hw *hw)
+{
+	return hw->mac.max_rx_queues;
+}
+
+/**
+ * ixgbe_stop_adapter - Disable Rx/Tx units
+ * @hw: pointer to hardware structure
+ *
+ * Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
+ * disables transmit and receive units. The adapter_stopped flag is used by
+ * the shared code and drivers to determine if the adapter is in a stopped
+ * state and should not touch the hardware.
+ **/
+s32 ixgbe_stop_adapter(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.stop_adapter, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_pba_string - Reads part number string from EEPROM
+ * @hw: pointer to hardware structure
+ * @pba_num: stores the part number string from the EEPROM
+ * @pba_num_size: part number string buffer length
+ *
+ * Reads the part number string from the EEPROM.
+ **/
+s32 ixgbe_read_pba_string(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size)
+{
+	return ixgbe_read_pba_string_generic(hw, pba_num, pba_num_size);
+}
+
+/**
+ * ixgbe_identify_phy - Get PHY type
+ * @hw: pointer to hardware structure
+ *
+ * Determines the physical layer module found on the current adapter.
+ **/
+s32 ixgbe_identify_phy(struct ixgbe_hw *hw)
+{
+	s32 status = IXGBE_SUCCESS;
+
+	if (hw->phy.type == ixgbe_phy_unknown) {
+		status = ixgbe_call_func(hw, hw->phy.ops.identify, (hw),
+					 IXGBE_NOT_IMPLEMENTED);
+	}
+
+	return status;
+}
+
+/**
+ * ixgbe_reset_phy - Perform a PHY reset
+ * @hw: pointer to hardware structure
+ **/
+s32 ixgbe_reset_phy(struct ixgbe_hw *hw)
+{
+	s32 status = IXGBE_SUCCESS;
+
+	if (hw->phy.type == ixgbe_phy_unknown) {
+		if (ixgbe_identify_phy(hw) != IXGBE_SUCCESS)
+			status = IXGBE_ERR_PHY;
+	}
+
+	if (status == IXGBE_SUCCESS) {
+		status = ixgbe_call_func(hw, hw->phy.ops.reset, (hw),
+					 IXGBE_NOT_IMPLEMENTED);
+	}
+	return status;
+}
+
+/**
+ * ixgbe_get_phy_firmware_version -
+ * @hw: pointer to hardware structure
+ * @firmware_version: pointer to firmware version
+ **/
+s32 ixgbe_get_phy_firmware_version(struct ixgbe_hw *hw, u16 *firmware_version)
+{
+	s32 status = IXGBE_SUCCESS;
+
+	status = ixgbe_call_func(hw, hw->phy.ops.get_firmware_version,
+				 (hw, firmware_version),
+				 IXGBE_NOT_IMPLEMENTED);
+	return status;
+}
+
+/**
+ * ixgbe_read_phy_reg - Read PHY register
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit address of PHY register to read
+ * @device_type: type of device you want to communicate with
+ * @phy_data: Pointer to read data from PHY register
+ *
+ * Reads a value from a specified PHY register
+ **/
+s32 ixgbe_read_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+		       u16 *phy_data)
+{
+	if (hw->phy.id == 0)
+		ixgbe_identify_phy(hw);
+
+	return ixgbe_call_func(hw, hw->phy.ops.read_reg, (hw, reg_addr,
+			       device_type, phy_data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_phy_reg - Write PHY register
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: type of device you want to communicate with
+ * @phy_data: Data to write to the PHY register
+ *
+ * Writes a value to specified PHY register
+ **/
+s32 ixgbe_write_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+			u16 phy_data)
+{
+	if (hw->phy.id == 0)
+		ixgbe_identify_phy(hw);
+
+	return ixgbe_call_func(hw, hw->phy.ops.write_reg, (hw, reg_addr,
+			       device_type, phy_data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_phy_link - Restart PHY autoneg
+ * @hw: pointer to hardware structure
+ *
+ * Restart autonegotiation and PHY and waits for completion.
+ **/
+s32 ixgbe_setup_phy_link(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.setup_link, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_internal_phy - Configure integrated PHY
+ * @hw: pointer to hardware structure
+ *
+ * Reconfigure the integrated PHY in order to enable talk to the external PHY.
+ * Returns success if not implemented, since nothing needs to be done in this
+ * case.
+ */
+s32 ixgbe_setup_internal_phy(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.setup_internal_link, (hw),
+			       IXGBE_SUCCESS);
+}
+
+/**
+ * ixgbe_check_phy_link - Determine link and speed status
+ * @hw: pointer to hardware structure
+ * @speed: link speed
+ * @link_up: true when link is up
+ *
+ * Reads a PHY register to determine if link is up and the current speed for
+ * the PHY.
+ **/
+s32 ixgbe_check_phy_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+			 bool *link_up)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.check_link, (hw, speed,
+			       link_up), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_phy_link_speed - Set auto advertise
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
+ *
+ * Sets the auto advertised capabilities
+ **/
+s32 ixgbe_setup_phy_link_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+			       bool autoneg_wait_to_complete)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.setup_link_speed, (hw, speed,
+			       autoneg_wait_to_complete),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_phy_power - Control the phy power state
+ * @hw: pointer to hardware structure
+ * @on: true for on, false for off
+ */
+s32 ixgbe_set_phy_power(struct ixgbe_hw *hw, bool on)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.set_phy_power, (hw, on),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_check_link - Get link and speed status
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @link_up: true when link is up
+ * @link_up_wait_to_complete: bool used to wait for link up or not
+ *
+ * Reads the links register to determine if link is up and the current speed
+ **/
+s32 ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+		     bool *link_up, bool link_up_wait_to_complete)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.check_link, (hw, speed,
+			       link_up, link_up_wait_to_complete),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_disable_tx_laser - Disable Tx laser
+ * @hw: pointer to hardware structure
+ *
+ * If the driver needs to disable the laser on SFI optics.
+ **/
+void ixgbe_disable_tx_laser(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.disable_tx_laser)
+		hw->mac.ops.disable_tx_laser(hw);
+}
+
+/**
+ * ixgbe_enable_tx_laser - Enable Tx laser
+ * @hw: pointer to hardware structure
+ *
+ * If the driver needs to enable the laser on SFI optics.
+ **/
+void ixgbe_enable_tx_laser(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.enable_tx_laser)
+		hw->mac.ops.enable_tx_laser(hw);
+}
+
+/**
+ * ixgbe_flap_tx_laser - flap Tx laser to start autotry process
+ * @hw: pointer to hardware structure
+ *
+ * When the driver changes the link speeds that it can support then
+ * flap the tx laser to alert the link partner to start autotry
+ * process on its end.
+ **/
+void ixgbe_flap_tx_laser(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.flap_tx_laser)
+		hw->mac.ops.flap_tx_laser(hw);
+}
+
+/**
+ * ixgbe_setup_link - Set link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
+ *
+ * Configures link settings.  Restarts the link.
+ * Performs autonegotiation if needed.
+ **/
+s32 ixgbe_setup_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+		     bool autoneg_wait_to_complete)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.setup_link, (hw, speed,
+			       autoneg_wait_to_complete),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_mac_link - Set link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
+ *
+ * Configures link settings.  Restarts the link.
+ * Performs autonegotiation if needed.
+ **/
+s32 ixgbe_setup_mac_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+			 bool autoneg_wait_to_complete)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.setup_mac_link, (hw, speed,
+			       autoneg_wait_to_complete),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_link_capabilities - Returns link capabilities
+ * @hw: pointer to hardware structure
+ * @speed: link speed capabilities
+ * @autoneg: true when autoneg or autotry is enabled
+ *
+ * Determines the link capabilities of the current configuration.
+ **/
+s32 ixgbe_get_link_capabilities(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+				bool *autoneg)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_link_capabilities, (hw,
+			       speed, autoneg), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_led_on - Turn on LEDs
+ * @hw: pointer to hardware structure
+ * @index: led number to turn on
+ *
+ * Turns on the software controllable LEDs.
+ **/
+s32 ixgbe_led_on(struct ixgbe_hw *hw, u32 index)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.led_on, (hw, index),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_led_off - Turn off LEDs
+ * @hw: pointer to hardware structure
+ * @index: led number to turn off
+ *
+ * Turns off the software controllable LEDs.
+ **/
+s32 ixgbe_led_off(struct ixgbe_hw *hw, u32 index)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.led_off, (hw, index),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_blink_led_start - Blink LEDs
+ * @hw: pointer to hardware structure
+ * @index: led number to blink
+ *
+ * Blink LED based on index.
+ **/
+s32 ixgbe_blink_led_start(struct ixgbe_hw *hw, u32 index)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.blink_led_start, (hw, index),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_blink_led_stop - Stop blinking LEDs
+ * @hw: pointer to hardware structure
+ * @index: led number to stop
+ *
+ * Stop blinking LED based on index.
+ **/
+s32 ixgbe_blink_led_stop(struct ixgbe_hw *hw, u32 index)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.blink_led_stop, (hw, index),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_init_eeprom_params - Initialize EEPROM parameters
+ * @hw: pointer to hardware structure
+ *
+ * Initializes the EEPROM parameters ixgbe_eeprom_info within the
+ * ixgbe_hw struct in order to set up EEPROM access.
+ **/
+s32 ixgbe_init_eeprom_params(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.init_params, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+
+/**
+ * ixgbe_write_eeprom - Write word to EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be written to
+ * @data: 16 bit word to be written to the EEPROM
+ *
+ * Writes 16 bit value to EEPROM. If ixgbe_eeprom_update_checksum is not
+ * called after this function, the EEPROM will most likely contain an
+ * invalid checksum.
+ **/
+s32 ixgbe_write_eeprom(struct ixgbe_hw *hw, u16 offset, u16 data)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.write, (hw, offset, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_eeprom_buffer - Write word(s) to EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be written to
+ * @data: 16 bit word(s) to be written to the EEPROM
+ * @words: number of words
+ *
+ * Writes 16 bit word(s) to EEPROM. If ixgbe_eeprom_update_checksum is not
+ * called after this function, the EEPROM will most likely contain an
+ * invalid checksum.
+ **/
+s32 ixgbe_write_eeprom_buffer(struct ixgbe_hw *hw, u16 offset, u16 words,
+			      u16 *data)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.write_buffer,
+			       (hw, offset, words, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_eeprom - Read word from EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be read
+ * @data: read 16 bit value from EEPROM
+ *
+ * Reads 16 bit value from EEPROM
+ **/
+s32 ixgbe_read_eeprom(struct ixgbe_hw *hw, u16 offset, u16 *data)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.read, (hw, offset, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_eeprom_buffer - Read word(s) from EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be read
+ * @data: read 16 bit word(s) from EEPROM
+ * @words: number of words
+ *
+ * Reads 16 bit word(s) from EEPROM
+ **/
+s32 ixgbe_read_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
+			     u16 words, u16 *data)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.read_buffer,
+			       (hw, offset, words, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_validate_eeprom_checksum - Validate EEPROM checksum
+ * @hw: pointer to hardware structure
+ * @checksum_val: calculated checksum
+ *
+ * Performs checksum calculation and validates the EEPROM checksum
+ **/
+s32 ixgbe_validate_eeprom_checksum(struct ixgbe_hw *hw, u16 *checksum_val)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.validate_checksum,
+			       (hw, checksum_val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_eeprom_update_checksum - Updates the EEPROM checksum
+ * @hw: pointer to hardware structure
+ **/
+s32 ixgbe_update_eeprom_checksum(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->eeprom.ops.update_checksum, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_insert_mac_addr - Find a RAR for this mac address
+ * @hw: pointer to hardware structure
+ * @addr: Address to put into receive address register
+ * @vmdq: VMDq pool to assign
+ *
+ * Puts an ethernet address into a receive address register, or
+ * finds the rar that it is aleady in; adds to the pool list
+ **/
+s32 ixgbe_insert_mac_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.insert_mac_addr,
+			       (hw, addr, vmdq),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_rar - Set Rx address register
+ * @hw: pointer to hardware structure
+ * @index: Receive address register to write
+ * @addr: Address to put into receive address register
+ * @vmdq: VMDq "set"
+ * @enable_addr: set flag that address is active
+ *
+ * Puts an ethernet address into a receive address register.
+ **/
+s32 ixgbe_set_rar(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
+		  u32 enable_addr)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_rar, (hw, index, addr, vmdq,
+			       enable_addr), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_clear_rar - Clear Rx address register
+ * @hw: pointer to hardware structure
+ * @index: Receive address register to write
+ *
+ * Puts an ethernet address into a receive address register.
+ **/
+s32 ixgbe_clear_rar(struct ixgbe_hw *hw, u32 index)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.clear_rar, (hw, index),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_vmdq - Associate a VMDq index with a receive address
+ * @hw: pointer to hardware structure
+ * @rar: receive address register index to associate with VMDq index
+ * @vmdq: VMDq set or pool index
+ **/
+s32 ixgbe_set_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_vmdq, (hw, rar, vmdq),
+			       IXGBE_NOT_IMPLEMENTED);
+
+}
+
+/**
+ * ixgbe_set_vmdq_san_mac - Associate VMDq index 127 with a receive address
+ * @hw: pointer to hardware structure
+ * @vmdq: VMDq default pool index
+ **/
+s32 ixgbe_set_vmdq_san_mac(struct ixgbe_hw *hw, u32 vmdq)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_vmdq_san_mac,
+			       (hw, vmdq), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_clear_vmdq - Disassociate a VMDq index from a receive address
+ * @hw: pointer to hardware structure
+ * @rar: receive address register index to disassociate with VMDq index
+ * @vmdq: VMDq set or pool index
+ **/
+s32 ixgbe_clear_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.clear_vmdq, (hw, rar, vmdq),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_init_rx_addrs - Initializes receive address filters.
+ * @hw: pointer to hardware structure
+ *
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive address registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
+ **/
+s32 ixgbe_init_rx_addrs(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.init_rx_addrs, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_num_rx_addrs - Returns the number of RAR entries.
+ * @hw: pointer to hardware structure
+ **/
+u32 ixgbe_get_num_rx_addrs(struct ixgbe_hw *hw)
+{
+	return hw->mac.num_rar_entries;
+}
+
+/**
+ * ixgbe_update_uc_addr_list - Updates the MAC's list of secondary addresses
+ * @hw: pointer to hardware structure
+ * @addr_list: the list of new multicast addresses
+ * @addr_count: number of addresses
+ * @func: iterator function to walk the multicast address list
+ *
+ * The given list replaces any existing list. Clears the secondary addrs from
+ * receive address registers. Uses unused receive address registers for the
+ * first secondary addresses, and falls back to promiscuous mode as needed.
+ **/
+s32 ixgbe_update_uc_addr_list(struct ixgbe_hw *hw, u8 *addr_list,
+			      u32 addr_count, ixgbe_mc_addr_itr func)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.update_uc_addr_list, (hw,
+			       addr_list, addr_count, func),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_update_mc_addr_list - Updates the MAC's list of multicast addresses
+ * @hw: pointer to hardware structure
+ * @mc_addr_list: the list of new multicast addresses
+ * @mc_addr_count: number of addresses
+ * @func: iterator function to walk the multicast address list
+ * @clear: flag, when set clears the table beforehand
+ *
+ * The given list replaces any existing list. Clears the MC addrs from receive
+ * address registers and the multicast table. Uses unused receive address
+ * registers for the first multicast addresses, and hashes the rest into the
+ * multicast table.
+ **/
+s32 ixgbe_update_mc_addr_list(struct ixgbe_hw *hw, u8 *mc_addr_list,
+			      u32 mc_addr_count, ixgbe_mc_addr_itr func,
+			      bool clear)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.update_mc_addr_list, (hw,
+			       mc_addr_list, mc_addr_count, func, clear),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_enable_mc - Enable multicast address in RAR
+ * @hw: pointer to hardware structure
+ *
+ * Enables multicast address in RAR and the use of the multicast hash table.
+ **/
+s32 ixgbe_enable_mc(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.enable_mc, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_disable_mc - Disable multicast address in RAR
+ * @hw: pointer to hardware structure
+ *
+ * Disables multicast address in RAR and the use of the multicast hash table.
+ **/
+s32 ixgbe_disable_mc(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.disable_mc, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_clear_vfta - Clear VLAN filter table
+ * @hw: pointer to hardware structure
+ *
+ * Clears the VLAN filer table, and the VMDq index associated with the filter
+ **/
+s32 ixgbe_clear_vfta(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.clear_vfta, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_vfta - Set VLAN filter table
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vind: VMDq output index that maps queue to VLAN id in VLVFB
+ * @vlan_on: boolean flag to turn on/off VLAN
+ * @vlvf_bypass: boolean flag indicating updating the default pool is okay
+ *
+ * Turn on/off specified VLAN in the VLAN filter table.
+ **/
+s32 ixgbe_set_vfta(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on,
+		   bool vlvf_bypass)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_vfta, (hw, vlan, vind,
+			       vlan_on, vlvf_bypass), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_vlvf - Set VLAN Pool Filter
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vind: VMDq output index that maps queue to VLAN id in VLVFB
+ * @vlan_on: boolean flag to turn on/off VLAN in VLVF
+ * @vfta_delta: pointer to the difference between the current value of VFTA
+ *		 and the desired value
+ * @vfta: the desired value of the VFTA
+ * @vlvf_bypass: boolean flag indicating updating the default pool is okay
+ *
+ * Turn on/off specified bit in VLVF table.
+ **/
+s32 ixgbe_set_vlvf(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on,
+		   u32 *vfta_delta, u32 vfta, bool vlvf_bypass)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_vlvf, (hw, vlan, vind,
+			       vlan_on, vfta_delta, vfta, vlvf_bypass),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_toggle_txdctl - Toggle VF's queues
+ * @hw: pointer to hardware structure
+ * @vind: VMDq pool index
+ *
+ * Enable and disable each queue in VF.
+ */
+s32 ixgbe_toggle_txdctl(struct ixgbe_hw *hw, u32 vind)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.toggle_txdctl, (hw,
+			       vind), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_fc_enable - Enable flow control
+ * @hw: pointer to hardware structure
+ *
+ * Configures the flow control settings based on SW configuration.
+ **/
+s32 ixgbe_fc_enable(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.fc_enable, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_fc - Set up flow control
+ * @hw: pointer to hardware structure
+ *
+ * Called at init time to set up flow control.
+ **/
+s32 ixgbe_setup_fc(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.setup_fc, (hw),
+		IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_fw_drv_ver - Try to send the driver version number FW
+ * @hw: pointer to hardware structure
+ * @maj: driver major number to be sent to firmware
+ * @min: driver minor number to be sent to firmware
+ * @build: driver build number to be sent to firmware
+ * @ver: driver version number to be sent to firmware
+ * @len: length of driver_ver string
+ * @driver_ver: driver string
+ **/
+s32 ixgbe_set_fw_drv_ver(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build,
+			 u8 ver, u16 len, char *driver_ver)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.set_fw_drv_ver, (hw, maj, min,
+			       build, ver, len, driver_ver),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
+ * @hw: pointer to hardware structure
+ *
+ * Updates the temperatures in mac.thermal_sensor_data
+ **/
+s32 ixgbe_get_thermal_sensor_data(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_thermal_sensor_data, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_init_thermal_sensor_thresh - Inits thermal sensor thresholds
+ * @hw: pointer to hardware structure
+ *
+ * Inits the thermal sensor thresholds according to the NVM map
+ **/
+s32 ixgbe_init_thermal_sensor_thresh(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.init_thermal_sensor_thresh, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_dmac_config - Configure DMA Coalescing registers.
+ * @hw: pointer to hardware structure
+ *
+ * Configure DMA coalescing. If enabling dmac, dmac is activated.
+ * When disabling dmac, dmac enable dmac bit is cleared.
+ **/
+s32 ixgbe_dmac_config(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.dmac_config, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_dmac_update_tcs - Configure DMA Coalescing registers.
+ * @hw: pointer to hardware structure
+ *
+ * Disables dmac, updates per TC settings, and then enable dmac.
+ **/
+s32 ixgbe_dmac_update_tcs(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.dmac_update_tcs, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_dmac_config_tcs - Configure DMA Coalescing registers.
+ * @hw: pointer to hardware structure
+ *
+ * Configure DMA coalescing threshold per TC and set high priority bit for
+ * FCOE TC. The dmac enable bit must be cleared before configuring.
+ **/
+s32 ixgbe_dmac_config_tcs(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.dmac_config_tcs, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_setup_eee - Enable/disable EEE support
+ * @hw: pointer to the HW structure
+ * @enable_eee: boolean flag to enable EEE
+ *
+ * Enable/disable EEE based on enable_ee flag.
+ * Auto-negotiation must be started after BASE-T EEE bits in PHY register 7.3C
+ * are modified.
+ *
+ **/
+s32 ixgbe_setup_eee(struct ixgbe_hw *hw, bool enable_eee)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.setup_eee, (hw, enable_eee),
+			IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_set_source_address_pruning - Enable/Disable source address pruning
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable source address pruning
+ * @pool: Rx pool - Rx pool to toggle source address pruning
+ **/
+void ixgbe_set_source_address_pruning(struct ixgbe_hw *hw, bool enable,
+				      unsigned int pool)
+{
+	if (hw->mac.ops.set_source_address_pruning)
+		hw->mac.ops.set_source_address_pruning(hw, enable, pool);
+}
+
+/**
+ * ixgbe_set_ethertype_anti_spoofing - Enable/Disable Ethertype anti-spoofing
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable switch for Ethertype anti-spoofing
+ * @vf: Virtual Function pool - VF Pool to set for Ethertype anti-spoofing
+ *
+ **/
+void ixgbe_set_ethertype_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
+{
+	if (hw->mac.ops.set_ethertype_anti_spoofing)
+		hw->mac.ops.set_ethertype_anti_spoofing(hw, enable, vf);
+}
+
+/**
+ * ixgbe_read_iosf_sb_reg - Read 32 bit PHY register
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit address of PHY register to read
+ * @device_type: type of device you want to communicate with
+ * @phy_data: Pointer to read data from PHY register
+ *
+ * Reads a value from a specified PHY register
+ **/
+s32 ixgbe_read_iosf_sb_reg(struct ixgbe_hw *hw, u32 reg_addr,
+			   u32 device_type, u32 *phy_data)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.read_iosf_sb_reg, (hw, reg_addr,
+			       device_type, phy_data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_iosf_sb_reg - Write 32 bit register through IOSF Sideband
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: type of device you want to communicate with
+ * @phy_data: Data to write to the PHY register
+ *
+ * Writes a value to specified PHY register
+ **/
+s32 ixgbe_write_iosf_sb_reg(struct ixgbe_hw *hw, u32 reg_addr,
+			    u32 device_type, u32 phy_data)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.write_iosf_sb_reg, (hw, reg_addr,
+			       device_type, phy_data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_disable_mdd - Disable malicious driver detection
+ * @hw: pointer to hardware structure
+ *
+ **/
+void ixgbe_disable_mdd(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.disable_mdd)
+		hw->mac.ops.disable_mdd(hw);
+}
+
+/**
+ * ixgbe_enable_mdd - Enable malicious driver detection
+ * @hw: pointer to hardware structure
+ *
+ **/
+void ixgbe_enable_mdd(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.enable_mdd)
+		hw->mac.ops.enable_mdd(hw);
+}
+
+/**
+ * ixgbe_mdd_event - Handle malicious driver detection event
+ * @hw: pointer to hardware structure
+ * @vf_bitmap: vf bitmap of malicious vfs
+ *
+ **/
+void ixgbe_mdd_event(struct ixgbe_hw *hw, u32 *vf_bitmap)
+{
+	if (hw->mac.ops.mdd_event)
+		hw->mac.ops.mdd_event(hw, vf_bitmap);
+}
+
+/**
+ * ixgbe_restore_mdd_vf - Restore VF that was disabled during malicious driver
+ * detection event
+ * @hw: pointer to hardware structure
+ * @vf: vf index
+ *
+ **/
+void ixgbe_restore_mdd_vf(struct ixgbe_hw *hw, u32 vf)
+{
+	if (hw->mac.ops.restore_mdd_vf)
+		hw->mac.ops.restore_mdd_vf(hw, vf);
+}
+
+/**
+ * ixgbe_fw_recovery_mode - Check if in FW NVM recovery mode
+ * @hw: pointer to hardware structure
+ *
+ **/
+bool ixgbe_fw_recovery_mode(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.fw_recovery_mode)
+		return hw->mac.ops.fw_recovery_mode(hw);
+	return false;
+}
+
+/**
+ * ixgbe_enter_lplu - Transition to low power states
+ * @hw: pointer to hardware structure
+ *
+ * Configures Low Power Link Up on transition to low power states
+ * (from D0 to non-D0).
+ **/
+s32 ixgbe_enter_lplu(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.enter_lplu, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_handle_lasi - Handle external Base T PHY interrupt
+ * @hw: pointer to hardware structure
+ *
+ * Handle external Base T PHY interrupt. If high temperature
+ * failure alarm then return error, else if link status change
+ * then setup internal/external PHY link
+ *
+ * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
+ * failure alarm, else return PHY access status.
+ */
+s32 ixgbe_handle_lasi(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.handle_lasi, (hw),
+				IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_analog_reg8 - Reads 8 bit analog register
+ * @hw: pointer to hardware structure
+ * @reg: analog register to read
+ * @val: read value
+ *
+ * Performs write operation to analog register specified.
+ **/
+s32 ixgbe_read_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 *val)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.read_analog_reg8, (hw, reg,
+			       val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_analog_reg8 - Writes 8 bit analog register
+ * @hw: pointer to hardware structure
+ * @reg: analog register to write
+ * @val: value to write
+ *
+ * Performs write operation to Atlas analog register specified.
+ **/
+s32 ixgbe_write_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 val)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.write_analog_reg8, (hw, reg,
+			       val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_init_uta_tables - Initializes Unicast Table Arrays.
+ * @hw: pointer to hardware structure
+ *
+ * Initializes the Unicast Table Arrays to zero on device load.  This
+ * is part of the Rx init addr execution path.
+ **/
+s32 ixgbe_init_uta_tables(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.init_uta_tables, (hw),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_i2c_byte - Reads 8 bit word over I2C at specified device address
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: I2C bus address to read from
+ * @data: value read
+ *
+ * Performs byte read operation to SFP module's EEPROM over I2C interface.
+ **/
+s32 ixgbe_read_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
+			u8 *data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.read_i2c_byte, (hw, byte_offset,
+			       dev_addr, data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_i2c_byte_unlocked - Reads 8 bit word via I2C from device address
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: I2C bus address to read from
+ * @data: value read
+ *
+ * Performs byte read operation to SFP module's EEPROM over I2C interface.
+ **/
+s32 ixgbe_read_i2c_byte_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
+				 u8 dev_addr, u8 *data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.read_i2c_byte_unlocked,
+			       (hw, byte_offset, dev_addr, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_link - Perform read operation on link device
+ * @hw: pointer to the hardware structure
+ * @addr: bus address to read from
+ * @reg: device register to read from
+ * @val: pointer to location to receive read value
+ *
+ * Returns an error code on error.
+ */
+s32 ixgbe_read_link(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val)
+{
+	return ixgbe_call_func(hw, hw->link.ops.read_link, (hw, addr,
+			       reg, val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_link_unlocked - Perform read operation on link device
+ * @hw: pointer to the hardware structure
+ * @addr: bus address to read from
+ * @reg: device register to read from
+ * @val: pointer to location to receive read value
+ *
+ * Returns an error code on error.
+ **/
+s32 ixgbe_read_link_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val)
+{
+	return ixgbe_call_func(hw, hw->link.ops.read_link_unlocked,
+			       (hw, addr, reg, val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_i2c_byte - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: I2C bus address to write to
+ * @data: value to write
+ *
+ * Performs byte write operation to SFP module's EEPROM over I2C interface
+ * at a specified device address.
+ **/
+s32 ixgbe_write_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
+			 u8 data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.write_i2c_byte, (hw, byte_offset,
+			       dev_addr, data), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_i2c_byte_unlocked - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: I2C bus address to write to
+ * @data: value to write
+ *
+ * Performs byte write operation to SFP module's EEPROM over I2C interface
+ * at a specified device address.
+ **/
+s32 ixgbe_write_i2c_byte_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
+				  u8 dev_addr, u8 data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.write_i2c_byte_unlocked,
+			       (hw, byte_offset, dev_addr, data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_link - Perform write operation on link device
+ * @hw: pointer to the hardware structure
+ * @addr: bus address to write to
+ * @reg: device register to write to
+ * @val: value to write
+ *
+ * Returns an error code on error.
+ */
+s32 ixgbe_write_link(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val)
+{
+	return ixgbe_call_func(hw, hw->link.ops.write_link,
+			       (hw, addr, reg, val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_link_unlocked - Perform write operation on link device
+ * @hw: pointer to the hardware structure
+ * @addr: bus address to write to
+ * @reg: device register to write to
+ * @val: value to write
+ *
+ * Returns an error code on error.
+ **/
+s32 ixgbe_write_link_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val)
+{
+	return ixgbe_call_func(hw, hw->link.ops.write_link_unlocked,
+			       (hw, addr, reg, val), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_write_i2c_eeprom - Writes 8 bit EEPROM word over I2C interface
+ * @hw: pointer to hardware structure
+ * @byte_offset: EEPROM byte offset to write
+ * @eeprom_data: value to write
+ *
+ * Performs byte write operation to SFP module's EEPROM over I2C interface.
+ **/
+s32 ixgbe_write_i2c_eeprom(struct ixgbe_hw *hw,
+			   u8 byte_offset, u8 eeprom_data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.write_i2c_eeprom,
+			       (hw, byte_offset, eeprom_data),
+			       IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_read_i2c_eeprom - Reads 8 bit EEPROM word over I2C interface
+ * @hw: pointer to hardware structure
+ * @byte_offset: EEPROM byte offset to read
+ * @eeprom_data: value read
+ *
+ * Performs byte read operation to SFP module's EEPROM over I2C interface.
+ **/
+s32 ixgbe_read_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data)
+{
+	return ixgbe_call_func(hw, hw->phy.ops.read_i2c_eeprom,
+			      (hw, byte_offset, eeprom_data),
+			      IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_get_supported_physical_layer - Returns physical layer type
+ * @hw: pointer to hardware structure
+ *
+ * Determines physical layer capabilities of the current configuration.
+ **/
+u64 ixgbe_get_supported_physical_layer(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.get_supported_physical_layer,
+			       (hw), IXGBE_PHYSICAL_LAYER_UNKNOWN);
+}
+
+/**
+ * ixgbe_enable_rx_dma - Enables Rx DMA unit, dependent on device specifics
+ * @hw: pointer to hardware structure
+ * @regval: bitfield to write to the Rx DMA register
+ *
+ * Enables the Rx DMA unit of the device.
+ **/
+s32 ixgbe_enable_rx_dma(struct ixgbe_hw *hw, u32 regval)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.enable_rx_dma,
+			       (hw, regval), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_disable_sec_rx_path - Stops the receive data path
+ * @hw: pointer to hardware structure
+ *
+ * Stops the receive data path.
+ **/
+s32 ixgbe_disable_sec_rx_path(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.disable_sec_rx_path,
+				(hw), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_enable_sec_rx_path - Enables the receive data path
+ * @hw: pointer to hardware structure
+ *
+ * Enables the receive data path.
+ **/
+s32 ixgbe_enable_sec_rx_path(struct ixgbe_hw *hw)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.enable_sec_rx_path,
+				(hw), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_acquire_swfw_semaphore - Acquire SWFW semaphore
+ * @hw: pointer to hardware structure
+ * @mask: Mask to specify which semaphore to acquire
+ *
+ * Acquires the SWFW semaphore through SW_FW_SYNC register for the specified
+ * function (CSR, PHY0, PHY1, EEPROM, Flash)
+ **/
+s32 ixgbe_acquire_swfw_semaphore(struct ixgbe_hw *hw, u32 mask)
+{
+	return ixgbe_call_func(hw, hw->mac.ops.acquire_swfw_sync,
+			       (hw, mask), IXGBE_NOT_IMPLEMENTED);
+}
+
+/**
+ * ixgbe_release_swfw_semaphore - Release SWFW semaphore
+ * @hw: pointer to hardware structure
+ * @mask: Mask to specify which semaphore to release
+ *
+ * Releases the SWFW semaphore through SW_FW_SYNC register for the specified
+ * function (CSR, PHY0, PHY1, EEPROM, Flash)
+ **/
+void ixgbe_release_swfw_semaphore(struct ixgbe_hw *hw, u32 mask)
+{
+	if (hw->mac.ops.release_swfw_sync)
+		hw->mac.ops.release_swfw_sync(hw, mask);
+}
+
+/**
+ * ixgbe_init_swfw_semaphore - Clean up SWFW semaphore
+ * @hw: pointer to hardware structure
+ *
+ * Attempts to acquire the SWFW semaphore through SW_FW_SYNC register.
+ * Regardless of whether is succeeds or not it then release the semaphore.
+ * This is function is called to recover from catastrophic failures that
+ * may have left the semaphore locked.
+ **/
+void ixgbe_init_swfw_semaphore(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.init_swfw_sync)
+		hw->mac.ops.init_swfw_sync(hw);
+}
+
+void ixgbe_disable_rx(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.disable_rx)
+		hw->mac.ops.disable_rx(hw);
+}
+
+void ixgbe_enable_rx(struct ixgbe_hw *hw)
+{
+	if (hw->mac.ops.enable_rx)
+		hw->mac.ops.enable_rx(hw);
+}
+
+/**
+ * ixgbe_set_rate_select_speed - Set module link speed
+ * @hw: pointer to hardware structure
+ * @speed: link speed to set
+ *
+ * Set module link speed via the rate select.
+ */
+void ixgbe_set_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed)
+{
+	if (hw->mac.ops.set_rate_select_speed)
+		hw->mac.ops.set_rate_select_speed(hw, speed);
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_api.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_api.h
new file mode 100644
index 000000000000..7387cacd374e
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_api.h
@@ -0,0 +1,194 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_API_H_
+#define _IXGBE_API_H_
+
+#include "ixgbe_type.h"
+
+void ixgbe_dcb_get_rtrup2tc(struct ixgbe_hw *hw, u8 *map);
+
+s32 ixgbe_init_shared_code(struct ixgbe_hw *hw);
+
+extern s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_82599(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_X540(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_X550(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_X550EM(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_X550EM_x(struct ixgbe_hw *hw);
+extern s32 ixgbe_init_ops_X550EM_a(struct ixgbe_hw *hw);
+
+s32 ixgbe_set_mac_type(struct ixgbe_hw *hw);
+s32 ixgbe_init_hw(struct ixgbe_hw *hw);
+s32 ixgbe_reset_hw(struct ixgbe_hw *hw);
+s32 ixgbe_start_hw(struct ixgbe_hw *hw);
+s32 ixgbe_clear_hw_cntrs(struct ixgbe_hw *hw);
+enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw);
+s32 ixgbe_get_mac_addr(struct ixgbe_hw *hw, u8 *mac_addr);
+s32 ixgbe_get_bus_info(struct ixgbe_hw *hw);
+u32 ixgbe_get_num_of_tx_queues(struct ixgbe_hw *hw);
+u32 ixgbe_get_num_of_rx_queues(struct ixgbe_hw *hw);
+s32 ixgbe_stop_adapter(struct ixgbe_hw *hw);
+s32 ixgbe_read_pba_string(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size);
+
+s32 ixgbe_identify_phy(struct ixgbe_hw *hw);
+s32 ixgbe_reset_phy(struct ixgbe_hw *hw);
+s32 ixgbe_read_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+		       u16 *phy_data);
+s32 ixgbe_write_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+			u16 phy_data);
+
+s32 ixgbe_setup_phy_link(struct ixgbe_hw *hw);
+s32 ixgbe_setup_internal_phy(struct ixgbe_hw *hw);
+s32 ixgbe_check_phy_link(struct ixgbe_hw *hw,
+			 ixgbe_link_speed *speed,
+			 bool *link_up);
+s32 ixgbe_setup_phy_link_speed(struct ixgbe_hw *hw,
+			       ixgbe_link_speed speed,
+			       bool autoneg_wait_to_complete);
+s32 ixgbe_set_phy_power(struct ixgbe_hw *, bool on);
+void ixgbe_disable_tx_laser(struct ixgbe_hw *hw);
+void ixgbe_enable_tx_laser(struct ixgbe_hw *hw);
+void ixgbe_flap_tx_laser(struct ixgbe_hw *hw);
+s32 ixgbe_setup_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+		     bool autoneg_wait_to_complete);
+s32 ixgbe_setup_mac_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+			 bool autoneg_wait_to_complete);
+s32 ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+		     bool *link_up, bool link_up_wait_to_complete);
+s32 ixgbe_get_link_capabilities(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+				bool *autoneg);
+s32 ixgbe_led_on(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_led_off(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_blink_led_start(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_blink_led_stop(struct ixgbe_hw *hw, u32 index);
+
+s32 ixgbe_init_eeprom_params(struct ixgbe_hw *hw);
+s32 ixgbe_write_eeprom(struct ixgbe_hw *hw, u16 offset, u16 data);
+s32 ixgbe_write_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
+			      u16 words, u16 *data);
+s32 ixgbe_read_eeprom(struct ixgbe_hw *hw, u16 offset, u16 *data);
+s32 ixgbe_read_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
+			     u16 words, u16 *data);
+
+s32 ixgbe_validate_eeprom_checksum(struct ixgbe_hw *hw, u16 *checksum_val);
+s32 ixgbe_update_eeprom_checksum(struct ixgbe_hw *hw);
+
+s32 ixgbe_insert_mac_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq);
+s32 ixgbe_set_rar(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
+		  u32 enable_addr);
+s32 ixgbe_clear_rar(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_set_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
+s32 ixgbe_set_vmdq_san_mac(struct ixgbe_hw *hw, u32 vmdq);
+s32 ixgbe_clear_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
+s32 ixgbe_init_rx_addrs(struct ixgbe_hw *hw);
+u32 ixgbe_get_num_rx_addrs(struct ixgbe_hw *hw);
+s32 ixgbe_update_uc_addr_list(struct ixgbe_hw *hw, u8 *addr_list,
+			      u32 addr_count, ixgbe_mc_addr_itr func);
+s32 ixgbe_update_mc_addr_list(struct ixgbe_hw *hw, u8 *mc_addr_list,
+			      u32 mc_addr_count, ixgbe_mc_addr_itr func,
+			      bool clear);
+void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr_list, u32 vmdq);
+s32 ixgbe_enable_mc(struct ixgbe_hw *hw);
+s32 ixgbe_disable_mc(struct ixgbe_hw *hw);
+s32 ixgbe_clear_vfta(struct ixgbe_hw *hw);
+s32 ixgbe_set_vfta(struct ixgbe_hw *hw, u32 vlan,
+		   u32 vind, bool vlan_on, bool vlvf_bypass);
+s32 ixgbe_set_vlvf(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+		   bool vlan_on, u32 *vfta_delta, u32 vfta,
+		   bool vlvf_bypass);
+s32 ixgbe_toggle_txdctl(struct ixgbe_hw *hw, u32 vind);
+s32 ixgbe_fc_enable(struct ixgbe_hw *hw);
+s32 ixgbe_setup_fc(struct ixgbe_hw *hw);
+s32 ixgbe_set_fw_drv_ver(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build,
+			 u8 ver, u16 len, char *driver_ver);
+s32 ixgbe_get_thermal_sensor_data(struct ixgbe_hw *hw);
+s32 ixgbe_init_thermal_sensor_thresh(struct ixgbe_hw *hw);
+void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr);
+s32 ixgbe_get_phy_firmware_version(struct ixgbe_hw *hw,
+				   u16 *firmware_version);
+s32 ixgbe_read_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 *val);
+s32 ixgbe_write_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 val);
+s32 ixgbe_init_uta_tables(struct ixgbe_hw *hw);
+s32 ixgbe_read_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data);
+u64 ixgbe_get_supported_physical_layer(struct ixgbe_hw *hw);
+s32 ixgbe_enable_rx_dma(struct ixgbe_hw *hw, u32 regval);
+s32 ixgbe_disable_sec_rx_path(struct ixgbe_hw *hw);
+s32 ixgbe_enable_sec_rx_path(struct ixgbe_hw *hw);
+s32 ixgbe_mng_fw_enabled(struct ixgbe_hw *hw);
+s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
+s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl);
+s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl,
+					bool cloud_mode);
+void ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
+					   union ixgbe_atr_hash_dword input,
+					   union ixgbe_atr_hash_dword common,
+					   u8 queue);
+s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
+				    union ixgbe_atr_input *input_mask, bool cloud_mode);
+s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
+					  union ixgbe_atr_input *input,
+					  u16 soft_id, u8 queue, bool cloud_mode);
+s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
+					  union ixgbe_atr_input *input,
+					  u16 soft_id);
+s32 ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
+					union ixgbe_atr_input *input,
+					union ixgbe_atr_input *mask,
+					u16 soft_id,
+					u8 queue,
+					bool cloud_mode);
+void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
+					  union ixgbe_atr_input *mask);
+u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
+				     union ixgbe_atr_hash_dword common);
+bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
+s32 ixgbe_read_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
+			u8 *data);
+s32 ixgbe_read_i2c_byte_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
+				 u8 dev_addr, u8 *data);
+s32 ixgbe_read_link(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val);
+s32 ixgbe_read_link_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 *val);
+s32 ixgbe_write_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
+			 u8 data);
+void ixgbe_set_fdir_drop_queue_82599(struct ixgbe_hw *hw, u8 dropqueue);
+s32 ixgbe_write_i2c_byte_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
+				  u8 dev_addr, u8 data);
+s32 ixgbe_write_link(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val);
+s32 ixgbe_write_link_unlocked(struct ixgbe_hw *hw, u8 addr, u16 reg, u16 val);
+s32 ixgbe_write_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 eeprom_data);
+s32 ixgbe_get_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr);
+s32 ixgbe_set_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr);
+s32 ixgbe_get_device_caps(struct ixgbe_hw *hw, u16 *device_caps);
+s32 ixgbe_acquire_swfw_semaphore(struct ixgbe_hw *hw, u32 mask);
+void ixgbe_release_swfw_semaphore(struct ixgbe_hw *hw, u32 mask);
+void ixgbe_init_swfw_semaphore(struct ixgbe_hw *hw);
+s32 ixgbe_get_wwn_prefix(struct ixgbe_hw *hw, u16 *wwnn_prefix,
+			 u16 *wwpn_prefix);
+s32 ixgbe_get_fcoe_boot_status(struct ixgbe_hw *hw, u16 *bs);
+s32 ixgbe_dmac_config(struct ixgbe_hw *hw);
+s32 ixgbe_dmac_update_tcs(struct ixgbe_hw *hw);
+s32 ixgbe_dmac_config_tcs(struct ixgbe_hw *hw);
+s32 ixgbe_setup_eee(struct ixgbe_hw *hw, bool enable_eee);
+void ixgbe_set_source_address_pruning(struct ixgbe_hw *hw, bool enable,
+				      unsigned int vf);
+void ixgbe_set_ethertype_anti_spoofing(struct ixgbe_hw *hw, bool enable,
+				       int vf);
+s32 ixgbe_read_iosf_sb_reg(struct ixgbe_hw *hw, u32 reg_addr,
+			u32 device_type, u32 *phy_data);
+s32 ixgbe_write_iosf_sb_reg(struct ixgbe_hw *hw, u32 reg_addr,
+			u32 device_type, u32 phy_data);
+void ixgbe_disable_mdd(struct ixgbe_hw *hw);
+void ixgbe_enable_mdd(struct ixgbe_hw *hw);
+void ixgbe_mdd_event(struct ixgbe_hw *hw, u32 *vf_bitmap);
+void ixgbe_restore_mdd_vf(struct ixgbe_hw *hw, u32 vf);
+bool ixgbe_fw_recovery_mode(struct ixgbe_hw *hw);
+s32 ixgbe_enter_lplu(struct ixgbe_hw *hw);
+s32 ixgbe_handle_lasi(struct ixgbe_hw *hw);
+void ixgbe_set_rate_select_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed);
+void ixgbe_disable_rx(struct ixgbe_hw *hw);
+void ixgbe_enable_rx(struct ixgbe_hw *hw);
+s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,
+			u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm);
+
+#endif /* _IXGBE_API_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.c
new file mode 100644
index 000000000000..121382abb143
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.c
@@ -0,0 +1,149 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+
+#include "ixgbe.h"
+#include "ixgbe_cna.h"
+#include "ixgbe_vmdq.h"
+
+static int ixgbe_cna_open(struct net_device *cnadev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(cnadev);
+
+	strscpy(cnadev->name, adapter->netdev->name, sizeof(cnadev->name));
+
+	DPRINTK(PROBE, INFO, "CNA pseudo device opened %s\n", cnadev->name);
+	return 0;
+}
+
+static int ixgbe_cna_close(struct net_device *cnadev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(cnadev);
+
+	DPRINTK(PROBE, INFO, "CNA pseudo device closed %s\n", cnadev->name);
+	return 0;
+}
+
+static int ixgbe_cna_change_mtu(struct net_device *cnadev, int new_mtu)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(cnadev);
+	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
+
+	/* MTU < 68 is an error and causes problems on some kernels */
+	if ((new_mtu < 68) || (max_frame > IXGBE_MAX_JUMBO_FRAME_SIZE))
+		return -EINVAL;
+
+	DPRINTK(PROBE, INFO, "changing MTU from %d to %d\n",
+		cnadev->mtu, new_mtu);
+	/* must set new MTU before calling down or up */
+	cnadev->mtu = new_mtu;
+
+	return 0;
+}
+
+int ixgbe_cna_enable(struct ixgbe_adapter *adapter)
+{
+	struct net_device *cnadev;
+	struct net_device *netdev;
+	int err;
+	u64 wwpn;
+	u64 wwnn;
+
+	netdev = adapter->netdev;
+	/*
+	 * Oppositely to regular net device, CNA device doesn't have
+	 * a private allocated region as we don't want to duplicate
+	 * ixgbe_adapter information. Though, the CNA device still need
+	 * to access the ixgbe_adapter while allocating queues or such. Thereby,
+	 * cnadev->priv needs to point to netdev->priv.
+	 */
+	cnadev = alloc_etherdev_mq(0, MAX_TX_QUEUES);
+	if (!cnadev) {
+		err = -ENOMEM;
+		goto err_alloc_etherdev;
+	}
+	adapter->cnadev = cnadev;
+	SET_MODULE_OWNER(cnadev);
+
+	cnadev->priv = adapter;
+
+	cnadev->open		= &ixgbe_cna_open;
+	cnadev->stop		= &ixgbe_cna_close;
+	cnadev->change_mtu	= &ixgbe_cna_change_mtu;
+	cnadev->do_ioctl	= netdev->do_ioctl;
+	cnadev->hard_start_xmit	= netdev->hard_start_xmit;
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+	cnadev->vlan_rx_register = netdev->vlan_rx_register;
+	cnadev->vlan_rx_add_vid  = netdev->vlan_rx_add_vid;
+	cnadev->vlan_rx_kill_vid = netdev->vlan_rx_kill_vid;
+#endif
+	ixgbe_set_ethtool_ops(cnadev);
+
+#if IS_ENABLED(CONFIG_DCB)
+	cnadev->dcbnl_ops = netdev->dcbnl_ops;
+#endif /* CONFIG_DCB */
+
+	cnadev->mtu = netdev->mtu;
+	cnadev->pdev = netdev->pdev;
+	cnadev->gso_max_size = GSO_MAX_SIZE;
+	cnadev->features = netdev->features | NETIF_F_CNA | NETIF_F_HW_VLAN_FILTER;
+
+	/* set the MAC address to SAN mac address */
+	if (ixgbe_validate_mac_addr(adapter->hw.mac.san_addr) == 0)
+		memcpy(cnadev->dev_addr,
+		       adapter->hw.mac.san_addr,
+		       cnadev->addr_len);
+
+	cnadev->features |= NETIF_F_FCOE_CRC |
+			    NETIF_F_FCOE_MTU |
+			    NETIF_F_FSO;
+
+	cnadev->ndo_fcoe_ddp_setup = &ixgbe_fcoe_ddp_get;
+	cnadev->ndo_fcoe_ddp_done = &ixgbe_fcoe_ddp_put;
+	cnadev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;
+
+	netif_carrier_off(cnadev);
+	netif_tx_stop_all_queues(cnadev);
+
+	VMKNETDDI_REGISTER_QUEUEOPS(cnadev, ixgbe_netqueue_ops);
+
+	err = register_netdev(cnadev);
+	if (err)
+		goto err_register;
+
+	DPRINTK(PROBE, INFO, "CNA pseudo device registered %s\n", netdev->name);
+
+	return err;
+
+err_register:
+	DPRINTK(PROBE, INFO, "CNA pseudo device cannot be registered %s\n",
+		netdev->name);
+	free_netdev(cnadev);
+err_alloc_etherdev:
+	DPRINTK(PROBE, INFO, "CNA cannot be enabled on %s\n", netdev->name);
+	adapter->flags2 &= ~IXGBE_FLAG2_CNA_ENABLED;
+	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
+	adapter->ring_feature[RING_F_FCOE].indices = 0;
+	return err;
+}
+
+void ixgbe_cna_disable(struct ixgbe_adapter *adapter)
+{
+	if (!(adapter->flags2 & IXGBE_FLAG2_CNA_ENABLED))
+		return;
+
+	adapter->flags2 &= ~IXGBE_FLAG2_CNA_ENABLED;
+	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
+	adapter->ring_feature[RING_F_FCOE].indices = 0;
+
+	if (adapter->cnadev) {
+		unregister_netdev(adapter->cnadev);
+		DPRINTK(PROBE, INFO, "CNA pseudo device unregistered %s\n",
+			adapter->cnadev->name);
+
+		free_netdev(adapter->cnadev);
+ 		adapter->cnadev = NULL;
+ 	}
+}
+
+/* ixgbe_cna.c */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.h
new file mode 100644
index 000000000000..07229f52f7a6
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_cna.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_CNA_H_
+#define _IXGBE_CNA_H_
+
+int ixgbe_cna_enable(struct ixgbe_adapter *adapter);
+void ixgbe_cna_disable(struct ixgbe_adapter *adapter);
+
+#endif /* _IXGBE_CNA_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
index 62ddb452f862..f70f3563c066 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c
@@ -1,50 +1,133 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/netdevice.h>
-
-#include "ixgbe.h"
 #include "ixgbe_common.h"
 #include "ixgbe_phy.h"
-
-static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
-static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
-static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
-static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);
-static void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
-static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
+#include "ixgbe_dcb.h"
+#include "ixgbe_dcb_82599.h"
+#include "ixgbe_api.h"
+
+STATIC s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
+STATIC void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);
+STATIC void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
+STATIC void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
 					u16 count);
-static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);
-static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
-static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
-static void ixgbe_release_eeprom(struct ixgbe_hw *hw);
-
-static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);
-static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg);
-static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
+STATIC u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);
+STATIC void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
+STATIC void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
+STATIC void ixgbe_release_eeprom(struct ixgbe_hw *hw);
+
+STATIC s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);
+STATIC s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
+					 u16 *san_mac_offset);
+STATIC s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
 					     u16 words, u16 *data);
-static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
-					     u16 words, u16 *data);
-static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
+					      u16 words, u16 *data);
+STATIC s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
 						 u16 offset);
-static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw);
 
-/* Base table for registers values that change by MAC */
-const u32 ixgbe_mvals_8259X[IXGBE_MVALS_IDX_LIMIT] = {
-	IXGBE_MVALS_INIT(8259X)
-};
+/**
+ * ixgbe_init_ops_generic - Inits function ptrs
+ * @hw: pointer to the hardware structure
+ *
+ * Initialize the function pointers.
+ **/
+s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw)
+{
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	struct ixgbe_mac_info *mac = &hw->mac;
+	u32 eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
+
+	DEBUGFUNC("ixgbe_init_ops_generic");
+
+	/* EEPROM */
+	eeprom->ops.init_params = ixgbe_init_eeprom_params_generic;
+	/* If EEPROM is valid (bit 8 = 1), use EERD otherwise use bit bang */
+	if (eec & IXGBE_EEC_PRES) {
+		eeprom->ops.read = ixgbe_read_eerd_generic;
+		eeprom->ops.read_buffer = ixgbe_read_eerd_buffer_generic;
+	} else {
+		eeprom->ops.read = ixgbe_read_eeprom_bit_bang_generic;
+		eeprom->ops.read_buffer =
+				 ixgbe_read_eeprom_buffer_bit_bang_generic;
+	}
+	eeprom->ops.write = ixgbe_write_eeprom_generic;
+	eeprom->ops.write_buffer = ixgbe_write_eeprom_buffer_bit_bang_generic;
+	eeprom->ops.validate_checksum =
+				      ixgbe_validate_eeprom_checksum_generic;
+	eeprom->ops.update_checksum = ixgbe_update_eeprom_checksum_generic;
+	eeprom->ops.calc_checksum = ixgbe_calc_eeprom_checksum_generic;
+
+	/* MAC */
+	mac->ops.init_hw = ixgbe_init_hw_generic;
+	mac->ops.reset_hw = NULL;
+	mac->ops.start_hw = ixgbe_start_hw_generic;
+	mac->ops.clear_hw_cntrs = ixgbe_clear_hw_cntrs_generic;
+	mac->ops.get_media_type = NULL;
+	mac->ops.get_supported_physical_layer = NULL;
+	mac->ops.enable_rx_dma = ixgbe_enable_rx_dma_generic;
+	mac->ops.get_mac_addr = ixgbe_get_mac_addr_generic;
+	mac->ops.stop_adapter = ixgbe_stop_adapter_generic;
+	mac->ops.get_bus_info = ixgbe_get_bus_info_generic;
+	mac->ops.set_lan_id = ixgbe_set_lan_id_multi_port_pcie;
+	mac->ops.acquire_swfw_sync = ixgbe_acquire_swfw_sync;
+	mac->ops.release_swfw_sync = ixgbe_release_swfw_sync;
+	mac->ops.prot_autoc_read = prot_autoc_read_generic;
+	mac->ops.prot_autoc_write = prot_autoc_write_generic;
+
+	/* LEDs */
+	mac->ops.led_on = ixgbe_led_on_generic;
+	mac->ops.led_off = ixgbe_led_off_generic;
+	mac->ops.blink_led_start = ixgbe_blink_led_start_generic;
+	mac->ops.blink_led_stop = ixgbe_blink_led_stop_generic;
+	mac->ops.init_led_link_act = ixgbe_init_led_link_act_generic;
+
+	/* RAR, Multicast, VLAN */
+	mac->ops.set_rar = ixgbe_set_rar_generic;
+	mac->ops.clear_rar = ixgbe_clear_rar_generic;
+	mac->ops.insert_mac_addr = NULL;
+	mac->ops.set_vmdq = NULL;
+	mac->ops.clear_vmdq = NULL;
+	mac->ops.init_rx_addrs = ixgbe_init_rx_addrs_generic;
+	mac->ops.update_uc_addr_list = ixgbe_update_uc_addr_list_generic;
+	mac->ops.update_mc_addr_list = ixgbe_update_mc_addr_list_generic;
+	mac->ops.enable_mc = ixgbe_enable_mc_generic;
+	mac->ops.disable_mc = ixgbe_disable_mc_generic;
+	mac->ops.clear_vfta = NULL;
+	mac->ops.set_vfta = NULL;
+	mac->ops.set_vlvf = NULL;
+	mac->ops.init_uta_tables = NULL;
+	mac->ops.enable_rx = ixgbe_enable_rx_generic;
+	mac->ops.disable_rx = ixgbe_disable_rx_generic;
+	mac->ops.toggle_txdctl = ixgbe_toggle_txdctl_generic;
+
+	/* Flow Control */
+	mac->ops.fc_enable = ixgbe_fc_enable_generic;
+	mac->ops.setup_fc = ixgbe_setup_fc_generic;
+	mac->ops.fc_autoneg = ixgbe_fc_autoneg;
+
+	/* Link */
+	mac->ops.get_link_capabilities = NULL;
+	mac->ops.setup_link = NULL;
+	mac->ops.check_link = NULL;
+	mac->ops.dmac_config = NULL;
+	mac->ops.dmac_update_tcs = NULL;
+	mac->ops.dmac_config_tcs = NULL;
+
+	return IXGBE_SUCCESS;
+}
 
 /**
- *  ixgbe_device_supports_autoneg_fc - Check if phy supports autoneg flow
- *  control
- *  @hw: pointer to hardware structure
+ * ixgbe_device_supports_autoneg_fc - Check if device supports autonegotiation
+ * of flow control
+ * @hw: pointer to hardware structure
+ *
+ * This function returns true if the device supports flow control
+ * autonegotiation, and false if it does not.
  *
- *  There are several phys that do not support autoneg flow control. This
- *  function check the device id to see if the associated phy supports
- *  autoneg flow control.
  **/
 bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
 {
@@ -52,19 +135,25 @@ bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
 	ixgbe_link_speed speed;
 	bool link_up;
 
+	DEBUGFUNC("ixgbe_device_supports_autoneg_fc");
+
 	switch (hw->phy.media_type) {
+	case ixgbe_media_type_fiber_qsfp:
 	case ixgbe_media_type_fiber:
 		/* flow control autoneg black list */
 		switch (hw->device_id) {
 		case IXGBE_DEV_ID_X550EM_A_SFP:
 		case IXGBE_DEV_ID_X550EM_A_SFP_N:
+		case IXGBE_DEV_ID_X550EM_A_QSFP:
+		case IXGBE_DEV_ID_X550EM_A_QSFP_N:
 			supported = false;
 			break;
 		default:
 			hw->mac.ops.check_link(hw, &speed, &link_up, false);
 			/* if link is down, assume supported */
 			if (link_up)
-				supported = speed == IXGBE_LINK_SPEED_1GB_FULL;
+				supported = speed == IXGBE_LINK_SPEED_1GB_FULL ?
+				true : false;
 			else
 				supported = true;
 		}
@@ -91,39 +180,36 @@ bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
 			supported = true;
 			break;
 		default:
-			break;
+			supported = false;
 		}
 	default:
 		break;
 	}
 
-	if (!supported)
-		hw_dbg(hw, "Device %x does not support flow control autoneg\n",
-		       hw->device_id);
-
 	return supported;
 }
 
 /**
- *  ixgbe_setup_fc_generic - Set up flow control
- *  @hw: pointer to hardware structure
+ * ixgbe_setup_fc_generic - Set up flow control
+ * @hw: pointer to hardware structure
  *
- *  Called at init time to set up flow control.
+ * Called at init time to set up flow control.
  **/
 s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
 {
-	s32 ret_val = 0;
+	s32 ret_val = IXGBE_SUCCESS;
 	u32 reg = 0, reg_bp = 0;
 	u16 reg_cu = 0;
 	bool locked = false;
 
-	/*
-	 * Validate the requested mode.  Strict IEEE mode does not allow
-	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH.
-	 */
+	DEBUGFUNC("ixgbe_setup_fc_generic");
+
+	/* Validate the requested mode */
 	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
-		hw_dbg(hw, "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			   "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
+		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+		goto out;
 	}
 
 	/*
@@ -142,17 +228,18 @@ s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
 	case ixgbe_media_type_backplane:
 		/* some MAC's need RMW protection on AUTOC */
 		ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &reg_bp);
-		if (ret_val)
-			return ret_val;
+		if (ret_val != IXGBE_SUCCESS)
+			goto out;
 
-		fallthrough; /* only backplane uses autoc */
+		/* fall through - only backplane uses autoc */
+	case ixgbe_media_type_fiber_qsfp:
 	case ixgbe_media_type_fiber:
 		reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
 
 		break;
 	case ixgbe_media_type_copper:
-		hw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,
-					MDIO_MMD_AN, &reg_cu);
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
+				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg_cu);
 		break;
 	default:
 		break;
@@ -213,11 +300,14 @@ s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
 			reg_cu |= IXGBE_TAF_SYM_PAUSE | IXGBE_TAF_ASM_PAUSE;
 		break;
 	default:
-		hw_dbg(hw, "Flow control param set incorrectly\n");
-		return IXGBE_ERR_CONFIG;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
+			     "Flow control param set incorrectly\n");
+		ret_val = IXGBE_ERR_CONFIG;
+		goto out;
+		break;
 	}
 
-	if (hw->mac.type != ixgbe_mac_X540) {
+	if (hw->mac.type < ixgbe_mac_X540) {
 		/*
 		 * Enable auto-negotiation between the MAC & PHY;
 		 * the MAC will advertise clause 37 flow control.
@@ -239,32 +329,29 @@ s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw)
 	 *
 	 */
 	if (hw->phy.media_type == ixgbe_media_type_backplane) {
-		/* Need the SW/FW semaphore around AUTOC writes if 82599 and
-		 * LESM is on, likewise reset_pipeline requries the lock as
-		 * it also writes AUTOC.
-		 */
+		reg_bp |= IXGBE_AUTOC_AN_RESTART;
 		ret_val = hw->mac.ops.prot_autoc_write(hw, reg_bp, locked);
 		if (ret_val)
-			return ret_val;
-
+			goto out;
 	} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&
-		   ixgbe_device_supports_autoneg_fc(hw)) {
-		hw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,
-				      MDIO_MMD_AN, reg_cu);
+		    (ixgbe_device_supports_autoneg_fc(hw))) {
+		hw->phy.ops.write_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, reg_cu);
 	}
 
-	hw_dbg(hw, "Set up FC; IXGBE_AUTOC = 0x%08X\n", reg);
+	hw_dbg(hw, "Set up FC; PCS1GLCTL = 0x%08X\n", reg);
+out:
 	return ret_val;
 }
 
 /**
- *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx
- *  @hw: pointer to hardware structure
+ * ixgbe_start_hw_generic - Prepare hardware for Tx/Rx
+ * @hw: pointer to hardware structure
  *
- *  Starts the hardware by filling the bus info structure and media type, clears
- *  all on chip counters, initializes receive address registers, multicast
- *  table, VLAN filter table, calls routine to set up link and flow control
- *  settings, and leaves transmit and receive units disabled and uninitialized
+ * Starts the hardware by filling the bus info structure and media type, clears
+ * all on chip counters, initializes receive address registers, multicast
+ * table, VLAN filter table, calls routine to set up link and flow control
+ * settings, and leaves transmit and receive units disabled and uninitialized
  **/
 s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
 {
@@ -272,11 +359,12 @@ s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
 	u32 ctrl_ext;
 	u16 device_caps;
 
+	DEBUGFUNC("ixgbe_start_hw_generic");
+
 	/* Set the media type */
 	hw->phy.media_type = hw->mac.ops.get_media_type(hw);
 
-	/* Identify the PHY */
-	hw->phy.ops.identify(hw);
+	/* PHY ops initialization must be done in reset_hw() */
 
 	/* Clear the VLAN filter table */
 	hw->mac.ops.clear_vfta(hw);
@@ -290,18 +378,18 @@ s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
 	IXGBE_WRITE_REG(hw, IXGBE_CTRL_EXT, ctrl_ext);
 	IXGBE_WRITE_FLUSH(hw);
 
-	/* Setup flow control if method for doing so */
-	if (hw->mac.ops.setup_fc) {
-		ret_val = hw->mac.ops.setup_fc(hw);
-		if (ret_val)
-			return ret_val;
+	/* Setup flow control */
+	ret_val = ixgbe_setup_fc(hw);
+	if (ret_val != IXGBE_SUCCESS && ret_val != IXGBE_NOT_IMPLEMENTED) {
+		hw_dbg(hw, "Flow control setup failed, returning %d\n", ret_val);
+		return ret_val;
 	}
 
-	/* Cashe bit indicating need for crosstalk fix */
+	/* Cache bit indicating need for crosstalk fix */
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		hw->mac.ops.get_device_caps(hw, &device_caps);
 		if (device_caps & IXGBE_DEVICE_CAPS_NO_CROSSTALK_WR)
 			hw->need_crosstalk_fix = false;
@@ -316,22 +404,23 @@ s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
 	/* Clear adapter stopped flag */
 	hw->adapter_stopped = false;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_start_hw_gen2 - Init sequence for common device family
- *  @hw: pointer to hw structure
+ * ixgbe_start_hw_gen2 - Init sequence for common device family
+ * @hw: pointer to hw structure
  *
  * Performs the init sequence common to the second generation
  * of 10 GbE devices.
  * Devices in the second generation:
- *     82599
- *     X540
+ *    82599
+ *    X540
  **/
-s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
+void ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
 {
 	u32 i;
+	u32 regval;
 
 	/* Clear the rate limiters */
 	for (i = 0; i < hw->mac.max_tx_queues; i++) {
@@ -340,27 +429,41 @@ s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
 	}
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	/* Disable relaxed ordering */
+	for (i = 0; i < hw->mac.max_tx_queues; i++) {
+		regval = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL_82599(i));
+		regval &= ~IXGBE_DCA_TXCTRL_DESC_WRO_EN;
+		IXGBE_WRITE_REG(hw, IXGBE_DCA_TXCTRL_82599(i), regval);
+	}
+
+	for (i = 0; i < hw->mac.max_rx_queues; i++) {
+		regval = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
+		regval &= ~(IXGBE_DCA_RXCTRL_DATA_WRO_EN |
+			    IXGBE_DCA_RXCTRL_HEAD_WRO_EN);
+		IXGBE_WRITE_REG(hw, IXGBE_DCA_RXCTRL(i), regval);
+	}
 }
 
 /**
- *  ixgbe_init_hw_generic - Generic hardware initialization
- *  @hw: pointer to hardware structure
+ * ixgbe_init_hw_generic - Generic hardware initialization
+ * @hw: pointer to hardware structure
  *
- *  Initialize the hardware by resetting the hardware, filling the bus info
- *  structure and media type, clears all on chip counters, initializes receive
- *  address registers, multicast table, VLAN filter table, calls routine to set
- *  up link and flow control settings, and leaves transmit and receive units
- *  disabled and uninitialized
+ * Initialize the hardware by resetting the hardware, filling the bus info
+ * structure and media type, clears all on chip counters, initializes receive
+ * address registers, multicast table, VLAN filter table, calls routine to set
+ * up link and flow control settings, and leaves transmit and receive units
+ * disabled and uninitialized
  **/
 s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)
 {
 	s32 status;
 
+	DEBUGFUNC("ixgbe_init_hw_generic");
+
 	/* Reset the hardware */
 	status = hw->mac.ops.reset_hw(hw);
 
-	if (status == 0) {
+	if (status == IXGBE_SUCCESS || status == IXGBE_ERR_SFP_NOT_PRESENT) {
 		/* Start the HW */
 		status = hw->mac.ops.start_hw(hw);
 	}
@@ -369,20 +472,25 @@ s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)
 	if (hw->mac.ops.init_led_link_act)
 		hw->mac.ops.init_led_link_act(hw);
 
+	if (status != IXGBE_SUCCESS)
+		hw_dbg(hw, "Failed to initialize HW, STATUS = %d\n", status);
+
 	return status;
 }
 
 /**
- *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters
- *  @hw: pointer to hardware structure
+ * ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters
+ * @hw: pointer to hardware structure
  *
- *  Clears all hardware statistics counters by reading them from the hardware
- *  Statistics counters are clear on read.
+ * Clears all hardware statistics counters by reading them from the hardware
+ * Statistics counters are clear on read.
  **/
 s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
 {
 	u16 i = 0;
 
+	DEBUGFUNC("ixgbe_clear_hw_cntrs_generic");
+
 	IXGBE_READ_REG(hw, IXGBE_CRCERRS);
 	IXGBE_READ_REG(hw, IXGBE_ILLERRC);
 	IXGBE_READ_REG(hw, IXGBE_ERRBC);
@@ -470,23 +578,27 @@ s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
 
 	if (hw->mac.type == ixgbe_mac_X550 || hw->mac.type == ixgbe_mac_X540) {
 		if (hw->phy.id == 0)
-			hw->phy.ops.identify(hw);
-		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECL, MDIO_MMD_PCS, &i);
-		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECH, MDIO_MMD_PCS, &i);
-		hw->phy.ops.read_reg(hw, IXGBE_LDPCECL, MDIO_MMD_PCS, &i);
-		hw->phy.ops.read_reg(hw, IXGBE_LDPCECH, MDIO_MMD_PCS, &i);
+			ixgbe_identify_phy(hw);
+		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECL,
+				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
+		hw->phy.ops.read_reg(hw, IXGBE_PCRC8ECH,
+				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
+		hw->phy.ops.read_reg(hw, IXGBE_LDPCECL,
+				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
+		hw->phy.ops.read_reg(hw, IXGBE_LDPCECH,
+				     IXGBE_MDIO_PCS_DEV_TYPE, &i);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_pba_string_generic - Reads part number string from EEPROM
- *  @hw: pointer to hardware structure
- *  @pba_num: stores the part number string from the EEPROM
- *  @pba_num_size: part number string buffer length
+ * ixgbe_read_pba_string_generic - Reads part number string from EEPROM
+ * @hw: pointer to hardware structure
+ * @pba_num: stores the part number string from the EEPROM
+ * @pba_num_size: part number string buffer length
  *
- *  Reads the part number string from the EEPROM.
+ * Reads the part number string from the EEPROM.
  **/
 s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
 				  u32 pba_num_size)
@@ -497,6 +609,8 @@ s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
 	u16 offset;
 	u16 length;
 
+	DEBUGFUNC("ixgbe_read_pba_string_generic");
+
 	if (pba_num == NULL) {
 		hw_dbg(hw, "PBA string buffer was null\n");
 		return IXGBE_ERR_INVALID_ARGUMENT;
@@ -551,7 +665,7 @@ s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
 				pba_num[offset] += 'A' - 0xA;
 		}
 
-		return 0;
+		return IXGBE_SUCCESS;
 	}
 
 	ret_val = hw->eeprom.ops.read(hw, pba_ptr, &length);
@@ -586,17 +700,17 @@ s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
 	}
 	pba_num[offset * 2] = '\0';
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_get_mac_addr_generic - Generic get MAC address
- *  @hw: pointer to hardware structure
- *  @mac_addr: Adapter MAC address
+ * ixgbe_get_mac_addr_generic - Generic get MAC address
+ * @hw: pointer to hardware structure
+ * @mac_addr: Adapter MAC address
  *
- *  Reads the adapter's MAC address from first Receive Address Register (RAR0)
- *  A reset of the adapter must be performed prior to calling this function
- *  in order for the MAC address to have been loaded from the EEPROM into RAR0
+ * Reads the adapter's MAC address from first Receive Address Register (RAR0)
+ * A reset of the adapter must be performed prior to calling this function
+ * in order for the MAC address to have been loaded from the EEPROM into RAR0
  **/
 s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
 {
@@ -604,6 +718,8 @@ s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
 	u32 rar_low;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_get_mac_addr_generic");
+
 	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(0));
 	rar_low = IXGBE_READ_REG(hw, IXGBE_RAL(0));
 
@@ -613,81 +729,102 @@ s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
 	for (i = 0; i < 2; i++)
 		mac_addr[i+4] = (u8)(rar_high >> (i*8));
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
-enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status)
+/**
+ * ixgbe_set_pci_config_data_generic - Generic store PCI bus info
+ * @hw: pointer to hardware structure
+ * @link_status: the link status returned by the PCI config space
+ *
+ * Stores the PCI bus info (speed, width, type) within the ixgbe_hw structure
+ **/
+void ixgbe_set_pci_config_data_generic(struct ixgbe_hw *hw, u16 link_status)
 {
+	struct ixgbe_mac_info *mac = &hw->mac;
+
+	if (hw->bus.type == ixgbe_bus_type_unknown)
+		hw->bus.type = ixgbe_bus_type_pci_express;
+
 	switch (link_status & IXGBE_PCI_LINK_WIDTH) {
 	case IXGBE_PCI_LINK_WIDTH_1:
-		return ixgbe_bus_width_pcie_x1;
+		hw->bus.width = ixgbe_bus_width_pcie_x1;
+		break;
 	case IXGBE_PCI_LINK_WIDTH_2:
-		return ixgbe_bus_width_pcie_x2;
+		hw->bus.width = ixgbe_bus_width_pcie_x2;
+		break;
 	case IXGBE_PCI_LINK_WIDTH_4:
-		return ixgbe_bus_width_pcie_x4;
+		hw->bus.width = ixgbe_bus_width_pcie_x4;
+		break;
 	case IXGBE_PCI_LINK_WIDTH_8:
-		return ixgbe_bus_width_pcie_x8;
+		hw->bus.width = ixgbe_bus_width_pcie_x8;
+		break;
 	default:
-		return ixgbe_bus_width_unknown;
+		hw->bus.width = ixgbe_bus_width_unknown;
+		break;
 	}
-}
 
-enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status)
-{
 	switch (link_status & IXGBE_PCI_LINK_SPEED) {
 	case IXGBE_PCI_LINK_SPEED_2500:
-		return ixgbe_bus_speed_2500;
+		hw->bus.speed = ixgbe_bus_speed_2500;
+		break;
 	case IXGBE_PCI_LINK_SPEED_5000:
-		return ixgbe_bus_speed_5000;
+		hw->bus.speed = ixgbe_bus_speed_5000;
+		break;
 	case IXGBE_PCI_LINK_SPEED_8000:
-		return ixgbe_bus_speed_8000;
+		hw->bus.speed = ixgbe_bus_speed_8000;
+		break;
 	default:
-		return ixgbe_bus_speed_unknown;
+		hw->bus.speed = ixgbe_bus_speed_unknown;
+		break;
 	}
+
+	mac->ops.set_lan_id(hw);
 }
 
 /**
- *  ixgbe_get_bus_info_generic - Generic set PCI bus info
- *  @hw: pointer to hardware structure
+ * ixgbe_get_bus_info_generic - Generic set PCI bus info
+ * @hw: pointer to hardware structure
  *
- *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
+ * Gets the PCI bus info (speed, width, type) then calls helper function to
+ * store this data within the ixgbe_hw structure.
  **/
 s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
 {
 	u16 link_status;
 
-	hw->bus.type = ixgbe_bus_type_pci_express;
+	DEBUGFUNC("ixgbe_get_bus_info_generic");
 
 	/* Get the negotiated link width and speed from PCI config space */
-	link_status = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_LINK_STATUS);
+	link_status = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_LINK_STATUS);
 
-	hw->bus.width = ixgbe_convert_bus_width(link_status);
-	hw->bus.speed = ixgbe_convert_bus_speed(link_status);
+	ixgbe_set_pci_config_data_generic(hw, link_status);
 
-	hw->mac.ops.set_lan_id(hw);
-
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices
- *  @hw: pointer to the HW structure
+ * ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices
+ * @hw: pointer to the HW structure
  *
- *  Determines the LAN function id by reading memory-mapped registers
- *  and swaps the port value if requested.
+ * Determines the LAN function id by reading memory-mapped registers and swaps
+ * the port value if requested, and set MAC instance for devices that share
+ * CS4227.
  **/
 void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)
 {
 	struct ixgbe_bus_info *bus = &hw->bus;
-	u16 ee_ctrl_4;
 	u32 reg;
+	u16 ee_ctrl_4;
+
+	DEBUGFUNC("ixgbe_set_lan_id_multi_port_pcie");
 
 	reg = IXGBE_READ_REG(hw, IXGBE_STATUS);
 	bus->func = (reg & IXGBE_STATUS_LAN_ID) >> IXGBE_STATUS_LAN_ID_SHIFT;
-	bus->lan_id = bus->func;
+	bus->lan_id = (u8)bus->func;
 
 	/* check for a port swap */
-	reg = IXGBE_READ_REG(hw, IXGBE_FACTPS(hw));
+	reg = IXGBE_READ_REG(hw, IXGBE_FACTPS_BY_MAC(hw));
 	if (reg & IXGBE_FACTPS_LFS)
 		bus->func ^= 0x1;
 
@@ -700,19 +837,21 @@ void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units
- *  @hw: pointer to hardware structure
+ * ixgbe_stop_adapter_generic - Generic stop Tx/Rx units
+ * @hw: pointer to hardware structure
  *
- *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
- *  disables transmit and receive units. The adapter_stopped flag is used by
- *  the shared code and drivers to determine if the adapter is in a stopped
- *  state and should not touch the hardware.
+ * Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
+ * disables transmit and receive units. The adapter_stopped flag is used by
+ * the shared code and drivers to determine if the adapter is in a stopped
+ * state and should not touch the hardware.
  **/
 s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
 {
 	u32 reg_val;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_stop_adapter_generic");
+
 	/*
 	 * Set the adapter_stopped flag so other driver functions stop touching
 	 * the hardware
@@ -720,7 +859,7 @@ s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
 	hw->adapter_stopped = true;
 
 	/* Disable the receive unit */
-	hw->mac.ops.disable_rx(hw);
+	ixgbe_disable_rx(hw);
 
 	/* Clear interrupt mask to stop interrupts from being generated */
 	IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_IRQ_CLEAR_MASK);
@@ -742,27 +881,27 @@ s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
 
 	/* flush all queues disables */
 	IXGBE_WRITE_FLUSH(hw);
-	usleep_range(1000, 2000);
+	msec_delay(2);
 
 	/*
-	 * Prevent the PCI-E bus from from hanging by disabling PCI-E master
+	 * Prevent the PCI-E bus from hanging by disabling PCI-E master
 	 * access and verify no pending requests
 	 */
 	return ixgbe_disable_pcie_master(hw);
 }
 
 /**
- *  ixgbe_init_led_link_act_generic - Store the LED index link/activity.
- *  @hw: pointer to hardware structure
+ * ixgbe_init_led_link_act_generic - Store the LED index link/activity.
+ * @hw: pointer to hardware structure
  *
- *  Store the index for the link active LED. This will be used to support
- *  blinking the LED.
+ * Store the index for the link active LED. This will be used to support
+ * blinking the LED.
  **/
 s32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 	u32 led_reg, led_mode;
-	u16 i;
+	u8 i;
 
 	led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
 
@@ -771,38 +910,38 @@ s32 ixgbe_init_led_link_act_generic(struct ixgbe_hw *hw)
 		led_mode = led_reg >> IXGBE_LED_MODE_SHIFT(i);
 
 		if ((led_mode & IXGBE_LED_MODE_MASK_BASE) ==
-		    IXGBE_LED_LINK_ACTIVE) {
+		     IXGBE_LED_LINK_ACTIVE) {
 			mac->led_link_act = i;
-			return 0;
+			return IXGBE_SUCCESS;
 		}
 	}
 
-	/* If LEDCTL register does not have the LED link active set, then use
+	/*
+	 * If LEDCTL register does not have the LED link active set, then use
 	 * known MAC defaults.
 	 */
 	switch (hw->mac.type) {
-	case ixgbe_mac_x550em_a:
-		mac->led_link_act = 0;
-		break;
+	case ixgbe_mac_X550EM_a:
 	case ixgbe_mac_X550EM_x:
 		mac->led_link_act = 1;
 		break;
 	default:
 		mac->led_link_act = 2;
 	}
-
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_led_on_generic - Turns on the software controllable LEDs.
- *  @hw: pointer to hardware structure
- *  @index: led number to turn on
+ * ixgbe_led_on_generic - Turns on the software controllable LEDs.
+ * @hw: pointer to hardware structure
+ * @index: led number to turn on
  **/
 s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)
 {
 	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
 
+	DEBUGFUNC("ixgbe_led_on_generic");
+
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
 
@@ -812,18 +951,20 @@ s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_led_off_generic - Turns off the software controllable LEDs.
- *  @hw: pointer to hardware structure
- *  @index: led number to turn off
+ * ixgbe_led_off_generic - Turns off the software controllable LEDs.
+ * @hw: pointer to hardware structure
+ * @index: led number to turn off
  **/
 s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)
 {
 	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
 
+	DEBUGFUNC("ixgbe_led_off_generic");
+
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
 
@@ -833,15 +974,15 @@ s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params
- *  @hw: pointer to hardware structure
+ * ixgbe_init_eeprom_params_generic - Initialize EEPROM params
+ * @hw: pointer to hardware structure
  *
- *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
- *  ixgbe_hw struct in order to set up EEPROM access.
+ * Initializes the EEPROM parameters ixgbe_eeprom_info within the
+ * ixgbe_hw struct in order to set up EEPROM access.
  **/
 s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
 {
@@ -849,6 +990,8 @@ s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
 	u32 eec;
 	u16 eeprom_size;
 
+	DEBUGFUNC("ixgbe_init_eeprom_params_generic");
+
 	if (eeprom->type == ixgbe_eeprom_uninitialized) {
 		eeprom->type = ixgbe_eeprom_none;
 		/* Set default semaphore delay to 10ms which is a well
@@ -861,7 +1004,7 @@ s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
 		 * Check for EEPROM present first.
 		 * If not present leave as none
 		 */
-		eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+		eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 		if (eec & IXGBE_EEC_PRES) {
 			eeprom->type = ixgbe_eeprom_spi;
 
@@ -871,43 +1014,50 @@ s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
 			 */
 			eeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>
 					    IXGBE_EEC_SIZE_SHIFT);
-			eeprom->word_size = BIT(eeprom_size +
-						 IXGBE_EEPROM_WORD_SIZE_SHIFT);
+			eeprom->word_size = 1 << (eeprom_size +
+					     IXGBE_EEPROM_WORD_SIZE_SHIFT);
 		}
 
 		if (eec & IXGBE_EEC_ADDR_SIZE)
 			eeprom->address_bits = 16;
 		else
 			eeprom->address_bits = 8;
-		hw_dbg(hw, "Eeprom params: type = %d, size = %d, address bits: %d\n",
-		       eeprom->type, eeprom->word_size, eeprom->address_bits);
+		hw_dbg(hw, "Eeprom params: type = %d, size = %d, address bits: "
+			  "%d\n", eeprom->type, eeprom->word_size,
+			  eeprom->address_bits);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_write_eeprom_buffer_bit_bang_generic - Write EEPROM using bit-bang
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to write
- *  @words: number of words
- *  @data: 16 bit word(s) to write to EEPROM
+ * ixgbe_write_eeprom_buffer_bit_bang_generic - Write EEPROM using bit-bang
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to write
+ * @words: number of word(s)
+ * @data: 16 bit word(s) to write to EEPROM
  *
- *  Reads 16 bit word(s) from EEPROM through bit-bang method
+ * Reads 16 bit word(s) from EEPROM through bit-bang method
  **/
 s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
 					       u16 words, u16 *data)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u16 i, count;
 
+	DEBUGFUNC("ixgbe_write_eeprom_buffer_bit_bang_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (words == 0)
-		return IXGBE_ERR_INVALID_ARGUMENT;
+	if (words == 0) {
+		status = IXGBE_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
 
-	if (offset + words > hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset + words > hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		goto out;
+	}
 
 	/*
 	 * The EEPROM page size cannot be queried from the chip. We do lazy
@@ -924,28 +1074,29 @@ s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
 	 */
 	for (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {
 		count = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?
-			 IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);
+			IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);
 		status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset + i,
 							    count, &data[i]);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			break;
 	}
 
+out:
 	return status;
 }
 
 /**
- *  ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be written to
- *  @words: number of word(s)
- *  @data: 16 bit word(s) to be written to the EEPROM
+ * ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be written to
+ * @words: number of word(s)
+ * @data: 16 bit word(s) to be written to the EEPROM
  *
- *  If ixgbe_eeprom_update_checksum is not called after this function, the
- *  EEPROM will most likely contain an invalid checksum.
+ * If ixgbe_eeprom_update_checksum is not called after this function, the
+ * EEPROM will most likely contain an invalid checksum.
  **/
-static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
+STATIC s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
 					      u16 words, u16 *data)
 {
 	s32 status;
@@ -954,106 +1105,126 @@ static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
 	u16 i;
 	u8 write_opcode = IXGBE_EEPROM_WRITE_OPCODE_SPI;
 
+	DEBUGFUNC("ixgbe_write_eeprom_buffer_bit_bang");
+
 	/* Prepare the EEPROM for writing  */
 	status = ixgbe_acquire_eeprom(hw);
-	if (status)
-		return status;
 
-	if (ixgbe_ready_eeprom(hw) != 0) {
-		ixgbe_release_eeprom(hw);
-		return IXGBE_ERR_EEPROM;
+	if (status == IXGBE_SUCCESS) {
+		if (ixgbe_ready_eeprom(hw) != IXGBE_SUCCESS) {
+			ixgbe_release_eeprom(hw);
+			status = IXGBE_ERR_EEPROM;
+		}
 	}
 
-	for (i = 0; i < words; i++) {
-		ixgbe_standby_eeprom(hw);
-
-		/* Send the WRITE ENABLE command (8 bit opcode) */
-		ixgbe_shift_out_eeprom_bits(hw,
-					    IXGBE_EEPROM_WREN_OPCODE_SPI,
-					    IXGBE_EEPROM_OPCODE_BITS);
-
-		ixgbe_standby_eeprom(hw);
-
-		/* Some SPI eeproms use the 8th address bit embedded
-		 * in the opcode
-		 */
-		if ((hw->eeprom.address_bits == 8) &&
-		    ((offset + i) >= 128))
-			write_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;
-
-		/* Send the Write command (8-bit opcode + addr) */
-		ixgbe_shift_out_eeprom_bits(hw, write_opcode,
-					    IXGBE_EEPROM_OPCODE_BITS);
-		ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
-					    hw->eeprom.address_bits);
-
-		page_size = hw->eeprom.word_page_size;
-
-		/* Send the data in burst via SPI */
-		do {
-			word = data[i];
-			word = (word >> 8) | (word << 8);
-			ixgbe_shift_out_eeprom_bits(hw, word, 16);
+	if (status == IXGBE_SUCCESS) {
+		for (i = 0; i < words; i++) {
+			ixgbe_standby_eeprom(hw);
 
-			if (page_size == 0)
-				break;
+			/*  Send the WRITE ENABLE command (8 bit opcode )  */
+			ixgbe_shift_out_eeprom_bits(hw,
+						   IXGBE_EEPROM_WREN_OPCODE_SPI,
+						   IXGBE_EEPROM_OPCODE_BITS);
 
-			/* do not wrap around page */
-			if (((offset + i) & (page_size - 1)) ==
-			    (page_size - 1))
-				break;
-		} while (++i < words);
+			ixgbe_standby_eeprom(hw);
 
-		ixgbe_standby_eeprom(hw);
-		usleep_range(10000, 20000);
+			/*
+			 * Some SPI eeproms use the 8th address bit embedded
+			 * in the opcode
+			 */
+			if ((hw->eeprom.address_bits == 8) &&
+			    ((offset + i) >= 128))
+				write_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;
+
+			/* Send the Write command (8-bit opcode + addr) */
+			ixgbe_shift_out_eeprom_bits(hw, write_opcode,
+						    IXGBE_EEPROM_OPCODE_BITS);
+			ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
+						    hw->eeprom.address_bits);
+
+			page_size = hw->eeprom.word_page_size;
+
+			/* Send the data in burst via SPI*/
+			do {
+				word = data[i];
+				word = (word >> 8) | (word << 8);
+				ixgbe_shift_out_eeprom_bits(hw, word, 16);
+
+				if (page_size == 0)
+					break;
+
+				/* do not wrap around page */
+				if (((offset + i) & (page_size - 1)) ==
+				    (page_size - 1))
+					break;
+			} while (++i < words);
+
+			ixgbe_standby_eeprom(hw);
+			msec_delay(10);
+		}
+		/* Done with writing - release the EEPROM */
+		ixgbe_release_eeprom(hw);
 	}
-	/* Done with writing - release the EEPROM */
-	ixgbe_release_eeprom(hw);
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be written to
- *  @data: 16 bit word to be written to the EEPROM
+ * ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be written to
+ * @data: 16 bit word to be written to the EEPROM
  *
- *  If ixgbe_eeprom_update_checksum is not called after this function, the
- *  EEPROM will most likely contain an invalid checksum.
+ * If ixgbe_eeprom_update_checksum is not called after this function, the
+ * EEPROM will most likely contain an invalid checksum.
  **/
 s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
 {
+	s32 status;
+
+	DEBUGFUNC("ixgbe_write_eeprom_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (offset >= hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset >= hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		goto out;
+	}
+
+	status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);
 
-	return ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);
+out:
+	return status;
 }
 
 /**
- *  ixgbe_read_eeprom_buffer_bit_bang_generic - Read EEPROM using bit-bang
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be read
- *  @words: number of word(s)
- *  @data: read 16 bit words(s) from EEPROM
+ * ixgbe_read_eeprom_buffer_bit_bang_generic - Read EEPROM using bit-bang
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be read
+ * @data: read 16 bit words(s) from EEPROM
+ * @words: number of word(s)
  *
- *  Reads 16 bit word(s) from EEPROM through bit-bang method
+ * Reads 16 bit word(s) from EEPROM through bit-bang method
  **/
 s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
 					      u16 words, u16 *data)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u16 i, count;
 
+	DEBUGFUNC("ixgbe_read_eeprom_buffer_bit_bang_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (words == 0)
-		return IXGBE_ERR_INVALID_ARGUMENT;
+	if (words == 0) {
+		status = IXGBE_ERR_INVALID_ARGUMENT;
+		goto out;
+	}
 
-	if (offset + words > hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset + words > hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		goto out;
+	}
 
 	/*
 	 * We cannot hold synchronization semaphores for too long
@@ -1062,28 +1233,29 @@ s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
 	 */
 	for (i = 0; i < words; i += IXGBE_EEPROM_RD_BUFFER_MAX_COUNT) {
 		count = (words - i) / IXGBE_EEPROM_RD_BUFFER_MAX_COUNT > 0 ?
-			 IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);
+			IXGBE_EEPROM_RD_BUFFER_MAX_COUNT : (words - i);
 
 		status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset + i,
 							   count, &data[i]);
 
-		if (status)
-			return status;
+		if (status != IXGBE_SUCCESS)
+			break;
 	}
 
-	return 0;
+out:
+	return status;
 }
 
 /**
- *  ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be read
- *  @words: number of word(s)
- *  @data: read 16 bit word(s) from EEPROM
+ * ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be read
+ * @words: number of word(s)
+ * @data: read 16 bit word(s) from EEPROM
  *
- *  Reads 16 bit word(s) from EEPROM through bit-bang method
+ * Reads 16 bit word(s) from EEPROM through bit-bang method
  **/
-static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
+STATIC s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
 					     u16 words, u16 *data)
 {
 	s32 status;
@@ -1091,84 +1263,106 @@ static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
 	u8 read_opcode = IXGBE_EEPROM_READ_OPCODE_SPI;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_read_eeprom_buffer_bit_bang");
+
 	/* Prepare the EEPROM for reading  */
 	status = ixgbe_acquire_eeprom(hw);
-	if (status)
-		return status;
 
-	if (ixgbe_ready_eeprom(hw) != 0) {
-		ixgbe_release_eeprom(hw);
-		return IXGBE_ERR_EEPROM;
+	if (status == IXGBE_SUCCESS) {
+		if (ixgbe_ready_eeprom(hw) != IXGBE_SUCCESS) {
+			ixgbe_release_eeprom(hw);
+			status = IXGBE_ERR_EEPROM;
+		}
 	}
 
-	for (i = 0; i < words; i++) {
-		ixgbe_standby_eeprom(hw);
-		/* Some SPI eeproms use the 8th address bit embedded
-		 * in the opcode
-		 */
-		if ((hw->eeprom.address_bits == 8) &&
-		    ((offset + i) >= 128))
-			read_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;
-
-		/* Send the READ command (opcode + addr) */
-		ixgbe_shift_out_eeprom_bits(hw, read_opcode,
-					    IXGBE_EEPROM_OPCODE_BITS);
-		ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
-					    hw->eeprom.address_bits);
+	if (status == IXGBE_SUCCESS) {
+		for (i = 0; i < words; i++) {
+			ixgbe_standby_eeprom(hw);
+			/*
+			 * Some SPI eeproms use the 8th address bit embedded
+			 * in the opcode
+			 */
+			if ((hw->eeprom.address_bits == 8) &&
+			    ((offset + i) >= 128))
+				read_opcode |= IXGBE_EEPROM_A8_OPCODE_SPI;
+
+			/* Send the READ command (opcode + addr) */
+			ixgbe_shift_out_eeprom_bits(hw, read_opcode,
+						    IXGBE_EEPROM_OPCODE_BITS);
+			ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
+						    hw->eeprom.address_bits);
+
+			/* Read the data. */
+			word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
+			data[i] = (word_in >> 8) | (word_in << 8);
+		}
 
-		/* Read the data. */
-		word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
-		data[i] = (word_in >> 8) | (word_in << 8);
+		/* End this read operation */
+		ixgbe_release_eeprom(hw);
 	}
 
-	/* End this read operation */
-	ixgbe_release_eeprom(hw);
-
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be read
- *  @data: read 16 bit value from EEPROM
+ * ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be read
+ * @data: read 16 bit value from EEPROM
  *
- *  Reads 16 bit value from EEPROM through bit-bang method
+ * Reads 16 bit value from EEPROM through bit-bang method
  **/
 s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
 				       u16 *data)
 {
+	s32 status;
+
+	DEBUGFUNC("ixgbe_read_eeprom_bit_bang_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (offset >= hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset >= hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		goto out;
+	}
+
+	status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);
 
-	return ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);
+out:
+	return status;
 }
 
 /**
- *  ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD
- *  @hw: pointer to hardware structure
- *  @offset: offset of word in the EEPROM to read
- *  @words: number of word(s)
- *  @data: 16 bit word(s) from the EEPROM
+ * ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD
+ * @hw: pointer to hardware structure
+ * @offset: offset of word in the EEPROM to read
+ * @words: number of word(s)
+ * @data: 16 bit word(s) from the EEPROM
  *
- *  Reads a 16 bit word(s) from the EEPROM using the EERD register.
+ * Reads a 16 bit word(s) from the EEPROM using the EERD register.
  **/
 s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,
 				   u16 words, u16 *data)
 {
 	u32 eerd;
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_read_eerd_buffer_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (words == 0)
-		return IXGBE_ERR_INVALID_ARGUMENT;
+	if (words == 0) {
+		status = IXGBE_ERR_INVALID_ARGUMENT;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM words");
+		goto out;
+	}
 
-	if (offset >= hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset >= hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM offset");
+		goto out;
+	}
 
 	for (i = 0; i < words; i++) {
 		eerd = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |
@@ -1177,34 +1371,36 @@ s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,
 		IXGBE_WRITE_REG(hw, IXGBE_EERD, eerd);
 		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);
 
-		if (status == 0) {
+		if (status == IXGBE_SUCCESS) {
 			data[i] = (IXGBE_READ_REG(hw, IXGBE_EERD) >>
 				   IXGBE_EEPROM_RW_REG_DATA);
 		} else {
 			hw_dbg(hw, "Eeprom read timed out\n");
-			return status;
+			goto out;
 		}
 	}
-
-	return 0;
+out:
+	return status;
 }
 
 /**
- *  ixgbe_detect_eeprom_page_size_generic - Detect EEPROM page size
- *  @hw: pointer to hardware structure
- *  @offset: offset within the EEPROM to be used as a scratch pad
+ * ixgbe_detect_eeprom_page_size_generic - Detect EEPROM page size
+ * @hw: pointer to hardware structure
+ * @offset: offset within the EEPROM to be used as a scratch pad
  *
- *  Discover EEPROM page size by writing marching data at given offset.
- *  This function is called only when we are writing a new large buffer
- *  at given offset so the data would be overwritten anyway.
+ * Discover EEPROM page size by writing marching data at given offset.
+ * This function is called only when we are writing a new large buffer
+ * at given offset so the data would be overwritten anyway.
  **/
-static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
 						 u16 offset)
 {
 	u16 data[IXGBE_EEPROM_PAGE_SIZE_MAX];
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_detect_eeprom_page_size_generic");
+
 	for (i = 0; i < IXGBE_EEPROM_PAGE_SIZE_MAX; i++)
 		data[i] = i;
 
@@ -1212,12 +1408,12 @@ static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
 	status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset,
 					     IXGBE_EEPROM_PAGE_SIZE_MAX, data);
 	hw->eeprom.word_page_size = 0;
-	if (status)
-		return status;
+	if (status != IXGBE_SUCCESS)
+		goto out;
 
 	status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);
-	if (status)
-		return status;
+	if (status != IXGBE_SUCCESS)
+		goto out;
 
 	/*
 	 * When writing in burst more than the actual page size
@@ -1225,18 +1421,19 @@ static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
 	 */
 	hw->eeprom.word_page_size = IXGBE_EEPROM_PAGE_SIZE_MAX - data[0];
 
-	hw_dbg(hw, "Detected EEPROM page size = %d words.\n",
-	       hw->eeprom.word_page_size);
-	return 0;
+	hw_dbg(hw, "Detected EEPROM page size = %d words.",
+		  hw->eeprom.word_page_size);
+out:
+	return status;
 }
 
 /**
- *  ixgbe_read_eerd_generic - Read EEPROM word using EERD
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @data: word read from the EEPROM
+ * ixgbe_read_eerd_generic - Read EEPROM word using EERD
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @data: word read from the EEPROM
  *
- *  Reads a 16 bit word from the EEPROM using the EERD register.
+ * Reads a 16 bit word from the EEPROM using the EERD register.
  **/
 s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
 {
@@ -1244,59 +1441,68 @@ s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
 }
 
 /**
- *  ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @words: number of words
- *  @data: word(s) write to the EEPROM
+ * ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @words: number of word(s)
+ * @data: word(s) write to the EEPROM
  *
- *  Write a 16 bit word(s) to the EEPROM using the EEWR register.
+ * Write a 16 bit word(s) to the EEPROM using the EEWR register.
  **/
 s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,
 				    u16 words, u16 *data)
 {
 	u32 eewr;
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_write_eewr_generic");
+
 	hw->eeprom.ops.init_params(hw);
 
-	if (words == 0)
-		return IXGBE_ERR_INVALID_ARGUMENT;
+	if (words == 0) {
+		status = IXGBE_ERR_INVALID_ARGUMENT;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM words");
+		goto out;
+	}
 
-	if (offset >= hw->eeprom.word_size)
-		return IXGBE_ERR_EEPROM;
+	if (offset >= hw->eeprom.word_size) {
+		status = IXGBE_ERR_EEPROM;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT, "Invalid EEPROM offset");
+		goto out;
+	}
 
 	for (i = 0; i < words; i++) {
 		eewr = ((offset + i) << IXGBE_EEPROM_RW_ADDR_SHIFT) |
-		       (data[i] << IXGBE_EEPROM_RW_REG_DATA) |
-		       IXGBE_EEPROM_RW_REG_START;
+			(data[i] << IXGBE_EEPROM_RW_REG_DATA) |
+			IXGBE_EEPROM_RW_REG_START;
 
 		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
-		if (status) {
+		if (status != IXGBE_SUCCESS) {
 			hw_dbg(hw, "Eeprom write EEWR timed out\n");
-			return status;
+			goto out;
 		}
 
 		IXGBE_WRITE_REG(hw, IXGBE_EEWR, eewr);
 
 		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
-		if (status) {
+		if (status != IXGBE_SUCCESS) {
 			hw_dbg(hw, "Eeprom write EEWR timed out\n");
-			return status;
+			goto out;
 		}
 	}
 
-	return 0;
+out:
+	return status;
 }
 
 /**
- *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @data: word write to the EEPROM
+ * ixgbe_write_eewr_generic - Write EEPROM word using EEWR
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @data: word write to the EEPROM
  *
- *  Write a 16 bit word to the EEPROM using the EEWR register.
+ * Write a 16 bit word to the EEPROM using the EEWR register.
  **/
 s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
 {
@@ -1304,17 +1510,20 @@ s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
 }
 
 /**
- *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status
- *  @hw: pointer to hardware structure
- *  @ee_reg: EEPROM flag for polling
+ * ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status
+ * @hw: pointer to hardware structure
+ * @ee_reg: EEPROM flag for polling
  *
- *  Polls the status bit (bit 1) of the EERD or EEWR to determine when the
- *  read or write is done respectively.
+ * Polls the status bit (bit 1) of the EERD or EEWR to determine when the
+ * read or write is done respectively.
  **/
-static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)
+s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)
 {
 	u32 i;
 	u32 reg;
+	s32 status = IXGBE_ERR_EEPROM;
+
+	DEBUGFUNC("ixgbe_poll_eerd_eewr_done");
 
 	for (i = 0; i < IXGBE_EERD_EEWR_ATTEMPTS; i++) {
 		if (ee_reg == IXGBE_NVM_POLL_READ)
@@ -1323,162 +1532,196 @@ static s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)
 			reg = IXGBE_READ_REG(hw, IXGBE_EEWR);
 
 		if (reg & IXGBE_EEPROM_RW_REG_DONE) {
-			return 0;
+			status = IXGBE_SUCCESS;
+			break;
 		}
-		udelay(5);
+		usec_delay(5);
 	}
-	return IXGBE_ERR_EEPROM;
+
+	if (i == IXGBE_EERD_EEWR_ATTEMPTS)
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "EEPROM read/write done polling timed out");
+
+	return status;
 }
 
 /**
- *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang
- *  @hw: pointer to hardware structure
+ * ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang
+ * @hw: pointer to hardware structure
  *
- *  Prepares EEPROM for access using bit-bang method. This function should
- *  be called before issuing a command to the EEPROM.
+ * Prepares EEPROM for access using bit-bang method. This function should
+ * be called before issuing a command to the EEPROM.
  **/
-static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u32 eec;
 	u32 i;
 
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) != 0)
-		return IXGBE_ERR_SWFW_SYNC;
+	DEBUGFUNC("ixgbe_acquire_eeprom");
 
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM)
+	    != IXGBE_SUCCESS)
+		status = IXGBE_ERR_SWFW_SYNC;
 
-	/* Request EEPROM Access */
-	eec |= IXGBE_EEC_REQ;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	if (status == IXGBE_SUCCESS) {
+		eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
-	for (i = 0; i < IXGBE_EEPROM_GRANT_ATTEMPTS; i++) {
-		eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
-		if (eec & IXGBE_EEC_GNT)
-			break;
-		udelay(5);
-	}
+		/* Request EEPROM Access */
+		eec |= IXGBE_EEC_REQ;
+		IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 
-	/* Release if grant not acquired */
-	if (!(eec & IXGBE_EEC_GNT)) {
-		eec &= ~IXGBE_EEC_REQ;
-		IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
-		hw_dbg(hw, "Could not acquire EEPROM grant\n");
+		for (i = 0; i < IXGBE_EEPROM_GRANT_ATTEMPTS; i++) {
+			eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
+			if (eec & IXGBE_EEC_GNT)
+				break;
+			usec_delay(5);
+		}
 
-		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
-		return IXGBE_ERR_EEPROM;
-	}
+		/* Release if grant not acquired */
+		if (!(eec & IXGBE_EEC_GNT)) {
+			eec &= ~IXGBE_EEC_REQ;
+			IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
+			hw_dbg(hw, "Could not acquire EEPROM grant\n");
 
-	/* Setup EEPROM for Read/Write */
-	/* Clear CS and SK */
-	eec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
-	IXGBE_WRITE_FLUSH(hw);
-	udelay(1);
-	return 0;
+			hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+			status = IXGBE_ERR_EEPROM;
+		}
+
+		/* Setup EEPROM for Read/Write */
+		if (status == IXGBE_SUCCESS) {
+			/* Clear CS and SK */
+			eec &= ~(IXGBE_EEC_CS | IXGBE_EEC_SK);
+			IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
+			IXGBE_WRITE_FLUSH(hw);
+			usec_delay(1);
+		}
+	}
+	return status;
 }
 
 /**
- *  ixgbe_get_eeprom_semaphore - Get hardware semaphore
- *  @hw: pointer to hardware structure
+ * ixgbe_get_eeprom_semaphore - Get hardware semaphore
+ * @hw: pointer to hardware structure
  *
- *  Sets the hardware semaphores so EEPROM access can occur for bit-bang method
+ * Sets the hardware semaphores so EEPROM access can occur for bit-bang method
  **/
-static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_ERR_EEPROM;
 	u32 timeout = 2000;
 	u32 i;
 	u32 swsm;
 
+	DEBUGFUNC("ixgbe_get_eeprom_semaphore");
+
 	/* Get SMBI software semaphore between device drivers first */
 	for (i = 0; i < timeout; i++) {
 		/*
 		 * If the SMBI bit is 0 when we read it, then the bit will be
 		 * set and we have the semaphore
 		 */
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
-		if (!(swsm & IXGBE_SWSM_SMBI))
+		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
+		if (!(swsm & IXGBE_SWSM_SMBI)) {
+			status = IXGBE_SUCCESS;
 			break;
-		usleep_range(50, 100);
+		}
+		usec_delay(50);
 	}
 
 	if (i == timeout) {
-		hw_dbg(hw, "Driver can't access the Eeprom - SMBI Semaphore not granted.\n");
-		/* this release is particularly important because our attempts
+		hw_dbg(hw, "Driver can't access the Eeprom - SMBI Semaphore "
+			 "not granted.\n");
+		/*
+		 * this release is particularly important because our attempts
 		 * above to get the semaphore may have succeeded, and if there
 		 * was a timeout, we should unconditionally clear the semaphore
 		 * bits to free the driver to make progress
 		 */
 		ixgbe_release_eeprom_semaphore(hw);
 
-		usleep_range(50, 100);
-		/* one last try
+		usec_delay(50);
+		/*
+		 * one last try
 		 * If the SMBI bit is 0 when we read it, then the bit will be
 		 * set and we have the semaphore
 		 */
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
-		if (swsm & IXGBE_SWSM_SMBI) {
-			hw_dbg(hw, "Software semaphore SMBI between device drivers not granted.\n");
-			return IXGBE_ERR_EEPROM;
-		}
+		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
+		if (!(swsm & IXGBE_SWSM_SMBI))
+			status = IXGBE_SUCCESS;
 	}
 
 	/* Now get the semaphore between SW/FW through the SWESMBI bit */
-	for (i = 0; i < timeout; i++) {
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
+	if (status == IXGBE_SUCCESS) {
+		for (i = 0; i < timeout; i++) {
+			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
 
-		/* Set the SW EEPROM semaphore bit to request access */
-		swsm |= IXGBE_SWSM_SWESMBI;
-		IXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);
+			/* Set the SW EEPROM semaphore bit to request access */
+			swsm |= IXGBE_SWSM_SWESMBI;
+			IXGBE_WRITE_REG(hw, IXGBE_SWSM_BY_MAC(hw), swsm);
 
-		/* If we set the bit successfully then we got the
-		 * semaphore.
-		 */
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
-		if (swsm & IXGBE_SWSM_SWESMBI)
-			break;
-
-		usleep_range(50, 100);
-	}
+			/*
+			 * If we set the bit successfully then we got the
+			 * semaphore.
+			 */
+			swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
+			if (swsm & IXGBE_SWSM_SWESMBI)
+				break;
 
-	/* Release semaphores and return error if SW EEPROM semaphore
-	 * was not granted because we don't have access to the EEPROM
-	 */
-	if (i >= timeout) {
-		hw_dbg(hw, "SWESMBI Software EEPROM semaphore not granted.\n");
-		ixgbe_release_eeprom_semaphore(hw);
-		return IXGBE_ERR_EEPROM;
+			usec_delay(50);
+		}
+
+		/*
+		 * Release semaphores and return error if SW EEPROM semaphore
+		 * was not granted because we don't have access to the EEPROM
+		 */
+		if (i >= timeout) {
+			ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			    "SWESMBI Software EEPROM semaphore not granted.\n");
+			ixgbe_release_eeprom_semaphore(hw);
+			status = IXGBE_ERR_EEPROM;
+		}
+	} else {
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "Software semaphore SMBI between device drivers "
+			     "not granted.\n");
 	}
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_release_eeprom_semaphore - Release hardware semaphore
- *  @hw: pointer to hardware structure
+ * ixgbe_release_eeprom_semaphore - Release hardware semaphore
+ * @hw: pointer to hardware structure
  *
- *  This function clears hardware semaphore bits.
+ * This function clears hardware semaphore bits.
  **/
-static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
+STATIC void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
 {
 	u32 swsm;
 
-	swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
+	DEBUGFUNC("ixgbe_release_eeprom_semaphore");
+
+	swsm = IXGBE_READ_REG(hw, IXGBE_SWSM);
 
 	/* Release both semaphores by writing 0 to the bits SWESMBI and SMBI */
 	swsm &= ~(IXGBE_SWSM_SWESMBI | IXGBE_SWSM_SMBI);
-	IXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);
+	IXGBE_WRITE_REG(hw, IXGBE_SWSM, swsm);
 	IXGBE_WRITE_FLUSH(hw);
 }
 
 /**
- *  ixgbe_ready_eeprom - Polls for EEPROM ready
- *  @hw: pointer to hardware structure
+ * ixgbe_ready_eeprom - Polls for EEPROM ready
+ * @hw: pointer to hardware structure
  **/
-static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u16 i;
 	u8 spi_stat_reg;
 
+	DEBUGFUNC("ixgbe_ready_eeprom");
+
 	/*
 	 * Read "Status Register" repeatedly until the LSB is cleared.  The
 	 * EEPROM will signal that the command has been completed by clearing
@@ -1492,9 +1735,9 @@ static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
 		if (!(spi_stat_reg & IXGBE_EEPROM_STATUS_RDY_SPI))
 			break;
 
-		udelay(5);
+		usec_delay(5);
 		ixgbe_standby_eeprom(hw);
-	}
+	};
 
 	/*
 	 * On some parts, SPI write time could vary from 0-20mSec on 3.3V
@@ -1502,53 +1745,57 @@ static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
 	 */
 	if (i >= IXGBE_EEPROM_MAX_RETRY_SPI) {
 		hw_dbg(hw, "SPI EEPROM Status error\n");
-		return IXGBE_ERR_EEPROM;
+		status = IXGBE_ERR_EEPROM;
 	}
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state
- *  @hw: pointer to hardware structure
+ * ixgbe_standby_eeprom - Returns EEPROM to a "standby" state
+ * @hw: pointer to hardware structure
  **/
-static void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
+STATIC void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
 {
 	u32 eec;
 
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	DEBUGFUNC("ixgbe_standby_eeprom");
+
+	eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 	/* Toggle CS to flush commands */
 	eec |= IXGBE_EEC_CS;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(1);
+	usec_delay(1);
 	eec &= ~IXGBE_EEC_CS;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(1);
+	usec_delay(1);
 }
 
 /**
- *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.
- *  @hw: pointer to hardware structure
- *  @data: data to send to the EEPROM
- *  @count: number of bits to shift out
+ * ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.
+ * @hw: pointer to hardware structure
+ * @data: data to send to the EEPROM
+ * @count: number of bits to shift out
  **/
-static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
+STATIC void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
 					u16 count)
 {
 	u32 eec;
 	u32 mask;
 	u32 i;
 
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	DEBUGFUNC("ixgbe_shift_out_eeprom_bits");
+
+	eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 	/*
 	 * Mask is used to shift "count" bits of "data" out to the EEPROM
 	 * one bit at a time.  Determine the starting bit based on count
 	 */
-	mask = BIT(count - 1);
+	mask = 0x01 << (count - 1);
 
 	for (i = 0; i < count; i++) {
 		/*
@@ -1563,10 +1810,10 @@ static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
 		else
 			eec &= ~IXGBE_EEC_DI;
 
-		IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+		IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 		IXGBE_WRITE_FLUSH(hw);
 
-		udelay(1);
+		usec_delay(1);
 
 		ixgbe_raise_eeprom_clk(hw, &eec);
 		ixgbe_lower_eeprom_clk(hw, &eec);
@@ -1576,25 +1823,27 @@ static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
 		 * EEPROM
 		 */
 		mask = mask >> 1;
-	}
+	};
 
 	/* We leave the "DI" bit set to "0" when we leave this routine. */
 	eec &= ~IXGBE_EEC_DI;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 	IXGBE_WRITE_FLUSH(hw);
 }
 
 /**
- *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM
- *  @hw: pointer to hardware structure
- *  @count: number of bits to shift
+ * ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM
+ * @hw: pointer to hardware structure
+ * @count: number of bits to shift
  **/
-static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
+STATIC u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
 {
 	u32 eec;
 	u32 i;
 	u16 data = 0;
 
+	DEBUGFUNC("ixgbe_shift_in_eeprom_bits");
+
 	/*
 	 * In order to read a register from the EEPROM, we need to shift
 	 * 'count' bits in from the EEPROM. Bits are "shifted in" by raising
@@ -1602,7 +1851,7 @@ static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
 	 * the value of the "DO" bit.  During this "shifting in" process the
 	 * "DI" bit should always be clear.
 	 */
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 	eec &= ~(IXGBE_EEC_DO | IXGBE_EEC_DI);
 
@@ -1610,7 +1859,7 @@ static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
 		data = data << 1;
 		ixgbe_raise_eeprom_clk(hw, &eec);
 
-		eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+		eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 		eec &= ~(IXGBE_EEC_DI);
 		if (eec & IXGBE_EEC_DO)
@@ -1623,74 +1872,78 @@ static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
 }
 
 /**
- *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.
- *  @hw: pointer to hardware structure
- *  @eec: EEC register's current value
+ * ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.
+ * @hw: pointer to hardware structure
+ * @eec: EEC register's current value
  **/
-static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
+STATIC void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
 {
+	DEBUGFUNC("ixgbe_raise_eeprom_clk");
+
 	/*
 	 * Raise the clock input to the EEPROM
 	 * (setting the SK bit), then delay
 	 */
 	*eec = *eec | IXGBE_EEC_SK;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), *eec);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(1);
+	usec_delay(1);
 }
 
 /**
- *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.
- *  @hw: pointer to hardware structure
- *  @eec: EEC's current value
+ * ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.
+ * @hw: pointer to hardware structure
+ * @eec: EEC's current value
  **/
-static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
+STATIC void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
 {
+	DEBUGFUNC("ixgbe_lower_eeprom_clk");
+
 	/*
 	 * Lower the clock input to the EEPROM (clearing the SK bit), then
 	 * delay
 	 */
 	*eec = *eec & ~IXGBE_EEC_SK;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), *eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), *eec);
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(1);
+	usec_delay(1);
 }
 
 /**
- *  ixgbe_release_eeprom - Release EEPROM, release semaphores
- *  @hw: pointer to hardware structure
+ * ixgbe_release_eeprom - Release EEPROM, release semaphores
+ * @hw: pointer to hardware structure
  **/
-static void ixgbe_release_eeprom(struct ixgbe_hw *hw)
+STATIC void ixgbe_release_eeprom(struct ixgbe_hw *hw)
 {
 	u32 eec;
 
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	DEBUGFUNC("ixgbe_release_eeprom");
+
+	eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 	eec |= IXGBE_EEC_CS;  /* Pull CS high */
 	eec &= ~IXGBE_EEC_SK; /* Lower SCK */
 
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 	IXGBE_WRITE_FLUSH(hw);
 
-	udelay(1);
+	usec_delay(1);
 
 	/* Stop requesting EEPROM access */
 	eec &= ~IXGBE_EEC_REQ;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), eec);
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), eec);
 
 	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
 
-	/*
-	 * Delay before attempt to obtain semaphore again to allow FW
-	 * access. semaphore_delay is in ms we need us for usleep_range
-	 */
-	usleep_range(hw->eeprom.semaphore_delay * 1000,
-		     hw->eeprom.semaphore_delay * 2000);
+	/* Delay before attempt to obtain semaphore again to allow FW access */
+	msec_delay(hw->eeprom.semaphore_delay);
 }
 
 /**
- *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum
- *  @hw: pointer to hardware structure
+ * ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum
+ * @hw: pointer to hardware structure
+ *
+ * Returns a negative error code on error, or the 16-bit checksum
  **/
 s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
 {
@@ -1701,11 +1954,13 @@ s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
 	u16 pointer = 0;
 	u16 word = 0;
 
+	DEBUGFUNC("ixgbe_calc_eeprom_checksum_generic");
+
 	/* Include 0x0-0x3F in the checksum */
 	for (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {
 		if (hw->eeprom.ops.read(hw, i, &word)) {
 			hw_dbg(hw, "EEPROM read failed\n");
-			break;
+			return IXGBE_ERR_EEPROM;
 		}
 		checksum += word;
 	}
@@ -1744,12 +1999,12 @@ s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum
- *  @hw: pointer to hardware structure
- *  @checksum_val: calculated checksum
+ * ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum
+ * @hw: pointer to hardware structure
+ * @checksum_val: calculated checksum
  *
- *  Performs checksum calculation and validates the EEPROM checksum.  If the
- *  caller does not need checksum_val, the value can be NULL.
+ * Performs checksum calculation and validates the EEPROM checksum.  If the
+ * caller does not need checksum_val, the value can be NULL.
  **/
 s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
 					   u16 *checksum_val)
@@ -1758,8 +2013,9 @@ s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
 	u16 checksum;
 	u16 read_checksum = 0;
 
-	/*
-	 * Read the first word from the EEPROM. If this times out or fails, do
+	DEBUGFUNC("ixgbe_validate_eeprom_checksum_generic");
+
+	/* Read the first word from the EEPROM. If this times out or fails, do
 	 * not continue or we could be in for a very long wait while every
 	 * EEPROM read fails
 	 */
@@ -1795,16 +2051,17 @@ s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum
- *  @hw: pointer to hardware structure
+ * ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum
+ * @hw: pointer to hardware structure
  **/
 s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
 {
 	s32 status;
 	u16 checksum;
 
-	/*
-	 * Read the first word from the EEPROM. If this times out or fails, do
+	DEBUGFUNC("ixgbe_update_eeprom_checksum_generic");
+
+	/* Read the first word from the EEPROM. If this times out or fails, do
 	 * not continue or we could be in for a very long wait while every
 	 * EEPROM read fails
 	 */
@@ -1826,14 +2083,40 @@ s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_set_rar_generic - Set Rx address register
- *  @hw: pointer to hardware structure
- *  @index: Receive address register to write
- *  @addr: Address to put into receive address register
- *  @vmdq: VMDq "set" or "pool" index
- *  @enable_addr: set flag that address is active
+ * ixgbe_validate_mac_addr - Validate MAC address
+ * @mac_addr: pointer to MAC address.
+ *
+ * Tests a MAC address to ensure it is a valid Individual Address.
+ **/
+s32 ixgbe_validate_mac_addr(u8 *mac_addr)
+{
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_validate_mac_addr");
+
+	/* Make sure it is not a multicast address */
+	if (IXGBE_IS_MULTICAST(mac_addr)) {
+		status = IXGBE_ERR_INVALID_MAC_ADDR;
+	/* Not a broadcast address */
+	} else if (IXGBE_IS_BROADCAST(mac_addr)) {
+		status = IXGBE_ERR_INVALID_MAC_ADDR;
+	/* Reject the zero address */
+	} else if (mac_addr[0] == 0 && mac_addr[1] == 0 && mac_addr[2] == 0 &&
+		   mac_addr[3] == 0 && mac_addr[4] == 0 && mac_addr[5] == 0) {
+		status = IXGBE_ERR_INVALID_MAC_ADDR;
+	}
+	return status;
+}
+
+/**
+ * ixgbe_set_rar_generic - Set Rx address register
+ * @hw: pointer to hardware structure
+ * @index: Receive address register to write
+ * @addr: Address to put into receive address register
+ * @vmdq: VMDq "set" or "pool" index
+ * @enable_addr: set flag that address is active
  *
- *  Puts an ethernet address into a receive address register.
+ * Puts an ethernet address into a receive address register.
  **/
 s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
 			  u32 enable_addr)
@@ -1841,9 +2124,12 @@ s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
 	u32 rar_low, rar_high;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_set_rar_generic");
+
 	/* Make sure we are using a valid rar index range */
 	if (index >= rar_entries) {
-		hw_dbg(hw, "RAR index %d is out of range.\n", index);
+		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
+			     "RAR index %d is out of range.\n", index);
 		return IXGBE_ERR_INVALID_ARGUMENT;
 	}
 
@@ -1870,32 +2156,30 @@ s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
 	if (enable_addr != 0)
 		rar_high |= IXGBE_RAH_AV;
 
-	/* Record lower 32 bits of MAC address and then make
-	 * sure that write is flushed to hardware before writing
-	 * the upper 16 bits and setting the valid bit.
-	 */
 	IXGBE_WRITE_REG(hw, IXGBE_RAL(index), rar_low);
-	IXGBE_WRITE_FLUSH(hw);
 	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_clear_rar_generic - Remove Rx address register
- *  @hw: pointer to hardware structure
- *  @index: Receive address register to write
+ * ixgbe_clear_rar_generic - Remove Rx address register
+ * @hw: pointer to hardware structure
+ * @index: Receive address register to write
  *
- *  Clears an ethernet address from a receive address register.
+ * Clears an ethernet address from a receive address register.
  **/
 s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)
 {
 	u32 rar_high;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_clear_rar_generic");
+
 	/* Make sure we are using a valid rar index range */
 	if (index >= rar_entries) {
-		hw_dbg(hw, "RAR index %d is out of range.\n", index);
+		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
+			     "RAR index %d is out of range.\n", index);
 		return IXGBE_ERR_INVALID_ARGUMENT;
 	}
 
@@ -1907,52 +2191,58 @@ s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)
 	rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(index));
 	rar_high &= ~(0x0000FFFF | IXGBE_RAH_AV);
 
-	/* Clear the address valid bit and upper 16 bits of the address
-	 * before clearing the lower bits. This way we aren't updating
-	 * a live filter.
-	 */
-	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
-	IXGBE_WRITE_FLUSH(hw);
 	IXGBE_WRITE_REG(hw, IXGBE_RAL(index), 0);
+	IXGBE_WRITE_REG(hw, IXGBE_RAH(index), rar_high);
 
 	/* clear VMDq pool/queue selection for this RAR */
 	hw->mac.ops.clear_vmdq(hw, index, IXGBE_CLEAR_VMDQ_ALL);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.
- *  @hw: pointer to hardware structure
+ * ixgbe_init_rx_addrs_generic - Initializes receive address filters.
+ * @hw: pointer to hardware structure
  *
- *  Places the MAC address in receive address register 0 and clears the rest
- *  of the receive address registers. Clears the multicast table. Assumes
- *  the receiver is in reset when the routine is called.
+ * Places the MAC address in receive address register 0 and clears the rest
+ * of the receive address registers. Clears the multicast table. Assumes
+ * the receiver is in reset when the routine is called.
  **/
 s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
 {
 	u32 i;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_init_rx_addrs_generic");
+
 	/*
 	 * If the current mac address is valid, assume it is a software override
 	 * to the permanent address.
 	 * Otherwise, use the permanent address from the eeprom.
 	 */
-	if (!is_valid_ether_addr(hw->mac.addr)) {
+	if (ixgbe_validate_mac_addr(hw->mac.addr) ==
+	    IXGBE_ERR_INVALID_MAC_ADDR) {
 		/* Get the MAC address from the RAR0 for later reference */
 		hw->mac.ops.get_mac_addr(hw, hw->mac.addr);
 
-		hw_dbg(hw, " Keeping Current RAR0 Addr =%pM\n", hw->mac.addr);
+		hw_dbg(hw, " Keeping Current RAR0 Addr =%.2X %.2X %.2X ",
+			  hw->mac.addr[0], hw->mac.addr[1],
+			  hw->mac.addr[2]);
+		hw_dbg(hw, "%.2X %.2X %.2X\n", hw->mac.addr[3],
+			  hw->mac.addr[4], hw->mac.addr[5]);
 	} else {
 		/* Setup the receive address. */
 		hw_dbg(hw, "Overriding MAC Address in RAR[0]\n");
-		hw_dbg(hw, " New MAC Addr =%pM\n", hw->mac.addr);
+		hw_dbg(hw, " New MAC Addr =%.2X %.2X %.2X ",
+			  hw->mac.addr[0], hw->mac.addr[1],
+			  hw->mac.addr[2]);
+		hw_dbg(hw, "%.2X %.2X %.2X\n", hw->mac.addr[3],
+			  hw->mac.addr[4], hw->mac.addr[5]);
 
 		hw->mac.ops.set_rar(hw, 0, hw->mac.addr, 0, IXGBE_RAH_AV);
 	}
 
-	/*  clear VMDq pool/queue selection for RAR 0 */
+	/* clear VMDq pool/queue selection for RAR 0 */
 	hw->mac.ops.clear_vmdq(hw, 0, IXGBE_CLEAR_VMDQ_ALL);
 
 	hw->addr_ctrl.overflow_promisc = 0;
@@ -1974,28 +2264,133 @@ s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
 	for (i = 0; i < hw->mac.mcft_size; i++)
 		IXGBE_WRITE_REG(hw, IXGBE_MTA(i), 0);
 
-	if (hw->mac.ops.init_uta_tables)
-		hw->mac.ops.init_uta_tables(hw);
+	ixgbe_init_uta_tables(hw);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_add_uc_addr - Adds a secondary unicast address.
+ * @hw: pointer to hardware structure
+ * @addr: new address
+ * @vmdq: VMDq "set" or "pool" index
+ *
+ * Adds it to unused receive address register or goes into promiscuous mode.
+ **/
+void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
+{
+	u32 rar_entries = hw->mac.num_rar_entries;
+	u32 rar;
+
+	DEBUGFUNC("ixgbe_add_uc_addr");
+
+	hw_dbg(hw, " UC Addr = %.2X %.2X %.2X %.2X %.2X %.2X\n",
+		  addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+	/*
+	 * Place this address in the RAR if there is room,
+	 * else put the controller into promiscuous mode
+	 */
+	if (hw->addr_ctrl.rar_used_count < rar_entries) {
+		rar = hw->addr_ctrl.rar_used_count;
+		hw->mac.ops.set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
+		hw_dbg(hw, "Added a secondary address to RAR[%d]\n", rar);
+		hw->addr_ctrl.rar_used_count++;
+	} else {
+		hw->addr_ctrl.overflow_promisc++;
+	}
+
+	hw_dbg(hw, "ixgbe_add_uc_addr Complete\n");
+}
+
+/**
+ * ixgbe_update_uc_addr_list_generic - Updates MAC list of secondary addresses
+ * @hw: pointer to hardware structure
+ * @addr_list: the list of new addresses
+ * @addr_count: number of addresses
+ * @next: iterator function to walk the address list
+ *
+ * The given list replaces any existing list.  Clears the secondary addrs from
+ * receive address registers.  Uses unused receive address registers for the
+ * first secondary addresses, and falls back to promiscuous mode as needed.
+ *
+ * Drivers using secondary unicast addresses must set user_set_promisc when
+ * manually putting the device into promiscuous mode.
+ **/
+s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
+				      u32 addr_count, ixgbe_mc_addr_itr next)
+{
+	u8 *addr;
+	u32 i;
+	u32 old_promisc_setting = hw->addr_ctrl.overflow_promisc;
+	u32 uc_addr_in_use;
+	u32 fctrl;
+	u32 vmdq;
+
+	DEBUGFUNC("ixgbe_update_uc_addr_list_generic");
+
+	/*
+	 * Clear accounting of old secondary address list,
+	 * don't count RAR[0]
+	 */
+	uc_addr_in_use = hw->addr_ctrl.rar_used_count - 1;
+	hw->addr_ctrl.rar_used_count -= uc_addr_in_use;
+	hw->addr_ctrl.overflow_promisc = 0;
+
+	/* Zero out the other receive addresses */
+	hw_dbg(hw, "Clearing RAR[1-%d]\n", uc_addr_in_use+1);
+	for (i = 0; i < uc_addr_in_use; i++) {
+		IXGBE_WRITE_REG(hw, IXGBE_RAL(1+i), 0);
+		IXGBE_WRITE_REG(hw, IXGBE_RAH(1+i), 0);
+	}
+
+	/* Add the new addresses */
+	for (i = 0; i < addr_count; i++) {
+		hw_dbg(hw, " Adding the secondary addresses:\n");
+		addr = next(hw, &addr_list, &vmdq);
+		ixgbe_add_uc_addr(hw, addr, vmdq);
+	}
+
+	if (hw->addr_ctrl.overflow_promisc) {
+		/* enable promisc if not already in overflow or set by user */
+		if (!old_promisc_setting && !hw->addr_ctrl.user_set_promisc) {
+			hw_dbg(hw, " Entering address overflow promisc mode\n");
+			fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
+			fctrl |= IXGBE_FCTRL_UPE;
+			IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
+		}
+	} else {
+		/* only disable if set by overflow, not by user */
+		if (old_promisc_setting && !hw->addr_ctrl.user_set_promisc) {
+			hw_dbg(hw, " Leaving address overflow promisc mode\n");
+			fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
+			fctrl &= ~IXGBE_FCTRL_UPE;
+			IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
+		}
+	}
 
-	return 0;
+	hw_dbg(hw, "ixgbe_update_uc_addr_list_generic Complete\n");
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_mta_vector - Determines bit-vector in multicast table to set
- *  @hw: pointer to hardware structure
- *  @mc_addr: the multicast address
+ * ixgbe_mta_vector - Determines bit-vector in multicast table to set
+ * @hw: pointer to hardware structure
+ * @mc_addr: the multicast address
  *
- *  Extracts the 12 bits, from a multicast address, to determine which
- *  bit-vector to set in the multicast table. The hardware uses 12 bits, from
- *  incoming rx multicast addresses, to determine the bit-vector to check in
- *  the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set
- *  by the MO field of the MCSTCTRL. The MO field is set during initialization
- *  to mc_filter_type.
+ * Extracts the 12 bits, from a multicast address, to determine which
+ * bit-vector to set in the multicast table. The hardware uses 12 bits, from
+ * incoming rx multicast addresses, to determine the bit-vector to check in
+ * the MTA. Which of the 4 combination, of 12-bits, the hardware uses is set
+ * by the MO field of the MCSTCTRL. The MO field is set during initialization
+ * to mc_filter_type.
  **/
-static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
+STATIC s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
 {
 	u32 vector = 0;
 
+	DEBUGFUNC("ixgbe_mta_vector");
+
 	switch (hw->mac.mc_filter_type) {
 	case 0:   /* use bits [47:36] of the address */
 		vector = ((mc_addr[4] >> 4) | (((u16)mc_addr[5]) << 4));
@@ -2011,6 +2406,7 @@ static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
 		break;
 	default:  /* Invalid mc_filter_type */
 		hw_dbg(hw, "MC filter type param set incorrectly\n");
+		ASSERT(0);
 		break;
 	}
 
@@ -2020,18 +2416,20 @@ static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
 }
 
 /**
- *  ixgbe_set_mta - Set bit-vector in multicast table
- *  @hw: pointer to hardware structure
- *  @mc_addr: Multicast address
+ * ixgbe_set_mta - Set bit-vector in multicast table
+ * @hw: pointer to hardware structure
+ * @mc_addr: Multicast address
  *
- *  Sets the bit-vector in the multicast table.
+ * Sets the bit-vector in the multicast table.
  **/
-static void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
+void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
 {
 	u32 vector;
 	u32 vector_bit;
 	u32 vector_reg;
 
+	DEBUGFUNC("ixgbe_set_mta");
+
 	hw->addr_ctrl.mta_in_use++;
 
 	vector = ixgbe_mta_vector(hw, mc_addr);
@@ -2048,40 +2446,46 @@ static void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
 	 */
 	vector_reg = (vector >> 5) & 0x7F;
 	vector_bit = vector & 0x1F;
-	hw->mac.mta_shadow[vector_reg] |= BIT(vector_bit);
+	hw->mac.mta_shadow[vector_reg] |= (1 << vector_bit);
 }
 
 /**
- *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses
- *  @hw: pointer to hardware structure
- *  @netdev: pointer to net device structure
+ * ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses
+ * @hw: pointer to hardware structure
+ * @mc_addr_list: the list of new multicast addresses
+ * @mc_addr_count: number of addresses
+ * @next: iterator function to walk the multicast address list
+ * @clear: flag, when set clears the table beforehand
  *
- *  The given list replaces any existing list. Clears the MC addrs from receive
- *  address registers and the multicast table. Uses unused receive address
- *  registers for the first multicast addresses, and hashes the rest into the
- *  multicast table.
+ * When the clear flag is set, the given list replaces any existing list.
+ * Hashes the given addresses into the multicast table.
  **/
-s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,
-				      struct net_device *netdev)
+s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
+				      u32 mc_addr_count, ixgbe_mc_addr_itr next,
+				      bool clear)
 {
-	struct netdev_hw_addr *ha;
 	u32 i;
+	u32 vmdq;
+
+	DEBUGFUNC("ixgbe_update_mc_addr_list_generic");
 
 	/*
 	 * Set the new number of MC addresses that we are being requested to
 	 * use.
 	 */
-	hw->addr_ctrl.num_mc_addrs = netdev_mc_count(netdev);
+	hw->addr_ctrl.num_mc_addrs = mc_addr_count;
 	hw->addr_ctrl.mta_in_use = 0;
 
 	/* Clear mta_shadow */
-	hw_dbg(hw, " Clearing MTA\n");
-	memset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));
+	if (clear) {
+		hw_dbg(hw, " Clearing MTA\n");
+		memset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));
+	}
 
-	/* Update mta shadow */
-	netdev_for_each_mc_addr(ha, netdev) {
+	/* Update mta_shadow */
+	for (i = 0; i < mc_addr_count; i++) {
 		hw_dbg(hw, " Adding the multicast addresses:\n");
-		ixgbe_set_mta(hw, ha->addr);
+		ixgbe_set_mta(hw, next(hw, &mc_addr_list, &vmdq));
 	}
 
 	/* Enable mta */
@@ -2094,67 +2498,77 @@ s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,
 				IXGBE_MCSTCTRL_MFE | hw->mac.mc_filter_type);
 
 	hw_dbg(hw, "ixgbe_update_mc_addr_list_generic Complete\n");
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_enable_mc_generic - Enable multicast address in RAR
- *  @hw: pointer to hardware structure
+ * ixgbe_enable_mc_generic - Enable multicast address in RAR
+ * @hw: pointer to hardware structure
  *
- *  Enables multicast address in RAR and the use of the multicast hash table.
+ * Enables multicast address in RAR and the use of the multicast hash table.
  **/
 s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)
 {
 	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;
 
+	DEBUGFUNC("ixgbe_enable_mc_generic");
+
 	if (a->mta_in_use > 0)
 		IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, IXGBE_MCSTCTRL_MFE |
 				hw->mac.mc_filter_type);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_disable_mc_generic - Disable multicast address in RAR
- *  @hw: pointer to hardware structure
+ * ixgbe_disable_mc_generic - Disable multicast address in RAR
+ * @hw: pointer to hardware structure
  *
- *  Disables multicast address in RAR and the use of the multicast hash table.
+ * Disables multicast address in RAR and the use of the multicast hash table.
  **/
 s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)
 {
 	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;
 
+	DEBUGFUNC("ixgbe_disable_mc_generic");
+
 	if (a->mta_in_use > 0)
 		IXGBE_WRITE_REG(hw, IXGBE_MCSTCTRL, hw->mac.mc_filter_type);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_fc_enable_generic - Enable flow control
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_enable_generic - Enable flow control
+ * @hw: pointer to hardware structure
  *
- *  Enable flow control according to the current settings.
+ * Enable flow control according to the current settings.
  **/
 s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
 {
+	s32 ret_val = IXGBE_SUCCESS;
 	u32 mflcn_reg, fccfg_reg;
 	u32 reg;
 	u32 fcrtl, fcrth;
 	int i;
 
-	/* Validate the water mark configuration. */
-	if (!hw->fc.pause_time)
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
+	DEBUGFUNC("ixgbe_fc_enable_generic");
+
+	/* Validate the water mark configuration */
+	if (!hw->fc.pause_time) {
+		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+		goto out;
+	}
 
 	/* Low water mark of zero causes XOFF floods */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
 		    hw->fc.high_water[i]) {
 			if (!hw->fc.low_water[i] ||
 			    hw->fc.low_water[i] >= hw->fc.high_water[i]) {
 				hw_dbg(hw, "Invalid water mark configuration\n");
-				return IXGBE_ERR_INVALID_LINK_SETTINGS;
+				ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+				goto out;
 			}
 		}
 	}
@@ -2210,8 +2624,11 @@ s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
 		fccfg_reg |= IXGBE_FCCFG_TFCE_802_3X;
 		break;
 	default:
-		hw_dbg(hw, "Flow control param set incorrectly\n");
-		return IXGBE_ERR_CONFIG;
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
+			     "Flow control param set incorrectly\n");
+		ret_val = IXGBE_ERR_CONFIG;
+		goto out;
+		break;
 	}
 
 	/* Set 802.3x based flow control settings. */
@@ -2219,8 +2636,9 @@ s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
 	IXGBE_WRITE_REG(hw, IXGBE_MFLCN, mflcn_reg);
 	IXGBE_WRITE_REG(hw, IXGBE_FCCFG, fccfg_reg);
 
+
 	/* Set up and enable Rx high/low water mark thresholds, enable XON. */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
 		    hw->fc.high_water[i]) {
 			fcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;
@@ -2242,33 +2660,40 @@ s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
 	}
 
 	/* Configure pause time (2 TCs per register) */
-	reg = hw->fc.pause_time * 0x00010001U;
-	for (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)
+	reg = hw->fc.pause_time * 0x00010001;
+	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
 		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);
 
+	/* Configure flow control refresh threshold value */
 	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);
 
-	return 0;
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_negotiate_fc - Negotiate flow control
- *  @hw: pointer to hardware structure
- *  @adv_reg: flow control advertised settings
- *  @lp_reg: link partner's flow control settings
- *  @adv_sym: symmetric pause bit in advertisement
- *  @adv_asm: asymmetric pause bit in advertisement
- *  @lp_sym: symmetric pause bit in link partner advertisement
- *  @lp_asm: asymmetric pause bit in link partner advertisement
+ * ixgbe_negotiate_fc - Negotiate flow control
+ * @hw: pointer to hardware structure
+ * @adv_reg: flow control advertised settings
+ * @lp_reg: link partner's flow control settings
+ * @adv_sym: symmetric pause bit in advertisement
+ * @adv_asm: asymmetric pause bit in advertisement
+ * @lp_sym: symmetric pause bit in link partner advertisement
+ * @lp_asm: asymmetric pause bit in link partner advertisement
  *
- *  Find the intersection between advertised settings and link partner's
- *  advertised settings
+ * Find the intersection between advertised settings and link partner's
+ * advertised settings
  **/
 s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,
 		       u32 adv_sym, u32 adv_asm, u32 lp_sym, u32 lp_asm)
 {
-	if ((!(adv_reg)) ||  (!(lp_reg)))
+	if ((!(adv_reg)) ||  (!(lp_reg))) {
+		ERROR_REPORT3(IXGBE_ERROR_UNSUPPORTED,
+			     "Local or link partner's advertised flow control "
+			     "settings are NULL. Local: %x, link partner: %x\n",
+			     adv_reg, lp_reg);
 		return IXGBE_ERR_FC_NOT_NEGOTIATED;
+	}
 
 	if ((adv_reg & adv_sym) && (lp_reg & lp_sym)) {
 		/*
@@ -2297,19 +2722,19 @@ s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,
 		hw->fc.current_mode = ixgbe_fc_none;
 		hw_dbg(hw, "Flow Control = NONE.\n");
 	}
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber
+ * @hw: pointer to hardware structure
  *
- *  Enable flow control according on 1 gig fiber.
+ * Enable flow control according on 1 gig fiber.
  **/
-static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
 {
 	u32 pcs_anadv_reg, pcs_lpab_reg, linkstat;
-	s32 ret_val;
+	s32 ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
 
 	/*
 	 * On multispeed fiber at 1g, bail out if
@@ -2319,31 +2744,34 @@ static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
 
 	linkstat = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
 	if ((!!(linkstat & IXGBE_PCS1GLSTA_AN_COMPLETE) == 0) ||
-	    (!!(linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1))
-		return IXGBE_ERR_FC_NOT_NEGOTIATED;
+	    (!!(linkstat & IXGBE_PCS1GLSTA_AN_TIMED_OUT) == 1)) {
+		hw_dbg(hw, "Auto-Negotiation did not complete or timed out\n");
+		goto out;
+	}
 
 	pcs_anadv_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
 	pcs_lpab_reg = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
 
 	ret_val =  ixgbe_negotiate_fc(hw, pcs_anadv_reg,
-			       pcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,
-			       IXGBE_PCS1GANA_ASM_PAUSE,
-			       IXGBE_PCS1GANA_SYM_PAUSE,
-			       IXGBE_PCS1GANA_ASM_PAUSE);
+				      pcs_lpab_reg, IXGBE_PCS1GANA_SYM_PAUSE,
+				      IXGBE_PCS1GANA_ASM_PAUSE,
+				      IXGBE_PCS1GANA_SYM_PAUSE,
+				      IXGBE_PCS1GANA_ASM_PAUSE);
 
+out:
 	return ret_val;
 }
 
 /**
- *  ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37
+ * @hw: pointer to hardware structure
  *
- *  Enable flow control according to IEEE clause 37.
+ * Enable flow control according to IEEE clause 37.
  **/
-static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
 {
 	u32 links2, anlp1_reg, autoc_reg, links;
-	s32 ret_val;
+	s32 ret_val = IXGBE_ERR_FC_NOT_NEGOTIATED;
 
 	/*
 	 * On backplane, bail out if
@@ -2351,13 +2779,17 @@ static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
 	 * - we are 82599 and link partner is not AN enabled
 	 */
 	links = IXGBE_READ_REG(hw, IXGBE_LINKS);
-	if ((links & IXGBE_LINKS_KX_AN_COMP) == 0)
-		return IXGBE_ERR_FC_NOT_NEGOTIATED;
+	if ((links & IXGBE_LINKS_KX_AN_COMP) == 0) {
+		hw_dbg(hw, "Auto-Negotiation did not complete\n");
+		goto out;
+	}
 
 	if (hw->mac.type == ixgbe_mac_82599EB) {
 		links2 = IXGBE_READ_REG(hw, IXGBE_LINKS2);
-		if ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0)
-			return IXGBE_ERR_FC_NOT_NEGOTIATED;
+		if ((links2 & IXGBE_LINKS2_AN_SUPPORTED) == 0) {
+			hw_dbg(hw, "Link partner is not AN enabled\n");
+			goto out;
+		}
 	}
 	/*
 	 * Read the 10g AN autoc and LP ability registers and resolve
@@ -2370,25 +2802,26 @@ static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
 		anlp1_reg, IXGBE_AUTOC_SYM_PAUSE, IXGBE_AUTOC_ASM_PAUSE,
 		IXGBE_ANLP1_SYM_PAUSE, IXGBE_ANLP1_ASM_PAUSE);
 
+out:
 	return ret_val;
 }
 
 /**
- *  ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37
+ * @hw: pointer to hardware structure
  *
- *  Enable flow control according to IEEE clause 37.
+ * Enable flow control according to IEEE clause 37.
  **/
-static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
 {
 	u16 technology_ability_reg = 0;
 	u16 lp_technology_ability_reg = 0;
 
-	hw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,
-			     MDIO_MMD_AN,
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_ADVT,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 			     &technology_ability_reg);
-	hw->phy.ops.read_reg(hw, MDIO_AN_LPA,
-			     MDIO_MMD_AN,
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_LP,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 			     &lp_technology_ability_reg);
 
 	return ixgbe_negotiate_fc(hw, (u32)technology_ability_reg,
@@ -2398,11 +2831,11 @@ static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_fc_autoneg - Configure flow control
- *  @hw: pointer to hardware structure
+ * ixgbe_fc_autoneg - Configure flow control
+ * @hw: pointer to hardware structure
  *
- *  Compares our advertised flow control capabilities to those advertised by
- *  our link partner, and determines the proper flow control mode to use.
+ * Compares our advertised flow control capabilities to those advertised by
+ * our link partner, and determines the proper flow control mode to use.
  **/
 void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
 {
@@ -2410,24 +2843,30 @@ void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
 	ixgbe_link_speed speed;
 	bool link_up;
 
+	DEBUGFUNC("ixgbe_fc_autoneg");
+
 	/*
 	 * AN should have completed when the cable was plugged in.
 	 * Look for reasons to bail out.  Bail out if:
 	 * - FC autoneg is disabled, or if
 	 * - link is not up.
-	 *
-	 * Since we're being called from an LSC, link is already known to be up.
-	 * So use link_up_wait_to_complete=false.
 	 */
-	if (hw->fc.disable_fc_autoneg)
+	if (hw->fc.disable_fc_autoneg) {
+		/* TODO: This should be just an informative log */
+		ERROR_REPORT1(IXGBE_ERROR_CAUTION,
+			      "Flow control autoneg is disabled");
 		goto out;
+	}
 
 	hw->mac.ops.check_link(hw, &speed, &link_up, false);
-	if (!link_up)
+	if (!link_up) {
+		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE, "The link is down");
 		goto out;
+	}
 
 	switch (hw->phy.media_type) {
 	/* Autoneg flow control on fiber adapters */
+	case ixgbe_media_type_fiber_qsfp:
 	case ixgbe_media_type_fiber:
 		if (speed == IXGBE_LINK_SPEED_1GB_FULL)
 			ret_val = ixgbe_fc_autoneg_fiber(hw);
@@ -2449,7 +2888,7 @@ void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
 	}
 
 out:
-	if (ret_val == 0) {
+	if (ret_val == IXGBE_SUCCESS) {
 		hw->fc.fc_was_autonegged = true;
 	} else {
 		hw->fc.fc_was_autonegged = false;
@@ -2457,46 +2896,46 @@ void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
 	}
 }
 
-/**
+/*
  * ixgbe_pcie_timeout_poll - Return number of times to poll for completion
  * @hw: pointer to hardware structure
  *
  * System-wide timeout range is encoded in PCIe Device Control2 register.
  *
- *  Add 10% to specified maximum and return the number of times to poll for
- *  completion timeout, in units of 100 microsec.  Never return less than
- *  800 = 80 millisec.
- **/
-static u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)
+ * Add 10% to specified maximum and return the number of times to poll for
+ * completion timeout, in units of 100 microsec.  Never return less than
+ * 800 = 80 millisec.
+ */
+STATIC u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)
 {
 	s16 devctl2;
 	u32 pollcnt;
 
-	devctl2 = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_CONTROL2);
+	devctl2 = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_CONTROL2);
 	devctl2 &= IXGBE_PCIDEVCTRL2_TIMEO_MASK;
 
 	switch (devctl2) {
 	case IXGBE_PCIDEVCTRL2_65_130ms:
-		 pollcnt = 1300;         /* 130 millisec */
+		pollcnt = 1300;		/* 130 millisec */
 		break;
 	case IXGBE_PCIDEVCTRL2_260_520ms:
-		pollcnt = 5200;         /* 520 millisec */
+		pollcnt = 5200;		/* 520 millisec */
 		break;
 	case IXGBE_PCIDEVCTRL2_1_2s:
-		pollcnt = 20000;        /* 2 sec */
+		pollcnt = 20000;	/* 2 sec */
 		break;
 	case IXGBE_PCIDEVCTRL2_4_8s:
-		pollcnt = 80000;        /* 8 sec */
+		pollcnt = 80000;	/* 8 sec */
 		break;
 	case IXGBE_PCIDEVCTRL2_17_34s:
-		pollcnt = 34000;        /* 34 sec */
+		pollcnt = 34000;	/* 34 sec */
 		break;
-	case IXGBE_PCIDEVCTRL2_50_100us:        /* 100 microsecs */
-	case IXGBE_PCIDEVCTRL2_1_2ms:           /* 2 millisecs */
-	case IXGBE_PCIDEVCTRL2_16_32ms:         /* 32 millisec */
-	case IXGBE_PCIDEVCTRL2_16_32ms_def:     /* 32 millisec default */
+	case IXGBE_PCIDEVCTRL2_50_100us:	/* 100 microsecs */
+	case IXGBE_PCIDEVCTRL2_1_2ms:		/* 2 millisecs */
+	case IXGBE_PCIDEVCTRL2_16_32ms:		/* 32 millisec */
+	case IXGBE_PCIDEVCTRL2_16_32ms_def:	/* 32 millisec default */
 	default:
-		pollcnt = 800;          /* 80 millisec minimum */
+		pollcnt = 800;		/* 80 millisec minimum */
 		break;
 	}
 
@@ -2505,43 +2944,35 @@ static u32 ixgbe_pcie_timeout_poll(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_disable_pcie_master - Disable PCI-express master access
- *  @hw: pointer to hardware structure
+ * ixgbe_disable_pcie_master - Disable PCI-express master access
+ * @hw: pointer to hardware structure
  *
- *  Disables PCI-Express master access and verifies there are no pending
- *  requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable
- *  bit hasn't caused the master requests to be disabled, else 0
- *  is returned signifying master requests disabled.
+ * Disables PCI-Express master access and verifies there are no pending
+ * requests. IXGBE_ERR_MASTER_REQUESTS_PENDING is returned if master disable
+ * bit hasn't caused the master requests to be disabled, else IXGBE_SUCCESS
+ * is returned signifying master requests disabled.
  **/
-static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
+s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u32 i, poll;
 	u16 value;
 
+	DEBUGFUNC("ixgbe_disable_pcie_master");
+
 	/* Always set this bit to ensure any future transactions are blocked */
 	IXGBE_WRITE_REG(hw, IXGBE_CTRL, IXGBE_CTRL_GIO_DIS);
 
-	/* Poll for bit to read as set */
-	for (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {
-		if (IXGBE_READ_REG(hw, IXGBE_CTRL) & IXGBE_CTRL_GIO_DIS)
-			break;
-		usleep_range(100, 120);
-	}
-	if (i >= IXGBE_PCI_MASTER_DISABLE_TIMEOUT) {
-		hw_dbg(hw, "GIO disable did not set - requesting resets\n");
-		goto gio_disable_fail;
-	}
-
 	/* Exit if master requests are blocked */
 	if (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO) ||
-	    ixgbe_removed(hw->hw_addr))
-		return 0;
+	    IXGBE_REMOVED(hw->hw_addr))
+		goto out;
 
 	/* Poll for master request bit to clear */
 	for (i = 0; i < IXGBE_PCI_MASTER_DISABLE_TIMEOUT; i++) {
-		udelay(100);
+		usec_delay(100);
 		if (!(IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_GIO))
-			return 0;
+			goto out;
 	}
 
 	/*
@@ -2553,11 +2984,10 @@ static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
 	 * again to clear out any effects they may have had on our device.
 	 */
 	hw_dbg(hw, "GIO Master Disable bit didn't clear - requesting resets\n");
-gio_disable_fail:
 	hw->mac.flags |= IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
 
 	if (hw->mac.type >= ixgbe_mac_X550)
-		return 0;
+		goto out;
 
 	/*
 	 * Before proceeding, make sure that the PCIe block does not have
@@ -2565,25 +2995,29 @@ static s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
 	 */
 	poll = ixgbe_pcie_timeout_poll(hw);
 	for (i = 0; i < poll; i++) {
-		udelay(100);
-		value = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);
-		if (ixgbe_removed(hw->hw_addr))
-			return 0;
+		usec_delay(100);
+		value = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_STATUS);
+		if (IXGBE_REMOVED(hw->hw_addr))
+			goto out;
 		if (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
-			return 0;
+			goto out;
 	}
 
-	hw_dbg(hw, "PCIe transaction pending bit also did not clear.\n");
-	return IXGBE_ERR_MASTER_REQUESTS_PENDING;
+	ERROR_REPORT1(IXGBE_ERROR_POLLING,
+		     "PCIe transaction pending bit also did not clear.\n");
+	status = IXGBE_ERR_MASTER_REQUESTS_PENDING;
+
+out:
+	return status;
 }
 
 /**
- *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
- *  @hw: pointer to hardware structure
- *  @mask: Mask to specify which semaphore to acquire
+ * ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
+ * @hw: pointer to hardware structure
+ * @mask: Mask to specify which semaphore to acquire
  *
- *  Acquires the SWFW semaphore through the GSSR register for the specified
- *  function (CSR, PHY0, PHY1, EEPROM, Flash)
+ * Acquires the SWFW semaphore through the GSSR register for the specified
+ * function (CSR, PHY0, PHY1, EEPROM, Flash)
  **/
 s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 {
@@ -2593,6 +3027,8 @@ s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 	u32 timeout = 200;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_acquire_swfw_sync");
+
 	for (i = 0; i < timeout; i++) {
 		/*
 		 * SW NVM semaphore bit is used for access to all
@@ -2606,11 +3042,11 @@ s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 			gssr |= swmask;
 			IXGBE_WRITE_REG(hw, IXGBE_GSSR, gssr);
 			ixgbe_release_eeprom_semaphore(hw);
-			return 0;
+			return IXGBE_SUCCESS;
 		} else {
 			/* Resource is currently in use by FW or SW */
 			ixgbe_release_eeprom_semaphore(hw);
-			usleep_range(5000, 10000);
+			msec_delay(5);
 		}
 	}
 
@@ -2618,23 +3054,25 @@ s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 	if (gssr & (fwmask | swmask))
 		ixgbe_release_swfw_sync(hw, gssr & (fwmask | swmask));
 
-	usleep_range(5000, 10000);
+	msec_delay(5);
 	return IXGBE_ERR_SWFW_SYNC;
 }
 
 /**
- *  ixgbe_release_swfw_sync - Release SWFW semaphore
- *  @hw: pointer to hardware structure
- *  @mask: Mask to specify which semaphore to release
+ * ixgbe_release_swfw_sync - Release SWFW semaphore
+ * @hw: pointer to hardware structure
+ * @mask: Mask to specify which semaphore to release
  *
- *  Releases the SWFW semaphore through the GSSR register for the specified
- *  function (CSR, PHY0, PHY1, EEPROM, Flash)
+ * Releases the SWFW semaphore through the GSSR register for the specified
+ * function (CSR, PHY0, PHY1, EEPROM, Flash)
  **/
 void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 {
 	u32 gssr;
 	u32 swmask = mask;
 
+	DEBUGFUNC("ixgbe_release_swfw_sync");
+
 	ixgbe_get_eeprom_semaphore(hw);
 
 	gssr = IXGBE_READ_REG(hw, IXGBE_GSSR);
@@ -2645,47 +3083,21 @@ void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask)
 }
 
 /**
- * prot_autoc_read_generic - Hides MAC differences needed for AUTOC read
+ * ixgbe_disable_sec_rx_path_generic - Stops the receive data path
  * @hw: pointer to hardware structure
- * @reg_val: Value we read from AUTOC
- * @locked: bool to indicate whether the SW/FW lock should be taken.  Never
- *	    true in this the generic case.
  *
- * The default case requires no protection so just to the register read.
- **/
-s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)
-{
-	*locked = false;
-	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	return 0;
-}
-
-/**
- * prot_autoc_write_generic - Hides MAC differences needed for AUTOC write
- * @hw: pointer to hardware structure
- * @reg_val: value to write to AUTOC
- * @locked: bool to indicate whether the SW/FW lock was already taken by
- *	    previous read.
+ * Stops the receive data path and waits for the HW to internally empty
+ * the Rx security block
  **/
-s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked)
+s32 ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw)
 {
-	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_val);
-	return 0;
-}
+#define IXGBE_MAX_SECRX_POLL 4000
 
-/**
- *  ixgbe_disable_rx_buff_generic - Stops the receive data path
- *  @hw: pointer to hardware structure
- *
- *  Stops the receive data path and waits for the HW to internally
- *  empty the Rx security block.
- **/
-s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)
-{
-#define IXGBE_MAX_SECRX_POLL 40
 	int i;
 	int secrxreg;
 
+	DEBUGFUNC("ixgbe_disable_sec_rx_path_generic");
+
 	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
 	secrxreg |= IXGBE_SECRXCTRL_RX_DIS;
 	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
@@ -2695,65 +3107,103 @@ s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw)
 			break;
 		else
 			/* Use interrupt-safe sleep just in case */
-			udelay(1000);
+			usec_delay(10);
 	}
 
 	/* For informational purposes only */
 	if (i >= IXGBE_MAX_SECRX_POLL)
-		hw_dbg(hw, "Rx unit being enabled before security path fully disabled. Continuing with init.\n");
+		hw_dbg(hw, "Rx unit being enabled before security "
+			 "path fully disabled.  Continuing with init.\n");
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * prot_autoc_read_generic - Hides MAC differences needed for AUTOC read
+ * @hw: pointer to hardware structure
+ * @locked: bool to indicate whether the SW/FW lock was taken
+ * @reg_val: Value we read from AUTOC
+ *
+ * The default case requires no protection so just to the register read.
+ */
+s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *locked, u32 *reg_val)
+{
+	*locked = false;
+	*reg_val = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	return IXGBE_SUCCESS;
+}
 
-	return 0;
+/**
+ * prot_autoc_write_generic - Hides MAC differences needed for AUTOC write
+ * @hw: pointer to hardware structure
+ * @reg_val: value to write to AUTOC
+ * @locked: bool to indicate whether the SW/FW lock was already taken by
+ *          previous read.
+ *
+ * The default case requires no protection so just to the register write.
+ */
+s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked)
+{
+	UNREFERENCED_1PARAMETER(locked);
 
+	IXGBE_WRITE_REG(hw, IXGBE_AUTOC, reg_val);
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_enable_rx_buff - Enables the receive data path
- *  @hw: pointer to hardware structure
+ * ixgbe_enable_sec_rx_path_generic - Enables the receive data path
+ * @hw: pointer to hardware structure
  *
- *  Enables the receive data path
+ * Enables the receive data path.
  **/
-s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw)
+s32 ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw)
 {
 	u32 secrxreg;
 
+	DEBUGFUNC("ixgbe_enable_sec_rx_path_generic");
+
 	secrxreg = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
 	secrxreg &= ~IXGBE_SECRXCTRL_RX_DIS;
 	IXGBE_WRITE_REG(hw, IXGBE_SECRXCTRL, secrxreg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit
- *  @hw: pointer to hardware structure
- *  @regval: register value to write to RXCTRL
+ * ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit
+ * @hw: pointer to hardware structure
+ * @regval: register value to write to RXCTRL
  *
- *  Enables the Rx DMA unit
+ * Enables the Rx DMA unit
  **/
 s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval)
 {
+	DEBUGFUNC("ixgbe_enable_rx_dma_generic");
+
 	if (regval & IXGBE_RXCTRL_RXEN)
-		hw->mac.ops.enable_rx(hw);
+		ixgbe_enable_rx(hw);
 	else
-		hw->mac.ops.disable_rx(hw);
+		ixgbe_disable_rx(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_blink_led_start_generic - Blink LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to blink
+ * ixgbe_blink_led_start_generic - Blink LED based on index.
+ * @hw: pointer to hardware structure
+ * @index: led number to blink
  **/
 s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
 {
 	ixgbe_link_speed speed = 0;
-	bool link_up = false;
-	u32 autoc_reg = IXGBE_READ_REG(hw, IXGBE_AUTOC);
+	bool link_up = 0;
+	u32 autoc_reg = 0;
 	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+	s32 ret_val = IXGBE_SUCCESS;
 	bool locked = false;
-	s32 ret_val;
+
+	DEBUGFUNC("ixgbe_blink_led_start_generic");
 
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
@@ -2766,19 +3216,18 @@ s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
 
 	if (!link_up) {
 		ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);
-		if (ret_val)
-			return ret_val;
+		if (ret_val != IXGBE_SUCCESS)
+			goto out;
 
 		autoc_reg |= IXGBE_AUTOC_AN_RESTART;
 		autoc_reg |= IXGBE_AUTOC_FLU;
 
 		ret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);
-		if (ret_val)
-			return ret_val;
+		if (ret_val != IXGBE_SUCCESS)
+			goto out;
 
 		IXGBE_WRITE_FLUSH(hw);
-
-		usleep_range(10000, 20000);
+		msec_delay(10);
 	}
 
 	led_reg &= ~IXGBE_LED_MODE_MASK(index);
@@ -2786,34 +3235,37 @@ s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.
- *  @hw: pointer to hardware structure
- *  @index: led number to stop blinking
+ * ixgbe_blink_led_stop_generic - Stop blinking LED based on index.
+ * @hw: pointer to hardware structure
+ * @index: led number to stop blinking
  **/
 s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)
 {
 	u32 autoc_reg = 0;
 	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+	s32 ret_val = IXGBE_SUCCESS;
 	bool locked = false;
-	s32 ret_val;
+
+	DEBUGFUNC("ixgbe_blink_led_stop_generic");
 
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
 
 	ret_val = hw->mac.ops.prot_autoc_read(hw, &locked, &autoc_reg);
-	if (ret_val)
-		return ret_val;
+	if (ret_val != IXGBE_SUCCESS)
+		goto out;
 
 	autoc_reg &= ~IXGBE_AUTOC_FLU;
 	autoc_reg |= IXGBE_AUTOC_AN_RESTART;
 
 	ret_val = hw->mac.ops.prot_autoc_write(hw, autoc_reg, locked);
-	if (ret_val)
-		return ret_val;
+	if (ret_val != IXGBE_SUCCESS)
+		goto out;
 
 	led_reg &= ~IXGBE_LED_MODE_MASK(index);
 	led_reg &= ~IXGBE_LED_BLINK(index);
@@ -2821,45 +3273,50 @@ s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+out:
+	return ret_val;
 }
 
 /**
- *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM
- *  @hw: pointer to hardware structure
- *  @san_mac_offset: SAN MAC address offset
+ * ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM
+ * @hw: pointer to hardware structure
+ * @san_mac_offset: SAN MAC address offset
  *
- *  This function will read the EEPROM location for the SAN MAC address
- *  pointer, and returns the value at that location.  This is used in both
- *  get and set mac_addr routines.
+ * This function will read the EEPROM location for the SAN MAC address
+ * pointer, and returns the value at that location.  This is used in both
+ * get and set mac_addr routines.
  **/
-static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
-					u16 *san_mac_offset)
+STATIC s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
+					 u16 *san_mac_offset)
 {
 	s32 ret_val;
 
+	DEBUGFUNC("ixgbe_get_san_mac_addr_offset");
+
 	/*
 	 * First read the EEPROM pointer to see if the MAC addresses are
 	 * available.
 	 */
 	ret_val = hw->eeprom.ops.read(hw, IXGBE_SAN_MAC_ADDR_PTR,
 				      san_mac_offset);
-	if (ret_val)
-		hw_err(hw, "eeprom read at offset %d failed\n",
-		       IXGBE_SAN_MAC_ADDR_PTR);
+	if (ret_val) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom at offset %d failed",
+			      IXGBE_SAN_MAC_ADDR_PTR);
+	}
 
 	return ret_val;
 }
 
 /**
- *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM
- *  @hw: pointer to hardware structure
- *  @san_mac_addr: SAN MAC address
+ * ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM
+ * @hw: pointer to hardware structure
+ * @san_mac_addr: SAN MAC address
  *
- *  Reads the SAN MAC address from the EEPROM, if it's available.  This is
- *  per-port, so set_lan_id() must be called before reading the addresses.
- *  set_lan_id() is called by identify_sfp(), but this cannot be relied
- *  upon for non-SFP connections, so we must call it here.
+ * Reads the SAN MAC address from the EEPROM, if it's available.  This is
+ * per-port, so set_lan_id() must be called before reading the addresses.
+ * set_lan_id() is called by identify_sfp(), but this cannot be relied
+ * upon for non-SFP connections, so we must call it here.
  **/
 s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
 {
@@ -2867,14 +3324,15 @@ s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
 	u8 i;
 	s32 ret_val;
 
+	DEBUGFUNC("ixgbe_get_san_mac_addr_generic");
+
 	/*
 	 * First read the EEPROM pointer to see if the MAC addresses are
 	 * available.  If they're not, no point in calling set_lan_id() here.
 	 */
 	ret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
 	if (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)
-
-		goto san_mac_addr_clr;
+		goto san_mac_addr_out;
 
 	/* make sure we know which port we need to program */
 	hw->mac.ops.set_lan_id(hw);
@@ -2885,35 +3343,73 @@ s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
 		ret_val = hw->eeprom.ops.read(hw, san_mac_offset,
 					      &san_mac_data);
 		if (ret_val) {
-			hw_err(hw, "eeprom read at offset %d failed\n",
-			       san_mac_offset);
-			goto san_mac_addr_clr;
+			ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+				      "eeprom read at offset %d failed",
+				      san_mac_offset);
+			goto san_mac_addr_out;
 		}
 		san_mac_addr[i * 2] = (u8)(san_mac_data);
 		san_mac_addr[i * 2 + 1] = (u8)(san_mac_data >> 8);
 		san_mac_offset++;
 	}
-	return 0;
+	return IXGBE_SUCCESS;
 
-san_mac_addr_clr:
-	/* No addresses available in this EEPROM.  It's not necessarily an
+san_mac_addr_out:
+	/*
+	 * No addresses available in this EEPROM.  It's not an
 	 * error though, so just wipe the local address and return.
 	 */
 	for (i = 0; i < 6; i++)
 		san_mac_addr[i] = 0xFF;
-	return ret_val;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_set_san_mac_addr_generic - Write the SAN MAC address to the EEPROM
+ * @hw: pointer to hardware structure
+ * @san_mac_addr: SAN MAC address
+ *
+ * Write a SAN MAC address to the EEPROM.
+ **/
+s32 ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
+{
+	s32 ret_val;
+	u16 san_mac_data, san_mac_offset;
+	u8 i;
+
+	DEBUGFUNC("ixgbe_set_san_mac_addr_generic");
+
+	/* Look for SAN mac address pointer.  If not defined, return */
+	ret_val = ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
+	if (ret_val || san_mac_offset == 0 || san_mac_offset == 0xFFFF)
+		return IXGBE_ERR_NO_SAN_ADDR_PTR;
+
+	/* Make sure we know which port we need to write */
+	hw->mac.ops.set_lan_id(hw);
+	/* Apply the port offset to the address offset */
+	(hw->bus.func) ? (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT1_OFFSET) :
+			 (san_mac_offset += IXGBE_SAN_MAC_ADDR_PORT0_OFFSET);
+
+	for (i = 0; i < 3; i++) {
+		san_mac_data = (u16)((u16)(san_mac_addr[i * 2 + 1]) << 8);
+		san_mac_data |= (u16)(san_mac_addr[i * 2]);
+		hw->eeprom.ops.write(hw, san_mac_offset, san_mac_data);
+		san_mac_offset++;
+	}
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count
- *  @hw: pointer to hardware structure
+ * ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count
+ * @hw: pointer to hardware structure
  *
- *  Read PCIe configuration space, and get the MSI-X vector count from
- *  the capabilities table.
+ * Read PCIe configuration space, and get the MSI-X vector count from
+ * the capabilities table.
  **/
 u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
 {
-	u16 msix_count;
+	u16 msix_count = 1;
 	u16 max_msix_count;
 	u16 pcie_offset;
 
@@ -2926,16 +3422,17 @@ u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		pcie_offset = IXGBE_PCIE_MSIX_82599_CAPS;
 		max_msix_count = IXGBE_MAX_MSIX_VECTORS_82599;
 		break;
 	default:
-		return 1;
+		return msix_count;
 	}
 
-	msix_count = ixgbe_read_pci_cfg_word(hw, pcie_offset);
-	if (ixgbe_removed(hw->hw_addr))
+	DEBUGFUNC("ixgbe_get_pcie_msix_count_generic");
+	msix_count = IXGBE_READ_PCIE_WORD(hw, pcie_offset);
+	if (IXGBE_REMOVED(hw->hw_addr))
 		msix_count = 0;
 	msix_count &= IXGBE_PCIE_MSIX_TBL_SZ_MASK;
 
@@ -2949,45 +3446,117 @@ u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address
- *  @hw: pointer to hardware struct
- *  @rar: receive address register index to disassociate
- *  @vmdq: VMDq pool index to remove from the rar
+ * ixgbe_insert_mac_addr_generic - Find a RAR for this mac address
+ * @hw: pointer to hardware structure
+ * @addr: Address to put into receive address register
+ * @vmdq: VMDq pool to assign
+ *
+ * Puts an ethernet address into a receive address register, or
+ * finds the rar that it is aleady in; adds to the pool list
+ **/
+s32 ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
+{
+	static const u32 NO_EMPTY_RAR_FOUND = 0xFFFFFFFF;
+	u32 first_empty_rar = NO_EMPTY_RAR_FOUND;
+	u32 rar;
+	u32 rar_low, rar_high;
+	u32 addr_low, addr_high;
+
+	DEBUGFUNC("ixgbe_insert_mac_addr_generic");
+
+	/* swap bytes for HW little endian */
+	addr_low  = addr[0] | (addr[1] << 8)
+			    | (addr[2] << 16)
+			    | (addr[3] << 24);
+	addr_high = addr[4] | (addr[5] << 8);
+
+	/*
+	 * Either find the mac_id in rar or find the first empty space.
+	 * rar_highwater points to just after the highest currently used
+	 * rar in order to shorten the search.  It grows when we add a new
+	 * rar to the top.
+	 */
+	for (rar = 0; rar < hw->mac.rar_highwater; rar++) {
+		rar_high = IXGBE_READ_REG(hw, IXGBE_RAH(rar));
+
+		if (((IXGBE_RAH_AV & rar_high) == 0)
+		    && first_empty_rar == NO_EMPTY_RAR_FOUND) {
+			first_empty_rar = rar;
+		} else if ((rar_high & 0xFFFF) == addr_high) {
+			rar_low = IXGBE_READ_REG(hw, IXGBE_RAL(rar));
+			if (rar_low == addr_low)
+				break;    /* found it already in the rars */
+		}
+	}
+
+	if (rar < hw->mac.rar_highwater) {
+		/* already there so just add to the pool bits */
+		ixgbe_set_vmdq(hw, rar, vmdq);
+	} else if (first_empty_rar != NO_EMPTY_RAR_FOUND) {
+		/* stick it into first empty RAR slot we found */
+		rar = first_empty_rar;
+		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
+	} else if (rar == hw->mac.rar_highwater) {
+		/* add it to the top of the list and inc the highwater mark */
+		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
+		hw->mac.rar_highwater++;
+	} else if (rar >= hw->mac.num_rar_entries) {
+		return IXGBE_ERR_INVALID_MAC_ADDR;
+	}
+
+	/*
+	 * If we found rar[0], make sure the default pool bit (we use pool 0)
+	 * remains cleared to be sure default pool packets will get delivered
+	 */
+	if (rar == 0)
+		ixgbe_clear_vmdq(hw, rar, 0);
+
+	return rar;
+}
+
+/**
+ * ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address
+ * @hw: pointer to hardware struct
+ * @rar: receive address register index to disassociate
+ * @vmdq: VMDq pool index to remove from the rar
  **/
 s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 {
 	u32 mpsar_lo, mpsar_hi;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_clear_vmdq_generic");
+
 	/* Make sure we are using a valid rar index range */
 	if (rar >= rar_entries) {
-		hw_dbg(hw, "RAR index %d is out of range.\n", rar);
+		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
+			     "RAR index %d is out of range.\n", rar);
 		return IXGBE_ERR_INVALID_ARGUMENT;
 	}
 
 	mpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
 	mpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));
 
-	if (ixgbe_removed(hw->hw_addr))
-		return 0;
+	if (IXGBE_REMOVED(hw->hw_addr))
+		goto done;
 
 	if (!mpsar_lo && !mpsar_hi)
-		return 0;
+		goto done;
 
 	if (vmdq == IXGBE_CLEAR_VMDQ_ALL) {
 		if (mpsar_lo) {
 			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);
-			mpsar_lo = 0;
+			mpsar_lo = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
 		}
 		if (mpsar_hi) {
 			IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);
-			mpsar_hi = 0;
+			mpsar_hi = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));
 		}
 	} else if (vmdq < 32) {
-		mpsar_lo &= ~BIT(vmdq);
+		mpsar_lo &= ~(1 << vmdq);
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar_lo);
 	} else {
-		mpsar_hi &= ~BIT(vmdq - 32);
+		mpsar_hi &= ~(1 << (vmdq - 32));
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar_hi);
 	}
 
@@ -2995,89 +3564,98 @@ s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 	if (mpsar_lo == 0 && mpsar_hi == 0 &&
 	    rar != 0 && rar != hw->mac.san_mac_rar_index)
 		hw->mac.ops.clear_rar(hw, rar);
-
-	return 0;
+done:
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address
- *  @hw: pointer to hardware struct
- *  @rar: receive address register index to associate with a VMDq index
- *  @vmdq: VMDq pool index
+ * ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address
+ * @hw: pointer to hardware struct
+ * @rar: receive address register index to associate with a VMDq index
+ * @vmdq: VMDq pool index
  **/
 s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
 {
 	u32 mpsar;
 	u32 rar_entries = hw->mac.num_rar_entries;
 
+	DEBUGFUNC("ixgbe_set_vmdq_generic");
+
 	/* Make sure we are using a valid rar index range */
 	if (rar >= rar_entries) {
-		hw_dbg(hw, "RAR index %d is out of range.\n", rar);
+		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
+			     "RAR index %d is out of range.\n", rar);
 		return IXGBE_ERR_INVALID_ARGUMENT;
 	}
 
 	if (vmdq < 32) {
 		mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_LO(rar));
-		mpsar |= BIT(vmdq);
+		mpsar |= 1 << vmdq;
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), mpsar);
 	} else {
 		mpsar = IXGBE_READ_REG(hw, IXGBE_MPSAR_HI(rar));
-		mpsar |= BIT(vmdq - 32);
+		mpsar |= 1 << (vmdq - 32);
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), mpsar);
 	}
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  This function should only be involved in the IOV mode.
- *  In IOV mode, Default pool is next pool after the number of
- *  VFs advertized and not 0.
- *  MPSAR table needs to be updated for SAN_MAC RAR [hw->mac.san_mac_rar_index]
+ * This function should only be involved in the IOV mode.
+ * In IOV mode, Default pool is next pool after the number of
+ * VFs advertized and not 0.
+ * MPSAR table needs to be updated for SAN_MAC RAR [hw->mac.san_mac_rar_index]
  *
- *  ixgbe_set_vmdq_san_mac - Associate default VMDq pool index with a rx address
- *  @hw: pointer to hardware struct
- *  @vmdq: VMDq pool index
+ * ixgbe_set_vmdq_san_mac - Associate default VMDq pool index with a rx address
+ * @hw: pointer to hardware struct
+ * @vmdq: VMDq pool index
  **/
 s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)
 {
 	u32 rar = hw->mac.san_mac_rar_index;
 
+	DEBUGFUNC("ixgbe_set_vmdq_san_mac");
+
 	if (vmdq < 32) {
-		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), BIT(vmdq));
+		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 1 << vmdq);
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 0);
 	} else {
 		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_LO(rar), 0);
-		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), BIT(vmdq - 32));
+		IXGBE_WRITE_REG(hw, IXGBE_MPSAR_HI(rar), 1 << (vmdq - 32));
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array
- *  @hw: pointer to hardware structure
+ * ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array
+ * @hw: pointer to hardware structure
  **/
 s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)
 {
 	int i;
 
+	DEBUGFUNC("ixgbe_init_uta_tables_generic");
+	hw_dbg(hw, " Clearing UTA\n");
+
 	for (i = 0; i < 128; i++)
 		IXGBE_WRITE_REG(hw, IXGBE_UTA(i), 0);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot
- *  @hw: pointer to hardware structure
- *  @vlan: VLAN id to write to VLAN filter
- *  @vlvf_bypass: true to find vlanid only, false returns first empty slot if
+ * ixgbe_find_vlvf_slot - find the vlanid or the first empty slot
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vlvf_bypass: true to find vlanid only, false returns first empty slot if
  *		  vlanid not found
  *
- *  return the VLVF index where this VLAN id should be placed
+ *
+ * return the VLVF index where this VLAN id should be placed
  *
  **/
-static s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)
+s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)
 {
 	s32 regindex, first_empty_slot;
 	u32 bits;
@@ -3112,28 +3690,30 @@ static s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass)
 	 * slot we found during our search, else error.
 	 */
 	if (!first_empty_slot)
-		hw_dbg(hw, "No space in VLVF.\n");
+		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE, "No space in VLVF.\n");
 
-	return first_empty_slot ? : IXGBE_ERR_NO_SPACE;
+	return first_empty_slot ? first_empty_slot : IXGBE_ERR_NO_SPACE;
 }
 
 /**
- *  ixgbe_set_vfta_generic - Set VLAN filter table
- *  @hw: pointer to hardware structure
- *  @vlan: VLAN id to write to VLAN filter
- *  @vind: VMDq output index that maps queue to VLAN id in VFVFB
- *  @vlan_on: boolean flag to turn on/off VLAN in VFVF
- *  @vlvf_bypass: boolean flag indicating updating default pool is okay
+ * ixgbe_set_vfta_generic - Set VLAN filter table
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vind: VMDq output index that maps queue to VLAN id in VLVFB
+ * @vlan_on: boolean flag to turn on/off VLAN
+ * @vlvf_bypass: boolean flag indicating updating default pool is okay
  *
- *  Turn on/off specified VLAN in the VLAN filter table.
+ * Turn on/off specified VLAN in the VLAN filter table.
  **/
 s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 			   bool vlan_on, bool vlvf_bypass)
 {
-	u32 regidx, vfta_delta, vfta, bits;
-	s32 vlvf_index;
+	u32 regidx, vfta_delta, vfta;
+	s32 ret_val;
+
+	DEBUGFUNC("ixgbe_set_vfta_generic");
 
-	if ((vlan > 4095) || (vind > 63))
+	if (vlan > 4095 || vind > 63)
 		return IXGBE_ERR_PARAM;
 
 	/*
@@ -3149,18 +3729,62 @@ s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 	 *    bits[4-0]:  which bit in the register
 	 */
 	regidx = vlan / 32;
-	vfta_delta = BIT(vlan % 32);
+	vfta_delta = 1 << (vlan % 32);
 	vfta = IXGBE_READ_REG(hw, IXGBE_VFTA(regidx));
 
-	/* vfta_delta represents the difference between the current value
+	/*
+	 * vfta_delta represents the difference between the current value
 	 * of vfta and the value we want in the register.  Since the diff
-	 * is an XOR mask we can just update vfta using an XOR.
+	 * is an XOR mask we can just update the vfta using an XOR
 	 */
 	vfta_delta &= vlan_on ? ~vfta : vfta;
 	vfta ^= vfta_delta;
 
 	/* Part 2
-	 * If VT Mode is set
+	 * Call ixgbe_set_vlvf_generic to set VLVFB and VLVF
+	 */
+	ret_val = ixgbe_set_vlvf_generic(hw, vlan, vind, vlan_on, &vfta_delta,
+					 vfta, vlvf_bypass);
+	if (ret_val != IXGBE_SUCCESS) {
+		if (vlvf_bypass)
+			goto vfta_update;
+		return ret_val;
+	}
+
+vfta_update:
+	/* Update VFTA now that we are ready for traffic */
+	if (vfta_delta)
+		IXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_set_vlvf_generic - Set VLAN Pool Filter
+ * @hw: pointer to hardware structure
+ * @vlan: VLAN id to write to VLAN filter
+ * @vind: VMDq output index that maps queue to VLAN id in VLVFB
+ * @vlan_on: boolean flag to turn on/off VLAN in VLVF
+ * @vfta_delta: pointer to the difference between the current value of VFTA
+ *		 and the desired value
+ * @vfta: the desired value of the VFTA
+ * @vlvf_bypass: boolean flag indicating updating default pool is okay
+ *
+ * Turn on/off specified bit in VLVF table.
+ **/
+s32 ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+			   bool vlan_on, u32 *vfta_delta, u32 vfta,
+			   bool vlvf_bypass)
+{
+	u32 bits;
+	s32 vlvf_index;
+
+	DEBUGFUNC("ixgbe_set_vlvf_generic");
+
+	if (vlan > 4095 || vind > 63)
+		return IXGBE_ERR_PARAM;
+
+	/* If VT Mode is set
 	 *   Either vlan_on
 	 *     make sure the vlan is in VLVF
 	 *     set the vind bit in the matching VLVFB
@@ -3168,24 +3792,21 @@ s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 	 *     clear the pool bit and possibly the vind
 	 */
 	if (!(IXGBE_READ_REG(hw, IXGBE_VT_CTL) & IXGBE_VT_CTL_VT_ENABLE))
-		goto vfta_update;
+		return IXGBE_SUCCESS;
 
 	vlvf_index = ixgbe_find_vlvf_slot(hw, vlan, vlvf_bypass);
-	if (vlvf_index < 0) {
-		if (vlvf_bypass)
-			goto vfta_update;
+	if (vlvf_index < 0)
 		return vlvf_index;
-	}
 
 	bits = IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32));
 
 	/* set the pool bit */
-	bits |= BIT(vind % 32);
+	bits |= 1 << (vind % 32);
 	if (vlan_on)
 		goto vlvf_update;
 
 	/* clear the pool bit */
-	bits ^= BIT(vind % 32);
+	bits ^= 1 << (vind % 32);
 
 	if (!bits &&
 	    !IXGBE_READ_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + 1 - vind / 32))) {
@@ -3193,14 +3814,14 @@ s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 		 * we run the risk of stray packets leaking into
 		 * the PF via the default pool
 		 */
-		if (vfta_delta)
-			IXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);
+		if (*vfta_delta)
+			IXGBE_WRITE_REG(hw, IXGBE_VFTA(vlan / 32), vfta);
 
 		/* disable VLVF and clear remaining bit from pool */
 		IXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), 0);
 		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), 0);
 
-		return 0;
+		return IXGBE_SUCCESS;
 	}
 
 	/* If there are still bits set in the VLVFB registers
@@ -3217,31 +3838,28 @@ s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
 	 * been cleared.  This will be indicated by "bits" being
 	 * zero.
 	 */
-	vfta_delta = 0;
+	*vfta_delta = 0;
 
 vlvf_update:
 	/* record pool change and enable VLAN ID if not already enabled */
 	IXGBE_WRITE_REG(hw, IXGBE_VLVFB(vlvf_index * 2 + vind / 32), bits);
 	IXGBE_WRITE_REG(hw, IXGBE_VLVF(vlvf_index), IXGBE_VLVF_VIEN | vlan);
 
-vfta_update:
-	/* Update VFTA now that we are ready for traffic */
-	if (vfta_delta)
-		IXGBE_WRITE_REG(hw, IXGBE_VFTA(regidx), vfta);
-
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_clear_vfta_generic - Clear VLAN filter table
- *  @hw: pointer to hardware structure
+ * ixgbe_clear_vfta_generic - Clear VLAN filter table
+ * @hw: pointer to hardware structure
  *
- *  Clears the VLAN filer table, and the VMDq index associated with the filter
+ * Clears the VLAN filer table, and the VMDq index associated with the filter
  **/
 s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
 {
 	u32 offset;
 
+	DEBUGFUNC("ixgbe_clear_vfta_generic");
+
 	for (offset = 0; offset < hw->mac.vft_size; offset++)
 		IXGBE_WRITE_REG(hw, IXGBE_VFTA(offset), 0);
 
@@ -3251,18 +3869,74 @@ s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
 		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(offset * 2 + 1), 0);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_toggle_txdctl_generic - Toggle VF's queues
+ * @hw: pointer to hardware structure
+ * @vf_number: VF index
+ *
+ * Enable and disable each queue in VF.
+ */
+s32 ixgbe_toggle_txdctl_generic(struct ixgbe_hw *hw, u32 vf_number)
+{
+	u8  queue_count, i;
+	u32 offset, reg;
+
+	if (vf_number > 63)
+		return IXGBE_ERR_PARAM;
+
+	/*
+	 * Determine number of queues by checking
+	 * number of virtual functions
+	 */
+	reg = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
+	switch (reg & IXGBE_GCR_EXT_VT_MODE_MASK) {
+	case IXGBE_GCR_EXT_VT_MODE_64:
+		queue_count = 2;
+		break;
+	case IXGBE_GCR_EXT_VT_MODE_32:
+		queue_count = 4;
+		break;
+	case IXGBE_GCR_EXT_VT_MODE_16:
+		queue_count = 8;
+		break;
+	default:
+		return IXGBE_ERR_CONFIG;
+	}
+
+	/* Toggle queues */
+	for (i = 0; i < queue_count; ++i) {
+		/* Calculate offset of current queue */
+		offset = queue_count * vf_number + i;
+
+		/* Enable queue */
+		reg = IXGBE_READ_REG(hw, IXGBE_PVFTXDCTL(offset));
+		reg |= IXGBE_TXDCTL_ENABLE;
+		IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(offset), reg);
+		IXGBE_WRITE_FLUSH(hw);
+
+		/* Disable queue */
+		reg = IXGBE_READ_REG(hw, IXGBE_PVFTXDCTL(offset));
+		reg &= ~IXGBE_TXDCTL_ENABLE;
+		IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(offset), reg);
+		IXGBE_WRITE_FLUSH(hw);
+	}
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_need_crosstalk_fix - Determine if we need to do cross talk fix
- *  @hw: pointer to hardware structure
+ * ixgbe_need_crosstalk_fix - Determine if we need to do cross talk fix
+ * @hw: pointer to hardware structure
  *
- *  Contains the logic to identify if we need to verify link for the
- *  crosstalk fix
+ * Contains the logic to identify if we need to verify link for the
+ * crosstalk fix
  **/
 static bool ixgbe_need_crosstalk_fix(struct ixgbe_hw *hw)
 {
+
 	/* Does FW say we need the fix */
 	if (!hw->need_crosstalk_fix)
 		return false;
@@ -3280,13 +3954,13 @@ static bool ixgbe_need_crosstalk_fix(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_check_mac_link_generic - Determine link and speed status
- *  @hw: pointer to hardware structure
- *  @speed: pointer to link speed
- *  @link_up: true when link is up
- *  @link_up_wait_to_complete: bool used to wait for link up or not
+ * ixgbe_check_mac_link_generic - Determine link and speed status
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @link_up: true when link is up
+ * @link_up_wait_to_complete: bool used to wait for link up or not
  *
- *  Reads the links register to determine if link is up and the current speed
+ * Reads the links register to determine if link is up and the current speed
  **/
 s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 				 bool *link_up, bool link_up_wait_to_complete)
@@ -3294,6 +3968,8 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 	u32 links_reg, links_orig;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_check_mac_link_generic");
+
 	/* If Crosstalk fix enabled do the sanity check of making sure
 	 * the SFP+ cage is full.
 	 */
@@ -3306,7 +3982,7 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 					IXGBE_ESDP_SDP2;
 			break;
 		case ixgbe_mac_X550EM_x:
-		case ixgbe_mac_x550em_a:
+		case ixgbe_mac_X550EM_a:
 			sfp_cage_full = IXGBE_READ_REG(hw, IXGBE_ESDP) &
 					IXGBE_ESDP_SDP0;
 			break;
@@ -3319,7 +3995,7 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 		if (!sfp_cage_full) {
 			*link_up = false;
 			*speed = IXGBE_LINK_SPEED_UNKNOWN;
-			return 0;
+			return IXGBE_SUCCESS;
 		}
 	}
 
@@ -3330,18 +4006,18 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 
 	if (links_orig != links_reg) {
 		hw_dbg(hw, "LINKS changed from %08X to %08X\n",
-		       links_orig, links_reg);
+			  links_orig, links_reg);
 	}
 
 	if (link_up_wait_to_complete) {
-		for (i = 0; i < IXGBE_LINK_UP_TIME; i++) {
+		for (i = 0; i < hw->mac.max_link_up_time; i++) {
 			if (links_reg & IXGBE_LINKS_UP) {
 				*link_up = true;
 				break;
 			} else {
 				*link_up = false;
 			}
-			msleep(100);
+			msec_delay(100);
 			links_reg = IXGBE_READ_REG(hw, IXGBE_LINKS);
 		}
 	} else {
@@ -3353,52 +4029,53 @@ s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 
 	switch (links_reg & IXGBE_LINKS_SPEED_82599) {
 	case IXGBE_LINKS_SPEED_10G_82599:
-		if ((hw->mac.type >= ixgbe_mac_X550) &&
-		    (links_reg & IXGBE_LINKS_SPEED_NON_STD))
-			*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
-		else
-			*speed = IXGBE_LINK_SPEED_10GB_FULL;
+		*speed = IXGBE_LINK_SPEED_10GB_FULL;
+		if (hw->mac.type >= ixgbe_mac_X550) {
+			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
+				*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
+		}
 		break;
 	case IXGBE_LINKS_SPEED_1G_82599:
 		*speed = IXGBE_LINK_SPEED_1GB_FULL;
 		break;
 	case IXGBE_LINKS_SPEED_100_82599:
-		if ((hw->mac.type >= ixgbe_mac_X550) &&
-		    (links_reg & IXGBE_LINKS_SPEED_NON_STD))
-			*speed = IXGBE_LINK_SPEED_5GB_FULL;
-		else
-			*speed = IXGBE_LINK_SPEED_100_FULL;
+		*speed = IXGBE_LINK_SPEED_100_FULL;
+		if (hw->mac.type == ixgbe_mac_X550) {
+			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
+				*speed = IXGBE_LINK_SPEED_5GB_FULL;
+		}
 		break;
 	case IXGBE_LINKS_SPEED_10_X550EM_A:
 		*speed = IXGBE_LINK_SPEED_UNKNOWN;
 		if (hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T ||
-		    hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T_L) {
+		    hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T_L)
 			*speed = IXGBE_LINK_SPEED_10_FULL;
-		}
 		break;
 	default:
 		*speed = IXGBE_LINK_SPEED_UNKNOWN;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_get_wwn_prefix_generic - Get alternative WWNN/WWPN prefix from
- *  the EEPROM
- *  @hw: pointer to hardware structure
- *  @wwnn_prefix: the alternative WWNN prefix
- *  @wwpn_prefix: the alternative WWPN prefix
+ * ixgbe_get_wwn_prefix_generic - Get alternative WWNN/WWPN prefix from
+ * the EEPROM
+ * @hw: pointer to hardware structure
+ * @wwnn_prefix: the alternative WWNN prefix
+ * @wwpn_prefix: the alternative WWPN prefix
  *
- *  This function will read the EEPROM from the alternative SAN MAC address
- *  block to check the support for the alternative WWNN/WWPN prefix support.
+ * This function will read the EEPROM from the alternative SAN MAC address
+ * block to check the support for the alternative WWNN/WWPN prefix support.
  **/
 s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,
-					u16 *wwpn_prefix)
+				 u16 *wwpn_prefix)
 {
 	u16 offset, caps;
 	u16 alt_san_mac_blk_offset;
 
+	DEBUGFUNC("ixgbe_get_wwn_prefix_generic");
+
 	/* clear output first */
 	*wwnn_prefix = 0xFFFF;
 	*wwpn_prefix = 0xFFFF;
@@ -3410,36 +4087,89 @@ s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,
 
 	if ((alt_san_mac_blk_offset == 0) ||
 	    (alt_san_mac_blk_offset == 0xFFFF))
-		return 0;
+		goto wwn_prefix_out;
 
 	/* check capability in alternative san mac address block */
 	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET;
 	if (hw->eeprom.ops.read(hw, offset, &caps))
 		goto wwn_prefix_err;
 	if (!(caps & IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN))
-		return 0;
+		goto wwn_prefix_out;
 
 	/* get the corresponding prefix for WWNN/WWPN */
 	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET;
-	if (hw->eeprom.ops.read(hw, offset, wwnn_prefix))
-		hw_err(hw, "eeprom read at offset %d failed\n", offset);
+	if (hw->eeprom.ops.read(hw, offset, wwnn_prefix)) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom read at offset %d failed", offset);
+	}
 
 	offset = alt_san_mac_blk_offset + IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET;
 	if (hw->eeprom.ops.read(hw, offset, wwpn_prefix))
 		goto wwn_prefix_err;
 
-	return 0;
+wwn_prefix_out:
+	return IXGBE_SUCCESS;
 
 wwn_prefix_err:
-	hw_err(hw, "eeprom read at offset %d failed\n", offset);
-	return 0;
+	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+		      "eeprom read at offset %d failed", offset);
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_get_fcoe_boot_status_generic - Get FCOE boot status from EEPROM
+ * @hw: pointer to hardware structure
+ * @bs: the fcoe boot status
+ *
+ * This function will read the FCOE boot status from the iSCSI FCOE block
+ **/
+s32 ixgbe_get_fcoe_boot_status_generic(struct ixgbe_hw *hw, u16 *bs)
+{
+	u16 offset, caps, flags;
+	s32 status;
+
+	DEBUGFUNC("ixgbe_get_fcoe_boot_status_generic");
+
+	/* clear output first */
+	*bs = ixgbe_fcoe_bootstatus_unavailable;
+
+	/* check if FCOE IBA block is present */
+	offset = IXGBE_FCOE_IBA_CAPS_BLK_PTR;
+	status = hw->eeprom.ops.read(hw, offset, &caps);
+	if (status != IXGBE_SUCCESS)
+		goto out;
+
+	if (!(caps & IXGBE_FCOE_IBA_CAPS_FCOE))
+		goto out;
+
+	/* check if iSCSI FCOE block is populated */
+	status = hw->eeprom.ops.read(hw, IXGBE_ISCSI_FCOE_BLK_PTR, &offset);
+	if (status != IXGBE_SUCCESS)
+		goto out;
+
+	if ((offset == 0) || (offset == 0xFFFF))
+		goto out;
+
+	/* read fcoe flags in iSCSI FCOE block */
+	offset = offset + IXGBE_ISCSI_FCOE_FLAGS_OFFSET;
+	status = hw->eeprom.ops.read(hw, offset, &flags);
+	if (status != IXGBE_SUCCESS)
+		goto out;
+
+	if (flags & IXGBE_ISCSI_FCOE_FLAGS_ENABLE)
+		*bs = ixgbe_fcoe_bootstatus_enabled;
+	else
+		*bs = ixgbe_fcoe_bootstatus_disabled;
+
+out:
+	return status;
 }
 
 /**
- *  ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing
- *  @hw: pointer to hardware structure
- *  @enable: enable or disable switch for MAC anti-spoofing
- *  @vf: Virtual Function pool - VF Pool to set for MAC anti-spoofing
+ * ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable switch for MAC anti-spoofing
+ * @vf: Virtual Function pool - VF Pool to set for MAC anti-spoofing
  *
  **/
 void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
@@ -3453,17 +4183,17 @@ void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
 
 	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
 	if (enable)
-		pfvfspoof |= BIT(vf_target_shift);
+		pfvfspoof |= (1 << vf_target_shift);
 	else
-		pfvfspoof &= ~BIT(vf_target_shift);
+		pfvfspoof &= ~(1 << vf_target_shift);
 	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);
 }
 
 /**
- *  ixgbe_set_vlan_anti_spoofing - Enable/Disable VLAN anti-spoofing
- *  @hw: pointer to hardware structure
- *  @enable: enable or disable switch for VLAN anti-spoofing
- *  @vf: Virtual Function pool - VF Pool to set for VLAN anti-spoofing
+ * ixgbe_set_vlan_anti_spoofing - Enable/Disable VLAN anti-spoofing
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable switch for VLAN anti-spoofing
+ * @vf: Virtual Function pool - VF Pool to set for VLAN anti-spoofing
  *
  **/
 void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
@@ -3477,106 +4207,43 @@ void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
 
 	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
 	if (enable)
-		pfvfspoof |= BIT(vf_target_shift);
+		pfvfspoof |= (1 << vf_target_shift);
 	else
-		pfvfspoof &= ~BIT(vf_target_shift);
+		pfvfspoof &= ~(1 << vf_target_shift);
 	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);
 }
 
 /**
- *  ixgbe_get_device_caps_generic - Get additional device capabilities
- *  @hw: pointer to hardware structure
- *  @device_caps: the EEPROM word with the extra device capabilities
+ * ixgbe_get_device_caps_generic - Get additional device capabilities
+ * @hw: pointer to hardware structure
+ * @device_caps: the EEPROM word with the extra device capabilities
  *
- *  This function will read the EEPROM location for the device capabilities,
- *  and return the word through device_caps.
+ * This function will read the EEPROM location for the device capabilities,
+ * and return the word through device_caps.
  **/
 s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps)
 {
-	hw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);
-
-	return 0;
-}
-
-/**
- * ixgbe_set_rxpba_generic - Initialize RX packet buffer
- * @hw: pointer to hardware structure
- * @num_pb: number of packet buffers to allocate
- * @headroom: reserve n KB of headroom
- * @strategy: packet buffer allocation strategy
- **/
-void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw,
-			     int num_pb,
-			     u32 headroom,
-			     int strategy)
-{
-	u32 pbsize = hw->mac.rx_pb_size;
-	int i = 0;
-	u32 rxpktsize, txpktsize, txpbthresh;
-
-	/* Reserve headroom */
-	pbsize -= headroom;
-
-	if (!num_pb)
-		num_pb = 1;
-
-	/* Divide remaining packet buffer space amongst the number
-	 * of packet buffers requested using supplied strategy.
-	 */
-	switch (strategy) {
-	case (PBA_STRATEGY_WEIGHTED):
-		/* pba_80_48 strategy weight first half of packet buffer with
-		 * 5/8 of the packet buffer space.
-		 */
-		rxpktsize = ((pbsize * 5 * 2) / (num_pb * 8));
-		pbsize -= rxpktsize * (num_pb / 2);
-		rxpktsize <<= IXGBE_RXPBSIZE_SHIFT;
-		for (; i < (num_pb / 2); i++)
-			IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);
-		fallthrough; /* configure remaining packet buffers */
-	case (PBA_STRATEGY_EQUAL):
-		/* Divide the remaining Rx packet buffer evenly among the TCs */
-		rxpktsize = (pbsize / (num_pb - i)) << IXGBE_RXPBSIZE_SHIFT;
-		for (; i < num_pb; i++)
-			IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);
-		break;
-	default:
-		break;
-	}
+	DEBUGFUNC("ixgbe_get_device_caps_generic");
 
-	/*
-	 * Setup Tx packet buffer and threshold equally for all TCs
-	 * TXPBTHRESH register is set in K so divide by 1024 and subtract
-	 * 10 since the largest packet we support is just over 9K.
-	 */
-	txpktsize = IXGBE_TXPBSIZE_MAX / num_pb;
-	txpbthresh = (txpktsize / 1024) - IXGBE_TXPKT_SIZE_MAX;
-	for (i = 0; i < num_pb; i++) {
-		IXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), txpktsize);
-		IXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), txpbthresh);
-	}
+	hw->eeprom.ops.read(hw, IXGBE_DEVICE_CAPS, device_caps);
 
-	/* Clear unused TCs, if any, to zero buffer size*/
-	for (; i < IXGBE_MAX_PB; i++) {
-		IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);
-		IXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), 0);
-		IXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), 0);
-	}
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_calculate_checksum - Calculate checksum for buffer
- *  @buffer: pointer to EEPROM
- *  @length: size of EEPROM to calculate a checksum for
- *
- *  Calculates the checksum for some buffer on a specified length.  The
- *  checksum calculated is returned.
+ * ixgbe_calculate_checksum - Calculate checksum for buffer
+ * @buffer: pointer to EEPROM
+ * @length: size of EEPROM to calculate a checksum for
+ * Calculates the checksum for some buffer on a specified length.  The
+ * checksum calculated is returned.
  **/
 u8 ixgbe_calculate_checksum(u8 *buffer, u32 length)
 {
 	u32 i;
 	u8 sum = 0;
 
+	DEBUGFUNC("ixgbe_calculate_checksum");
+
 	if (!buffer)
 		return 0;
 
@@ -3587,18 +4254,18 @@ u8 ixgbe_calculate_checksum(u8 *buffer, u32 length)
 }
 
 /**
- *  ixgbe_hic_unlocked - Issue command to manageability block unlocked
- *  @hw: pointer to the HW structure
- *  @buffer: command to write and where the return status will be placed
- *  @length: length of buffer, must be multiple of 4 bytes
- *  @timeout: time in ms to wait for command completion
+ * ixgbe_hic_unlocked - Issue command to manageability block unlocked
+ * @hw: pointer to the HW structure
+ * @buffer: command to write and where the return status will be placed
+ * @length: length of buffer, must be multiple of 4 bytes
+ * @timeout: time in ms to wait for command completion
  *
- *  Communicates with the manageability block. On success return 0
- *  else returns semaphore error when encountering an error acquiring
- *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
+ * Communicates with the manageability block. On success return IXGBE_SUCCESS
+ * else returns semaphore error when encountering an error acquiring
+ * semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
  *
- *  This function assumes that the IXGBE_GSSR_SW_MNG_SM semaphore is held
- *  by the caller.
+ * This function assumes that the IXGBE_GSSR_SW_MNG_SM semaphore is held
+ * by the caller.
  **/
 s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length,
 		       u32 timeout)
@@ -3606,8 +4273,10 @@ s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length,
 	u32 hicr, i, fwsts;
 	u16 dword_len;
 
+	DEBUGFUNC("ixgbe_hic_unlocked");
+
 	if (!length || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
-		hw_dbg(hw, "Buffer length failure buffersize-%d.\n", length);
+		hw_dbg(hw, "Buffer length failure buffersize=%d.\n", length);
 		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
 	}
 
@@ -3635,7 +4304,7 @@ s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length,
 	 */
 	for (i = 0; i < dword_len; i++)
 		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_FLEX_MNG,
-				      i, (__force u32)cpu_to_le32(buffer[i]));
+				      i, IXGBE_CPU_TO_LE32(buffer[i]));
 
 	/* Setting this bit tells the ARC that a new command is pending. */
 	IXGBE_WRITE_REG(hw, IXGBE_HICR, hicr | IXGBE_HICR_C);
@@ -3644,51 +4313,62 @@ s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 length,
 		hicr = IXGBE_READ_REG(hw, IXGBE_HICR);
 		if (!(hicr & IXGBE_HICR_C))
 			break;
-		usleep_range(1000, 2000);
+		msec_delay(1);
 	}
 
-	/* Check command successful completion. */
+	/* For each command except "Apply Update" perform
+	 * status checks in the HICR registry.
+	 */
+	if ((buffer[0] & IXGBE_HOST_INTERFACE_MASK_CMD) ==
+	    IXGBE_HOST_INTERFACE_APPLY_UPDATE_CMD)
+		return IXGBE_SUCCESS;
+
+	/* Check command completion */
 	if ((timeout && i == timeout) ||
-	    !(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV))
+	    !(IXGBE_READ_REG(hw, IXGBE_HICR) & IXGBE_HICR_SV)) {
+		ERROR_REPORT1(IXGBE_ERROR_CAUTION,
+			      "Command has failed with no status valid.\n");
 		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
+	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_host_interface_command - Issue command to manageability block
- *  @hw: pointer to the HW structure
- *  @buffer: contains the command to write and where the return status will
- *           be placed
- *  @length: length of buffer, must be multiple of 4 bytes
- *  @timeout: time in ms to wait for command completion
- *  @return_data: read and return data from the buffer (true) or not (false)
+ * ixgbe_host_interface_command - Issue command to manageability block
+ * @hw: pointer to the HW structure
+ * @buffer: contains the command to write and where the return status will
+ *  be placed
+ * @length: length of buffer, must be multiple of 4 bytes
+ * @timeout: time in ms to wait for command completion
+ * @return_data: read and return data from the buffer (true) or not (false)
  *  Needed because FW structures are big endian and decoding of
  *  these fields can be 8 bit or 16 bit based on command. Decoding
  *  is not easily understood without making a table of commands.
  *  So we will leave this up to the caller to read back the data
  *  in these cases.
  *
- *  Communicates with the manageability block.  On success return 0
- *  else return IXGBE_ERR_HOST_INTERFACE_COMMAND.
+ * Communicates with the manageability block. On success return IXGBE_SUCCESS
+ * else returns semaphore error when encountering an error acquiring
+ * semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
  **/
-s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer,
-				 u32 length, u32 timeout,
-				 bool return_data)
+s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,
+				 u32 length, u32 timeout, bool return_data)
 {
 	u32 hdr_size = sizeof(struct ixgbe_hic_hdr);
-	union {
-		struct ixgbe_hic_hdr hdr;
-		u32 u32arr[1];
-	} *bp = buffer;
-	u16 buf_len, dword_len;
+	struct ixgbe_hic_hdr *resp = (struct ixgbe_hic_hdr *)buffer;
+	u16 buf_len;
 	s32 status;
 	u32 bi;
+	u32 dword_len;
 
-	if (!length || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
-		hw_dbg(hw, "Buffer length failure buffersize-%d.\n", length);
+	DEBUGFUNC("ixgbe_host_interface_command");
+
+	if (length == 0 || length > IXGBE_HI_MAX_BLOCK_BYTE_LENGTH) {
+		hw_dbg(hw, "Buffer length failure buffersize=%d.\n", length);
 		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
 	}
+
 	/* Take management host interface semaphore */
 	status = hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_SW_MNG_SM);
 	if (status)
@@ -3706,16 +4386,31 @@ s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer,
 
 	/* first pull in the header so we know the buffer length */
 	for (bi = 0; bi < dword_len; bi++) {
-		bp->u32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
-		le32_to_cpus(&bp->u32arr[bi]);
+		buffer[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
+		IXGBE_LE32_TO_CPUS(&buffer[bi]);
 	}
 
-	/* If there is any thing in data position pull it in */
-	buf_len = bp->hdr.buf_len;
+	/*
+	 * If there is any thing in data position pull it in
+	 * Read Flash command requires reading buffer length from
+	 * two byes instead of one byte
+	 */
+	if (resp->cmd == 0x30 || resp->cmd == 0x31) {
+		for (; bi < dword_len + 2; bi++) {
+			buffer[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG,
+							  bi);
+			IXGBE_LE32_TO_CPUS(&buffer[bi]);
+		}
+		buf_len = (((u16)(resp->cmd_or_resp.ret_status) << 3)
+				  & 0xF00) | resp->buf_len;
+		hdr_size += (2 << 2);
+	} else {
+		buf_len = resp->buf_len;
+	}
 	if (!buf_len)
 		goto rel_out;
 
-	if (length < round_up(buf_len, 4) + hdr_size) {
+	if (length < buf_len + hdr_size) {
 		hw_dbg(hw, "Buffer not large enough for reply message.\n");
 		status = IXGBE_ERR_HOST_INTERFACE_COMMAND;
 		goto rel_out;
@@ -3726,8 +4421,8 @@ s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer,
 
 	/* Pull in the rest of the buffer (bi is where we left off) */
 	for (; bi <= dword_len; bi++) {
-		bp->u32arr[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
-		le32_to_cpus(&bp->u32arr[bi]);
+		buffer[bi] = IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG, bi);
+		IXGBE_LE32_TO_CPUS(&buffer[bi]);
 	}
 
 rel_out:
@@ -3737,32 +4432,35 @@ s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *buffer,
 }
 
 /**
- *  ixgbe_set_fw_drv_ver_generic - Sends driver version to firmware
- *  @hw: pointer to the HW structure
- *  @maj: driver version major number
- *  @min: driver version minor number
- *  @build: driver version build number
- *  @sub: driver version sub build number
- *  @len: length of driver_ver string
- *  @driver_ver: driver string
+ * ixgbe_set_fw_drv_ver_generic - Sends driver version to firmware
+ * @hw: pointer to the HW structure
+ * @maj: driver version major number
+ * @min: driver version minor number
+ * @build: driver version build number
+ * @sub: driver version sub build number
+ * @len: unused
+ * @driver_ver: unused
  *
- *  Sends driver version number to firmware through the manageability
- *  block.  On success return 0
- *  else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring
- *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
+ * Sends driver version number to firmware through the manageability
+ * block.  On success return IXGBE_SUCCESS
+ * else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring
+ * semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
  **/
 s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
-				 u8 build, u8 sub, __always_unused u16 len,
-				 __always_unused const char *driver_ver)
+				 u8 build, u8 sub, u16 len,
+				 const char *driver_ver)
 {
 	struct ixgbe_hic_drv_info fw_cmd;
 	int i;
-	s32 ret_val;
+	s32 ret_val = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_set_fw_drv_ver_generic");
+	UNREFERENCED_2PARAMETER(len, driver_ver);
 
 	fw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;
 	fw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN;
 	fw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;
-	fw_cmd.port_num = hw->bus.func;
+	fw_cmd.port_num = (u8)hw->bus.func;
 	fw_cmd.ver_maj = maj;
 	fw_cmd.ver_min = min;
 	fw_cmd.ver_build = build;
@@ -3774,16 +4472,16 @@ s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
 				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));
 
 	for (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {
-		ret_val = ixgbe_host_interface_command(hw, &fw_cmd,
+		ret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,
 						       sizeof(fw_cmd),
 						       IXGBE_HI_COMMAND_TIMEOUT,
 						       true);
-		if (ret_val != 0)
+		if (ret_val != IXGBE_SUCCESS)
 			continue;
 
 		if (fw_cmd.hdr.cmd_or_resp.ret_status ==
 		    FW_CEM_RESP_STATUS_SUCCESS)
-			ret_val = 0;
+			ret_val = IXGBE_SUCCESS;
 		else
 			ret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;
 
@@ -3793,6 +4491,65 @@ s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
 	return ret_val;
 }
 
+/**
+ * ixgbe_set_rxpba_generic - Initialize Rx packet buffer
+ * @hw: pointer to hardware structure
+ * @num_pb: number of packet buffers to allocate
+ * @headroom: reserve n KB of headroom
+ * @strategy: packet buffer allocation strategy
+ **/
+void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom,
+			     int strategy)
+{
+	u32 pbsize = hw->mac.rx_pb_size;
+	int i = 0;
+	u32 rxpktsize, txpktsize, txpbthresh;
+
+	/* Reserve headroom */
+	pbsize -= headroom;
+
+	if (!num_pb)
+		num_pb = 1;
+
+	/* Divide remaining packet buffer space amongst the number of packet
+	 * buffers requested using supplied strategy.
+	 */
+	switch (strategy) {
+	case PBA_STRATEGY_WEIGHTED:
+		/* ixgbe_dcb_pba_80_48 strategy weight first half of packet
+		 * buffer with 5/8 of the packet buffer space.
+		 */
+		rxpktsize = (pbsize * 5) / (num_pb * 4);
+		pbsize -= rxpktsize * (num_pb / 2);
+		rxpktsize <<= IXGBE_RXPBSIZE_SHIFT;
+		for (; i < (num_pb / 2); i++)
+			IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);
+		/* fall through - configure remaining packet buffers */
+	case PBA_STRATEGY_EQUAL:
+		rxpktsize = (pbsize / (num_pb - i)) << IXGBE_RXPBSIZE_SHIFT;
+		for (; i < num_pb; i++)
+			IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), rxpktsize);
+		break;
+	default:
+		break;
+	}
+
+	/* Only support an equally distributed Tx packet buffer strategy. */
+	txpktsize = IXGBE_TXPBSIZE_MAX / num_pb;
+	txpbthresh = (txpktsize / 1024) - IXGBE_TXPKT_SIZE_MAX;
+	for (i = 0; i < num_pb; i++) {
+		IXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), txpktsize);
+		IXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), txpbthresh);
+	}
+
+	/* Clear unused TCs, if any, to zero buffer size*/
+	for (; i < IXGBE_MAX_PB; i++) {
+		IXGBE_WRITE_REG(hw, IXGBE_RXPBSIZE(i), 0);
+		IXGBE_WRITE_REG(hw, IXGBE_TXPBSIZE(i), 0);
+		IXGBE_WRITE_REG(hw, IXGBE_TXPBTHRESH(i), 0);
+	}
+}
+
 /**
  * ixgbe_clear_tx_pending - Clear pending TX work from the PCIe fifo
  * @hw: pointer to the hardware structure
@@ -3821,23 +4578,25 @@ void ixgbe_clear_tx_pending(struct ixgbe_hw *hw)
 	hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
 	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0 | IXGBE_HLREG0_LPBK);
 
-	/* wait for a last completion before clearing buffers */
+	/* Wait for a last completion before clearing buffers */
 	IXGBE_WRITE_FLUSH(hw);
-	usleep_range(3000, 6000);
+	msec_delay(3);
 
-	/* Before proceeding, make sure that the PCIe block does not have
+	/*
+	 * Before proceeding, make sure that the PCIe block does not have
 	 * transactions pending.
 	 */
 	poll = ixgbe_pcie_timeout_poll(hw);
 	for (i = 0; i < poll; i++) {
-		usleep_range(100, 200);
-		value = ixgbe_read_pci_cfg_word(hw, IXGBE_PCI_DEVICE_STATUS);
-		if (ixgbe_removed(hw->hw_addr))
-			break;
+		usec_delay(100);
+		value = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_DEVICE_STATUS);
+		if (IXGBE_REMOVED(hw->hw_addr))
+			goto out;
 		if (!(value & IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING))
-			break;
+			goto out;
 	}
 
+out:
 	/* initiate cleaning flow for buffers in the PCIe transaction layer */
 	gcr_ext = IXGBE_READ_REG(hw, IXGBE_GCR_EXT);
 	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT,
@@ -3845,20 +4604,20 @@ void ixgbe_clear_tx_pending(struct ixgbe_hw *hw)
 
 	/* Flush all writes and allow 20usec for all transactions to clear */
 	IXGBE_WRITE_FLUSH(hw);
-	udelay(20);
+	usec_delay(20);
 
 	/* restore previous register values */
 	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);
 	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
 }
 
-static const u8 ixgbe_emc_temp_data[4] = {
+STATIC const u8 ixgbe_emc_temp_data[4] = {
 	IXGBE_EMC_INTERNAL_DATA,
 	IXGBE_EMC_DIODE1_DATA,
 	IXGBE_EMC_DIODE2_DATA,
 	IXGBE_EMC_DIODE3_DATA
 };
-static const u8 ixgbe_emc_therm_limit[4] = {
+STATIC const u8 ixgbe_emc_therm_limit[4] = {
 	IXGBE_EMC_INTERNAL_THERM_LIMIT,
 	IXGBE_EMC_DIODE1_THERM_LIMIT,
 	IXGBE_EMC_DIODE2_THERM_LIMIT,
@@ -3866,71 +4625,60 @@ static const u8 ixgbe_emc_therm_limit[4] = {
 };
 
 /**
- *  ixgbe_get_ets_data - Extracts the ETS bit data
- *  @hw: pointer to hardware structure
- *  @ets_cfg: extected ETS data
- *  @ets_offset: offset of ETS data
- *
- *  Returns error code.
- **/
-static s32 ixgbe_get_ets_data(struct ixgbe_hw *hw, u16 *ets_cfg,
-			      u16 *ets_offset)
-{
-	s32 status;
-
-	status = hw->eeprom.ops.read(hw, IXGBE_ETS_CFG, ets_offset);
-	if (status)
-		return status;
-
-	if ((*ets_offset == 0x0000) || (*ets_offset == 0xFFFF))
-		return IXGBE_NOT_IMPLEMENTED;
-
-	status = hw->eeprom.ops.read(hw, *ets_offset, ets_cfg);
-	if (status)
-		return status;
-
-	if ((*ets_cfg & IXGBE_ETS_TYPE_MASK) != IXGBE_ETS_TYPE_EMC_SHIFTED)
-		return IXGBE_NOT_IMPLEMENTED;
-
-	return 0;
-}
-
-/**
- *  ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
- *  @hw: pointer to hardware structure
+ * ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
+ * @hw: pointer to hardware structure
  *
- *  Returns the thermal sensor data structure
+ * Returns the thermal sensor data structure
  **/
 s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u16 ets_offset;
 	u16 ets_cfg;
 	u16 ets_sensor;
 	u8  num_sensors;
+	u8  sensor_index;
+	u8  sensor_location;
 	u8  i;
 	struct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;
 
-	/* Only support thermal sensors attached to physical port 0 */
-	if ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))
-		return IXGBE_NOT_IMPLEMENTED;
+	DEBUGFUNC("ixgbe_get_thermal_sensor_data_generic");
 
-	status = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);
+	/* Only support thermal sensors attached to 82599 physical port 0 */
+	if ((hw->mac.type != ixgbe_mac_82599EB) ||
+	    (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1)) {
+		status = IXGBE_NOT_IMPLEMENTED;
+		goto out;
+	}
+
+	status = hw->eeprom.ops.read(hw, IXGBE_ETS_CFG, &ets_offset);
 	if (status)
-		return status;
+		goto out;
+
+	if ((ets_offset == 0x0000) || (ets_offset == 0xFFFF)) {
+		status = IXGBE_NOT_IMPLEMENTED;
+		goto out;
+	}
+
+	status = hw->eeprom.ops.read(hw, ets_offset, &ets_cfg);
+	if (status)
+		goto out;
+
+	if (((ets_cfg & IXGBE_ETS_TYPE_MASK) >> IXGBE_ETS_TYPE_SHIFT)
+		!= IXGBE_ETS_TYPE_EMC) {
+		status = IXGBE_NOT_IMPLEMENTED;
+		goto out;
+	}
 
 	num_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);
 	if (num_sensors > IXGBE_MAX_SENSORS)
 		num_sensors = IXGBE_MAX_SENSORS;
 
 	for (i = 0; i < num_sensors; i++) {
-		u8  sensor_index;
-		u8  sensor_location;
-
 		status = hw->eeprom.ops.read(hw, (ets_offset + 1 + i),
 					     &ets_sensor);
 		if (status)
-			return status;
+			goto out;
 
 		sensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>
 				IXGBE_ETS_DATA_INDEX_SHIFT);
@@ -3943,11 +4691,11 @@ s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)
 					IXGBE_I2C_THERMAL_SENSOR_ADDR,
 					&data->sensor[i].temp);
 			if (status)
-				return status;
+				goto out;
 		}
 	}
-
-	return 0;
+out:
+	return status;
 }
 
 /**
@@ -3959,39 +4707,51 @@ s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)
  **/
 s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
+	u16 offset;
 	u16 ets_offset;
 	u16 ets_cfg;
 	u16 ets_sensor;
 	u8  low_thresh_delta;
 	u8  num_sensors;
+	u8  sensor_index;
+	u8  sensor_location;
 	u8  therm_limit;
 	u8  i;
 	struct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;
 
+	DEBUGFUNC("ixgbe_init_thermal_sensor_thresh_generic");
+
 	memset(data, 0, sizeof(struct ixgbe_thermal_sensor_data));
 
-	/* Only support thermal sensors attached to physical port 0 */
-	if ((IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))
+	/* Only support thermal sensors attached to 82599 physical port 0 */
+	if ((hw->mac.type != ixgbe_mac_82599EB) ||
+	    (IXGBE_READ_REG(hw, IXGBE_STATUS) & IXGBE_STATUS_LAN_ID_1))
 		return IXGBE_NOT_IMPLEMENTED;
 
-	status = ixgbe_get_ets_data(hw, &ets_cfg, &ets_offset);
-	if (status)
-		return status;
+	offset = IXGBE_ETS_CFG;
+	if (hw->eeprom.ops.read(hw, offset, &ets_offset))
+		goto eeprom_err;
+	if ((ets_offset == 0x0000) || (ets_offset == 0xFFFF))
+		return IXGBE_NOT_IMPLEMENTED;
+
+	offset = ets_offset;
+	if (hw->eeprom.ops.read(hw, offset, &ets_cfg))
+		goto eeprom_err;
+	if (((ets_cfg & IXGBE_ETS_TYPE_MASK) >> IXGBE_ETS_TYPE_SHIFT)
+		!= IXGBE_ETS_TYPE_EMC)
+		return IXGBE_NOT_IMPLEMENTED;
 
 	low_thresh_delta = ((ets_cfg & IXGBE_ETS_LTHRES_DELTA_MASK) >>
 			     IXGBE_ETS_LTHRES_DELTA_SHIFT);
 	num_sensors = (ets_cfg & IXGBE_ETS_NUM_SENSORS_MASK);
-	if (num_sensors > IXGBE_MAX_SENSORS)
-		num_sensors = IXGBE_MAX_SENSORS;
 
 	for (i = 0; i < num_sensors; i++) {
-		u8  sensor_index;
-		u8  sensor_location;
-
-		if (hw->eeprom.ops.read(hw, ets_offset + 1 + i, &ets_sensor)) {
-			hw_err(hw, "eeprom read at offset %d failed\n",
-			       ets_offset + 1 + i);
+		offset = ets_offset + 1 + i;
+		if (hw->eeprom.ops.read(hw, offset, &ets_sensor)) {
+			ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+				      "eeprom read at offset %d failed",
+				      offset);
 			continue;
 		}
 		sensor_index = ((ets_sensor & IXGBE_ETS_DATA_INDEX_MASK) >>
@@ -4004,25 +4764,29 @@ s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)
 			ixgbe_emc_therm_limit[sensor_index],
 			IXGBE_I2C_THERMAL_SENSOR_ADDR, therm_limit);
 
-		if (sensor_location == 0)
-			continue;
-
-		data->sensor[i].location = sensor_location;
-		data->sensor[i].caution_thresh = therm_limit;
-		data->sensor[i].max_op_thresh = therm_limit - low_thresh_delta;
+		if ((i < IXGBE_MAX_SENSORS) && (sensor_location != 0)) {
+			data->sensor[i].location = sensor_location;
+			data->sensor[i].caution_thresh = therm_limit;
+			data->sensor[i].max_op_thresh = therm_limit -
+							low_thresh_delta;
+		}
 	}
+	return status;
 
-	return 0;
+eeprom_err:
+	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+		      "eeprom read at offset %d failed", offset);
+	return IXGBE_NOT_IMPLEMENTED;
 }
 
 /**
- *  ixgbe_get_orom_version - Return option ROM from EEPROM
+ * ixgbe_get_orom_version - Return option ROM from EEPROM
  *
- *  @hw: pointer to hardware structure
- *  @nvm_ver: pointer to output structure
+ * @hw: pointer to hardware structure
+ * @nvm_ver: pointer to output structure
  *
- *  if valid option ROM version, nvm_ver->or_valid set to true
- *  else nvm_ver->or_valid is false.
+ * if valid option ROM version, nvm_ver->or_valid set to true
+ * else nvm_ver->or_valid is false.
  **/
 void ixgbe_get_orom_version(struct ixgbe_hw *hw,
 			    struct ixgbe_nvm_version *nvm_ver)
@@ -4034,7 +4798,7 @@ void ixgbe_get_orom_version(struct ixgbe_hw *hw,
 	hw->eeprom.ops.read(hw, NVM_OROM_OFFSET, &offset);
 
 	/* make sure offset is valid */
-	if (offset == 0x0 || offset == NVM_INVALID_PTR)
+	if ((offset == 0x0) || (offset == NVM_INVALID_PTR))
 		return;
 
 	hw->eeprom.ops.read(hw, offset + NVM_OROM_BLK_HI, &eeprom_cfg_blkh);
@@ -4054,13 +4818,13 @@ void ixgbe_get_orom_version(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_get_oem_prod_version Etrack ID from EEPROM
+ * ixgbe_get_oem_prod_version - Return OEM Product version
  *
- *  @hw: pointer to hardware structure
- *  @nvm_ver: pointer to output structure
+ * @hw: pointer to hardware structure
+ * @nvm_ver: pointer to output structure
  *
- *  if valid OEM product version, nvm_ver->oem_valid set to true
- *  else nvm_ver->oem_valid is false.
+ * if valid OEM product version, nvm_ver->oem_valid set to true
+ * else nvm_ver->oem_valid is false.
  **/
 void ixgbe_get_oem_prod_version(struct ixgbe_hw *hw,
 				struct ixgbe_nvm_version *nvm_ver)
@@ -4098,15 +4862,14 @@ void ixgbe_get_oem_prod_version(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_get_etk_id - Return Etrack ID from EEPROM
+ * ixgbe_get_etk_id - Return Etrack ID from EEPROM
  *
- *  @hw: pointer to hardware structure
- *  @nvm_ver: pointer to output structure
+ * @hw: pointer to hardware structure
+ * @nvm_ver: pointer to output structure
  *
- *  word read errors will return 0xFFFF
+ * word read errors will return 0xFFFF
  **/
-void ixgbe_get_etk_id(struct ixgbe_hw *hw,
-		      struct ixgbe_nvm_version *nvm_ver)
+void ixgbe_get_etk_id(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver)
 {
 	u16 etk_id_l, etk_id_h;
 
@@ -4127,15 +4890,32 @@ void ixgbe_get_etk_id(struct ixgbe_hw *hw,
 	}
 }
 
+/**
+ * ixgbe_dcb_get_rtrup2tc_generic - read rtrup2tc reg
+ * @hw: pointer to hardware structure
+ * @map: pointer to u8 arr for returning map
+ *
+ * Read the rtrup2tc HW register and resolve its content into map
+ **/
+void ixgbe_dcb_get_rtrup2tc_generic(struct ixgbe_hw *hw, u8 *map)
+{
+	u32 reg, i;
+
+	reg = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);
+	for (i = 0; i < IXGBE_DCB_MAX_USER_PRIORITY; i++)
+		map[i] = IXGBE_RTRUP2TC_UP_MASK &
+			(reg >> (i * IXGBE_RTRUP2TC_UP_SHIFT));
+	return;
+}
+
 void ixgbe_disable_rx_generic(struct ixgbe_hw *hw)
 {
+	u32 pfdtxgswc;
 	u32 rxctrl;
 
 	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
 	if (rxctrl & IXGBE_RXCTRL_RXEN) {
 		if (hw->mac.type != ixgbe_mac_82598EB) {
-			u32 pfdtxgswc;
-
 			pfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);
 			if (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {
 				pfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;
@@ -4152,6 +4932,7 @@ void ixgbe_disable_rx_generic(struct ixgbe_hw *hw)
 
 void ixgbe_enable_rx_generic(struct ixgbe_hw *hw)
 {
+	u32 pfdtxgswc;
 	u32 rxctrl;
 
 	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
@@ -4159,8 +4940,6 @@ void ixgbe_enable_rx_generic(struct ixgbe_hw *hw)
 
 	if (hw->mac.type != ixgbe_mac_82598EB) {
 		if (hw->mac.set_lben) {
-			u32 pfdtxgswc;
-
 			pfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);
 			pfdtxgswc |= IXGBE_PFDTXGSWC_VT_LBEN;
 			IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);
@@ -4169,9 +4948,10 @@ void ixgbe_enable_rx_generic(struct ixgbe_hw *hw)
 	}
 }
 
-/** ixgbe_mng_present - returns true when management capability is present
+/**
+ * ixgbe_mng_present - returns true when management capability is present
  * @hw: pointer to hardware structure
- **/
+ */
 bool ixgbe_mng_present(struct ixgbe_hw *hw)
 {
 	u32 fwsm;
@@ -4179,33 +4959,62 @@ bool ixgbe_mng_present(struct ixgbe_hw *hw)
 	if (hw->mac.type < ixgbe_mac_82599EB)
 		return false;
 
-	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));
+	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM_BY_MAC(hw));
 
 	return !!(fwsm & IXGBE_FWSM_FW_MODE_PT);
 }
 
 /**
- *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_mng_enabled - Is the manageability engine enabled?
+ * @hw: pointer to hardware structure
  *
- *  Set the link speed in the MAC and/or PHY register and restarts link.
- */
+ * Returns true if the manageability engine is enabled.
+ **/
+bool ixgbe_mng_enabled(struct ixgbe_hw *hw)
+{
+	u32 fwsm, manc, factps;
+
+	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM_BY_MAC(hw));
+	if ((fwsm & IXGBE_FWSM_MODE_MASK) != IXGBE_FWSM_FW_MODE_PT)
+		return false;
+
+	manc = IXGBE_READ_REG(hw, IXGBE_MANC);
+	if (!(manc & IXGBE_MANC_RCV_TCO_EN))
+		return false;
+
+	if (hw->mac.type <= ixgbe_mac_X540) {
+		factps = IXGBE_READ_REG(hw, IXGBE_FACTPS_BY_MAC(hw));
+		if (factps & IXGBE_FACTPS_MNGCG)
+			return false;
+	}
+
+	return true;
+}
+
+/**
+ * ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
+ *
+ * Set the link speed in the MAC and/or PHY register and restarts link.
+ **/
 s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 					  ixgbe_link_speed speed,
 					  bool autoneg_wait_to_complete)
 {
 	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
 	ixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	u32 speedcnt = 0;
 	u32 i = 0;
 	bool autoneg, link_up = false;
 
+	DEBUGFUNC("ixgbe_setup_mac_link_multispeed_fiber");
+
 	/* Mask off requested but non-supported speeds */
-	status = hw->mac.ops.get_link_capabilities(hw, &link_speed, &autoneg);
-	if (status)
+	status = ixgbe_get_link_capabilities(hw, &link_speed, &autoneg);
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	speed &= link_speed;
@@ -4220,29 +5029,28 @@ s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 		/* Set the module link speed */
 		switch (hw->phy.media_type) {
 		case ixgbe_media_type_fiber:
-			hw->mac.ops.set_rate_select_speed(hw,
+			ixgbe_set_rate_select_speed(hw,
 						    IXGBE_LINK_SPEED_10GB_FULL);
 			break;
 		case ixgbe_media_type_fiber_qsfp:
 			/* QSFP module automatically detects MAC link speed */
 			break;
 		default:
-			hw_dbg(hw, "Unexpected media type\n");
+			hw_dbg(hw, "Unexpected media type.\n");
 			break;
 		}
 
 		/* Allow module to change analog characteristics (1G->10G) */
-		msleep(40);
+		msec_delay(40);
 
-		status = hw->mac.ops.setup_mac_link(hw,
-						    IXGBE_LINK_SPEED_10GB_FULL,
-						    autoneg_wait_to_complete);
-		if (status)
+		status = ixgbe_setup_mac_link(hw,
+					      IXGBE_LINK_SPEED_10GB_FULL,
+					      autoneg_wait_to_complete);
+		if (status != IXGBE_SUCCESS)
 			return status;
 
 		/* Flap the Tx laser if it has not already been done */
-		if (hw->mac.ops.flap_tx_laser)
-			hw->mac.ops.flap_tx_laser(hw);
+		ixgbe_flap_tx_laser(hw);
 
 		/* Wait for the controller to acquire link.  Per IEEE 802.3ap,
 		 * Section 73.10.2, we may have to wait up to 500ms if KR is
@@ -4250,12 +5058,12 @@ s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 		 */
 		for (i = 0; i < 5; i++) {
 			/* Wait for the link partner to also set speed */
-			msleep(100);
+			msec_delay(100);
 
 			/* If we have link, just jump out */
-			status = hw->mac.ops.check_link(hw, &link_speed,
-							&link_up, false);
-			if (status)
+			status = ixgbe_check_link(hw, &link_speed,
+						  &link_up, false);
+			if (status != IXGBE_SUCCESS)
 				return status;
 
 			if (link_up)
@@ -4271,37 +5079,35 @@ s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 		/* Set the module link speed */
 		switch (hw->phy.media_type) {
 		case ixgbe_media_type_fiber:
-			hw->mac.ops.set_rate_select_speed(hw,
-						     IXGBE_LINK_SPEED_1GB_FULL);
+			ixgbe_set_rate_select_speed(hw,
+						    IXGBE_LINK_SPEED_1GB_FULL);
 			break;
 		case ixgbe_media_type_fiber_qsfp:
 			/* QSFP module automatically detects link speed */
 			break;
 		default:
-			hw_dbg(hw, "Unexpected media type\n");
+			hw_dbg(hw, "Unexpected media type.\n");
 			break;
 		}
 
 		/* Allow module to change analog characteristics (10G->1G) */
-		msleep(40);
+		msec_delay(40);
 
-		status = hw->mac.ops.setup_mac_link(hw,
-						    IXGBE_LINK_SPEED_1GB_FULL,
-						    autoneg_wait_to_complete);
-		if (status)
+		status = ixgbe_setup_mac_link(hw,
+					      IXGBE_LINK_SPEED_1GB_FULL,
+					      autoneg_wait_to_complete);
+		if (status != IXGBE_SUCCESS)
 			return status;
 
 		/* Flap the Tx laser if it has not already been done */
-		if (hw->mac.ops.flap_tx_laser)
-			hw->mac.ops.flap_tx_laser(hw);
+		ixgbe_flap_tx_laser(hw);
 
 		/* Wait for the link partner to also set speed */
-		msleep(100);
+		msec_delay(100);
 
 		/* If we have link, just jump out */
-		status = hw->mac.ops.check_link(hw, &link_speed, &link_up,
-						false);
-		if (status)
+		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
+		if (status != IXGBE_SUCCESS)
 			return status;
 
 		if (link_up)
@@ -4331,14 +5137,14 @@ s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_set_soft_rate_select_speed - Set module link speed
- *  @hw: pointer to hardware structure
- *  @speed: link speed to set
+ * ixgbe_set_soft_rate_select_speed - Set module link speed
+ * @hw: pointer to hardware structure
+ * @speed: link speed to set
  *
- *  Set module link speed via the soft rate select.
+ * Set module link speed via the soft rate select.
  */
 void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
-				      ixgbe_link_speed speed)
+					ixgbe_link_speed speed)
 {
 	s32 status;
 	u8 rs, eeprom_data;
@@ -4362,7 +5168,7 @@ void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
 					   &eeprom_data);
 	if (status) {
 		hw_dbg(hw, "Failed to read Rx Rate Select RS0\n");
-		return;
+		goto out;
 	}
 
 	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;
@@ -4372,7 +5178,7 @@ void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
 					    eeprom_data);
 	if (status) {
 		hw_dbg(hw, "Failed to write Rx Rate Select RS0\n");
-		return;
+		goto out;
 	}
 
 	/* Set RS1 */
@@ -4381,7 +5187,7 @@ void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
 					   &eeprom_data);
 	if (status) {
 		hw_dbg(hw, "Failed to read Rx Rate Select RS1\n");
-		return;
+		goto out;
 	}
 
 	eeprom_data = (eeprom_data & ~IXGBE_SFF_SOFT_RS_SELECT_MASK) | rs;
@@ -4391,6 +5197,8 @@ void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
 					    eeprom_data);
 	if (status) {
 		hw_dbg(hw, "Failed to write Rx Rate Select RS1\n");
-		return;
+		goto out;
 	}
+out:
+	return;
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h
index 4b531e8ae38a..6c8f6ea2226c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.h
@@ -1,24 +1,24 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_COMMON_H_
 #define _IXGBE_COMMON_H_
 
 #include "ixgbe_type.h"
-#include "ixgbe.h"
+
+void ixgbe_dcb_get_rtrup2tc_generic(struct ixgbe_hw *hw, u8 *map);
 
 u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);
 s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw);
 s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw);
 s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw);
-s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw);
+void ixgbe_start_hw_gen2(struct ixgbe_hw *hw);
 s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);
 s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
 				  u32 pba_num_size);
 s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr);
-enum ixgbe_bus_width ixgbe_convert_bus_width(u16 link_status);
-enum ixgbe_bus_speed ixgbe_convert_bus_speed(u16 link_status);
 s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);
+void ixgbe_set_pci_config_data_generic(struct ixgbe_hw *hw, u16 link_status);
 void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);
 s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);
 
@@ -44,64 +44,85 @@ s32 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);
 s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
 					   u16 *checksum_val);
 s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);
+s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg);
 
 s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
 			  u32 enable_addr);
 s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index);
 s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);
-s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw,
-				      struct net_device *netdev);
+s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
+				      u32 mc_addr_count,
+				      ixgbe_mc_addr_itr func, bool clear);
+s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
+				      u32 addr_count, ixgbe_mc_addr_itr func);
 s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw);
 s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw);
-s32 ixgbe_disable_rx_buff_generic(struct ixgbe_hw *hw);
-s32 ixgbe_enable_rx_buff_generic(struct ixgbe_hw *hw);
 s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval);
+s32 ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw);
+s32 ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw);
+
 s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw);
-s32 ixgbe_setup_fc_generic(struct ixgbe_hw *);
 bool ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw);
 void ixgbe_fc_autoneg(struct ixgbe_hw *hw);
+s32 ixgbe_setup_fc_generic(struct ixgbe_hw *hw);
 
+s32 ixgbe_validate_mac_addr(u8 *mac_addr);
 s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u32 mask);
 void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u32 mask);
+s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw);
+
+s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *, u32 *reg_val);
+s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked);
+
+s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);
+
 s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);
+s32 ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);
+
 s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
 s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq);
 s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
+s32 ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, u8 *addr, u32 vmdq);
 s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw);
 s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan,
-			   u32 vind, bool vlan_on, bool vlvf_bypass);
+			 u32 vind, bool vlan_on, bool vlvf_bypass);
+s32 ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+			   bool vlan_on, u32 *vfta_delta, u32 vfta,
+			   bool vlvf_bypass);
 s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);
+s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan, bool vlvf_bypass);
+s32 ixgbe_toggle_txdctl_generic(struct ixgbe_hw *hw, u32 vind);
+
 s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw,
-				 ixgbe_link_speed *speed,
-				 bool *link_up, bool link_up_wait_to_complete);
+			       ixgbe_link_speed *speed,
+			       bool *link_up, bool link_up_wait_to_complete);
+
 s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,
 				 u16 *wwpn_prefix);
 
-s32 prot_autoc_read_generic(struct ixgbe_hw *hw, bool *, u32 *reg_val);
-s32 prot_autoc_write_generic(struct ixgbe_hw *hw, u32 reg_val, bool locked);
-
-s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);
-s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_get_fcoe_boot_status_generic(struct ixgbe_hw *hw, u16 *bs);
 void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);
 void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);
 s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps);
+void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom,
+			     int strategy);
 s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
 				 u8 build, u8 ver, u16 len, const char *str);
 u8 ixgbe_calculate_checksum(u8 *buffer, u32 length);
-s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, void *, u32 length,
-				 u32 timeout, bool return_data);
-s32 ixgbe_hic_unlocked(struct ixgbe_hw *hw, u32 *buffer, u32 len, u32 timeout);
-s32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity,
+s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,
+				 u32 length, u32 timeout, bool return_data);
+s32 ixgbe_hic_unlocked(struct ixgbe_hw *, u32 *buffer, u32 length, u32 timeout);
+s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *);
+s32 ixgbe_fw_phy_activity(struct ixgbe_hw *, u16 activity,
 			  u32 (*data)[FW_PHY_ACT_DATA_COUNT]);
 void ixgbe_clear_tx_pending(struct ixgbe_hw *hw);
+
+extern s32 ixgbe_reset_pipeline_82599(struct ixgbe_hw *hw);
+extern void ixgbe_stop_mac_link_on_d3_82599(struct ixgbe_hw *hw);
 bool ixgbe_mng_present(struct ixgbe_hw *hw);
 bool ixgbe_mng_enabled(struct ixgbe_hw *hw);
 
-void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb,
-			     u32 headroom, int strategy);
-
-extern const u32 ixgbe_mvals_8259X[IXGBE_MVALS_IDX_LIMIT];
-
 #define IXGBE_I2C_THERMAL_SENSOR_ADDR	0xF8
 #define IXGBE_EMC_INTERNAL_DATA		0x00
 #define IXGBE_EMC_INTERNAL_THERM_LIMIT	0x20
@@ -114,8 +135,8 @@ extern const u32 ixgbe_mvals_8259X[IXGBE_MVALS_IDX_LIMIT];
 
 s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw);
 s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw);
-void ixgbe_get_etk_id(struct ixgbe_hw *hw,
-		      struct ixgbe_nvm_version *nvm_ver);
+
+void ixgbe_get_etk_id(struct ixgbe_hw *hw, struct ixgbe_nvm_version *nvm_ver);
 void ixgbe_get_oem_prod_version(struct ixgbe_hw *hw,
 				struct ixgbe_nvm_version *nvm_ver);
 void ixgbe_get_orom_version(struct ixgbe_hw *hw,
@@ -127,80 +148,4 @@ s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
 					  bool autoneg_wait_to_complete);
 void ixgbe_set_soft_rate_select_speed(struct ixgbe_hw *hw,
 				      ixgbe_link_speed speed);
-
-#define IXGBE_FAILED_READ_RETRIES 5
-#define IXGBE_FAILED_READ_REG 0xffffffffU
-#define IXGBE_FAILED_READ_CFG_DWORD 0xffffffffU
-#define IXGBE_FAILED_READ_CFG_WORD 0xffffU
-
-u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg);
-void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value);
-
-static inline bool ixgbe_removed(void __iomem *addr)
-{
-	return unlikely(!addr);
-}
-
-static inline void ixgbe_write_reg(struct ixgbe_hw *hw, u32 reg, u32 value)
-{
-	u8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);
-
-	if (ixgbe_removed(reg_addr))
-		return;
-	writel(value, reg_addr + reg);
-}
-#define IXGBE_WRITE_REG(a, reg, value) ixgbe_write_reg((a), (reg), (value))
-
-#ifndef writeq
-#define writeq writeq
-static inline void writeq(u64 val, void __iomem *addr)
-{
-	writel((u32)val, addr);
-	writel((u32)(val >> 32), addr + 4);
-}
-#endif
-
-static inline void ixgbe_write_reg64(struct ixgbe_hw *hw, u32 reg, u64 value)
-{
-	u8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);
-
-	if (ixgbe_removed(reg_addr))
-		return;
-	writeq(value, reg_addr + reg);
-}
-#define IXGBE_WRITE_REG64(a, reg, value) ixgbe_write_reg64((a), (reg), (value))
-
-u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg);
-#define IXGBE_READ_REG(a, reg) ixgbe_read_reg((a), (reg))
-
-#define IXGBE_WRITE_REG_ARRAY(a, reg, offset, value) \
-		ixgbe_write_reg((a), (reg) + ((offset) << 2), (value))
-
-#define IXGBE_READ_REG_ARRAY(a, reg, offset) \
-		ixgbe_read_reg((a), (reg) + ((offset) << 2))
-
-#define IXGBE_WRITE_FLUSH(a) ixgbe_read_reg((a), IXGBE_STATUS)
-
-#define ixgbe_hw_to_netdev(hw) (((struct ixgbe_adapter *)(hw)->back)->netdev)
-
-#define hw_dbg(hw, format, arg...) \
-	netdev_dbg(ixgbe_hw_to_netdev(hw), format, ## arg)
-#define hw_err(hw, format, arg...) \
-	netdev_err(ixgbe_hw_to_netdev(hw), format, ## arg)
-#define e_dev_info(format, arg...) \
-	dev_info(&adapter->pdev->dev, format, ## arg)
-#define e_dev_warn(format, arg...) \
-	dev_warn(&adapter->pdev->dev, format, ## arg)
-#define e_dev_err(format, arg...) \
-	dev_err(&adapter->pdev->dev, format, ## arg)
-#define e_dev_notice(format, arg...) \
-	dev_notice(&adapter->pdev->dev, format, ## arg)
-#define e_info(msglvl, format, arg...) \
-	netif_info(adapter, msglvl, adapter->netdev, format, ## arg)
-#define e_err(msglvl, format, arg...) \
-	netif_err(adapter, msglvl, adapter->netdev, format, ## arg)
-#define e_warn(msglvl, format, arg...) \
-	netif_warn(adapter, msglvl, adapter->netdev, format, ## arg)
-#define e_crit(msglvl, format, arg...) \
-	netif_crit(adapter, msglvl, adapter->netdev, format, ## arg)
 #endif /* IXGBE_COMMON */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
index d26cea5b43bd..a62250d95fa8 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.c
@@ -1,14 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
 
-#include "ixgbe.h"
 #include "ixgbe_type.h"
 #include "ixgbe_dcb.h"
 #include "ixgbe_dcb_82598.h"
 #include "ixgbe_dcb_82599.h"
 
 /**
- * ixgbe_ieee_credits - This calculates the ieee traffic class
+ * ixgbe_dcb_calculate_tc_credits - This calculates the ieee traffic class
  * credits from the configured bandwidth percentages. Credits
  * are the smallest unit programmable into the underlying
  * hardware. The IEEE 802.1Qaz specification do not use bandwidth
@@ -16,19 +16,19 @@
  * @bw: bandwidth index by traffic class
  * @refill: refill credits index by traffic class
  * @max: max credits by traffic class
- * @max_frame: maximum frame size
+ * @max_frame_size: maximum frame size
  */
-static s32 ixgbe_ieee_credits(__u8 *bw, __u16 *refill,
-			      __u16 *max, int max_frame)
+s32 ixgbe_dcb_calculate_tc_credits(u8 *bw, u16 *refill, u16 *max,
+				   int max_frame_size)
 {
 	int min_percent = 100;
 	int min_credit, multiplier;
 	int i;
 
-	min_credit = ((max_frame / 2) + DCB_CREDIT_QUANTUM - 1) /
-			DCB_CREDIT_QUANTUM;
+	min_credit = ((max_frame_size / 2) + IXGBE_DCB_CREDIT_QUANTUM - 1) /
+			IXGBE_DCB_CREDIT_QUANTUM;
 
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		if (bw[i] < min_percent && bw[i])
 			min_percent = bw[i];
 	}
@@ -36,52 +36,56 @@ static s32 ixgbe_ieee_credits(__u8 *bw, __u16 *refill,
 	multiplier = (min_credit / min_percent) + 1;
 
 	/* Find out the hw credits for each TC */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
-		int val = min(bw[i] * multiplier, MAX_CREDIT_REFILL);
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
+		int val = min(bw[i] * multiplier, IXGBE_DCB_MAX_CREDIT_REFILL);
 
 		if (val < min_credit)
 			val = min_credit;
-		refill[i] = val;
+		refill[i] = (u16)val;
 
-		max[i] = bw[i] ? (bw[i] * MAX_CREDIT)/100 : min_credit;
+		max[i] = bw[i] ? (bw[i]*IXGBE_DCB_MAX_CREDIT)/100 : min_credit;
 	}
+
 	return 0;
 }
 
 /**
- * ixgbe_dcb_calculate_tc_credits - Calculates traffic class credits
+ * ixgbe_dcb_calculate_tc_credits_cee - Calculates traffic class credits
  * @hw: pointer to hardware structure
  * @dcb_config: Struct containing DCB settings
- * @max_frame: Maximum frame size
+ * @max_frame_size: Maximum frame size
  * @direction: Configuring either Tx or Rx
  *
  * This function calculates the credits allocated to each traffic class.
  * It should be called only after the rules are checked by
- * ixgbe_dcb_check_config().
+ * ixgbe_dcb_check_config_cee().
  */
-s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw,
+s32 ixgbe_dcb_calculate_tc_credits_cee(struct ixgbe_hw *hw,
 				   struct ixgbe_dcb_config *dcb_config,
-				   int max_frame, u8 direction)
+				   u32 max_frame_size, u8 direction)
 {
-	struct tc_bw_alloc *p;
-	int min_credit;
-	int min_multiplier;
-	int min_percent = 100;
+	struct ixgbe_dcb_tc_path *p;
+	u32 min_multiplier	= 0;
+	u16 min_percent		= 100;
+	s32 ret_val =		IXGBE_SUCCESS;
 	/* Initialization values default for Tx settings */
-	u32 credit_refill       = 0;
-	u32 credit_max          = 0;
-	u16 link_percentage     = 0;
-	u8  bw_percent          = 0;
+	u32 min_credit		= 0;
+	u32 credit_refill	= 0;
+	u32 credit_max		= 0;
+	u16 link_percentage	= 0;
+	u8  bw_percent		= 0;
 	u8  i;
 
-	if (!dcb_config)
-		return DCB_ERR_CONFIG;
+	if (dcb_config == NULL) {
+		ret_val = IXGBE_ERR_CONFIG;
+		goto out;
+	}
 
-	min_credit = ((max_frame / 2) + DCB_CREDIT_QUANTUM - 1) /
-			DCB_CREDIT_QUANTUM;
+	min_credit = ((max_frame_size / 2) + IXGBE_DCB_CREDIT_QUANTUM - 1) /
+		     IXGBE_DCB_CREDIT_QUANTUM;
 
 	/* Find smallest link percentage */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		p = &dcb_config->tc_config[i].path[direction];
 		bw_percent = dcb_config->bw_percentage[direction][p->bwg_id];
 		link_percentage = p->bwg_percent;
@@ -103,7 +107,7 @@ s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw,
 	min_multiplier = (min_credit / min_percent) + 1;
 
 	/* Find out the link percentage for each TC first */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		p = &dcb_config->tc_config[i].path[direction];
 		bw_percent = dcb_config->bw_percentage[direction][p->bwg_id];
 
@@ -118,7 +122,7 @@ s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw,
 
 		/* Calculate credit refill ratio using multiplier */
 		credit_refill = min(link_percentage * min_multiplier,
-				    MAX_CREDIT_REFILL);
+				    (u32)IXGBE_DCB_MAX_CREDIT_REFILL);
 
 		/* Refill at least minimum credit */
 		if (credit_refill < min_credit)
@@ -127,7 +131,7 @@ s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw,
 		p->data_credits_refill = (u16)credit_refill;
 
 		/* Calculate maximum credit for the TC */
-		credit_max = (link_percentage * MAX_CREDIT) / 100;
+		credit_max = (link_percentage * IXGBE_DCB_MAX_CREDIT) / 100;
 
 		/*
 		 * Adjustment based on rule checking, if the percentage
@@ -137,87 +141,103 @@ s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *hw,
 		if (credit_max < min_credit)
 			credit_max = min_credit;
 
-		if (direction == DCB_TX_CONFIG) {
+		if (direction == IXGBE_DCB_TX_CONFIG) {
 			/*
 			 * Adjustment based on rule checking, if the
 			 * percentage of a TC is too small, the maximum
 			 * credit may not be enough to send out a TSO
 			 * packet in descriptor plane arbitration.
 			 */
-			if ((hw->mac.type == ixgbe_mac_82598EB) &&
-			    credit_max &&
-			    (credit_max < MINIMUM_CREDIT_FOR_TSO))
-				credit_max = MINIMUM_CREDIT_FOR_TSO;
+			if (credit_max && (credit_max <
+			    IXGBE_DCB_MIN_TSO_CREDIT)
+			    && (hw->mac.type == ixgbe_mac_82598EB))
+				credit_max = IXGBE_DCB_MIN_TSO_CREDIT;
 
 			dcb_config->tc_config[i].desc_credits_max =
-				(u16)credit_max;
+								(u16)credit_max;
 		}
 
 		p->data_credits_max = (u16)credit_max;
 	}
 
-	return 0;
+out:
+	return ret_val;
 }
 
-void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg, u8 *pfc_en)
+/**
+ * ixgbe_dcb_unpack_pfc_cee - Unpack dcb_config PFC info
+ * @cfg: dcb configuration to unpack into hardware consumable fields
+ * @map: user priority to traffic class map
+ * @pfc_up: u8 to store user priority PFC bitmask
+ *
+ * This unpacks the dcb configuration PFC info which is stored per
+ * traffic class into a 8bit user priority bitmask that can be
+ * consumed by hardware routines. The priority to tc map must be
+ * updated before calling this routine to use current up-to maps.
+ */
+void ixgbe_dcb_unpack_pfc_cee(struct ixgbe_dcb_config *cfg, u8 *map, u8 *pfc_up)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
-	int tc;
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
+	int up;
 
-	for (*pfc_en = 0, tc = 0; tc < MAX_TRAFFIC_CLASS; tc++) {
-		if (tc_config[tc].dcb_pfc != pfc_disabled)
-			*pfc_en |= BIT(tc);
+	/*
+	 * If the TC for this user priority has PFC enabled then set the
+	 * matching bit in 'pfc_up' to reflect that PFC is enabled.
+	 */
+	for (*pfc_up = 0, up = 0; up < IXGBE_DCB_MAX_USER_PRIORITY; up++) {
+		if (tc_config[map[up]].pfc != ixgbe_dcb_pfc_disabled)
+			*pfc_up |= 1 << up;
 	}
 }
 
-void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *cfg, int direction,
+void ixgbe_dcb_unpack_refill_cee(struct ixgbe_dcb_config *cfg, int direction,
 			     u16 *refill)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
 	int tc;
 
-	for (tc = 0; tc < MAX_TRAFFIC_CLASS; tc++)
+	for (tc = 0; tc < IXGBE_DCB_MAX_TRAFFIC_CLASS; tc++)
 		refill[tc] = tc_config[tc].path[direction].data_credits_refill;
 }
 
-void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *cfg, u16 *max)
+void ixgbe_dcb_unpack_max_cee(struct ixgbe_dcb_config *cfg, u16 *max)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
 	int tc;
 
-	for (tc = 0; tc < MAX_TRAFFIC_CLASS; tc++)
+	for (tc = 0; tc < IXGBE_DCB_MAX_TRAFFIC_CLASS; tc++)
 		max[tc] = tc_config[tc].desc_credits_max;
 }
 
-void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *cfg, int direction,
+void ixgbe_dcb_unpack_bwgid_cee(struct ixgbe_dcb_config *cfg, int direction,
 			    u8 *bwgid)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
 	int tc;
 
-	for (tc = 0; tc < MAX_TRAFFIC_CLASS; tc++)
+	for (tc = 0; tc < IXGBE_DCB_MAX_TRAFFIC_CLASS; tc++)
 		bwgid[tc] = tc_config[tc].path[direction].bwg_id;
 }
 
-void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *cfg, int direction,
-			    u8 *ptype)
+void ixgbe_dcb_unpack_tsa_cee(struct ixgbe_dcb_config *cfg, int direction,
+			   u8 *tsa)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
 	int tc;
 
-	for (tc = 0; tc < MAX_TRAFFIC_CLASS; tc++)
-		ptype[tc] = tc_config[tc].path[direction].prio_type;
+	for (tc = 0; tc < IXGBE_DCB_MAX_TRAFFIC_CLASS; tc++)
+		tsa[tc] = tc_config[tc].path[direction].tsa;
 }
 
 u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg, int direction, u8 up)
 {
-	struct tc_configuration *tc_config = &cfg->tc_config[0];
-	u8 prio_mask = BIT(up);
+	struct ixgbe_dcb_tc_config *tc_config = &cfg->tc_config[0];
+	u8 prio_mask = 1 << up;
 	u8 tc = cfg->num_tcs.pg_tcs;
 
 	/* If tc is 0 then DCB is likely not enabled or supported */
 	if (!tc)
-		return 0;
+		goto out;
 
 	/*
 	 * Test from maximum TC to 1 and report the first match we find.  If
@@ -228,163 +248,456 @@ u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *cfg, int direction, u8 up)
 		if (prio_mask & tc_config[tc].path[direction].up_to_tc_bitmap)
 			break;
 	}
-
+out:
 	return tc;
 }
 
-void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *cfg, int direction, u8 *map)
+void ixgbe_dcb_unpack_map_cee(struct ixgbe_dcb_config *cfg, int direction,
+			      u8 *map)
 {
 	u8 up;
 
-	for (up = 0; up < MAX_USER_PRIORITY; up++)
+	for (up = 0; up < IXGBE_DCB_MAX_USER_PRIORITY; up++)
 		map[up] = ixgbe_dcb_get_tc_from_up(cfg, direction, up);
 }
 
 /**
- * ixgbe_dcb_hw_config - Config and enable DCB
+ * ixgbe_dcb_config - Struct containing DCB settings.
+ * @dcb_config: Pointer to DCB config structure
+ *
+ * This function checks DCB rules for DCB settings.
+ * The following rules are checked:
+ * 1. The sum of bandwidth percentages of all Bandwidth Groups must total 100%.
+ * 2. The sum of bandwidth percentages of all Traffic Classes within a Bandwidth
+ *   Group must total 100.
+ * 3. A Traffic Class should not be set to both Link Strict Priority
+ *   and Group Strict Priority.
+ * 4. Link strict Bandwidth Groups can only have link strict traffic classes
+ *   with zero bandwidth.
+ */
+s32 ixgbe_dcb_check_config_cee(struct ixgbe_dcb_config *dcb_config)
+{
+	struct ixgbe_dcb_tc_path *p;
+	s32 ret_val = IXGBE_SUCCESS;
+	u8 i, j, bw = 0, bw_id;
+	u8 bw_sum[2][IXGBE_DCB_MAX_BW_GROUP];
+	bool link_strict[2][IXGBE_DCB_MAX_BW_GROUP];
+
+	memset(bw_sum, 0, sizeof(bw_sum));
+	memset(link_strict, 0, sizeof(link_strict));
+
+	/* First Tx, then Rx */
+	for (i = 0; i < 2; i++) {
+		/* Check each traffic class for rule violation */
+		for (j = 0; j < IXGBE_DCB_MAX_TRAFFIC_CLASS; j++) {
+			p = &dcb_config->tc_config[j].path[i];
+
+			bw = p->bwg_percent;
+			bw_id = p->bwg_id;
+
+			if (bw_id >= IXGBE_DCB_MAX_BW_GROUP) {
+				ret_val = IXGBE_ERR_CONFIG;
+				goto err_config;
+			}
+			if (p->tsa == ixgbe_dcb_tsa_strict) {
+				link_strict[i][bw_id] = true;
+				/* Link strict should have zero bandwidth */
+				if (bw) {
+					ret_val = IXGBE_ERR_CONFIG;
+					goto err_config;
+				}
+			} else if (!bw) {
+				/*
+				 * Traffic classes without link strict
+				 * should have non-zero bandwidth.
+				 */
+				ret_val = IXGBE_ERR_CONFIG;
+				goto err_config;
+			}
+			bw_sum[i][bw_id] += bw;
+		}
+
+		bw = 0;
+
+		/* Check each bandwidth group for rule violation */
+		for (j = 0; j < IXGBE_DCB_MAX_BW_GROUP; j++) {
+			bw += dcb_config->bw_percentage[i][j];
+			/*
+			 * Sum of bandwidth percentages of all traffic classes
+			 * within a Bandwidth Group must total 100 except for
+			 * link strict group (zero bandwidth).
+			 */
+			if (link_strict[i][j]) {
+				if (bw_sum[i][j]) {
+					/*
+					 * Link strict group should have zero
+					 * bandwidth.
+					 */
+					ret_val = IXGBE_ERR_CONFIG;
+					goto err_config;
+				}
+			} else if (bw_sum[i][j] != IXGBE_DCB_BW_PERCENT &&
+				   bw_sum[i][j] != 0) {
+				ret_val = IXGBE_ERR_CONFIG;
+				goto err_config;
+			}
+		}
+
+		if (bw != IXGBE_DCB_BW_PERCENT) {
+			ret_val = IXGBE_ERR_CONFIG;
+			goto err_config;
+		}
+	}
+
+err_config:
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_dcb_get_tc_stats - Returns status of each traffic class
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the status data for each of the Traffic Classes in use.
+ */
+s32 ixgbe_dcb_get_tc_stats(struct ixgbe_hw *hw, struct ixgbe_hw_stats *stats,
+			   u8 tc_count)
+{
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_get_tc_stats_82598(hw, stats, tc_count);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_get_tc_stats_82599(hw, stats, tc_count);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+/**
+ * ixgbe_dcb_get_pfc_stats - Returns CBFC status of each traffic class
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the CBFC status data for each of the Traffic Classes.
+ */
+s32 ixgbe_dcb_get_pfc_stats(struct ixgbe_hw *hw, struct ixgbe_hw_stats *stats,
+			    u8 tc_count)
+{
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_get_pfc_stats_82598(hw, stats, tc_count);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_get_pfc_stats_82599(hw, stats, tc_count);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+/**
+ * ixgbe_dcb_config_rx_arbiter_cee - Config Rx arbiter
  * @hw: pointer to hardware structure
  * @dcb_config: pointer to ixgbe_dcb_config structure
  *
- * Configure dcb settings and enable dcb mode.
+ * Configure Rx Data Arbiter and credits for each traffic class.
  */
-s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw,
-			struct ixgbe_dcb_config *dcb_config)
+s32 ixgbe_dcb_config_rx_arbiter_cee(struct ixgbe_hw *hw,
+				struct ixgbe_dcb_config *dcb_config)
 {
-	u8 pfc_en;
-	u8 ptype[MAX_TRAFFIC_CLASS];
-	u8 bwgid[MAX_TRAFFIC_CLASS];
-	u8 prio_tc[MAX_TRAFFIC_CLASS];
-	u16 refill[MAX_TRAFFIC_CLASS];
-	u16 max[MAX_TRAFFIC_CLASS];
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	u8 tsa[IXGBE_DCB_MAX_TRAFFIC_CLASS]	= { 0 };
+	u8 bwgid[IXGBE_DCB_MAX_TRAFFIC_CLASS]	= { 0 };
+	u8 map[IXGBE_DCB_MAX_USER_PRIORITY]	= { 0 };
+	u16 refill[IXGBE_DCB_MAX_TRAFFIC_CLASS]	= { 0 };
+	u16 max[IXGBE_DCB_MAX_TRAFFIC_CLASS]	= { 0 };
+
+	ixgbe_dcb_unpack_refill_cee(dcb_config, IXGBE_DCB_TX_CONFIG, refill);
+	ixgbe_dcb_unpack_max_cee(dcb_config, max);
+	ixgbe_dcb_unpack_bwgid_cee(dcb_config, IXGBE_DCB_TX_CONFIG, bwgid);
+	ixgbe_dcb_unpack_tsa_cee(dcb_config, IXGBE_DCB_TX_CONFIG, tsa);
+	ixgbe_dcb_unpack_map_cee(dcb_config, IXGBE_DCB_TX_CONFIG, map);
 
-	/* Unpack CEE standard containers */
-	ixgbe_dcb_unpack_pfc(dcb_config, &pfc_en);
-	ixgbe_dcb_unpack_refill(dcb_config, DCB_TX_CONFIG, refill);
-	ixgbe_dcb_unpack_max(dcb_config, max);
-	ixgbe_dcb_unpack_bwgid(dcb_config, DCB_TX_CONFIG, bwgid);
-	ixgbe_dcb_unpack_prio(dcb_config, DCB_TX_CONFIG, ptype);
-	ixgbe_dcb_unpack_map(dcb_config, DCB_TX_CONFIG, prio_tc);
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, tsa);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwgid,
+							tsa, map);
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+/**
+ * ixgbe_dcb_config_tx_desc_arbiter_cee - Config Tx Desc arbiter
+ * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
+ *
+ * Configure Tx Descriptor Arbiter and credits for each traffic class.
+ */
+s32 ixgbe_dcb_config_tx_desc_arbiter_cee(struct ixgbe_hw *hw,
+				     struct ixgbe_dcb_config *dcb_config)
+{
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	u8 tsa[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u8 bwgid[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u16 refill[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u16 max[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+
+	ixgbe_dcb_unpack_refill_cee(dcb_config, IXGBE_DCB_TX_CONFIG, refill);
+	ixgbe_dcb_unpack_max_cee(dcb_config, max);
+	ixgbe_dcb_unpack_bwgid_cee(dcb_config, IXGBE_DCB_TX_CONFIG, bwgid);
+	ixgbe_dcb_unpack_tsa_cee(dcb_config, IXGBE_DCB_TX_CONFIG, tsa);
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
-		return ixgbe_dcb_hw_config_82598(hw, pfc_en, refill, max,
-						 bwgid, ptype);
+		ret = ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max,
+							     bwgid, tsa);
+		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		return ixgbe_dcb_hw_config_82599(hw, pfc_en, refill, max,
-						 bwgid, ptype, prio_tc);
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max,
+							     bwgid, tsa);
+		break;
 	default:
 		break;
 	}
-	return 0;
+	return ret;
 }
 
-/* Helper routines to abstract HW specifics from DCB netlink ops */
-s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
+/**
+ * ixgbe_dcb_config_tx_data_arbiter_cee - Config Tx data arbiter
+ * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
+ *
+ * Configure Tx Data Arbiter and credits for each traffic class.
+ */
+s32 ixgbe_dcb_config_tx_data_arbiter_cee(struct ixgbe_hw *hw,
+				     struct ixgbe_dcb_config *dcb_config)
 {
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	u8 tsa[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u8 bwgid[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u8 map[IXGBE_DCB_MAX_USER_PRIORITY] = { 0 };
+	u16 refill[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u16 max[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+
+	ixgbe_dcb_unpack_refill_cee(dcb_config, IXGBE_DCB_TX_CONFIG, refill);
+	ixgbe_dcb_unpack_max_cee(dcb_config, max);
+	ixgbe_dcb_unpack_bwgid_cee(dcb_config, IXGBE_DCB_TX_CONFIG, bwgid);
+	ixgbe_dcb_unpack_tsa_cee(dcb_config, IXGBE_DCB_TX_CONFIG, tsa);
+	ixgbe_dcb_unpack_map_cee(dcb_config, IXGBE_DCB_TX_CONFIG, map);
+
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
-		return ixgbe_dcb_config_pfc_82598(hw, pfc_en);
+		ret = ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max,
+							     bwgid, tsa);
+		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		return ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max,
+							     bwgid, tsa,
+							     map);
+		break;
 	default:
 		break;
 	}
-	return -EINVAL;
+	return ret;
 }
 
-s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame)
+/**
+ * ixgbe_dcb_config_pfc_cee - Config priority flow control
+ * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
+ *
+ * Configure Priority Flow Control for each traffic class.
+ */
+s32 ixgbe_dcb_config_pfc_cee(struct ixgbe_hw *hw,
+			 struct ixgbe_dcb_config *dcb_config)
 {
-	__u16 refill[IEEE_8021QAZ_MAX_TCS], max[IEEE_8021QAZ_MAX_TCS];
-	__u8 prio_type[IEEE_8021QAZ_MAX_TCS];
-	int i;
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	u8 pfc_en;
+	u8 map[IXGBE_DCB_MAX_USER_PRIORITY] = { 0 };
 
-	/* naively give each TC a bwg to map onto CEE hardware */
-	__u8 bwg_id[IEEE_8021QAZ_MAX_TCS] = {0, 1, 2, 3, 4, 5, 6, 7};
+	ixgbe_dcb_unpack_map_cee(dcb_config, IXGBE_DCB_TX_CONFIG, map);
+	ixgbe_dcb_unpack_pfc_cee(dcb_config, map, &pfc_en);
 
-	/* Map TSA onto CEE prio type */
-	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
-		switch (ets->tc_tsa[i]) {
-		case IEEE_8021QAZ_TSA_STRICT:
-			prio_type[i] = 2;
-			break;
-		case IEEE_8021QAZ_TSA_ETS:
-			prio_type[i] = 0;
-			break;
-		default:
-			/* Hardware only supports priority strict or
-			 * ETS transmission selection algorithms if
-			 * we receive some other value from dcbnl
-			 * throw an error
-			 */
-			return -EINVAL;
-		}
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_config_pfc_82598(hw, pfc_en);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_pfc_82599(hw, pfc_en, map);
+		break;
+	default:
+		break;
 	}
+	return ret;
+}
 
-	ixgbe_ieee_credits(ets->tc_tx_bw, refill, max, max_frame);
-	return ixgbe_dcb_hw_ets_config(hw, refill, max,
-				       bwg_id, prio_type, ets->prio_tc);
+/**
+ * ixgbe_dcb_config_tc_stats - Config traffic class statistics
+ * @hw: pointer to hardware structure
+ *
+ * Configure queue statistics registers, all queues belonging to same traffic
+ * class uses a single set of queue statistics counters.
+ */
+s32 ixgbe_dcb_config_tc_stats(struct ixgbe_hw *hw)
+{
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_config_tc_stats_82598(hw);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_tc_stats_82599(hw, NULL);
+		break;
+	default:
+		break;
+	}
+	return ret;
 }
 
-s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw,
-			    u16 *refill, u16 *max, u8 *bwg_id,
-			    u8 *prio_type, u8 *prio_tc)
+/**
+ * ixgbe_dcb_hw_config_cee - Config and enable DCB
+ * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
+ *
+ * Configure dcb settings and enable dcb mode.
+ */
+s32 ixgbe_dcb_hw_config_cee(struct ixgbe_hw *hw,
+			struct ixgbe_dcb_config *dcb_config)
 {
+	s32 ret = IXGBE_NOT_IMPLEMENTED;
+	u8 pfc_en;
+	u8 tsa[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u8 bwgid[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u8 map[IXGBE_DCB_MAX_USER_PRIORITY] = { 0 };
+	u16 refill[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	u16 max[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+
+	/* Unpack CEE standard containers */
+	ixgbe_dcb_unpack_refill_cee(dcb_config, IXGBE_DCB_TX_CONFIG, refill);
+	ixgbe_dcb_unpack_max_cee(dcb_config, max);
+	ixgbe_dcb_unpack_bwgid_cee(dcb_config, IXGBE_DCB_TX_CONFIG, bwgid);
+	ixgbe_dcb_unpack_tsa_cee(dcb_config, IXGBE_DCB_TX_CONFIG, tsa);
+	ixgbe_dcb_unpack_map_cee(dcb_config, IXGBE_DCB_TX_CONFIG, map);
+
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
-		ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max,
-							prio_type);
-		ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max,
-							     bwg_id, prio_type);
-		ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max,
-							     bwg_id, prio_type);
+		ret = ixgbe_dcb_hw_config_82598(hw, dcb_config->link_speed,
+						refill, max, bwgid, tsa);
 		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max,
-						  bwg_id, prio_type, prio_tc);
-		ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max,
-						       bwg_id, prio_type);
-		ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id,
-						       prio_type, prio_tc);
+	case ixgbe_mac_X550EM_a:
+		ixgbe_dcb_config_82599(hw, dcb_config);
+		ret = ixgbe_dcb_hw_config_82599(hw, dcb_config->link_speed,
+						refill, max, bwgid,
+						tsa, map);
+
+		ixgbe_dcb_config_tc_stats_82599(hw, dcb_config);
 		break;
 	default:
 		break;
 	}
-	return 0;
+
+	if (!ret && dcb_config->pfc_mode_enable) {
+		ixgbe_dcb_unpack_pfc_cee(dcb_config, map, &pfc_en);
+		ret = ixgbe_dcb_config_pfc(hw, pfc_en, map);
+	}
+
+	return ret;
 }
 
-static void ixgbe_dcb_read_rtrup2tc_82599(struct ixgbe_hw *hw, u8 *map)
+/* Helper routines to abstract HW specifics from DCB netlink ops */
+s32 ixgbe_dcb_config_pfc(struct ixgbe_hw *hw, u8 pfc_en, u8 *map)
 {
-	u32 reg, i;
+	int ret = IXGBE_ERR_PARAM;
 
-	reg = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);
-	for (i = 0; i < MAX_USER_PRIORITY; i++)
-		map[i] = IXGBE_RTRUP2TC_UP_MASK &
-			(reg >> (i * IXGBE_RTRUP2TC_UP_SHIFT));
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ret = ixgbe_dcb_config_pfc_82598(hw, pfc_en);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		ret = ixgbe_dcb_config_pfc_82599(hw, pfc_en, map);
+		break;
+	default:
+		break;
+	}
+	return ret;
 }
 
-void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw, u8 *map)
+s32 ixgbe_dcb_hw_config(struct ixgbe_hw *hw, u16 *refill, u16 *max,
+			    u8 *bwg_id, u8 *tsa, u8 *map)
 {
 	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, tsa);
+		ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id,
+						       tsa);
+		ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id,
+						       tsa);
+		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		ixgbe_dcb_read_rtrup2tc_82599(hw, map);
+	case ixgbe_mac_X550EM_a:
+		ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id,
+						  tsa, map);
+		ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id,
+						       tsa);
+		ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id,
+						       tsa, map);
 		break;
 	default:
 		break;
 	}
+	return 0;
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h
index 60cd5863bf5e..88217d1630ee 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb.h
@@ -1,146 +1,144 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#ifndef _DCB_CONFIG_H_
-#define _DCB_CONFIG_H_
+#ifndef _IXGBE_DCB_H_
+#define _IXGBE_DCB_H_
 
-#include <linux/dcbnl.h>
 #include "ixgbe_type.h"
 
-/* DCB data structures */
-
-#define IXGBE_MAX_PACKET_BUFFERS 8
-#define MAX_USER_PRIORITY        8
-#define MAX_BW_GROUP             8
-#define BW_PERCENT               100
-
-#define DCB_TX_CONFIG            0
-#define DCB_RX_CONFIG            1
-
-/* DCB error Codes */
-#define DCB_SUCCESS              0
-#define DCB_ERR_CONFIG           -1
-#define DCB_ERR_PARAM            -2
-
-/* Transmit and receive Errors */
-/* Error in bandwidth group allocation */
-#define DCB_ERR_BW_GROUP        -3
-/* Error in traffic class bandwidth allocation */
-#define DCB_ERR_TC_BW           -4
-/* Traffic class has both link strict and group strict enabled */
-#define DCB_ERR_LS_GS           -5
-/* Link strict traffic class has non zero bandwidth */
-#define DCB_ERR_LS_BW_NONZERO   -6
-/* Link strict bandwidth group has non zero bandwidth */
-#define DCB_ERR_LS_BWG_NONZERO  -7
-/*  Traffic class has zero bandwidth */
-#define DCB_ERR_TC_BW_ZERO      -8
-
-#define DCB_NOT_IMPLEMENTED      0x7FFFFFFF
-
-struct dcb_pfc_tc_debug {
-	u8  tc;
-	u8  pause_status;
-	u64 pause_quanta;
-};
+/* DCB defines */
+/* DCB credit calculation defines */
+#define IXGBE_DCB_CREDIT_QUANTUM	64
+#define IXGBE_DCB_MAX_CREDIT_REFILL	200   /* 200 * 64B = 12800B */
+#define IXGBE_DCB_MAX_TSO_SIZE		(32 * 1024) /* Max TSO pkt size in DCB*/
+#define IXGBE_DCB_MAX_CREDIT		(2 * IXGBE_DCB_MAX_CREDIT_REFILL)
 
-enum strict_prio_type {
-	prio_none = 0,
-	prio_group,
-	prio_link
-};
+/* 513 for 32KB TSO packet */
+#define IXGBE_DCB_MIN_TSO_CREDIT	\
+	((IXGBE_DCB_MAX_TSO_SIZE / IXGBE_DCB_CREDIT_QUANTUM) + 1)
+
+/* DCB configuration defines */
+#define IXGBE_DCB_MAX_USER_PRIORITY	8
+#define IXGBE_DCB_MAX_BW_GROUP		8
+#define IXGBE_DCB_BW_PERCENT		100
 
-/* DCB capability definitions */
-#define IXGBE_DCB_PG_SUPPORT        0x00000001
-#define IXGBE_DCB_PFC_SUPPORT       0x00000002
-#define IXGBE_DCB_BCN_SUPPORT       0x00000004
-#define IXGBE_DCB_UP2TC_SUPPORT     0x00000008
-#define IXGBE_DCB_GSP_SUPPORT       0x00000010
+#define IXGBE_DCB_TX_CONFIG		0
+#define IXGBE_DCB_RX_CONFIG		1
 
-#define IXGBE_DCB_8_TC_SUPPORT      0x80
+/* DCB capability defines */
+#define IXGBE_DCB_PG_SUPPORT	0x00000001
+#define IXGBE_DCB_PFC_SUPPORT	0x00000002
+#define IXGBE_DCB_BCN_SUPPORT	0x00000004
+#define IXGBE_DCB_UP2TC_SUPPORT	0x00000008
+#define IXGBE_DCB_GSP_SUPPORT	0x00000010
 
-struct dcb_support {
-	/* DCB capabilities */
-	u32 capabilities;
+struct ixgbe_dcb_support {
+	u32 capabilities; /* DCB capabilities */
 
 	/* Each bit represents a number of TCs configurable in the hw.
-	 * If 8 traffic classes can be configured, the value is 0x80.
-	 */
-	u8  traffic_classes;
-	u8  pfc_traffic_classes;
+	 * If 8 traffic classes can be configured, the value is 0x80. */
+	u8 traffic_classes;
+	u8 pfc_traffic_classes;
+};
+
+enum ixgbe_dcb_tsa {
+	ixgbe_dcb_tsa_ets = 0,
+	ixgbe_dcb_tsa_group_strict_cee,
+	ixgbe_dcb_tsa_strict
 };
 
 /* Traffic class bandwidth allocation per direction */
-struct tc_bw_alloc {
-	u8 bwg_id;		  /* Bandwidth Group (BWG) ID */
-	u8 bwg_percent;		  /* % of BWG's bandwidth */
-	u8 link_percent;	  /* % of link bandwidth */
-	u8 up_to_tc_bitmap;	  /* User Priority to Traffic Class mapping */
-	u16 data_credits_refill;  /* Credit refill amount in 64B granularity */
-	u16 data_credits_max;	  /* Max credits for a configured packet buffer
-				   * in 64B granularity.*/
-	enum strict_prio_type prio_type; /* Link or Group Strict Priority */
+struct ixgbe_dcb_tc_path {
+	u8 bwg_id; /* Bandwidth Group (BWG) ID */
+	u8 bwg_percent; /* % of BWG's bandwidth */
+	u8 link_percent; /* % of link bandwidth */
+	u8 up_to_tc_bitmap; /* User Priority to Traffic Class mapping */
+	u16 data_credits_refill; /* Credit refill amount in 64B granularity */
+	u16 data_credits_max; /* Max credits for a configured packet buffer
+			       * in 64B granularity.*/
+	enum ixgbe_dcb_tsa tsa; /* Link or Group Strict Priority */
 };
 
-enum dcb_pfc_type {
-	pfc_disabled = 0,
-	pfc_enabled_full,
-	pfc_enabled_tx,
-	pfc_enabled_rx
+enum ixgbe_dcb_pfc {
+	ixgbe_dcb_pfc_disabled = 0,
+	ixgbe_dcb_pfc_enabled,
+	ixgbe_dcb_pfc_enabled_txonly,
+	ixgbe_dcb_pfc_enabled_rxonly
 };
 
 /* Traffic class configuration */
-struct tc_configuration {
-	struct tc_bw_alloc path[2]; /* One each for Tx/Rx */
-	enum dcb_pfc_type  dcb_pfc; /* Class based flow control setting */
+struct ixgbe_dcb_tc_config {
+	struct ixgbe_dcb_tc_path path[2]; /* One each for Tx/Rx */
+	enum ixgbe_dcb_pfc pfc; /* Class based flow control setting */
 
 	u16 desc_credits_max; /* For Tx Descriptor arbitration */
 	u8 tc; /* Traffic class (TC) */
 };
 
-struct dcb_num_tcs {
+enum ixgbe_dcb_pba {
+	/* PBA[0-7] each use 64KB FIFO */
+	ixgbe_dcb_pba_equal = PBA_STRATEGY_EQUAL,
+	/* PBA[0-3] each use 80KB, PBA[4-7] each use 48KB */
+	ixgbe_dcb_pba_80_48 = PBA_STRATEGY_WEIGHTED
+};
+
+struct ixgbe_dcb_num_tcs {
 	u8 pg_tcs;
 	u8 pfc_tcs;
 };
 
 struct ixgbe_dcb_config {
-	struct dcb_support support;
-	struct dcb_num_tcs num_tcs;
-	struct tc_configuration tc_config[MAX_TRAFFIC_CLASS];
-	u8     bw_percentage[2][MAX_BW_GROUP]; /* One each for Tx/Rx */
-	bool   pfc_mode_enable;
-
-	u32  dcb_cfg_version; /* Not used...OS-specific? */
-	u32  link_speed; /* For bandwidth allocation validation purpose */
+	struct ixgbe_dcb_tc_config tc_config[IXGBE_DCB_MAX_TRAFFIC_CLASS];
+	struct ixgbe_dcb_support support;
+	struct ixgbe_dcb_num_tcs num_tcs;
+	u8 bw_percentage[2][IXGBE_DCB_MAX_BW_GROUP]; /* One each for Tx/Rx */
+	bool pfc_mode_enable;
+	bool round_robin_enable;
+
+	enum ixgbe_dcb_pba rx_pba_cfg;
+
+	u32 dcb_cfg_version; /* Not used...OS-specific? */
+	u32 link_speed; /* For bandwidth allocation validation purpose */
+	bool vt_mode;
 };
 
 /* DCB driver APIs */
-void ixgbe_dcb_unpack_pfc(struct ixgbe_dcb_config *cfg, u8 *pfc_en);
-void ixgbe_dcb_unpack_refill(struct ixgbe_dcb_config *, int, u16 *);
-void ixgbe_dcb_unpack_max(struct ixgbe_dcb_config *, u16 *);
-void ixgbe_dcb_unpack_bwgid(struct ixgbe_dcb_config *, int, u8 *);
-void ixgbe_dcb_unpack_prio(struct ixgbe_dcb_config *, int, u8 *);
-void ixgbe_dcb_unpack_map(struct ixgbe_dcb_config *, int, u8 *);
-u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *, int, u8);
+
+/* DCB rule checking */
+s32 ixgbe_dcb_check_config_cee(struct ixgbe_dcb_config *);
 
 /* DCB credits calculation */
-s32 ixgbe_dcb_calculate_tc_credits(struct ixgbe_hw *,
-				   struct ixgbe_dcb_config *, int, u8);
-
-/* DCB hw initialization */
-s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max);
-s32 ixgbe_dcb_hw_ets_config(struct ixgbe_hw *hw, u16 *refill, u16 *max,
-			    u8 *bwg_id, u8 *prio_type, u8 *tc_prio);
-s32 ixgbe_dcb_hw_pfc_config(struct ixgbe_hw *hw, u8 pfc_en, u8 *tc_prio);
-s32 ixgbe_dcb_hw_config(struct ixgbe_hw *, struct ixgbe_dcb_config *);
-
-void ixgbe_dcb_read_rtrup2tc(struct ixgbe_hw *hw, u8 *map);
-
-/* DCB definitions for credit calculation */
-#define DCB_CREDIT_QUANTUM	64   /* DCB Quantum */
-#define MAX_CREDIT_REFILL       511  /* 0x1FF * 64B = 32704B */
-#define DCB_MAX_TSO_SIZE        (32*1024) /* MAX TSO packet size supported in DCB mode */
-#define MINIMUM_CREDIT_FOR_TSO  (DCB_MAX_TSO_SIZE/64 + 1) /* 513 for 32KB TSO packet */
-#define MAX_CREDIT              4095 /* Maximum credit supported: 256KB * 1204 / 64B */
-
-#endif /* _DCB_CONFIG_H */
+s32 ixgbe_dcb_calculate_tc_credits(u8 *, u16 *, u16 *, int);
+s32 ixgbe_dcb_calculate_tc_credits_cee(struct ixgbe_hw *,
+				       struct ixgbe_dcb_config *, u32, u8);
+
+/* DCB PFC */
+s32 ixgbe_dcb_config_pfc(struct ixgbe_hw *, u8, u8 *);
+s32 ixgbe_dcb_config_pfc_cee(struct ixgbe_hw *, struct ixgbe_dcb_config *);
+
+/* DCB stats */
+s32 ixgbe_dcb_config_tc_stats(struct ixgbe_hw *);
+s32 ixgbe_dcb_get_tc_stats(struct ixgbe_hw *, struct ixgbe_hw_stats *, u8);
+s32 ixgbe_dcb_get_pfc_stats(struct ixgbe_hw *, struct ixgbe_hw_stats *, u8);
+
+/* DCB config arbiters */
+s32 ixgbe_dcb_config_tx_desc_arbiter_cee(struct ixgbe_hw *,
+					 struct ixgbe_dcb_config *);
+s32 ixgbe_dcb_config_tx_data_arbiter_cee(struct ixgbe_hw *,
+					 struct ixgbe_dcb_config *);
+s32 ixgbe_dcb_config_rx_arbiter_cee(struct ixgbe_hw *,
+				    struct ixgbe_dcb_config *);
+
+/* DCB unpack routines */
+void ixgbe_dcb_unpack_pfc_cee(struct ixgbe_dcb_config *, u8 *, u8 *);
+void ixgbe_dcb_unpack_refill_cee(struct ixgbe_dcb_config *, int, u16 *);
+void ixgbe_dcb_unpack_max_cee(struct ixgbe_dcb_config *, u16 *);
+void ixgbe_dcb_unpack_bwgid_cee(struct ixgbe_dcb_config *, int, u8 *);
+void ixgbe_dcb_unpack_tsa_cee(struct ixgbe_dcb_config *, int, u8 *);
+void ixgbe_dcb_unpack_map_cee(struct ixgbe_dcb_config *, int, u8 *);
+u8 ixgbe_dcb_get_tc_from_up(struct ixgbe_dcb_config *, int, u8);
+
+/* DCB initialization */
+s32 ixgbe_dcb_hw_config(struct ixgbe_hw *, u16 *, u16 *, u8 *, u8 *, u8 *);
+s32 ixgbe_dcb_hw_config_cee(struct ixgbe_hw *, struct ixgbe_dcb_config *);
+#endif /* _IXGBE_DCB_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
index 379ae747cdce..db550e5da7f9 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.c
@@ -1,29 +1,98 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
 
-#include "ixgbe.h"
 #include "ixgbe_type.h"
 #include "ixgbe_dcb.h"
 #include "ixgbe_dcb_82598.h"
 
+/**
+ * ixgbe_dcb_get_tc_stats_82598 - Return status data for each traffic class
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the status data for each of the Traffic Classes in use.
+ */
+s32 ixgbe_dcb_get_tc_stats_82598(struct ixgbe_hw *hw,
+				 struct ixgbe_hw_stats *stats,
+				 u8 tc_count)
+{
+	int tc;
+
+	DEBUGFUNC("dcb_get_tc_stats");
+
+	if (tc_count > IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return IXGBE_ERR_PARAM;
+
+	/* Statistics pertaining to each traffic class */
+	for (tc = 0; tc < tc_count; tc++) {
+		/* Transmitted Packets */
+		stats->qptc[tc] += IXGBE_READ_REG(hw, IXGBE_QPTC(tc));
+		/* Transmitted Bytes */
+		stats->qbtc[tc] += IXGBE_READ_REG(hw, IXGBE_QBTC(tc));
+		/* Received Packets */
+		stats->qprc[tc] += IXGBE_READ_REG(hw, IXGBE_QPRC(tc));
+		/* Received Bytes */
+		stats->qbrc[tc] += IXGBE_READ_REG(hw, IXGBE_QBRC(tc));
+
+#if 0
+		/* Can we get rid of these??  Consequently, getting rid
+		 * of the tc_stats structure.
+		 */
+		tc_stats_array[up]->in_overflow_discards = 0;
+		tc_stats_array[up]->out_overflow_discards = 0;
+#endif
+	}
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_dcb_get_pfc_stats_82598 - Returns CBFC status data
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the CBFC status data for each of the Traffic Classes.
+ */
+s32 ixgbe_dcb_get_pfc_stats_82598(struct ixgbe_hw *hw,
+				  struct ixgbe_hw_stats *stats,
+				  u8 tc_count)
+{
+	int tc;
+
+	DEBUGFUNC("dcb_get_pfc_stats");
+
+	if (tc_count > IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return IXGBE_ERR_PARAM;
+
+	for (tc = 0; tc < tc_count; tc++) {
+		/* Priority XOFF Transmitted */
+		stats->pxofftxc[tc] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(tc));
+		/* Priority XOFF Received */
+		stats->pxoffrxc[tc] += IXGBE_READ_REG(hw, IXGBE_PXOFFRXC(tc));
+	}
+
+	return IXGBE_SUCCESS;
+}
+
 /**
  * ixgbe_dcb_config_rx_arbiter_82598 - Config Rx data arbiter
  * @hw: pointer to hardware structure
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
- * @prio_type: priority type indexed by traffic class
+ * @tsa: transmission selection algorithm indexed by traffic class
  *
  * Configure Rx Data Arbiter and credits for each traffic class.
  */
-s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw,
-					u16 *refill,
-					u16 *max,
-					u8 *prio_type)
+s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw, u16 *refill,
+				      u16 *max, u8 *tsa)
 {
-	u32    reg           = 0;
-	u32    credit_refill = 0;
-	u32    credit_max    = 0;
-	u8     i             = 0;
+	u32 reg = 0;
+	u32 credit_refill = 0;
+	u32 credit_max = 0;
+	u8 i = 0;
 
 	reg = IXGBE_READ_REG(hw, IXGBE_RUPPBMR) | IXGBE_RUPPBMR_MQA;
 	IXGBE_WRITE_REG(hw, IXGBE_RUPPBMR, reg);
@@ -39,13 +108,13 @@ s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw,
 	IXGBE_WRITE_REG(hw, IXGBE_RMCS, reg);
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		credit_refill = refill[i];
-		credit_max    = max[i];
+		credit_max = max[i];
 
 		reg = credit_refill | (credit_max << IXGBE_RT2CR_MCL_SHIFT);
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_RT2CR_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_RT2CR(i), reg);
@@ -62,7 +131,7 @@ s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw,
 	reg &= ~IXGBE_RXCTRL_DMBYPS;
 	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, reg);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -71,18 +140,16 @@ s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw,
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
+ * @tsa: transmission selection algorithm indexed by traffic class
  *
  * Configure Tx Descriptor Arbiter and credits for each traffic class.
  */
 s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type)
+					   u16 *refill, u16 *max, u8 *bwg_id,
+					   u8 *tsa)
 {
-	u32    reg, max_credits;
-	u8     i;
+	u32 reg, max_credits;
+	u8 i;
 
 	reg = IXGBE_READ_REG(hw, IXGBE_DPMCS);
 
@@ -96,22 +163,22 @@ s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw,
 	IXGBE_WRITE_REG(hw, IXGBE_DPMCS, reg);
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		max_credits = max[i];
 		reg = max_credits << IXGBE_TDTQ2TCCR_MCL_SHIFT;
-		reg |= refill[i];
+		reg |= (u32)(refill[i]);
 		reg |= (u32)(bwg_id[i]) << IXGBE_TDTQ2TCCR_BWG_SHIFT;
 
-		if (prio_type[i] == prio_group)
+		if (tsa[i] == ixgbe_dcb_tsa_group_strict_cee)
 			reg |= IXGBE_TDTQ2TCCR_GSP;
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_TDTQ2TCCR_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_TDTQ2TCCR(i), reg);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -120,15 +187,13 @@ s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw,
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
+ * @tsa: transmission selection algorithm indexed by traffic class
  *
  * Configure Tx Data Arbiter and credits for each traffic class.
  */
 s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type)
+					   u16 *refill, u16 *max, u8 *bwg_id,
+					   u8 *tsa)
 {
 	u32 reg;
 	u8 i;
@@ -142,15 +207,15 @@ s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw,
 	IXGBE_WRITE_REG(hw, IXGBE_PDPMCS, reg);
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		reg = refill[i];
 		reg |= (u32)(max[i]) << IXGBE_TDPT2TCCR_MCL_SHIFT;
 		reg |= (u32)(bwg_id[i]) << IXGBE_TDPT2TCCR_BWG_SHIFT;
 
-		if (prio_type[i] == prio_group)
+		if (tsa[i] == ixgbe_dcb_tsa_group_strict_cee)
 			reg |= IXGBE_TDPT2TCCR_GSP;
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_TDPT2TCCR_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_TDPT2TCCR(i), reg);
@@ -161,7 +226,7 @@ s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw,
 	reg |= IXGBE_DTXCTL_ENDBUBD;
 	IXGBE_WRITE_REG(hw, IXGBE_DTXCTL, reg);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -174,7 +239,7 @@ s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw,
 s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en)
 {
 	u32 fcrtl, reg;
-	u8  i;
+	u8 i;
 
 	/* Enable Transmit Priority Flow Control */
 	reg = IXGBE_READ_REG(hw, IXGBE_RMCS);
@@ -192,8 +257,8 @@ s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en)
 	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, reg);
 
 	/* Configure PFC Tx thresholds per TC */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
-		if (!(pfc_en & BIT(i))) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
+		if (!(pfc_en & (1 << i))) {
 			IXGBE_WRITE_REG(hw, IXGBE_FCRTL(i), 0);
 			IXGBE_WRITE_REG(hw, IXGBE_FCRTH(i), 0);
 			continue;
@@ -206,15 +271,14 @@ s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en)
 	}
 
 	/* Configure pause time */
-	reg = hw->fc.pause_time * 0x00010001;
-	for (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)
+	reg = hw->fc.pause_time | (hw->fc.pause_time << 16);
+	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
 		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);
 
 	/* Configure flow control refresh threshold value */
 	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);
 
-
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -224,11 +288,11 @@ s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *hw, u8 pfc_en)
  * Configure queue statistics registers, all queues belonging to same traffic
  * class uses a single set of queue statistics counters.
  */
-static s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw)
+s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw)
 {
 	u32 reg = 0;
-	u8  i   = 0;
-	u8  j   = 0;
+	u8 i = 0;
+	u8 j = 0;
 
 	/* Receive Queues stats setting -  8 queues per statistics reg */
 	for (i = 0, j = 0; i < 15 && j < 8; i = i + 2, j++) {
@@ -239,37 +303,39 @@ static s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *hw)
 		reg |= ((0x1010101) * j);
 		IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i + 1), reg);
 	}
-	/* Transmit Queues stats setting -  4 queues per statistics reg */
+	/* Transmit Queues stats setting -  4 queues per statistics reg*/
 	for (i = 0; i < 8; i++) {
 		reg = IXGBE_READ_REG(hw, IXGBE_TQSMR(i));
 		reg |= ((0x1010101) * i);
 		IXGBE_WRITE_REG(hw, IXGBE_TQSMR(i), reg);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_dcb_hw_config_82598 - Config and enable DCB
  * @hw: pointer to hardware structure
- * @pfc_en: enabled pfc bitmask
+ * @link_speed: unused
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
+ * @tsa: transmission selection algorithm indexed by traffic class
  *
  * Configure dcb settings and enable dcb mode.
  */
-s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill,
-			      u16 *max, u8 *bwg_id, u8 *prio_type)
+s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw, int link_speed,
+			      u16 *refill, u16 *max, u8 *bwg_id,
+			      u8 *tsa)
 {
-	ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, prio_type);
-	ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max,
-					       bwg_id, prio_type);
-	ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max,
-					       bwg_id, prio_type);
-	ixgbe_dcb_config_pfc_82598(hw, pfc_en);
+	UNREFERENCED_1PARAMETER(link_speed);
+
+	ixgbe_dcb_config_rx_arbiter_82598(hw, refill, max, tsa);
+	ixgbe_dcb_config_tx_desc_arbiter_82598(hw, refill, max, bwg_id,
+					       tsa);
+	ixgbe_dcb_config_tx_data_arbiter_82598(hw, refill, max, bwg_id,
+					       tsa);
 	ixgbe_dcb_config_tc_stats_82598(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h
index fdca41abb44c..056700929d2d 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82598.h
@@ -1,72 +1,69 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#ifndef _DCB_82598_CONFIG_H_
-#define _DCB_82598_CONFIG_H_
+#ifndef _IXGBE_DCB_82598_H_
+#define _IXGBE_DCB_82598_H_
 
 /* DCB register definitions */
 
-#define IXGBE_DPMCS_MTSOS_SHIFT 16
-#define IXGBE_DPMCS_TDPAC       0x00000001 /* 0 Round Robin, 1 DFP - Deficit Fixed Priority */
-#define IXGBE_DPMCS_TRM         0x00000010 /* Transmit Recycle Mode */
-#define IXGBE_DPMCS_ARBDIS      0x00000040 /* DCB arbiter disable */
-#define IXGBE_DPMCS_TSOEF       0x00080000 /* TSO Expand Factor: 0=x4, 1=x2 */
-
-#define IXGBE_RUPPBMR_MQA       0x80000000 /* Enable UP to queue mapping */
-
-#define IXGBE_RT2CR_MCL_SHIFT   12 /* Offset to Max Credit Limit setting */
-#define IXGBE_RT2CR_LSP         0x80000000 /* LSP enable bit */
-
-#define IXGBE_RDRXCTL_MPBEN     0x00000010 /* DMA config for multiple packet buffers enable */
-#define IXGBE_RDRXCTL_MCEN      0x00000040 /* DMA config for multiple cores (RSS) enable */
-
-#define IXGBE_TDTQ2TCCR_MCL_SHIFT   12
-#define IXGBE_TDTQ2TCCR_BWG_SHIFT   9
-#define IXGBE_TDTQ2TCCR_GSP     0x40000000
-#define IXGBE_TDTQ2TCCR_LSP     0x80000000
-
-#define IXGBE_TDPT2TCCR_MCL_SHIFT   12
-#define IXGBE_TDPT2TCCR_BWG_SHIFT   9
-#define IXGBE_TDPT2TCCR_GSP     0x40000000
-#define IXGBE_TDPT2TCCR_LSP     0x80000000
-
-#define IXGBE_PDPMCS_TPPAC      0x00000020 /* 0 Round Robin, 1 for DFP - Deficit Fixed Priority */
-#define IXGBE_PDPMCS_ARBDIS     0x00000040 /* Arbiter disable */
-#define IXGBE_PDPMCS_TRM        0x00000100 /* Transmit Recycle Mode enable */
-
-#define IXGBE_DTXCTL_ENDBUBD    0x00000004 /* Enable DBU buffer division */
-
-#define IXGBE_TXPBSIZE_40KB     0x0000A000 /* 40KB Packet Buffer */
-#define IXGBE_RXPBSIZE_48KB     0x0000C000 /* 48KB Packet Buffer */
-#define IXGBE_RXPBSIZE_64KB     0x00010000 /* 64KB Packet Buffer */
-#define IXGBE_RXPBSIZE_80KB     0x00014000 /* 80KB Packet Buffer */
-
-#define IXGBE_RDRXCTL_RDMTS_1_2 0x00000000
-
-/* DCB hardware-specific driver APIs */
-
-/* DCB PFC functions */
-s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *, u8 pfc_en);
-
-/* DCB hw initialization */
-s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *hw,
-					u16 *refill,
-					u16 *max,
-					u8 *prio_type);
-
-s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type);
-
-s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type);
-
-s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill,
-			      u16 *max, u8 *bwg_id, u8 *prio_type);
-
-#endif /* _DCB_82598_CONFIG_H */
+#define IXGBE_DPMCS_MTSOS_SHIFT	16
+#define IXGBE_DPMCS_TDPAC	0x00000001 /* 0 Round Robin,
+					    * 1 DFP - Deficit Fixed Priority */
+#define IXGBE_DPMCS_TRM		0x00000010 /* Transmit Recycle Mode */
+#define IXGBE_DPMCS_ARBDIS	0x00000040 /* DCB arbiter disable */
+#define IXGBE_DPMCS_TSOEF	0x00080000 /* TSO Expand Factor: 0=x4, 1=x2 */
+
+#define IXGBE_RUPPBMR_MQA	0x80000000 /* Enable UP to queue mapping */
+
+#define IXGBE_RT2CR_MCL_SHIFT	12 /* Offset to Max Credit Limit setting */
+#define IXGBE_RT2CR_LSP		0x80000000 /* LSP enable bit */
+
+#define IXGBE_RDRXCTL_MPBEN	0x00000010 /* DMA config for multiple packet
+					    * buffers enable */
+#define IXGBE_RDRXCTL_MCEN	0x00000040 /* DMA config for multiple cores
+					    * (RSS) enable */
+
+#define IXGBE_TDTQ2TCCR_MCL_SHIFT	12
+#define IXGBE_TDTQ2TCCR_BWG_SHIFT	9
+#define IXGBE_TDTQ2TCCR_GSP	0x40000000
+#define IXGBE_TDTQ2TCCR_LSP	0x80000000
+
+#define IXGBE_TDPT2TCCR_MCL_SHIFT	12
+#define IXGBE_TDPT2TCCR_BWG_SHIFT	9
+#define IXGBE_TDPT2TCCR_GSP	0x40000000
+#define IXGBE_TDPT2TCCR_LSP	0x80000000
+
+#define IXGBE_PDPMCS_TPPAC	0x00000020 /* 0 Round Robin,
+					    * 1 DFP - Deficit Fixed Priority */
+#define IXGBE_PDPMCS_ARBDIS	0x00000040 /* Arbiter disable */
+#define IXGBE_PDPMCS_TRM	0x00000100 /* Transmit Recycle Mode enable */
+
+#define IXGBE_DTXCTL_ENDBUBD	0x00000004 /* Enable DBU buffer division */
+
+#define IXGBE_TXPBSIZE_40KB	0x0000A000 /* 40KB Packet Buffer */
+#define IXGBE_RXPBSIZE_48KB	0x0000C000 /* 48KB Packet Buffer */
+#define IXGBE_RXPBSIZE_64KB	0x00010000 /* 64KB Packet Buffer */
+#define IXGBE_RXPBSIZE_80KB	0x00014000 /* 80KB Packet Buffer */
+
+/* DCB driver APIs */
+
+/* DCB PFC */
+s32 ixgbe_dcb_config_pfc_82598(struct ixgbe_hw *, u8);
+
+/* DCB stats */
+s32 ixgbe_dcb_config_tc_stats_82598(struct ixgbe_hw *);
+s32 ixgbe_dcb_get_tc_stats_82598(struct ixgbe_hw *,
+				 struct ixgbe_hw_stats *, u8);
+s32 ixgbe_dcb_get_pfc_stats_82598(struct ixgbe_hw *,
+				  struct ixgbe_hw_stats *, u8);
+
+/* DCB config arbiters */
+s32 ixgbe_dcb_config_tx_desc_arbiter_82598(struct ixgbe_hw *, u16 *, u16 *,
+					   u8 *, u8 *);
+s32 ixgbe_dcb_config_tx_data_arbiter_82598(struct ixgbe_hw *, u16 *, u16 *,
+					   u8 *, u8 *);
+s32 ixgbe_dcb_config_rx_arbiter_82598(struct ixgbe_hw *, u16 *, u16 *, u8 *);
+
+/* DCB initialization */
+s32 ixgbe_dcb_hw_config_82598(struct ixgbe_hw *, int, u16 *, u16 *, u8 *, u8 *);
+#endif /* _IXGBE_DCB_82958_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c
index 7948849840a5..c226393a9c6c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.c
@@ -1,33 +1,100 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
 
-#include "ixgbe.h"
 #include "ixgbe_type.h"
 #include "ixgbe_dcb.h"
 #include "ixgbe_dcb_82599.h"
 
+/**
+ * ixgbe_dcb_get_tc_stats_82599 - Returns status for each traffic class
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the status data for each of the Traffic Classes in use.
+ */
+s32 ixgbe_dcb_get_tc_stats_82599(struct ixgbe_hw *hw,
+				 struct ixgbe_hw_stats *stats,
+				 u8 tc_count)
+{
+	int tc;
+
+	DEBUGFUNC("dcb_get_tc_stats");
+
+	if (tc_count > IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return IXGBE_ERR_PARAM;
+
+	/* Statistics pertaining to each traffic class */
+	for (tc = 0; tc < tc_count; tc++) {
+		/* Transmitted Packets */
+		stats->qptc[tc] += IXGBE_READ_REG(hw, IXGBE_QPTC(tc));
+		/* Transmitted Bytes (read low first to prevent missed carry) */
+		stats->qbtc[tc] += IXGBE_READ_REG(hw, IXGBE_QBTC_L(tc));
+		stats->qbtc[tc] +=
+			(((u64)(IXGBE_READ_REG(hw, IXGBE_QBTC_H(tc)))) << 32);
+		/* Received Packets */
+		stats->qprc[tc] += IXGBE_READ_REG(hw, IXGBE_QPRC(tc));
+		/* Received Bytes (read low first to prevent missed carry) */
+		stats->qbrc[tc] += IXGBE_READ_REG(hw, IXGBE_QBRC_L(tc));
+		stats->qbrc[tc] +=
+			(((u64)(IXGBE_READ_REG(hw, IXGBE_QBRC_H(tc)))) << 32);
+
+		/* Received Dropped Packet */
+		stats->qprdc[tc] += IXGBE_READ_REG(hw, IXGBE_QPRDC(tc));
+	}
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_dcb_get_pfc_stats_82599 - Return CBFC status data
+ * @hw: pointer to hardware structure
+ * @stats: pointer to statistics structure
+ * @tc_count:  Number of elements in bwg_array.
+ *
+ * This function returns the CBFC status data for each of the Traffic Classes.
+ */
+s32 ixgbe_dcb_get_pfc_stats_82599(struct ixgbe_hw *hw,
+				  struct ixgbe_hw_stats *stats,
+				  u8 tc_count)
+{
+	int tc;
+
+	DEBUGFUNC("dcb_get_pfc_stats");
+
+	if (tc_count > IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return IXGBE_ERR_PARAM;
+
+	for (tc = 0; tc < tc_count; tc++) {
+		/* Priority XOFF Transmitted */
+		stats->pxofftxc[tc] += IXGBE_READ_REG(hw, IXGBE_PXOFFTXC(tc));
+		/* Priority XOFF Received */
+		stats->pxoffrxc[tc] += IXGBE_READ_REG(hw, IXGBE_PXOFFRXCNT(tc));
+	}
+
+	return IXGBE_SUCCESS;
+}
+
 /**
  * ixgbe_dcb_config_rx_arbiter_82599 - Config Rx Data arbiter
  * @hw: pointer to hardware structure
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
- * @prio_tc: priority to tc assignments indexed by priority
+ * @tsa: transmission selection algorithm indexed by traffic class
+ * @map: priority to tc assignments indexed by priority
  *
  * Configure Rx Packet Arbiter and credits for each traffic class.
  */
-s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw,
-				      u16 *refill,
-				      u16 *max,
-				      u8 *bwg_id,
-				      u8 *prio_type,
-				      u8 *prio_tc)
+s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw, u16 *refill,
+				      u16 *max, u8 *bwg_id, u8 *tsa,
+				      u8 *map)
 {
-	u32    reg           = 0;
-	u32    credit_refill = 0;
-	u32    credit_max    = 0;
-	u8     i             = 0;
+	u32 reg = 0;
+	u32 credit_refill = 0;
+	u32 credit_max = 0;
+	u8  i = 0;
 
 	/*
 	 * Disable the arbiter before changing parameters
@@ -36,21 +103,27 @@ s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw,
 	reg = IXGBE_RTRPCS_RRM | IXGBE_RTRPCS_RAC | IXGBE_RTRPCS_ARBDIS;
 	IXGBE_WRITE_REG(hw, IXGBE_RTRPCS, reg);
 
-	/* Map all traffic classes to their UP */
+	/*
+	 * map all UPs to TCs. up_to_tc_bitmap for each TC has corresponding
+	 * bits sets for the UPs that needs to be mappped to that TC.
+	 * e.g if priorities 6 and 7 are to be mapped to a TC then the
+	 * up_to_tc_bitmap value for that TC will be 11000000 in binary.
+	 */
 	reg = 0;
-	for (i = 0; i < MAX_USER_PRIORITY; i++)
-		reg |= (prio_tc[i] << (i * IXGBE_RTRUP2TC_UP_SHIFT));
+	for (i = 0; i < IXGBE_DCB_MAX_USER_PRIORITY; i++)
+		reg |= (map[i] << (i * IXGBE_RTRUP2TC_UP_SHIFT));
+
 	IXGBE_WRITE_REG(hw, IXGBE_RTRUP2TC, reg);
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		credit_refill = refill[i];
-		credit_max    = max[i];
+		credit_max = max[i];
 		reg = credit_refill | (credit_max << IXGBE_RTRPT4C_MCL_SHIFT);
 
 		reg |= (u32)(bwg_id[i]) << IXGBE_RTRPT4C_BWG_SHIFT;
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_RTRPT4C_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_RTRPT4C(i), reg);
@@ -63,7 +136,7 @@ s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw,
 	reg = IXGBE_RTRPCS_RRM | IXGBE_RTRPCS_RAC;
 	IXGBE_WRITE_REG(hw, IXGBE_RTRPCS, reg);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -72,18 +145,15 @@ s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw,
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
+ * @tsa: transmission selection algorithm indexed by traffic class
  *
  * Configure Tx Descriptor Arbiter and credits for each traffic class.
  */
-s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw,
-					   u16 *refill,
-					   u16 *max,
-					   u8 *bwg_id,
-					   u8 *prio_type)
+s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw, u16 *refill,
+					   u16 *max, u8 *bwg_id, u8 *tsa)
 {
-	u32    reg, max_credits;
-	u8     i;
+	u32 reg, max_credits;
+	u8  i;
 
 	/* Clear the per-Tx queue credits; we use per-TC instead */
 	for (i = 0; i < 128; i++) {
@@ -92,16 +162,16 @@ s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw,
 	}
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		max_credits = max[i];
 		reg = max_credits << IXGBE_RTTDT2C_MCL_SHIFT;
-		reg |= refill[i];
+		reg |= (u32)(refill[i]);
 		reg |= (u32)(bwg_id[i]) << IXGBE_RTTDT2C_BWG_SHIFT;
 
-		if (prio_type[i] == prio_group)
+		if (tsa[i] == ixgbe_dcb_tsa_group_strict_cee)
 			reg |= IXGBE_RTTDT2C_GSP;
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_RTTDT2C_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_RTTDT2C(i), reg);
@@ -114,7 +184,7 @@ s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw,
 	reg = IXGBE_RTTDCS_TDPAC | IXGBE_RTTDCS_TDRM;
 	IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, reg);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -123,17 +193,14 @@ s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw,
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
- * @prio_tc: priority to tc assignments indexed by priority
+ * @tsa: transmission selection algorithm indexed by traffic class
+ * @map: priority to tc assignments indexed by priority
  *
  * Configure Tx Packet Arbiter and credits for each traffic class.
  */
-s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw,
-					   u16 *refill,
-					   u16 *max,
-					   u8 *bwg_id,
-					   u8 *prio_type,
-					   u8 *prio_tc)
+s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw, u16 *refill,
+					   u16 *max, u8 *bwg_id, u8 *tsa,
+					   u8 *map)
 {
 	u32 reg;
 	u8 i;
@@ -147,22 +214,28 @@ s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw,
 	      IXGBE_RTTPCS_ARBDIS;
 	IXGBE_WRITE_REG(hw, IXGBE_RTTPCS, reg);
 
-	/* Map all traffic classes to their UP */
+	/*
+	 * map all UPs to TCs. up_to_tc_bitmap for each TC has corresponding
+	 * bits sets for the UPs that needs to be mappped to that TC.
+	 * e.g if priorities 6 and 7 are to be mapped to a TC then the
+	 * up_to_tc_bitmap value for that TC will be 11000000 in binary.
+	 */
 	reg = 0;
-	for (i = 0; i < MAX_USER_PRIORITY; i++)
-		reg |= (prio_tc[i] << (i * IXGBE_RTTUP2TC_UP_SHIFT));
+	for (i = 0; i < IXGBE_DCB_MAX_USER_PRIORITY; i++)
+		reg |= (map[i] << (i * IXGBE_RTTUP2TC_UP_SHIFT));
+
 	IXGBE_WRITE_REG(hw, IXGBE_RTTUP2TC, reg);
 
 	/* Configure traffic class credits and priority */
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		reg = refill[i];
 		reg |= (u32)(max[i]) << IXGBE_RTTPT2C_MCL_SHIFT;
 		reg |= (u32)(bwg_id[i]) << IXGBE_RTTPT2C_BWG_SHIFT;
 
-		if (prio_type[i] == prio_group)
+		if (tsa[i] == ixgbe_dcb_tsa_group_strict_cee)
 			reg |= IXGBE_RTTPT2C_GSP;
 
-		if (prio_type[i] == prio_link)
+		if (tsa[i] == ixgbe_dcb_tsa_strict)
 			reg |= IXGBE_RTTPT2C_LSP;
 
 		IXGBE_WRITE_REG(hw, IXGBE_RTTPT2C(i), reg);
@@ -176,18 +249,18 @@ s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw,
 	      (IXGBE_RTTPCS_ARBD_DCB << IXGBE_RTTPCS_ARBD_SHIFT);
 	IXGBE_WRITE_REG(hw, IXGBE_RTTPCS, reg);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_dcb_config_pfc_82599 - Configure priority flow control
  * @hw: pointer to hardware structure
  * @pfc_en: enabled pfc bitmask
- * @prio_tc: priority to tc assignments indexed by priority
+ * @map: priority to tc assignments indexed by priority
  *
  * Configure Priority Flow Control (PFC) for each traffic class.
  */
-s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
+s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *map)
 {
 	u32 i, j, fcrtl, reg;
 	u8 max_tc = 0;
@@ -200,8 +273,8 @@ s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 	reg |= IXGBE_MFLCN_DPF;
 
 	/*
-	 * X540 & X550 supports per TC Rx priority flow control.
-	 * So clear all TCs and only enable those that should be
+	 * X540 supports per TC Rx priority flow control.  So
+	 * clear all TCs and only enable those that should be
 	 * enabled.
 	 */
 	reg &= ~(IXGBE_MFLCN_RPFCE_MASK | IXGBE_MFLCN_RFCE);
@@ -214,9 +287,9 @@ s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 
 	IXGBE_WRITE_REG(hw, IXGBE_MFLCN, reg);
 
-	for (i = 0; i < MAX_USER_PRIORITY; i++) {
-		if (prio_tc[i] > max_tc)
-			max_tc = prio_tc[i];
+	for (i = 0; i < IXGBE_DCB_MAX_USER_PRIORITY; i++) {
+		if (map[i] > max_tc)
+			max_tc = map[i];
 	}
 
 
@@ -224,8 +297,8 @@ s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 	for (i = 0; i <= max_tc; i++) {
 		int enabled = 0;
 
-		for (j = 0; j < MAX_USER_PRIORITY; j++) {
-			if ((prio_tc[j] == i) && (pfc_en & BIT(j))) {
+		for (j = 0; j < IXGBE_DCB_MAX_USER_PRIORITY; j++) {
+			if ((map[j] == i) && (pfc_en & (1 << j))) {
 				enabled = 1;
 				break;
 			}
@@ -236,7 +309,8 @@ s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 			fcrtl = (hw->fc.low_water[i] << 10) | IXGBE_FCRTL_XONE;
 			IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), fcrtl);
 		} else {
-			/* In order to prevent Tx hangs when the internal Tx
+			/*
+			 * In order to prevent Tx hangs when the internal Tx
 			 * switch is enabled we must set the high water mark
 			 * to the Rx packet buffer size - 24KB.  This allows
 			 * the Tx switch to function even under heavy Rx
@@ -249,99 +323,258 @@ s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc)
 		IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(i), reg);
 	}
 
-	for (; i < MAX_TRAFFIC_CLASS; i++) {
+	for (; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		IXGBE_WRITE_REG(hw, IXGBE_FCRTL_82599(i), 0);
 		IXGBE_WRITE_REG(hw, IXGBE_FCRTH_82599(i), 0);
 	}
 
 	/* Configure pause time (2 TCs per register) */
-	reg = hw->fc.pause_time * 0x00010001;
-	for (i = 0; i < (MAX_TRAFFIC_CLASS / 2); i++)
+	reg = hw->fc.pause_time | (hw->fc.pause_time << 16);
+	for (i = 0; i < (IXGBE_DCB_MAX_TRAFFIC_CLASS / 2); i++)
 		IXGBE_WRITE_REG(hw, IXGBE_FCTTV(i), reg);
 
 	/* Configure flow control refresh threshold value */
 	IXGBE_WRITE_REG(hw, IXGBE_FCRTV, hw->fc.pause_time / 2);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_dcb_config_tc_stats_82599 - Config traffic class statistics
  * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
  *
  * Configure queue statistics registers, all queues belonging to same traffic
  * class uses a single set of queue statistics counters.
  */
-static s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *hw)
+s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *hw,
+				    struct ixgbe_dcb_config *dcb_config)
 {
 	u32 reg = 0;
 	u8  i   = 0;
+	u8 tc_count = 8;
+	bool vt_mode = false;
 
-	/*
-	 * Receive Queues stats setting
-	 * 32 RQSMR registers, each configuring 4 queues.
-	 * Set all 16 queues of each TC to the same stat
-	 * with TC 'n' going to stat 'n'.
-	 */
-	for (i = 0; i < 32; i++) {
-		reg = 0x01010101 * (i / 4);
-		IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i), reg);
+	if (dcb_config != NULL) {
+		tc_count = dcb_config->num_tcs.pg_tcs;
+		vt_mode = dcb_config->vt_mode;
 	}
-	/*
-	 * Transmit Queues stats setting
-	 * 32 TQSM registers, each controlling 4 queues.
-	 * Set all queues of each TC to the same stat
-	 * with TC 'n' going to stat 'n'.
-	 * Tx queues are allocated non-uniformly to TCs:
-	 * 32, 32, 16, 16, 8, 8, 8, 8.
-	 */
-	for (i = 0; i < 32; i++) {
-		if (i < 8)
-			reg = 0x00000000;
-		else if (i < 16)
-			reg = 0x01010101;
-		else if (i < 20)
-			reg = 0x02020202;
-		else if (i < 24)
-			reg = 0x03030303;
-		else if (i < 26)
-			reg = 0x04040404;
-		else if (i < 28)
-			reg = 0x05050505;
-		else if (i < 30)
-			reg = 0x06060606;
+
+	if (!((tc_count == 8 && vt_mode == false) || tc_count == 4))
+		return IXGBE_ERR_PARAM;
+
+	if (tc_count == 8 && vt_mode == false) {
+		/*
+		 * Receive Queues stats setting
+		 * 32 RQSMR registers, each configuring 4 queues.
+		 *
+		 * Set all 16 queues of each TC to the same stat
+		 * with TC 'n' going to stat 'n'.
+		 */
+		for (i = 0; i < 32; i++) {
+			reg = 0x01010101 * (i / 4);
+			IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i), reg);
+		}
+		/*
+		 * Transmit Queues stats setting
+		 * 32 TQSM registers, each controlling 4 queues.
+		 *
+		 * Set all queues of each TC to the same stat
+		 * with TC 'n' going to stat 'n'.
+		 * Tx queues are allocated non-uniformly to TCs:
+		 * 32, 32, 16, 16, 8, 8, 8, 8.
+		 */
+		for (i = 0; i < 32; i++) {
+			if (i < 8)
+				reg = 0x00000000;
+			else if (i < 16)
+				reg = 0x01010101;
+			else if (i < 20)
+				reg = 0x02020202;
+			else if (i < 24)
+				reg = 0x03030303;
+			else if (i < 26)
+				reg = 0x04040404;
+			else if (i < 28)
+				reg = 0x05050505;
+			else if (i < 30)
+				reg = 0x06060606;
+			else
+				reg = 0x07070707;
+			IXGBE_WRITE_REG(hw, IXGBE_TQSM(i), reg);
+		}
+	} else if (tc_count == 4 && vt_mode == false) {
+		/*
+		 * Receive Queues stats setting
+		 * 32 RQSMR registers, each configuring 4 queues.
+		 *
+		 * Set all 16 queues of each TC to the same stat
+		 * with TC 'n' going to stat 'n'.
+		 */
+		for (i = 0; i < 32; i++) {
+			if (i % 8 > 3)
+				/* In 4 TC mode, odd 16-queue ranges are
+				 *  not used.
+				*/
+				continue;
+			reg = 0x01010101 * (i / 8);
+			IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i), reg);
+		}
+		/*
+		 * Transmit Queues stats setting
+		 * 32 TQSM registers, each controlling 4 queues.
+		 *
+		 * Set all queues of each TC to the same stat
+		 * with TC 'n' going to stat 'n'.
+		 * Tx queues are allocated non-uniformly to TCs:
+		 * 64, 32, 16, 16.
+		 */
+		for (i = 0; i < 32; i++) {
+			if (i < 16)
+				reg = 0x00000000;
+			else if (i < 24)
+				reg = 0x01010101;
+			else if (i < 28)
+				reg = 0x02020202;
+			else
+				reg = 0x03030303;
+			IXGBE_WRITE_REG(hw, IXGBE_TQSM(i), reg);
+		}
+	} else if (tc_count == 4 && vt_mode == true) {
+		/*
+		 * Receive Queues stats setting
+		 * 32 RQSMR registers, each configuring 4 queues.
+		 *
+		 * Queue Indexing in 32 VF with DCB mode maps 4 TC's to each
+		 * pool. Set all 32 queues of each TC across pools to the same
+		 * stat with TC 'n' going to stat 'n'.
+		 */
+		for (i = 0; i < 32; i++)
+			IXGBE_WRITE_REG(hw, IXGBE_RQSMR(i), 0x03020100);
+		/*
+		 * Transmit Queues stats setting
+		 * 32 TQSM registers, each controlling 4 queues.
+		 *
+		 * Queue Indexing in 32 VF with DCB mode maps 4 TC's to each
+		 * pool. Set all 32 queues of each TC across pools to the same
+		 * stat with TC 'n' going to stat 'n'.
+		 */
+		for (i = 0; i < 32; i++)
+			IXGBE_WRITE_REG(hw, IXGBE_TQSM(i), 0x03020100);
+	}
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_dcb_config_82599 - Configure general DCB parameters
+ * @hw: pointer to hardware structure
+ * @dcb_config: pointer to ixgbe_dcb_config structure
+ *
+ * Configure general DCB parameters.
+ */
+s32 ixgbe_dcb_config_82599(struct ixgbe_hw *hw,
+			   struct ixgbe_dcb_config *dcb_config)
+{
+	u32 reg;
+	u32 q;
+
+	/* Disable the Tx desc arbiter so that MTQC can be changed */
+	reg = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
+	reg |= IXGBE_RTTDCS_ARBDIS;
+	IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, reg);
+
+	reg = IXGBE_READ_REG(hw, IXGBE_MRQC);
+	if (dcb_config->num_tcs.pg_tcs == 8) {
+		/* Enable DCB for Rx with 8 TCs */
+		switch (reg & IXGBE_MRQC_MRQE_MASK) {
+		case 0:
+		case IXGBE_MRQC_RT4TCEN:
+			/* RSS disabled cases */
+			reg = (reg & ~IXGBE_MRQC_MRQE_MASK) |
+			      IXGBE_MRQC_RT8TCEN;
+			break;
+		case IXGBE_MRQC_RSSEN:
+		case IXGBE_MRQC_RTRSS4TCEN:
+			/* RSS enabled cases */
+			reg = (reg & ~IXGBE_MRQC_MRQE_MASK) |
+			      IXGBE_MRQC_RTRSS8TCEN;
+			break;
+		default:
+			/*
+			 * Unsupported value, assume stale data,
+			 * overwrite no RSS
+			 */
+			ASSERT(0);
+			reg = (reg & ~IXGBE_MRQC_MRQE_MASK) |
+			      IXGBE_MRQC_RT8TCEN;
+		}
+	}
+	if (dcb_config->num_tcs.pg_tcs == 4) {
+		/* We support both VT-on and VT-off with 4 TCs. */
+		if (dcb_config->vt_mode)
+			reg = (reg & ~IXGBE_MRQC_MRQE_MASK) |
+			      IXGBE_MRQC_VMDQRT4TCEN;
 		else
-			reg = 0x07070707;
-		IXGBE_WRITE_REG(hw, IXGBE_TQSM(i), reg);
+			reg = (reg & ~IXGBE_MRQC_MRQE_MASK) |
+			      IXGBE_MRQC_RTRSS4TCEN;
+	}
+	IXGBE_WRITE_REG(hw, IXGBE_MRQC, reg);
+
+	/* Enable DCB for Tx with 8 TCs */
+	if (dcb_config->num_tcs.pg_tcs == 8)
+		reg = IXGBE_MTQC_RT_ENA | IXGBE_MTQC_8TC_8TQ;
+	else {
+		/* We support both VT-on and VT-off with 4 TCs. */
+		reg = IXGBE_MTQC_RT_ENA | IXGBE_MTQC_4TC_4TQ;
+		if (dcb_config->vt_mode)
+			reg |= IXGBE_MTQC_VT_ENA;
 	}
+	IXGBE_WRITE_REG(hw, IXGBE_MTQC, reg);
 
-	return 0;
+	/* Disable drop for all queues */
+	for (q = 0; q < 128; q++)
+		IXGBE_WRITE_REG(hw, IXGBE_QDE,
+				(IXGBE_QDE_WRITE | (q << IXGBE_QDE_IDX_SHIFT)));
+
+	/* Enable the Tx desc arbiter */
+	reg = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
+	reg &= ~IXGBE_RTTDCS_ARBDIS;
+	IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, reg);
+
+	/* Enable Security TX Buffer IFG for DCB */
+	reg = IXGBE_READ_REG(hw, IXGBE_SECTXMINIFG);
+	reg |= IXGBE_SECTX_DCB;
+	IXGBE_WRITE_REG(hw, IXGBE_SECTXMINIFG, reg);
+
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_dcb_hw_config_82599 - Configure and enable DCB
  * @hw: pointer to hardware structure
- * @pfc_en: enabled pfc bitmask
+ * @link_speed: unused
  * @refill: refill credits index by traffic class
  * @max: max credits index by traffic class
  * @bwg_id: bandwidth grouping indexed by traffic class
- * @prio_type: priority type indexed by traffic class
- * @prio_tc: priority to tc assignments indexed by priority
+ * @tsa: transmission selection algorithm indexed by traffic class
+ * @map: priority to tc assignments indexed by priority
  *
  * Configure dcb settings and enable dcb mode.
  */
-s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill,
-			      u16 *max, u8 *bwg_id, u8 *prio_type, u8 *prio_tc)
+s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw, int link_speed,
+			      u16 *refill, u16 *max, u8 *bwg_id, u8 *tsa,
+			      u8 *map)
 {
-	ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id,
-					  prio_type, prio_tc);
-	ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max,
-					       bwg_id, prio_type);
-	ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max,
-					       bwg_id, prio_type, prio_tc);
-	ixgbe_dcb_config_pfc_82599(hw, pfc_en, prio_tc);
-	ixgbe_dcb_config_tc_stats_82599(hw);
-
-	return 0;
+	UNREFERENCED_1PARAMETER(link_speed);
+
+	ixgbe_dcb_config_rx_arbiter_82599(hw, refill, max, bwg_id, tsa,
+					  map);
+	ixgbe_dcb_config_tx_desc_arbiter_82599(hw, refill, max, bwg_id,
+					       tsa);
+	ixgbe_dcb_config_tx_data_arbiter_82599(hw, refill, max, bwg_id,
+					       tsa, map);
+
+	return IXGBE_SUCCESS;
 }
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h
index c6f084883cab..3abd7731abdc 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_82599.h
@@ -1,100 +1,97 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#ifndef _DCB_82599_CONFIG_H_
-#define _DCB_82599_CONFIG_H_
+#ifndef _IXGBE_DCB_82599_H_
+#define _IXGBE_DCB_82599_H_
 
 /* DCB register definitions */
-#define IXGBE_RTTDCS_TDPAC      0x00000001 /* 0 Round Robin,
+#define IXGBE_RTTDCS_TDPAC	0x00000001 /* 0 Round Robin,
 					    * 1 WSP - Weighted Strict Priority
 					    */
-#define IXGBE_RTTDCS_VMPAC      0x00000002 /* 0 Round Robin,
+#define IXGBE_RTTDCS_VMPAC	0x00000002 /* 0 Round Robin,
 					    * 1 WRR - Weighted Round Robin
 					    */
-#define IXGBE_RTTDCS_TDRM       0x00000010 /* Transmit Recycle Mode */
-#define IXGBE_RTTDCS_ARBDIS     0x00000040 /* DCB arbiter disable */
-#define IXGBE_RTTDCS_BDPM       0x00400000 /* Bypass Data Pipe - must clear! */
-#define IXGBE_RTTDCS_BPBFSM     0x00800000 /* Bypass PB Free Space - must
+#define IXGBE_RTTDCS_TDRM	0x00000010 /* Transmit Recycle Mode */
+#define IXGBE_RTTDCS_BDPM	0x00400000 /* Bypass Data Pipe - must clear! */
+#define IXGBE_RTTDCS_BPBFSM	0x00800000 /* Bypass PB Free Space - must
 					     * clear!
 					     */
-#define IXGBE_RTTDCS_SPEED_CHG  0x80000000 /* Link speed change */
+#define IXGBE_RTTDCS_SPEED_CHG	0x80000000 /* Link speed change */
 
 /* Receive UP2TC mapping */
-#define IXGBE_RTRUP2TC_UP_SHIFT 3
+#define IXGBE_RTRUP2TC_UP_SHIFT	3
 #define IXGBE_RTRUP2TC_UP_MASK	7
 /* Transmit UP2TC mapping */
-#define IXGBE_RTTUP2TC_UP_SHIFT 3
+#define IXGBE_RTTUP2TC_UP_SHIFT	3
 
-#define IXGBE_RTRPT4C_MCL_SHIFT 12 /* Offset to Max Credit Limit setting */
-#define IXGBE_RTRPT4C_BWG_SHIFT 9  /* Offset to BWG index */
-#define IXGBE_RTRPT4C_GSP       0x40000000 /* GSP enable bit */
-#define IXGBE_RTRPT4C_LSP       0x80000000 /* LSP enable bit */
+#define IXGBE_RTRPT4C_MCL_SHIFT	12 /* Offset to Max Credit Limit setting */
+#define IXGBE_RTRPT4C_BWG_SHIFT	9  /* Offset to BWG index */
+#define IXGBE_RTRPT4C_GSP	0x40000000 /* GSP enable bit */
+#define IXGBE_RTRPT4C_LSP	0x80000000 /* LSP enable bit */
 
-#define IXGBE_RDRXCTL_MPBEN     0x00000010 /* DMA config for multiple packet
+#define IXGBE_RDRXCTL_MPBEN	0x00000010 /* DMA config for multiple packet
 					    * buffers enable
 					    */
-#define IXGBE_RDRXCTL_MCEN      0x00000040 /* DMA config for multiple cores
+#define IXGBE_RDRXCTL_MCEN	0x00000040 /* DMA config for multiple cores
 					    * (RSS) enable
 					    */
 
 /* RTRPCS Bit Masks */
-#define IXGBE_RTRPCS_RRM        0x00000002 /* Receive Recycle Mode enable */
+#define IXGBE_RTRPCS_RRM	0x00000002 /* Receive Recycle Mode enable */
 /* Receive Arbitration Control: 0 Round Robin, 1 DFP */
-#define IXGBE_RTRPCS_RAC        0x00000004
-#define IXGBE_RTRPCS_ARBDIS     0x00000040 /* Arbitration disable bit */
+#define IXGBE_RTRPCS_RAC	0x00000004
+#define IXGBE_RTRPCS_ARBDIS	0x00000040 /* Arbitration disable bit */
 
 /* RTTDT2C Bit Masks */
-#define IXGBE_RTTDT2C_MCL_SHIFT 12
-#define IXGBE_RTTDT2C_BWG_SHIFT 9
-#define IXGBE_RTTDT2C_GSP       0x40000000
-#define IXGBE_RTTDT2C_LSP       0x80000000
+#define IXGBE_RTTDT2C_MCL_SHIFT	12
+#define IXGBE_RTTDT2C_BWG_SHIFT	9
+#define IXGBE_RTTDT2C_GSP	0x40000000
+#define IXGBE_RTTDT2C_LSP	0x80000000
 
-#define IXGBE_RTTPT2C_MCL_SHIFT 12
-#define IXGBE_RTTPT2C_BWG_SHIFT 9
-#define IXGBE_RTTPT2C_GSP       0x40000000
-#define IXGBE_RTTPT2C_LSP       0x80000000
+#define IXGBE_RTTPT2C_MCL_SHIFT	12
+#define IXGBE_RTTPT2C_BWG_SHIFT	9
+#define IXGBE_RTTPT2C_GSP	0x40000000
+#define IXGBE_RTTPT2C_LSP	0x80000000
 
 /* RTTPCS Bit Masks */
-#define IXGBE_RTTPCS_TPPAC      0x00000020 /* 0 Round Robin,
+#define IXGBE_RTTPCS_TPPAC	0x00000020 /* 0 Round Robin,
 					    * 1 SP - Strict Priority
 					    */
-#define IXGBE_RTTPCS_ARBDIS     0x00000040 /* Arbiter disable */
-#define IXGBE_RTTPCS_TPRM       0x00000100 /* Transmit Recycle Mode enable */
-#define IXGBE_RTTPCS_ARBD_SHIFT 22
-#define IXGBE_RTTPCS_ARBD_DCB   0x4        /* Arbitration delay in DCB mode */
+#define IXGBE_RTTPCS_ARBDIS	0x00000040 /* Arbiter disable */
+#define IXGBE_RTTPCS_TPRM	0x00000100 /* Transmit Recycle Mode enable */
+#define IXGBE_RTTPCS_ARBD_SHIFT	22
+#define IXGBE_RTTPCS_ARBD_DCB	0x4 /* Arbitration delay in DCB mode */
 
-/* SECTXMINIFG DCB */
-#define IXGBE_SECTX_DCB		0x00001F00 /* DCB TX Buffer IFG */
-
-
-/* DCB hardware-specific driver APIs */
-
-/* DCB PFC functions */
-s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *hw, u8 pfc_en, u8 *prio_tc);
-
-/* DCB hw initialization */
-s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *hw,
-					u16 *refill,
-					u16 *max,
-					u8 *bwg_id,
-					u8 *prio_type,
-					u8 *prio_tc);
+#define IXGBE_TXPBTHRESH_DCB	0xA /* THRESH value for DCB mode */
 
-s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type);
-
-s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *hw,
-						u16 *refill,
-						u16 *max,
-						u8 *bwg_id,
-						u8 *prio_type,
-						u8 *prio_tc);
-
-s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *hw, u8 pfc_en, u16 *refill,
-			      u16 *max, u8 *bwg_id, u8 *prio_type,
-			      u8 *prio_tc);
-
-#endif /* _DCB_82599_CONFIG_H */
+/* SECTXMINIFG DCB */
+#define IXGBE_SECTX_DCB		0x00001F00 /* DCB TX Buffer SEC IFG */
+
+/* DCB driver APIs */
+
+/* DCB PFC */
+s32 ixgbe_dcb_config_pfc_82599(struct ixgbe_hw *, u8, u8 *);
+
+/* DCB stats */
+s32 ixgbe_dcb_config_tc_stats_82599(struct ixgbe_hw *,
+				    struct ixgbe_dcb_config *);
+s32 ixgbe_dcb_get_tc_stats_82599(struct ixgbe_hw *,
+				 struct ixgbe_hw_stats *, u8);
+s32 ixgbe_dcb_get_pfc_stats_82599(struct ixgbe_hw *,
+				  struct ixgbe_hw_stats *, u8);
+
+/* DCB config arbiters */
+s32 ixgbe_dcb_config_tx_desc_arbiter_82599(struct ixgbe_hw *, u16 *, u16 *,
+					   u8 *, u8 *);
+s32 ixgbe_dcb_config_tx_data_arbiter_82599(struct ixgbe_hw *, u16 *, u16 *,
+					   u8 *, u8 *, u8 *);
+s32 ixgbe_dcb_config_rx_arbiter_82599(struct ixgbe_hw *, u16 *, u16 *, u8 *,
+				      u8 *, u8 *);
+
+/* DCB initialization */
+s32 ixgbe_dcb_config_82599(struct ixgbe_hw *,
+			   struct ixgbe_dcb_config *);
+
+s32 ixgbe_dcb_hw_config_82599(struct ixgbe_hw *, int, u16 *, u16 *, u8 *,
+			      u8 *, u8 *);
+#endif /* _IXGBE_DCB_82959_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
index c00332d2e02a..5bec2f9d710c 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_dcb_nl.c
@@ -1,11 +1,12 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #include "ixgbe.h"
+
+#if IS_ENABLED(CONFIG_DCB)
 #include <linux/dcbnl.h>
 #include "ixgbe_dcb_82598.h"
 #include "ixgbe_dcb_82599.h"
-#include "ixgbe_sriov.h"
 
 /* Callbacks for DCB netlink in the kernel */
 #define BIT_DCB_MODE	0x01
@@ -13,40 +14,36 @@
 #define BIT_PG_RX	0x04
 #define BIT_PG_TX	0x08
 #define BIT_APP_UPCHG	0x10
-#define BIT_LINKSPEED   0x80
+#define BIT_RESETLINK	0x40
+#define BIT_LINKSPEED	0x80
 
 /* Responses for the DCB_C_SET_ALL command */
-#define DCB_HW_CHG_RST  0  /* DCB configuration changed with reset */
-#define DCB_NO_HW_CHG   1  /* DCB configuration did not change */
-#define DCB_HW_CHG      2  /* DCB configuration changed, no reset */
+#define DCB_HW_CHG_RST	0  /* DCB configuration changed with reset */
+#define DCB_NO_HW_CHG	1  /* DCB configuration did not change */
+#define DCB_HW_CHG	2  /* DCB configuration changed, no reset */
 
-static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
+int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
 {
 	struct ixgbe_dcb_config *scfg = &adapter->temp_dcb_cfg;
 	struct ixgbe_dcb_config *dcfg = &adapter->dcb_cfg;
-	struct tc_configuration *src = NULL;
-	struct tc_configuration *dst = NULL;
+	struct ixgbe_dcb_tc_config *src = NULL;
+	struct ixgbe_dcb_tc_config *dst = NULL;
 	int i, j;
-	int tx = DCB_TX_CONFIG;
-	int rx = DCB_RX_CONFIG;
+	int tx = IXGBE_DCB_TX_CONFIG;
+	int rx = IXGBE_DCB_RX_CONFIG;
 	int changes = 0;
-#ifdef IXGBE_FCOE
-	struct dcb_app app = {
-			      .selector = DCB_APP_IDTYPE_ETHTYPE,
-			      .protocol = ETH_P_FCOE,
-			     };
-	u8 up = dcb_getapp(adapter->netdev, &app);
 
-	if (up && !(up & BIT(adapter->fcoe.up)))
+#if IS_ENABLED(CONFIG_FCOE)
+	if (adapter->fcoe.up_set != adapter->fcoe.up)
 		changes |= BIT_APP_UPCHG;
-#endif
+#endif /* CONFIG_FCOE */
 
 	for (i = DCB_PG_ATTR_TC_0; i < tc_max + DCB_PG_ATTR_TC_0; i++) {
 		src = &scfg->tc_config[i - DCB_PG_ATTR_TC_0];
 		dst = &dcfg->tc_config[i - DCB_PG_ATTR_TC_0];
 
-		if (dst->path[tx].prio_type != src->path[tx].prio_type) {
-			dst->path[tx].prio_type = src->path[tx].prio_type;
+		if (dst->path[tx].tsa != src->path[tx].tsa) {
+			dst->path[tx].tsa = src->path[tx].tsa;
 			changes |= BIT_PG_TX;
 		}
 
@@ -61,14 +58,14 @@ static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
 		}
 
 		if (dst->path[tx].up_to_tc_bitmap !=
-				src->path[tx].up_to_tc_bitmap) {
+		    src->path[tx].up_to_tc_bitmap) {
 			dst->path[tx].up_to_tc_bitmap =
 				src->path[tx].up_to_tc_bitmap;
 			changes |= (BIT_PG_TX | BIT_PFC | BIT_APP_UPCHG);
 		}
 
-		if (dst->path[rx].prio_type != src->path[rx].prio_type) {
-			dst->path[rx].prio_type = src->path[rx].prio_type;
+		if (dst->path[rx].tsa != src->path[rx].tsa) {
+			dst->path[rx].tsa = src->path[rx].tsa;
 			changes |= BIT_PG_RX;
 		}
 
@@ -83,7 +80,7 @@ static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
 		}
 
 		if (dst->path[rx].up_to_tc_bitmap !=
-				src->path[rx].up_to_tc_bitmap) {
+		    src->path[rx].up_to_tc_bitmap) {
 			dst->path[rx].up_to_tc_bitmap =
 				src->path[rx].up_to_tc_bitmap;
 			changes |= (BIT_PG_RX | BIT_PFC | BIT_APP_UPCHG);
@@ -92,6 +89,7 @@ static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
 
 	for (i = DCB_PG_ATTR_BW_ID_0; i < DCB_PG_ATTR_BW_ID_MAX; i++) {
 		j = i - DCB_PG_ATTR_BW_ID_0;
+
 		if (dcfg->bw_percentage[tx][j] != scfg->bw_percentage[tx][j]) {
 			dcfg->bw_percentage[tx][j] = scfg->bw_percentage[tx][j];
 			changes |= BIT_PG_TX;
@@ -104,8 +102,8 @@ static int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
 
 	for (i = DCB_PFC_UP_ATTR_0; i < DCB_PFC_UP_ATTR_MAX; i++) {
 		j = i - DCB_PFC_UP_ATTR_0;
-		if (dcfg->tc_config[j].dcb_pfc != scfg->tc_config[j].dcb_pfc) {
-			dcfg->tc_config[j].dcb_pfc = scfg->tc_config[j].dcb_pfc;
+		if (dcfg->tc_config[j].pfc != scfg->tc_config[j].pfc) {
+			dcfg->tc_config[j].pfc = scfg->tc_config[j].pfc;
 			changes |= BIT_PFC;
 		}
 	}
@@ -128,6 +126,7 @@ static u8 ixgbe_dcbnl_get_state(struct net_device *netdev)
 static u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	int err = 0;
 
 	/* Fail command if not in CEE mode */
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
@@ -135,10 +134,12 @@ static u8 ixgbe_dcbnl_set_state(struct net_device *netdev, u8 state)
 
 	/* verify there is something to do, if not then exit */
 	if (!state == !(adapter->flags & IXGBE_FLAG_DCB_ENABLED))
-		return 0;
+		goto out;
 
-	return !!ixgbe_setup_tc(netdev,
-				state ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);
+	err = ixgbe_setup_tc(netdev,
+			     state ? adapter->dcb_cfg.num_tcs.pg_tcs : 0);
+out:
+	return !!err;
 }
 
 static void ixgbe_dcbnl_get_perm_hw_addr(struct net_device *netdev,
@@ -170,8 +171,13 @@ static void ixgbe_dcbnl_set_pg_tc_cfg_tx(struct net_device *netdev, int tc,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+	if (tc < 0 || tc >= IXGBE_DCB_MAX_TRAFFIC_CLASS) {
+		netdev_err(netdev, "Traffic class out of range.\n");
+		return;
+	}
+
 	if (prio != DCB_ATTR_VALUE_UNDEFINED)
-		adapter->temp_dcb_cfg.tc_config[tc].path[0].prio_type = prio;
+		adapter->temp_dcb_cfg.tc_config[tc].path[0].tsa = prio;
 	if (bwg_id != DCB_ATTR_VALUE_UNDEFINED)
 		adapter->temp_dcb_cfg.tc_config[tc].path[0].bwg_id = bwg_id;
 	if (bw_pct != DCB_ATTR_VALUE_UNDEFINED)
@@ -187,6 +193,12 @@ static void ixgbe_dcbnl_set_pg_bwg_cfg_tx(struct net_device *netdev, int bwg_id,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+	if (bwg_id < 0 || bwg_id >= IXGBE_DCB_MAX_BW_GROUP) {
+		netdev_err(netdev,
+			   "BWG index out of range.\n");
+		return;
+	}
+
 	adapter->temp_dcb_cfg.bw_percentage[0][bwg_id] = bw_pct;
 }
 
@@ -196,8 +208,13 @@ static void ixgbe_dcbnl_set_pg_tc_cfg_rx(struct net_device *netdev, int tc,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+	if (tc < 0 || tc >= IXGBE_DCB_MAX_TRAFFIC_CLASS) {
+		netdev_err(netdev, "Traffic class out of range.\n");
+		return;
+	}
+
 	if (prio != DCB_ATTR_VALUE_UNDEFINED)
-		adapter->temp_dcb_cfg.tc_config[tc].path[1].prio_type = prio;
+		adapter->temp_dcb_cfg.tc_config[tc].path[1].tsa = prio;
 	if (bwg_id != DCB_ATTR_VALUE_UNDEFINED)
 		adapter->temp_dcb_cfg.tc_config[tc].path[1].bwg_id = bwg_id;
 	if (bw_pct != DCB_ATTR_VALUE_UNDEFINED)
@@ -213,6 +230,12 @@ static void ixgbe_dcbnl_set_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+	if (bwg_id < 0 || bwg_id >= IXGBE_DCB_MAX_BW_GROUP) {
+		netdev_err(netdev,
+			   "BWG index out of range.\n");
+		return;
+	}
+
 	adapter->temp_dcb_cfg.bw_percentage[1][bwg_id] = bw_pct;
 }
 
@@ -222,7 +245,7 @@ static void ixgbe_dcbnl_get_pg_tc_cfg_tx(struct net_device *netdev, int tc,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
-	*prio = adapter->dcb_cfg.tc_config[tc].path[0].prio_type;
+	*prio = adapter->dcb_cfg.tc_config[tc].path[0].tsa;
 	*bwg_id = adapter->dcb_cfg.tc_config[tc].path[0].bwg_id;
 	*bw_pct = adapter->dcb_cfg.tc_config[tc].path[0].bwg_percent;
 	*up_map = adapter->dcb_cfg.tc_config[tc].path[0].up_to_tc_bitmap;
@@ -242,7 +265,7 @@ static void ixgbe_dcbnl_get_pg_tc_cfg_rx(struct net_device *netdev, int tc,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
-	*prio = adapter->dcb_cfg.tc_config[tc].path[1].prio_type;
+	*prio = adapter->dcb_cfg.tc_config[tc].path[1].tsa;
 	*bwg_id = adapter->dcb_cfg.tc_config[tc].path[1].bwg_id;
 	*bw_pct = adapter->dcb_cfg.tc_config[tc].path[1].bwg_percent;
 	*up_map = adapter->dcb_cfg.tc_config[tc].path[1].up_to_tc_bitmap;
@@ -256,23 +279,22 @@ static void ixgbe_dcbnl_get_pg_bwg_cfg_rx(struct net_device *netdev, int bwg_id,
 	*bw_pct = adapter->dcb_cfg.bw_percentage[1][bwg_id];
 }
 
-static void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev, int priority,
-				    u8 setting)
+static void ixgbe_dcbnl_set_pfc_cfg(struct net_device *netdev, int up, u8 pfc)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	u8 tc = ixgbe_dcb_get_tc_from_up(&adapter->temp_dcb_cfg, 0, up);
 
-	adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc = setting;
-	if (adapter->temp_dcb_cfg.tc_config[priority].dcb_pfc !=
-	    adapter->dcb_cfg.tc_config[priority].dcb_pfc)
+	adapter->temp_dcb_cfg.tc_config[tc].pfc = pfc;
+	if (adapter->temp_dcb_cfg.tc_config[tc].pfc !=
+	    adapter->dcb_cfg.tc_config[tc].pfc)
 		adapter->temp_dcb_cfg.pfc_mode_enable = true;
 }
 
-static void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev, int priority,
-				    u8 *setting)
+static void ixgbe_dcbnl_get_pfc_cfg(struct net_device *netdev, int up, u8 *pfc)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-
-	*setting = adapter->dcb_cfg.tc_config[priority].dcb_pfc;
+	u8 tc = ixgbe_dcb_get_tc_from_up(&adapter->dcb_cfg, 0, up);
+	*pfc = adapter->dcb_cfg.tc_config[tc].pfc;
 }
 
 static void ixgbe_dcbnl_devreset(struct net_device *dev)
@@ -283,13 +305,21 @@ static void ixgbe_dcbnl_devreset(struct net_device *dev)
 		usleep_range(1000, 2000);
 
 	if (netif_running(dev))
+#ifdef HAVE_NET_DEVICE_OPS
 		dev->netdev_ops->ndo_stop(dev);
+#else
+		dev->stop(dev);
+#endif
 
 	ixgbe_clear_interrupt_scheme(adapter);
 	ixgbe_init_interrupt_scheme(adapter);
 
 	if (netif_running(dev))
+#ifdef HAVE_NET_DEVICE_OPS
 		dev->netdev_ops->ndo_open(dev);
+#else
+		dev->open(dev);
+#endif
 
 	clear_bit(__IXGBE_RESETTING, &adapter->state);
 }
@@ -300,83 +330,80 @@ static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
 	struct ixgbe_dcb_config *dcb_cfg = &adapter->dcb_cfg;
 	struct ixgbe_hw *hw = &adapter->hw;
 	int ret = DCB_NO_HW_CHG;
-	int i;
+	u8 prio_tc[IXGBE_DCB_MAX_USER_PRIORITY] = { 0 };
 
 	/* Fail command if not in CEE mode */
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
-		return DCB_NO_HW_CHG;
+		return ret;
 
 	adapter->dcb_set_bitmap |= ixgbe_copy_dcb_cfg(adapter,
-						      MAX_TRAFFIC_CLASS);
+						      IXGBE_DCB_MAX_TRAFFIC_CLASS);
 	if (!adapter->dcb_set_bitmap)
-		return DCB_NO_HW_CHG;
+		return ret;
+
+	ixgbe_dcb_unpack_map_cee(dcb_cfg, IXGBE_DCB_TX_CONFIG, prio_tc);
 
-	if (adapter->dcb_set_bitmap & (BIT_PG_TX|BIT_PG_RX)) {
-		u16 refill[MAX_TRAFFIC_CLASS], max[MAX_TRAFFIC_CLASS];
-		u8 bwg_id[MAX_TRAFFIC_CLASS], prio_type[MAX_TRAFFIC_CLASS];
+	if (adapter->dcb_set_bitmap & (BIT_PG_TX | BIT_PG_RX)) {
 		/* Priority to TC mapping in CEE case default to 1:1 */
-		u8 prio_tc[MAX_USER_PRIORITY];
 		int max_frame = adapter->netdev->mtu + ETH_HLEN + ETH_FCS_LEN;
+#ifdef HAVE_MQPRIO
+		int i;
+#endif
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		if (adapter->netdev->features & NETIF_F_FCOE_MTU)
 			max_frame = max(max_frame, IXGBE_FCOE_JUMBO_FRAME_SIZE);
 #endif
 
-		ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,
-					       DCB_TX_CONFIG);
-		ixgbe_dcb_calculate_tc_credits(hw, dcb_cfg, max_frame,
-					       DCB_RX_CONFIG);
+		ixgbe_dcb_calculate_tc_credits_cee(hw, dcb_cfg, max_frame,
+						   IXGBE_DCB_TX_CONFIG);
 
-		ixgbe_dcb_unpack_refill(dcb_cfg, DCB_TX_CONFIG, refill);
-		ixgbe_dcb_unpack_max(dcb_cfg, max);
-		ixgbe_dcb_unpack_bwgid(dcb_cfg, DCB_TX_CONFIG, bwg_id);
-		ixgbe_dcb_unpack_prio(dcb_cfg, DCB_TX_CONFIG, prio_type);
-		ixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);
+		ixgbe_dcb_calculate_tc_credits_cee(hw, dcb_cfg, max_frame,
+						   IXGBE_DCB_RX_CONFIG);
 
-		ixgbe_dcb_hw_ets_config(hw, refill, max, bwg_id,
-					prio_type, prio_tc);
+		ixgbe_dcb_hw_config_cee(hw, dcb_cfg);
 
+#ifdef HAVE_MQPRIO
 		for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
 			netdev_set_prio_tc_map(netdev, i, prio_tc[i]);
-
+#endif /* HAVE_MQPRIO */
 		ret = DCB_HW_CHG_RST;
 	}
 
 	if (adapter->dcb_set_bitmap & BIT_PFC) {
 		if (dcb_cfg->pfc_mode_enable) {
 			u8 pfc_en;
-			u8 prio_tc[MAX_USER_PRIORITY];
-
-			ixgbe_dcb_unpack_map(dcb_cfg, DCB_TX_CONFIG, prio_tc);
-			ixgbe_dcb_unpack_pfc(dcb_cfg, &pfc_en);
-			ixgbe_dcb_hw_pfc_config(hw, pfc_en, prio_tc);
+			ixgbe_dcb_unpack_pfc_cee(dcb_cfg, prio_tc, &pfc_en);
+			ixgbe_dcb_config_pfc(hw, pfc_en, prio_tc);
 		} else {
 			hw->mac.ops.fc_enable(hw);
 		}
+		/* This is known driver so disable MDD before updating SRRCTL */
+		if ((adapter->num_vfs) && (hw->mac.ops.disable_mdd) &&
+		    (adapter->flags & IXGBE_FLAG_MDD_ENABLED))
+			hw->mac.ops.disable_mdd(hw);
 
 		ixgbe_set_rx_drop_en(adapter);
 
-		ret = DCB_HW_CHG;
+		if ((adapter->num_vfs) && (hw->mac.ops.enable_mdd) &&
+		    (adapter->flags & IXGBE_FLAG_MDD_ENABLED))
+			hw->mac.ops.enable_mdd(hw);
+
+		if (ret != DCB_HW_CHG_RST)
+			ret = DCB_HW_CHG;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* Reprogam FCoE hardware offloads when the traffic class
 	 * FCoE is using changes. This happens if the APP info
 	 * changes or the up2tc mapping is updated.
 	 */
 	if (adapter->dcb_set_bitmap & BIT_APP_UPCHG) {
-		struct dcb_app app = {
-				      .selector = DCB_APP_IDTYPE_ETHTYPE,
-				      .protocol = ETH_P_FCOE,
-				     };
-		u8 up = dcb_getapp(netdev, &app);
-
-		adapter->fcoe.up = ffs(up) - 1;
+		adapter->fcoe.up_set = adapter->fcoe.up;
 		ixgbe_dcbnl_devreset(netdev);
 		ret = DCB_HW_CHG_RST;
 	}
-#endif
+#endif /* CONFIG_FCOE */
 
 	adapter->dcb_set_bitmap = 0x00;
 	return ret;
@@ -384,7 +411,9 @@ static u8 ixgbe_dcbnl_set_all(struct net_device *netdev)
 
 static u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)
 {
+#ifdef HAVE_DCBNL_IEEE
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#endif
 
 	switch (capid) {
 	case DCB_CAP_ATTR_PG:
@@ -408,9 +437,11 @@ static u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)
 	case DCB_CAP_ATTR_BCN:
 		*cap = false;
 		break;
+#ifdef HAVE_DCBNL_IEEE
 	case DCB_CAP_ATTR_DCBX:
 		*cap = adapter->dcbx_cap;
 		break;
+#endif
 	default:
 		*cap = false;
 		break;
@@ -419,9 +450,14 @@ static u8 ixgbe_dcbnl_getcap(struct net_device *netdev, int capid, u8 *cap)
 	return 0;
 }
 
+#ifdef NUMTCS_RETURNS_U8
+static u8 ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
+#else
 static int ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	u8 rval = 0;
 
 	if (adapter->flags & IXGBE_FLAG_DCB_ENABLED) {
 		switch (tcid) {
@@ -432,18 +468,42 @@ static int ixgbe_dcbnl_getnumtcs(struct net_device *netdev, int tcid, u8 *num)
 			*num = adapter->dcb_cfg.num_tcs.pfc_tcs;
 			break;
 		default:
-			return -EINVAL;
+			rval = -EINVAL;
+			break;
 		}
 	} else {
-		return -EINVAL;
+		rval = -EINVAL;
 	}
 
-	return 0;
+	return rval;
 }
 
+#ifdef NUMTCS_RETURNS_U8
+static u8 ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)
+#else
 static int ixgbe_dcbnl_setnumtcs(struct net_device *netdev, int tcid, u8 num)
+#endif
 {
-	return -EINVAL;
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	u8 rval = 0;
+
+	if (adapter->flags & IXGBE_FLAG_DCB_ENABLED) {
+		switch (tcid) {
+		case DCB_NUMTCS_ATTR_PG:
+			adapter->dcb_cfg.num_tcs.pg_tcs = num;
+			break;
+		case DCB_NUMTCS_ATTR_PFC:
+			adapter->dcb_cfg.num_tcs.pfc_tcs = num;
+			break;
+		default:
+			rval = -EINVAL;
+			break;
+		}
+	} else {
+		rval = -EINVAL;
+	}
+
+	return rval;
 }
 
 static u8 ixgbe_dcbnl_getpfcstate(struct net_device *netdev)
@@ -458,8 +518,10 @@ static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
 	adapter->temp_dcb_cfg.pfc_mode_enable = state;
+	return;
 }
 
+#ifdef HAVE_DCBNL_OPS_GETAPP
 /**
  * ixgbe_dcbnl_getapp - retrieve the DCBX application user priority
  * @netdev : the corresponding netdev
@@ -467,35 +529,100 @@ static void ixgbe_dcbnl_setpfcstate(struct net_device *netdev, u8 state)
  * @id: id is either ether type or TCP/UDP port number
  *
  * Returns : on success, returns a non-zero 802.1p user priority bitmap
- * otherwise returns -EINVAL as the invalid user priority bitmap to indicate an
+ * otherwise returns 0 as the invalid user priority bitmap to indicate an
  * error.
  */
+#ifdef HAVE_DCBNL_OPS_SETAPP_RETURN_INT
 static int ixgbe_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
+#else
+static u8 ixgbe_dcbnl_getapp(struct net_device *netdev, u8 idtype, u16 id)
+#endif
 {
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	u8 rval = 0;
+#ifdef HAVE_DCBNL_IEEE
 	struct dcb_app app = {
-				.selector = idtype,
-				.protocol = id,
-			     };
+		.selector = idtype,
+		.protocol = id,
+	};
 
-	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE))
-		return -EINVAL;
+	rval = dcb_getapp(netdev, &app);
+#endif
+
+	switch (idtype) {
+	case DCB_APP_IDTYPE_ETHTYPE:
+#if IS_ENABLED(CONFIG_FCOE)
+		if (id == ETH_P_FCOE)
+			rval = ixgbe_fcoe_getapp(netdev);
+#endif
+		break;
+	case DCB_APP_IDTYPE_PORTNUM:
+		break;
+	default:
+		break;
+	}
 
-	return dcb_getapp(netdev, &app);
+	return rval;
 }
 
+/**
+ * ixgbe_dcbnl_setapp - set the DCBX application user priority
+ * @netdev: the corresponding netdev
+ * @idtype: identifies the id as ether type or TCP/UDP port number
+ * @id: id is either ether type or TCP/UDP port number
+ * @up: the 802.1p user priority bitmap
+ *
+ * Returns : 0 on success or 1 on error
+ */
+#ifdef HAVE_DCBNL_OPS_SETAPP_RETURN_INT
+static int ixgbe_dcbnl_setapp(struct net_device *netdev,
+			      u8 idtype, u16 id, u8 up)
+#else
+static u8 ixgbe_dcbnl_setapp(struct net_device *netdev,
+			     u8 idtype, u16 id, u8 up)
+#endif
+{
+	int err = 0;
+#ifdef HAVE_DCBNL_IEEE
+	struct dcb_app app;
+
+	app.selector = idtype;
+	app.protocol = id;
+	app.priority = up;
+	err = dcb_setapp(netdev, &app);
+#endif
+
+	switch (idtype) {
+	case DCB_APP_IDTYPE_ETHTYPE:
+#if IS_ENABLED(CONFIG_FCOE)
+		if (id == ETH_P_FCOE) {
+			struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+			adapter->fcoe.up = up ? ffs(up) - 1 : IXGBE_FCOE_DEFUP;
+		}
+#endif
+		break;
+	case DCB_APP_IDTYPE_PORTNUM:
+		break;
+	default:
+		break;
+	}
+
+	return err;
+}
+#endif /* HAVE_DCBNL_OPS_GETAPP */
+
+#ifdef HAVE_DCBNL_IEEE
 static int ixgbe_dcbnl_ieee_getets(struct net_device *dev,
 				   struct ieee_ets *ets)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ieee_ets *my_ets = adapter->ixgbe_ieee_ets;
 
-	ets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;
-
 	/* No IEEE PFC settings available */
 	if (!my_ets)
-		return 0;
+		return -EINVAL;
 
+	ets->ets_cap = adapter->dcb_cfg.num_tcs.pg_tcs;
 	ets->cbs = my_ets->cbs;
 	memcpy(ets->tc_tx_bw, my_ets->tc_tx_bw, sizeof(ets->tc_tx_bw));
 	memcpy(ets->tc_rx_bw, my_ets->tc_rx_bw, sizeof(ets->tc_rx_bw));
@@ -509,7 +636,7 @@ static int ixgbe_dcbnl_ieee_setets(struct net_device *dev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	int max_frame = dev->mtu + ETH_HLEN + ETH_FCS_LEN;
-	int i, err;
+	int i, err = 0;
 	__u8 max_tc = 0;
 	__u8 map_chg = 0;
 
@@ -521,13 +648,13 @@ static int ixgbe_dcbnl_ieee_setets(struct net_device *dev,
 						  GFP_KERNEL);
 		if (!adapter->ixgbe_ieee_ets)
 			return -ENOMEM;
-
 		/* initialize UP2TC mappings to invalid value */
 		for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)
 			adapter->ixgbe_ieee_ets->prio_tc[i] =
 				IEEE_8021QAZ_MAX_TCS;
 		/* if possible update UP2TC mappings from HW */
-		ixgbe_dcb_read_rtrup2tc(&adapter->hw,
+		if (adapter->hw.mac.ops.get_rtrup2tc)
+			adapter->hw.mac.ops.get_rtrup2tc(&adapter->hw,
 					adapter->ixgbe_ieee_ets->prio_tc);
 	}
 
@@ -546,15 +673,17 @@ static int ixgbe_dcbnl_ieee_setets(struct net_device *dev,
 	if (max_tc > adapter->dcb_cfg.num_tcs.pg_tcs)
 		return -EINVAL;
 
-	if (max_tc != adapter->hw_tcs) {
+	if (max_tc != netdev_get_num_tc(dev))
 		err = ixgbe_setup_tc(dev, max_tc);
-		if (err)
-			return err;
-	} else if (map_chg) {
+	else if (map_chg)
 		ixgbe_dcbnl_devreset(dev);
-	}
 
-	return ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);
+	if (err)
+		goto err_out;
+
+	err = ixgbe_dcb_hw_ets(&adapter->hw, ets, max_frame);
+err_out:
+	return err;
 }
 
 static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev,
@@ -564,17 +693,16 @@ static int ixgbe_dcbnl_ieee_getpfc(struct net_device *dev,
 	struct ieee_pfc *my_pfc = adapter->ixgbe_ieee_pfc;
 	int i;
 
-	pfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;
-
 	/* No IEEE PFC settings available */
 	if (!my_pfc)
-		return 0;
+		return -EINVAL;
 
+	pfc->pfc_cap = adapter->dcb_cfg.num_tcs.pfc_tcs;
 	pfc->pfc_en = my_pfc->pfc_en;
 	pfc->mbc = my_pfc->mbc;
 	pfc->delay = my_pfc->delay;
 
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		pfc->requests[i] = adapter->stats.pxoffrxc[i];
 		pfc->indications[i] = adapter->stats.pxofftxc[i];
 	}
@@ -603,14 +731,24 @@ static int ixgbe_dcbnl_ieee_setpfc(struct net_device *dev,
 	prio_tc = adapter->ixgbe_ieee_ets->prio_tc;
 	memcpy(adapter->ixgbe_ieee_pfc, pfc, sizeof(*adapter->ixgbe_ieee_pfc));
 
+
 	/* Enable link flow control parameters if PFC is disabled */
 	if (pfc->pfc_en)
-		err = ixgbe_dcb_hw_pfc_config(hw, pfc->pfc_en, prio_tc);
+		err = ixgbe_dcb_config_pfc(hw, pfc->pfc_en, prio_tc);
 	else
 		err = hw->mac.ops.fc_enable(hw);
 
+	/* This is known driver so disable MDD before updating SRRCTL */
+	if ((adapter->num_vfs) && (hw->mac.ops.disable_mdd) &&
+	    (adapter->flags & IXGBE_FLAG_MDD_ENABLED))
+		hw->mac.ops.disable_mdd(hw);
+
 	ixgbe_set_rx_drop_en(adapter);
 
+	if ((adapter->num_vfs) && (hw->mac.ops.enable_mdd) &&
+	    (adapter->flags & IXGBE_FLAG_MDD_ENABLED))
+		hw->mac.ops.enable_mdd(hw);
+
 	return err;
 }
 
@@ -618,47 +756,30 @@ static int ixgbe_dcbnl_ieee_setapp(struct net_device *dev,
 				   struct dcb_app *app)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	int err;
+	int err = -EINVAL;
 
 	if (!(adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE))
-		return -EINVAL;
+		return err;
 
 	err = dcb_ieee_setapp(dev, app);
-	if (err)
-		return err;
 
-#ifdef IXGBE_FCOE
-	if (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
+#if IS_ENABLED(CONFIG_FCOE)
+	if (!err && app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
 	    app->protocol == ETH_P_FCOE) {
 		u8 app_mask = dcb_ieee_getapp_mask(dev, app);
 
-		if (app_mask & BIT(adapter->fcoe.up))
-			return 0;
+		if (app_mask & (1 << adapter->fcoe.up))
+			return err;
 
 		adapter->fcoe.up = app->priority;
+		adapter->fcoe.up_set = adapter->fcoe.up;
 		ixgbe_dcbnl_devreset(dev);
 	}
 #endif
-
-	/* VF devices should use default UP when available */
-	if (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
-	    app->protocol == 0) {
-		int vf;
-
-		adapter->default_up = app->priority;
-
-		for (vf = 0; vf < adapter->num_vfs; vf++) {
-			struct vf_data_storage *vfinfo = &adapter->vfinfo[vf];
-
-			if (!vfinfo->pf_qos)
-				ixgbe_set_vmvir(adapter, vfinfo->pf_vlan,
-						app->priority, vf);
-		}
-	}
-
 	return 0;
 }
 
+#ifdef HAVE_DCBNL_IEEE_DELAPP
 static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev,
 				   struct dcb_app *app)
 {
@@ -670,39 +791,22 @@ static int ixgbe_dcbnl_ieee_delapp(struct net_device *dev,
 
 	err = dcb_ieee_delapp(dev, app);
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	if (!err && app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
 	    app->protocol == ETH_P_FCOE) {
 		u8 app_mask = dcb_ieee_getapp_mask(dev, app);
 
-		if (app_mask & BIT(adapter->fcoe.up))
-			return 0;
+		if (app_mask & (1 << adapter->fcoe.up))
+			return err;
 
 		adapter->fcoe.up = app_mask ?
-				   ffs(app_mask) - 1 : IXGBE_FCOE_DEFTC;
+				   ffs(app_mask) - 1 : IXGBE_FCOE_DEFUP;
 		ixgbe_dcbnl_devreset(dev);
 	}
 #endif
-	/* IF default priority is being removed clear VF default UP */
-	if (app->selector == IEEE_8021QAZ_APP_SEL_ETHERTYPE &&
-	    app->protocol == 0 && adapter->default_up == app->priority) {
-		int vf;
-		long unsigned int app_mask = dcb_ieee_getapp_mask(dev, app);
-		int qos = app_mask ? find_first_bit(&app_mask, 8) : 0;
-
-		adapter->default_up = qos;
-
-		for (vf = 0; vf < adapter->num_vfs; vf++) {
-			struct vf_data_storage *vfinfo = &adapter->vfinfo[vf];
-
-			if (!vfinfo->pf_qos)
-				ixgbe_set_vmvir(adapter, vfinfo->pf_vlan,
-						qos, vf);
-		}
-	}
-
 	return err;
 }
+#endif /* HAVE_DCBNL_IEEE_DELAPP */
 
 static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)
 {
@@ -713,9 +817,8 @@ static u8 ixgbe_dcbnl_getdcbx(struct net_device *dev)
 static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	struct ieee_ets ets = {0};
-	struct ieee_pfc pfc = {0};
-	int err = 0;
+	struct ieee_ets ets = { .ets_cap = 0 };
+	struct ieee_pfc pfc = { .pfc_en = 0 };
 
 	/* no support for LLD_MANAGED modes or CEE+IEEE */
 	if ((mode & DCB_CAP_DCBX_LLD_MANAGED) ||
@@ -736,7 +839,7 @@ static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)
 		ixgbe_dcbnl_ieee_setets(dev, &ets);
 		ixgbe_dcbnl_ieee_setpfc(dev, &pfc);
 	} else if (mode & DCB_CAP_DCBX_VER_CEE) {
-		u8 mask = BIT_PFC | BIT_PG_TX | BIT_PG_RX | BIT_APP_UPCHG;
+		u8 mask = (BIT_PFC | BIT_PG_TX | BIT_PG_RX | BIT_APP_UPCHG);
 
 		adapter->dcb_set_bitmap |= mask;
 		ixgbe_dcbnl_set_all(dev);
@@ -746,19 +849,25 @@ static u8 ixgbe_dcbnl_setdcbx(struct net_device *dev, u8 mode)
 		 */
 		ixgbe_dcbnl_ieee_setets(dev, &ets);
 		ixgbe_dcbnl_ieee_setpfc(dev, &pfc);
-		err = ixgbe_setup_tc(dev, 0);
+		ixgbe_setup_tc(dev, 0);
 	}
 
-	return err ? 1 : 0;
+	return 0;
 }
 
-const struct dcbnl_rtnl_ops ixgbe_dcbnl_ops = {
+#endif
+
+struct dcbnl_rtnl_ops ixgbe_dcbnl_ops = {
+#ifdef HAVE_DCBNL_IEEE
 	.ieee_getets	= ixgbe_dcbnl_ieee_getets,
 	.ieee_setets	= ixgbe_dcbnl_ieee_setets,
 	.ieee_getpfc	= ixgbe_dcbnl_ieee_getpfc,
 	.ieee_setpfc	= ixgbe_dcbnl_ieee_setpfc,
 	.ieee_setapp	= ixgbe_dcbnl_ieee_setapp,
+#ifdef HAVE_DCBNL_IEEE_DELAPP
 	.ieee_delapp	= ixgbe_dcbnl_ieee_delapp,
+#endif
+#endif
 	.getstate	= ixgbe_dcbnl_get_state,
 	.setstate	= ixgbe_dcbnl_set_state,
 	.getpermhwaddr	= ixgbe_dcbnl_get_perm_hw_addr,
@@ -778,7 +887,14 @@ const struct dcbnl_rtnl_ops ixgbe_dcbnl_ops = {
 	.setnumtcs	= ixgbe_dcbnl_setnumtcs,
 	.getpfcstate	= ixgbe_dcbnl_getpfcstate,
 	.setpfcstate	= ixgbe_dcbnl_setpfcstate,
+#ifdef HAVE_DCBNL_OPS_GETAPP
 	.getapp		= ixgbe_dcbnl_getapp,
+	.setapp		= ixgbe_dcbnl_setapp,
+#endif
+#ifdef HAVE_DCBNL_IEEE
 	.getdcbx	= ixgbe_dcbnl_getdcbx,
 	.setdcbx	= ixgbe_dcbnl_setdcbx,
+#endif
 };
+
+#endif /* CONFIG_DCB */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
index 5b1cf49df3d3..abf9cf4b2073 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_debugfs.c
@@ -1,18 +1,25 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
+#include "ixgbe.h"
+
+#ifdef HAVE_IXGBE_DEBUG_FS
 #include <linux/debugfs.h>
 #include <linux/module.h>
 
-#include "ixgbe.h"
-
 static struct dentry *ixgbe_dbg_root;
 
 static char ixgbe_dbg_reg_ops_buf[256] = "";
 
-static ssize_t ixgbe_dbg_common_ops_read(struct file *filp, char __user *buffer,
-					 size_t count, loff_t *ppos,
-					 char *dbg_buf)
+/**
+ * ixgbe_dbg_reg_ops_read - read for reg_ops datum
+ * @filp: the opened file
+ * @buffer: where to write the data for the user to read
+ * @count: the size of the user's buffer
+ * @ppos: file position offset
+ **/
+static ssize_t ixgbe_dbg_reg_ops_read(struct file *filp, char __user *buffer,
+				    size_t count, loff_t *ppos)
 {
 	struct ixgbe_adapter *adapter = filp->private_data;
 	char *buf;
@@ -23,7 +30,8 @@ static ssize_t ixgbe_dbg_common_ops_read(struct file *filp, char __user *buffer,
 		return 0;
 
 	buf = kasprintf(GFP_KERNEL, "%s: %s\n",
-			adapter->netdev->name, dbg_buf);
+			adapter->netdev->name,
+			ixgbe_dbg_reg_ops_buf);
 	if (!buf)
 		return -ENOMEM;
 
@@ -38,20 +46,6 @@ static ssize_t ixgbe_dbg_common_ops_read(struct file *filp, char __user *buffer,
 	return len;
 }
 
-/**
- * ixgbe_dbg_reg_ops_read - read for reg_ops datum
- * @filp: the opened file
- * @buffer: where to write the data for the user to read
- * @count: the size of the user's buffer
- * @ppos: file position offset
- **/
-static ssize_t ixgbe_dbg_reg_ops_read(struct file *filp, char __user *buffer,
-				      size_t count, loff_t *ppos)
-{
-	return ixgbe_dbg_common_ops_read(filp, buffer, count, ppos,
-					 ixgbe_dbg_reg_ops_buf);
-}
-
 /**
  * ixgbe_dbg_reg_ops_write - write into reg_ops datum
  * @filp: the opened file
@@ -86,7 +80,8 @@ static ssize_t ixgbe_dbg_reg_ops_write(struct file *filp,
 		u32 reg, value;
 		int cnt;
 		cnt = sscanf(&ixgbe_dbg_reg_ops_buf[5], "%x %x", &reg, &value);
-		if (cnt == 2) {
+		/* check format and bounds check register access */
+		if (cnt == 2 && reg <= IXGBE_HFDR) {
 			IXGBE_WRITE_REG(&adapter->hw, reg, value);
 			value = IXGBE_READ_REG(&adapter->hw, reg);
 			e_dev_info("write: 0x%08x = 0x%08x\n", reg, value);
@@ -97,7 +92,8 @@ static ssize_t ixgbe_dbg_reg_ops_write(struct file *filp,
 		u32 reg, value;
 		int cnt;
 		cnt = sscanf(&ixgbe_dbg_reg_ops_buf[4], "%x", &reg);
-		if (cnt == 1) {
+		/* check format and bounds check register access */
+		if (cnt == 1 && reg <= IXGBE_HFDR) {
 			value = IXGBE_READ_REG(&adapter->hw, reg);
 			e_dev_info("read 0x%08x = 0x%08x\n", reg, value);
 		} else {
@@ -128,11 +124,33 @@ static char ixgbe_dbg_netdev_ops_buf[256] = "";
  * @count: the size of the user's buffer
  * @ppos: file position offset
  **/
-static ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp, char __user *buffer,
+static ssize_t ixgbe_dbg_netdev_ops_read(struct file *filp,
+					 char __user *buffer,
 					 size_t count, loff_t *ppos)
 {
-	return ixgbe_dbg_common_ops_read(filp, buffer, count, ppos,
-					 ixgbe_dbg_netdev_ops_buf);
+	struct ixgbe_adapter *adapter = filp->private_data;
+	char *buf;
+	int len;
+
+	/* don't allow partial reads */
+	if (*ppos != 0)
+		return 0;
+
+	buf = kasprintf(GFP_KERNEL, "%s: %s\n",
+			adapter->netdev->name,
+			ixgbe_dbg_netdev_ops_buf);
+	if (!buf)
+		return -ENOMEM;
+
+	if (count < strlen(buf)) {
+		kfree(buf);
+		return -ENOSPC;
+	}
+
+	len = simple_read_from_buffer(buffer, count, ppos, buf, strlen(buf));
+
+	kfree(buf);
+	return len;
 }
 
 /**
@@ -166,9 +184,16 @@ static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp,
 	ixgbe_dbg_netdev_ops_buf[len] = '\0';
 
 	if (strncmp(ixgbe_dbg_netdev_ops_buf, "tx_timeout", 10) == 0) {
-		/* TX Queue number below is wrong, but ixgbe does not use it */
+#ifdef HAVE_NET_DEVICE_OPS
+#ifdef HAVE_TX_TIMEOUT_TXQUEUE
 		adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev,
 							    UINT_MAX);
+#else
+		adapter->netdev->netdev_ops->ndo_tx_timeout(adapter->netdev);
+#endif
+#else
+		adapter->netdev->tx_timeout(adapter->netdev);
+#endif /* HAVE_NET_DEVICE_OPS */
 		e_dev_info("tx_timeout called\n");
 	} else {
 		e_dev_info("Unknown command: %s\n", ixgbe_dbg_netdev_ops_buf);
@@ -178,7 +203,7 @@ static ssize_t ixgbe_dbg_netdev_ops_write(struct file *filp,
 	return count;
 }
 
-static const struct file_operations ixgbe_dbg_netdev_ops_fops = {
+static struct file_operations ixgbe_dbg_netdev_ops_fops = {
 	.owner = THIS_MODULE,
 	.open = simple_open,
 	.read = ixgbe_dbg_netdev_ops_read,
@@ -192,21 +217,32 @@ static const struct file_operations ixgbe_dbg_netdev_ops_fops = {
 void ixgbe_dbg_adapter_init(struct ixgbe_adapter *adapter)
 {
 	const char *name = pci_name(adapter->pdev);
-
+	struct dentry *pfile;
 	adapter->ixgbe_dbg_adapter = debugfs_create_dir(name, ixgbe_dbg_root);
-	debugfs_create_file("reg_ops", 0600, adapter->ixgbe_dbg_adapter,
-			    adapter, &ixgbe_dbg_reg_ops_fops);
-	debugfs_create_file("netdev_ops", 0600, adapter->ixgbe_dbg_adapter,
-			    adapter, &ixgbe_dbg_netdev_ops_fops);
+	if (adapter->ixgbe_dbg_adapter) {
+		pfile = debugfs_create_file("reg_ops", 0600,
+					    adapter->ixgbe_dbg_adapter, adapter,
+					    &ixgbe_dbg_reg_ops_fops);
+		if (!pfile)
+			e_dev_err("debugfs reg_ops for %s failed\n", name);
+		pfile = debugfs_create_file("netdev_ops", 0600,
+					    adapter->ixgbe_dbg_adapter, adapter,
+					    &ixgbe_dbg_netdev_ops_fops);
+		if (!pfile)
+			e_dev_err("debugfs netdev_ops for %s failed\n", name);
+	} else {
+		e_dev_err("debugfs entry for %s failed\n", name);
+	}
 }
 
 /**
  * ixgbe_dbg_adapter_exit - clear out the adapter's debugfs entries
- * @adapter: the adapter that is exiting
+ * @adapter: board private structure
  **/
 void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter)
 {
-	debugfs_remove_recursive(adapter->ixgbe_dbg_adapter);
+	if (adapter->ixgbe_dbg_adapter)
+		debugfs_remove_recursive(adapter->ixgbe_dbg_adapter);
 	adapter->ixgbe_dbg_adapter = NULL;
 }
 
@@ -216,6 +252,8 @@ void ixgbe_dbg_adapter_exit(struct ixgbe_adapter *adapter)
 void ixgbe_dbg_init(void)
 {
 	ixgbe_dbg_root = debugfs_create_dir(ixgbe_driver_name, NULL);
+	if (ixgbe_dbg_root == NULL)
+		pr_err("init of debugfs failed\n");
 }
 
 /**
@@ -225,3 +263,5 @@ void ixgbe_dbg_exit(void)
 {
 	debugfs_remove_recursive(ixgbe_dbg_root);
 }
+
+#endif /* HAVE_IXGBE_DEBUG_FS */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
index a280aa34ca1d..6e0c9e797874 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ethtool.c
@@ -1,108 +1,126 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 /* ethtool support for ixgbe */
 
-#include <linux/interrupt.h>
 #include <linux/types.h>
 #include <linux/module.h>
-#include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
 #include <linux/vmalloc.h>
 #include <linux/highmem.h>
-#include <linux/uaccess.h>
+
+#ifdef SIOCETHTOOL
+#include <asm/uaccess.h>
 
 #include "ixgbe.h"
+#ifdef ETHTOOL_GMODULEINFO
 #include "ixgbe_phy.h"
+#endif
+#ifdef HAVE_ETHTOOL_GET_TS_INFO
+#include <linux/net_tstamp.h>
+#endif
 
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
 
 #define IXGBE_ALL_RAR_ENTRIES 16
 
-enum {NETDEV_STATS, IXGBE_STATS};
-
+#ifdef ETHTOOL_OPS_COMPAT
+#include "kcompat_ethtool.c"
+#endif
+#ifdef ETHTOOL_GSTATS
 struct ixgbe_stats {
 	char stat_string[ETH_GSTRING_LEN];
-	int type;
 	int sizeof_stat;
 	int stat_offset;
 };
 
-#define IXGBE_STAT(m)		IXGBE_STATS, \
-				sizeof(((struct ixgbe_adapter *)0)->m), \
-				offsetof(struct ixgbe_adapter, m)
-#define IXGBE_NETDEV_STAT(m)	NETDEV_STATS, \
-				sizeof(((struct rtnl_link_stats64 *)0)->m), \
-				offsetof(struct rtnl_link_stats64, m)
-
-static const struct ixgbe_stats ixgbe_gstrings_stats[] = {
-	{"rx_packets", IXGBE_NETDEV_STAT(rx_packets)},
-	{"tx_packets", IXGBE_NETDEV_STAT(tx_packets)},
-	{"rx_bytes", IXGBE_NETDEV_STAT(rx_bytes)},
-	{"tx_bytes", IXGBE_NETDEV_STAT(tx_bytes)},
-	{"rx_pkts_nic", IXGBE_STAT(stats.gprc)},
-	{"tx_pkts_nic", IXGBE_STAT(stats.gptc)},
-	{"rx_bytes_nic", IXGBE_STAT(stats.gorc)},
-	{"tx_bytes_nic", IXGBE_STAT(stats.gotc)},
-	{"lsc_int", IXGBE_STAT(lsc_int)},
-	{"tx_busy", IXGBE_STAT(tx_busy)},
-	{"non_eop_descs", IXGBE_STAT(non_eop_descs)},
-	{"rx_errors", IXGBE_NETDEV_STAT(rx_errors)},
-	{"tx_errors", IXGBE_NETDEV_STAT(tx_errors)},
-	{"rx_dropped", IXGBE_NETDEV_STAT(rx_dropped)},
-	{"tx_dropped", IXGBE_NETDEV_STAT(tx_dropped)},
-	{"multicast", IXGBE_NETDEV_STAT(multicast)},
-	{"broadcast", IXGBE_STAT(stats.bprc)},
-	{"rx_no_buffer_count", IXGBE_STAT(stats.rnbc[0]) },
-	{"collisions", IXGBE_NETDEV_STAT(collisions)},
-	{"rx_over_errors", IXGBE_NETDEV_STAT(rx_over_errors)},
-	{"rx_crc_errors", IXGBE_NETDEV_STAT(rx_crc_errors)},
-	{"rx_frame_errors", IXGBE_NETDEV_STAT(rx_frame_errors)},
-	{"hw_rsc_aggregated", IXGBE_STAT(rsc_total_count)},
-	{"hw_rsc_flushed", IXGBE_STAT(rsc_total_flush)},
-	{"fdir_match", IXGBE_STAT(stats.fdirmatch)},
-	{"fdir_miss", IXGBE_STAT(stats.fdirmiss)},
-	{"fdir_overflow", IXGBE_STAT(fdir_overflow)},
-	{"rx_fifo_errors", IXGBE_NETDEV_STAT(rx_fifo_errors)},
-	{"rx_missed_errors", IXGBE_NETDEV_STAT(rx_missed_errors)},
-	{"tx_aborted_errors", IXGBE_NETDEV_STAT(tx_aborted_errors)},
-	{"tx_carrier_errors", IXGBE_NETDEV_STAT(tx_carrier_errors)},
-	{"tx_fifo_errors", IXGBE_NETDEV_STAT(tx_fifo_errors)},
-	{"tx_heartbeat_errors", IXGBE_NETDEV_STAT(tx_heartbeat_errors)},
-	{"tx_timeout_count", IXGBE_STAT(tx_timeout_count)},
-	{"tx_restart_queue", IXGBE_STAT(restart_queue)},
-	{"rx_length_errors", IXGBE_STAT(stats.rlec)},
-	{"rx_long_length_errors", IXGBE_STAT(stats.roc)},
-	{"rx_short_length_errors", IXGBE_STAT(stats.ruc)},
-	{"tx_flow_control_xon", IXGBE_STAT(stats.lxontxc)},
-	{"rx_flow_control_xon", IXGBE_STAT(stats.lxonrxc)},
-	{"tx_flow_control_xoff", IXGBE_STAT(stats.lxofftxc)},
-	{"rx_flow_control_xoff", IXGBE_STAT(stats.lxoffrxc)},
-	{"rx_csum_offload_errors", IXGBE_STAT(hw_csum_rx_error)},
-	{"alloc_rx_page", IXGBE_STAT(alloc_rx_page)},
-	{"alloc_rx_page_failed", IXGBE_STAT(alloc_rx_page_failed)},
-	{"alloc_rx_buff_failed", IXGBE_STAT(alloc_rx_buff_failed)},
-	{"rx_no_dma_resources", IXGBE_STAT(hw_rx_no_dma_resources)},
-	{"os2bmc_rx_by_bmc", IXGBE_STAT(stats.o2bgptc)},
-	{"os2bmc_tx_by_bmc", IXGBE_STAT(stats.b2ospc)},
-	{"os2bmc_tx_by_host", IXGBE_STAT(stats.o2bspc)},
-	{"os2bmc_rx_by_host", IXGBE_STAT(stats.b2ogprc)},
-	{"tx_hwtstamp_timeouts", IXGBE_STAT(tx_hwtstamp_timeouts)},
-	{"tx_hwtstamp_skipped", IXGBE_STAT(tx_hwtstamp_skipped)},
-	{"rx_hwtstamp_cleared", IXGBE_STAT(rx_hwtstamp_cleared)},
-	{"tx_ipsec", IXGBE_STAT(tx_ipsec)},
-	{"rx_ipsec", IXGBE_STAT(rx_ipsec)},
-#ifdef IXGBE_FCOE
-	{"fcoe_bad_fccrc", IXGBE_STAT(stats.fccrc)},
-	{"rx_fcoe_dropped", IXGBE_STAT(stats.fcoerpdc)},
-	{"rx_fcoe_packets", IXGBE_STAT(stats.fcoeprc)},
-	{"rx_fcoe_dwords", IXGBE_STAT(stats.fcoedwrc)},
-	{"fcoe_noddp", IXGBE_STAT(stats.fcoe_noddp)},
-	{"fcoe_noddp_ext_buff", IXGBE_STAT(stats.fcoe_noddp_ext_buff)},
-	{"tx_fcoe_packets", IXGBE_STAT(stats.fcoeptc)},
-	{"tx_fcoe_dwords", IXGBE_STAT(stats.fcoedwtc)},
-#endif /* IXGBE_FCOE */
+#define IXGBE_NETDEV_STAT(_net_stat) { \
+	.stat_string = #_net_stat, \
+	.sizeof_stat = sizeof_field(struct net_device_stats, _net_stat), \
+	.stat_offset = offsetof(struct net_device_stats, _net_stat) \
+}
+static const struct ixgbe_stats ixgbe_gstrings_net_stats[] = {
+	IXGBE_NETDEV_STAT(rx_packets),
+	IXGBE_NETDEV_STAT(tx_packets),
+	IXGBE_NETDEV_STAT(rx_bytes),
+	IXGBE_NETDEV_STAT(tx_bytes),
+	IXGBE_NETDEV_STAT(rx_errors),
+	IXGBE_NETDEV_STAT(tx_errors),
+	IXGBE_NETDEV_STAT(rx_dropped),
+	IXGBE_NETDEV_STAT(tx_dropped),
+	IXGBE_NETDEV_STAT(multicast),
+	IXGBE_NETDEV_STAT(collisions),
+	IXGBE_NETDEV_STAT(rx_over_errors),
+	IXGBE_NETDEV_STAT(rx_crc_errors),
+	IXGBE_NETDEV_STAT(rx_frame_errors),
+	IXGBE_NETDEV_STAT(rx_fifo_errors),
+	IXGBE_NETDEV_STAT(rx_missed_errors),
+	IXGBE_NETDEV_STAT(tx_aborted_errors),
+	IXGBE_NETDEV_STAT(tx_carrier_errors),
+	IXGBE_NETDEV_STAT(tx_fifo_errors),
+	IXGBE_NETDEV_STAT(tx_heartbeat_errors),
+};
+
+#define IXGBE_STAT(_name, _stat) { \
+	.stat_string = _name, \
+	.sizeof_stat = sizeof_field(struct ixgbe_adapter, _stat), \
+	.stat_offset = offsetof(struct ixgbe_adapter, _stat) \
+}
+static struct ixgbe_stats ixgbe_gstrings_stats[] = {
+	IXGBE_STAT("rx_pkts_nic", stats.gprc),
+	IXGBE_STAT("tx_pkts_nic", stats.gptc),
+	IXGBE_STAT("rx_bytes_nic", stats.gorc),
+	IXGBE_STAT("tx_bytes_nic", stats.gotc),
+	IXGBE_STAT("lsc_int", lsc_int),
+	IXGBE_STAT("tx_busy", tx_busy),
+	IXGBE_STAT("non_eop_descs", non_eop_descs),
+	IXGBE_STAT("broadcast", stats.bprc),
+	IXGBE_STAT("rx_no_buffer_count", stats.rnbc[0]) ,
+	IXGBE_STAT("tx_timeout_count", tx_timeout_count),
+	IXGBE_STAT("tx_restart_queue", restart_queue),
+	IXGBE_STAT("rx_length_errors", stats.rlec),
+	IXGBE_STAT("rx_long_length_errors", stats.roc),
+	IXGBE_STAT("rx_short_length_errors", stats.ruc),
+	IXGBE_STAT("tx_flow_control_xon", stats.lxontxc),
+	IXGBE_STAT("rx_flow_control_xon", stats.lxonrxc),
+	IXGBE_STAT("tx_flow_control_xoff", stats.lxofftxc),
+	IXGBE_STAT("rx_flow_control_xoff", stats.lxoffrxc),
+	IXGBE_STAT("rx_csum_offload_errors", hw_csum_rx_error),
+	IXGBE_STAT("alloc_rx_page", alloc_rx_page),
+	IXGBE_STAT("alloc_rx_page_failed", alloc_rx_page_failed),
+	IXGBE_STAT("alloc_rx_buff_failed", alloc_rx_buff_failed),
+	IXGBE_STAT("rx_no_dma_resources", hw_rx_no_dma_resources),
+	IXGBE_STAT("hw_rsc_aggregated", rsc_total_count),
+	IXGBE_STAT("hw_rsc_flushed", rsc_total_flush),
+#ifdef HAVE_TX_MQ
+	IXGBE_STAT("fdir_match", stats.fdirmatch),
+	IXGBE_STAT("fdir_miss", stats.fdirmiss),
+	IXGBE_STAT("fdir_overflow", fdir_overflow),
+#endif /* HAVE_TX_MQ */
+#if IS_ENABLED(CONFIG_FCOE)
+	IXGBE_STAT("fcoe_bad_fccrc", stats.fccrc),
+	IXGBE_STAT("fcoe_last_errors", stats.fclast),
+	IXGBE_STAT("rx_fcoe_dropped", stats.fcoerpdc),
+	IXGBE_STAT("rx_fcoe_packets", stats.fcoeprc),
+	IXGBE_STAT("rx_fcoe_dwords", stats.fcoedwrc),
+	IXGBE_STAT("fcoe_noddp", stats.fcoe_noddp),
+	IXGBE_STAT("fcoe_noddp_ext_buff", stats.fcoe_noddp_ext_buff),
+	IXGBE_STAT("tx_fcoe_packets", stats.fcoeptc),
+	IXGBE_STAT("tx_fcoe_dwords", stats.fcoedwtc),
+#endif /* CONFIG_FCOE */
+	IXGBE_STAT("os2bmc_rx_by_bmc", stats.o2bgptc),
+	IXGBE_STAT("os2bmc_tx_by_bmc", stats.b2ospc),
+	IXGBE_STAT("os2bmc_tx_by_host", stats.o2bspc),
+	IXGBE_STAT("os2bmc_rx_by_host", stats.b2ogprc),
+#ifdef HAVE_PTP_1588_CLOCK
+	IXGBE_STAT("tx_hwtstamp_timeouts", tx_hwtstamp_timeouts),
+	IXGBE_STAT("tx_hwtstamp_skipped", tx_hwtstamp_skipped),
+	IXGBE_STAT("rx_hwtstamp_cleared", rx_hwtstamp_cleared),
+#endif /* HAVE_PTP_1588_CLOCK */
 };
 
 /* ixgbe allocates num_tx_queues and num_rx_queues symmetrically so
@@ -110,46 +128,75 @@ static const struct ixgbe_stats ixgbe_gstrings_stats[] = {
  * used because we do not have a good way to get the max number of
  * rx queues with CONFIG_RPS disabled.
  */
+#ifdef HAVE_TX_MQ
+#ifdef HAVE_NETDEV_SELECT_QUEUE
 #define IXGBE_NUM_RX_QUEUES netdev->num_tx_queues
+#define IXGBE_NUM_TX_QUEUES netdev->num_tx_queues
+#else
+#define IXGBE_NUM_RX_QUEUES adapter->indices
+#define IXGBE_NUM_TX_QUEUES adapter->indices
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+#else /* HAVE_TX_MQ */
+#define IXGBE_NUM_TX_QUEUES 1
+#define IXGBE_NUM_RX_QUEUES ( \
+		((struct ixgbe_adapter *)netdev_priv(netdev))->num_rx_queues)
+#endif /* HAVE_TX_MQ */
 
 #define IXGBE_QUEUE_STATS_LEN ( \
-	(netdev->num_tx_queues + IXGBE_NUM_RX_QUEUES) * \
-	(sizeof(struct ixgbe_queue_stats) / sizeof(u64)))
-#define IXGBE_GLOBAL_STATS_LEN ARRAY_SIZE(ixgbe_gstrings_stats)
+		(IXGBE_NUM_TX_QUEUES + IXGBE_NUM_RX_QUEUES) * \
+		(sizeof(struct ixgbe_queue_stats) / sizeof(u64)))
+#define IXGBE_GLOBAL_STATS_LEN	ARRAY_SIZE(ixgbe_gstrings_stats)
+#define IXGBE_NETDEV_STATS_LEN	ARRAY_SIZE(ixgbe_gstrings_net_stats)
 #define IXGBE_PB_STATS_LEN ( \
-			(sizeof(((struct ixgbe_adapter *)0)->stats.pxonrxc) + \
-			 sizeof(((struct ixgbe_adapter *)0)->stats.pxontxc) + \
-			 sizeof(((struct ixgbe_adapter *)0)->stats.pxoffrxc) + \
-			 sizeof(((struct ixgbe_adapter *)0)->stats.pxofftxc)) \
-			/ sizeof(u64))
+		(sizeof(((struct ixgbe_adapter *)0)->stats.pxonrxc) + \
+		 sizeof(((struct ixgbe_adapter *)0)->stats.pxontxc) + \
+		 sizeof(((struct ixgbe_adapter *)0)->stats.pxoffrxc) + \
+		 sizeof(((struct ixgbe_adapter *)0)->stats.pxofftxc)) \
+		/ sizeof(u64))
+#define IXGBE_VF_STATS_LEN \
+	((((struct ixgbe_adapter *)netdev_priv(netdev))->num_vfs) * \
+	  (sizeof(struct vf_stats) / sizeof(u64)))
 #define IXGBE_STATS_LEN (IXGBE_GLOBAL_STATS_LEN + \
+			 IXGBE_NETDEV_STATS_LEN + \
 			 IXGBE_PB_STATS_LEN + \
-			 IXGBE_QUEUE_STATS_LEN)
+			 IXGBE_QUEUE_STATS_LEN + \
+			 IXGBE_VF_STATS_LEN)
 
+#endif /* ETHTOOL_GSTATS */
+#ifdef ETHTOOL_TEST
 static const char ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {
 	"Register test  (offline)", "Eeprom test    (offline)",
 	"Interrupt test (offline)", "Loopback test  (offline)",
 	"Link test   (on/offline)"
 };
-#define IXGBE_TEST_LEN sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN
+#define IXGBE_TEST_LEN	(sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN)
+#endif /* ETHTOOL_TEST */
 
+#ifdef HAVE_ETHTOOL_GET_SSET_COUNT
 static const char ixgbe_priv_flags_strings[][ETH_GSTRING_LEN] = {
-#define IXGBE_PRIV_FLAGS_LEGACY_RX	BIT(0)
+#define IXGBE_PRIV_FLAGS_FD_ATR		BIT(0)
+	"flow-director-atr",
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
+#define IXGBE_PRIV_FLAGS_LEGACY_RX	BIT(1)
 	"legacy-rx",
-#define IXGBE_PRIV_FLAGS_VF_IPSEC_EN	BIT(1)
-	"vf-ipsec",
+#endif
 };
 
 #define IXGBE_PRIV_FLAGS_STR_LEN ARRAY_SIZE(ixgbe_priv_flags_strings)
 
-#define ixgbe_isbackplane(type) ((type) == ixgbe_media_type_backplane)
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
+/* currently supported speeds for 10G */
+#define ADVERTISED_MASK_10G (SUPPORTED_10000baseT_Full | SUPPORTED_10000baseKX4_Full | SUPPORTED_10000baseKR_Full)
+
+#define ixgbe_isbackplane(type)  ((type == ixgbe_media_type_backplane)? true : false)
 
+#ifdef ETHTOOL_GLINKSETTINGS
 static void ixgbe_set_supported_10gtypes(struct ixgbe_hw *hw,
 					 struct ethtool_link_ksettings *cmd)
 {
 	if (!ixgbe_isbackplane(hw->phy.media_type)) {
-		ethtool_link_ksettings_add_link_mode(cmd, supported,
-						     10000baseT_Full);
+		ethtool_link_ksettings_add_link_mode
+			(cmd, supported, 10000baseT_Full);
 		return;
 	}
 
@@ -181,8 +228,8 @@ static void ixgbe_set_advertising_10gtypes(struct ixgbe_hw *hw,
 					   struct ethtool_link_ksettings *cmd)
 {
 	if (!ixgbe_isbackplane(hw->phy.media_type)) {
-		ethtool_link_ksettings_add_link_mode(cmd, advertising,
-						     10000baseT_Full);
+		ethtool_link_ksettings_add_link_mode
+			(cmd, advertising, 10000baseT_Full);
 		return;
 	}
 
@@ -222,20 +269,21 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 	ethtool_link_ksettings_zero_link_mode(cmd, advertising);
 
 	hw->mac.ops.get_link_capabilities(hw, &supported_link, &autoneg);
-
 	/* set the supported link speeds */
 	if (supported_link & IXGBE_LINK_SPEED_10GB_FULL) {
 		ixgbe_set_supported_10gtypes(hw, cmd);
 		ixgbe_set_advertising_10gtypes(hw, cmd);
 	}
+#ifdef HAVE_ETHTOOL_5G_BITS
 	if (supported_link & IXGBE_LINK_SPEED_5GB_FULL)
 		ethtool_link_ksettings_add_link_mode(cmd, supported,
 						     5000baseT_Full);
-
+#endif
+#ifdef HAVE_ETHTOOL_NEW_2500MB_BITS
 	if (supported_link & IXGBE_LINK_SPEED_2_5GB_FULL)
 		ethtool_link_ksettings_add_link_mode(cmd, supported,
 						     2500baseT_Full);
-
+#endif
 	if (supported_link & IXGBE_LINK_SPEED_1GB_FULL) {
 		if (ixgbe_isbackplane(hw->phy.media_type)) {
 			ethtool_link_ksettings_add_link_mode(cmd, supported,
@@ -263,7 +311,7 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 	}
 
 	/* set the advertised speeds */
-	if (hw->phy.autoneg_advertised) {
+	if (hw->phy.autoneg_advertised)	{
 		ethtool_link_ksettings_zero_link_mode(cmd, advertising);
 		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10_FULL)
 			ethtool_link_ksettings_add_link_mode(cmd, advertising,
@@ -282,12 +330,18 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 				ethtool_link_ksettings_add_link_mode
 					(cmd, advertising, 1000baseT_Full);
 		}
-		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_5GB_FULL)
+#ifdef HAVE_ETHTOOL_5G_BITS
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_5GB_FULL) {
 			ethtool_link_ksettings_add_link_mode(cmd, advertising,
 							     5000baseT_Full);
-		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL)
+		}
+#endif
+#ifdef HAVE_ETHTOOL_NEW_2500MB_BITS
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL) {
 			ethtool_link_ksettings_add_link_mode(cmd, advertising,
 							     2500baseT_Full);
+		}
+#endif
 	} else {
 		if (hw->phy.multispeed_fiber && !autoneg) {
 			if (supported_link & IXGBE_LINK_SPEED_10GB_FULL)
@@ -300,8 +354,9 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 		ethtool_link_ksettings_add_link_mode(cmd, supported, Autoneg);
 		ethtool_link_ksettings_add_link_mode(cmd, advertising, Autoneg);
 		cmd->base.autoneg = AUTONEG_ENABLE;
-	} else
+	} else {
 		cmd->base.autoneg = AUTONEG_DISABLE;
+	}
 
 	/* Determine the remaining settings based on the PHY type. */
 	switch (adapter->hw.phy.type) {
@@ -330,8 +385,8 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 	case ixgbe_phy_qsfp_active_unknown:
 	case ixgbe_phy_qsfp_intel:
 	case ixgbe_phy_qsfp_unknown:
-		/* SFP+ devices, further checking needed */
 		switch (adapter->hw.phy.sfp_type) {
+			/* SFP+ devices, further checking needed */
 		case ixgbe_sfp_type_da_cu:
 		case ixgbe_sfp_type_da_cu_core0:
 		case ixgbe_sfp_type_da_cu_core1:
@@ -381,20 +436,16 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 		}
 		break;
 	case ixgbe_phy_xaui:
-		ethtool_link_ksettings_add_link_mode(cmd, supported,
-						     FIBRE);
-		ethtool_link_ksettings_add_link_mode(cmd, advertising,
-						     FIBRE);
+		ethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);
+		ethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);
 		cmd->base.port = PORT_NONE;
 		break;
 	case ixgbe_phy_unknown:
 	case ixgbe_phy_generic:
 	case ixgbe_phy_sfp_unsupported:
 	default:
-		ethtool_link_ksettings_add_link_mode(cmd, supported,
-						     FIBRE);
-		ethtool_link_ksettings_add_link_mode(cmd, advertising,
-						     FIBRE);
+		ethtool_link_ksettings_add_link_mode(cmd, supported, FIBRE);
+		ethtool_link_ksettings_add_link_mode(cmd, advertising, FIBRE);
 		cmd->base.port = PORT_OTHER;
 		break;
 	}
@@ -429,9 +480,11 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 		case IXGBE_LINK_SPEED_5GB_FULL:
 			cmd->base.speed = SPEED_5000;
 			break;
+#ifdef SUPPORTED_2500baseX_Full
 		case IXGBE_LINK_SPEED_2_5GB_FULL:
 			cmd->base.speed = SPEED_2500;
 			break;
+#endif /* SUPPORTED_2500baseX_Full */
 		case IXGBE_LINK_SPEED_1GB_FULL:
 			cmd->base.speed = SPEED_1000;
 			break;
@@ -452,7 +505,228 @@ static int ixgbe_get_link_ksettings(struct net_device *netdev,
 
 	return 0;
 }
+#else /* ETHTOOL_GLINKSETTINGS */
+static __u32 ixgbe_backplane_type(struct ixgbe_hw *hw)
+{
+	__u32 mode = 0x00;
+
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_82598:
+	case IXGBE_DEV_ID_82599_KX4:
+	case IXGBE_DEV_ID_82599_KX4_MEZZ:
+	case IXGBE_DEV_ID_X550EM_X_KX4:
+		mode = SUPPORTED_10000baseKX4_Full;
+		break;
+	case IXGBE_DEV_ID_82598_BX:
+	case IXGBE_DEV_ID_82599_KR:
+	case IXGBE_DEV_ID_X550EM_X_KR:
+	case IXGBE_DEV_ID_X550EM_X_XFI:
+		mode = SUPPORTED_10000baseKR_Full;
+		break;
+	default:
+		mode = (SUPPORTED_10000baseKX4_Full |
+			SUPPORTED_10000baseKR_Full);
+		break;
+	}
+	return mode;
+}
+
+static int ixgbe_get_settings(struct net_device *netdev,
+			      struct ethtool_cmd *ecmd)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
+	ixgbe_link_speed supported_link;
+	bool autoneg = false;
+
+	hw->mac.ops.get_link_capabilities(hw, &supported_link, &autoneg);
+
+	/* set the supported link speeds */
+	if (supported_link & IXGBE_LINK_SPEED_10GB_FULL)
+		ecmd->supported |= (ixgbe_isbackplane(hw->phy.media_type)) ?
+				    ixgbe_backplane_type(hw) :
+				    SUPPORTED_10000baseT_Full;
+	if (supported_link & IXGBE_LINK_SPEED_1GB_FULL)
+		ecmd->supported |= (ixgbe_isbackplane(hw->phy.media_type)) ?
+				    SUPPORTED_1000baseKX_Full :
+				    SUPPORTED_1000baseT_Full;
+	if (supported_link & IXGBE_LINK_SPEED_100_FULL)
+		ecmd->supported |= SUPPORTED_100baseT_Full;
+	if (supported_link & IXGBE_LINK_SPEED_10_FULL)
+		ecmd->supported |= SUPPORTED_10baseT_Full;
+
+	/* default advertised speed if phy.autoneg_advertised isn't set */
+	ecmd->advertising = ecmd->supported;
+
+	/* set the advertised speeds */
+	if (hw->phy.autoneg_advertised) {
+		ecmd->advertising = 0;
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10_FULL)
+			ecmd->advertising |= ADVERTISED_10baseT_Full;
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)
+			ecmd->advertising |= ADVERTISED_100baseT_Full;
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)
+			ecmd->advertising |= (ecmd->supported & ADVERTISED_MASK_10G);
+		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_1GB_FULL) {
+			if (ecmd->supported & SUPPORTED_1000baseKX_Full)
+				ecmd->advertising |= ADVERTISED_1000baseKX_Full;
+			else
+				ecmd->advertising |= ADVERTISED_1000baseT_Full;
+		}
+	} else {
+		if (hw->phy.multispeed_fiber && !autoneg) {
+			if (supported_link & IXGBE_LINK_SPEED_10GB_FULL)
+				ecmd->advertising = ADVERTISED_10000baseT_Full;
+		}
+	}
+
+	if (autoneg) {
+		ecmd->supported |= SUPPORTED_Autoneg;
+		ecmd->advertising |= ADVERTISED_Autoneg;
+		ecmd->autoneg = AUTONEG_ENABLE;
+	} else {
+		ecmd->autoneg = AUTONEG_DISABLE;
+	}
+
+	ecmd->transceiver = XCVR_EXTERNAL;
+
+	/* Determine the remaining settings based on the PHY type. */
+	switch (adapter->hw.phy.type) {
+	case ixgbe_phy_tn:
+	case ixgbe_phy_aq:
+	case ixgbe_phy_x550em_ext_t:
+	case ixgbe_phy_fw:
+	case ixgbe_phy_cu_unknown:
+		ecmd->supported |= SUPPORTED_TP;
+		ecmd->advertising |= ADVERTISED_TP;
+		ecmd->port = PORT_TP;
+		break;
+	case ixgbe_phy_qt:
+		ecmd->supported |= SUPPORTED_FIBRE;
+		ecmd->advertising |= ADVERTISED_FIBRE;
+		ecmd->port = PORT_FIBRE;
+		break;
+	case ixgbe_phy_nl:
+	case ixgbe_phy_sfp_passive_tyco:
+	case ixgbe_phy_sfp_passive_unknown:
+	case ixgbe_phy_sfp_ftl:
+	case ixgbe_phy_sfp_avago:
+	case ixgbe_phy_sfp_intel:
+	case ixgbe_phy_sfp_unknown:
+	case ixgbe_phy_qsfp_passive_unknown:
+	case ixgbe_phy_qsfp_active_unknown:
+	case ixgbe_phy_qsfp_intel:
+	case ixgbe_phy_qsfp_unknown:
+		switch (adapter->hw.phy.sfp_type) {
+			/* SFP+ devices, further checking needed */
+		case ixgbe_sfp_type_da_cu:
+		case ixgbe_sfp_type_da_cu_core0:
+		case ixgbe_sfp_type_da_cu_core1:
+			ecmd->supported |= SUPPORTED_FIBRE;
+			ecmd->advertising |= ADVERTISED_FIBRE;
+			ecmd->port = PORT_DA;
+			break;
+		case ixgbe_sfp_type_sr:
+		case ixgbe_sfp_type_lr:
+		case ixgbe_sfp_type_srlr_core0:
+		case ixgbe_sfp_type_srlr_core1:
+		case ixgbe_sfp_type_1g_sx_core0:
+		case ixgbe_sfp_type_1g_sx_core1:
+		case ixgbe_sfp_type_1g_lx_core0:
+		case ixgbe_sfp_type_1g_lx_core1:
+			ecmd->supported |= SUPPORTED_FIBRE;
+			ecmd->advertising |= ADVERTISED_FIBRE;
+			ecmd->port = PORT_FIBRE;
+			break;
+		case ixgbe_sfp_type_not_present:
+			ecmd->supported |= SUPPORTED_FIBRE;
+			ecmd->advertising |= ADVERTISED_FIBRE;
+			ecmd->port = PORT_NONE;
+			break;
+		case ixgbe_sfp_type_1g_cu_core0:
+		case ixgbe_sfp_type_1g_cu_core1:
+			ecmd->supported |= SUPPORTED_TP;
+			ecmd->advertising |= ADVERTISED_TP;
+			ecmd->port = PORT_TP;
+			break;
+		case ixgbe_sfp_type_unknown:
+		default:
+			ecmd->supported |= SUPPORTED_FIBRE;
+			ecmd->advertising |= ADVERTISED_FIBRE;
+			ecmd->port = PORT_OTHER;
+			break;
+		}
+		break;
+	case ixgbe_phy_xaui:
+		ecmd->supported |= SUPPORTED_FIBRE;
+		ecmd->advertising |= ADVERTISED_FIBRE;
+		ecmd->port = PORT_NONE;
+		break;
+	case ixgbe_phy_unknown:
+	case ixgbe_phy_generic:
+	case ixgbe_phy_sfp_unsupported:
+	default:
+		ecmd->supported |= SUPPORTED_FIBRE;
+		ecmd->advertising |= ADVERTISED_FIBRE;
+		ecmd->port = PORT_OTHER;
+		break;
+	}
+
+	/* Indicate pause support */
+	ecmd->supported |= SUPPORTED_Pause;
+
+	switch (hw->fc.requested_mode) {
+	case ixgbe_fc_full:
+		ecmd->advertising |= ADVERTISED_Pause;
+		break;
+	case ixgbe_fc_rx_pause:
+		ecmd->advertising |= ADVERTISED_Pause |
+				     ADVERTISED_Asym_Pause;
+		break;
+	case ixgbe_fc_tx_pause:
+		ecmd->advertising |= ADVERTISED_Asym_Pause;
+		break;
+	default:
+		ecmd->advertising &= ~(ADVERTISED_Pause |
+				       ADVERTISED_Asym_Pause);
+	}
+
+	if (netif_carrier_ok(netdev)) {
+		switch (adapter->link_speed) {
+		case IXGBE_LINK_SPEED_10GB_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_10000);
+			break;
+		case IXGBE_LINK_SPEED_5GB_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_5000);
+			break;
+#ifdef SUPPORTED_2500baseX_Full
+		case IXGBE_LINK_SPEED_2_5GB_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_2500);
+			break;
+#endif /* SUPPORTED_2500baseX_Full */
+		case IXGBE_LINK_SPEED_1GB_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_1000);
+			break;
+		case IXGBE_LINK_SPEED_100_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_100);
+			break;
+		case IXGBE_LINK_SPEED_10_FULL:
+			ethtool_cmd_speed_set(ecmd, SPEED_10);
+			break;
+		default:
+			break;
+		}
+		ecmd->duplex = DUPLEX_FULL;
+	} else {
+		ethtool_cmd_speed_set(ecmd, SPEED_UNKNOWN);
+		ecmd->duplex = DUPLEX_UNKNOWN;
+	}
+
+	return 0;
+}
+#endif /* !ETHTOOL_GLINKSETTINGS */
 
+#ifdef ETHTOOL_GLINKSETTINGS
 static int ixgbe_set_link_ksettings(struct net_device *netdev,
 				    const struct ethtool_link_ksettings *cmd)
 {
@@ -461,8 +735,8 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 	u32 advertised, old;
 	s32 err = 0;
 
-	if ((hw->phy.media_type == ixgbe_media_type_copper) ||
-	    (hw->phy.multispeed_fiber)) {
+	if (hw->phy.media_type == ixgbe_media_type_copper ||
+	    hw->phy.multispeed_fiber) {
 		/*
 		 * this function does not support duplex forcing, but can
 		 * limit the advertising of the adapter to the specified speed
@@ -474,10 +748,10 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 
 		/* only allow one speed at a time if no autoneg */
 		if (!cmd->base.autoneg && hw->phy.multispeed_fiber) {
-			if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
-								  10000baseT_Full) &&
-			    ethtool_link_ksettings_test_link_mode(cmd, advertising,
-								  1000baseT_Full))
+			if (ethtool_link_ksettings_test_link_mode
+				(cmd, advertising, 10000baseT_Full) &&
+				ethtool_link_ksettings_test_link_mode
+					(cmd, advertising, 1000baseT_Full))
 				return -EINVAL;
 		}
 
@@ -486,20 +760,22 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  10000baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_10GB_FULL;
+#ifdef HAVE_ETHTOOL_5G_BITS
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  5000baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_5GB_FULL;
+#endif
+#ifdef HAVE_ETHTOOL_NEW_2500MB_BITS
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  2500baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_2_5GB_FULL;
+#endif
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  1000baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_1GB_FULL;
-
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  100baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_100_FULL;
-
 		if (ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							  10baseT_Full))
 			advertised |= IXGBE_LINK_SPEED_10_FULL;
@@ -521,7 +797,7 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 		/* in this case we currently only support 10Gb/FULL */
 		u32 speed = cmd->base.speed;
 
-		if ((cmd->base.autoneg == AUTONEG_ENABLE) ||
+		if (cmd->base.autoneg == AUTONEG_ENABLE ||
 		    (!ethtool_link_ksettings_test_link_mode(cmd, advertising,
 							    10000baseT_Full)) ||
 		    (speed + cmd->base.duplex != SPEED_10000 + DUPLEX_FULL))
@@ -530,16 +806,73 @@ static int ixgbe_set_link_ksettings(struct net_device *netdev,
 
 	return err;
 }
-
-static void ixgbe_get_pause_stats(struct net_device *netdev,
-				  struct ethtool_pause_stats *stats)
+#else
+static int ixgbe_set_settings(struct net_device *netdev,
+			      struct ethtool_cmd *ecmd)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw_stats *hwstats = &adapter->stats;
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 advertised, old;
+	s32 err = 0;
+
+	if ((hw->phy.media_type == ixgbe_media_type_copper) ||
+	    (hw->phy.multispeed_fiber)) {
+		/*
+		 * this function does not support duplex forcing, but can
+		 * limit the advertising of the adapter to the specified speed
+		 */
+		if (ecmd->advertising & ~ecmd->supported)
+			return -EINVAL;
+
+		/* only allow one speed at a time if no autoneg */
+		if (!ecmd->autoneg && hw->phy.multispeed_fiber) {
+			if (ecmd->advertising ==
+			    (ADVERTISED_10000baseT_Full |
+			     ADVERTISED_1000baseT_Full))
+				return -EINVAL;
+		}
+
+		old = hw->phy.autoneg_advertised;
+		advertised = 0;
+		if (ecmd->advertising & ADVERTISED_10000baseT_Full)
+			advertised |= IXGBE_LINK_SPEED_10GB_FULL;
+
+		if (ecmd->advertising & ADVERTISED_1000baseT_Full)
+			advertised |= IXGBE_LINK_SPEED_1GB_FULL;
+
+		if (ecmd->advertising & ADVERTISED_100baseT_Full)
+			advertised |= IXGBE_LINK_SPEED_100_FULL;
+
+		if (ecmd->advertising & ADVERTISED_10baseT_Full)
+			advertised |= IXGBE_LINK_SPEED_10_FULL;
+
+		if (old == advertised)
+			return err;
+		/* this sets the link speed and restarts auto-neg */
+		while (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))
+			usleep_range(1000, 2000);
+
+		hw->mac.autotry_restart = true;
+		err = hw->mac.ops.setup_link(hw, advertised, true);
+		if (err) {
+			e_info(probe, "setup link failed with code %d\n", err);
+			hw->mac.ops.setup_link(hw, old, true);
+		}
+		clear_bit(__IXGBE_IN_SFP_INIT, &adapter->state);
+	}
+	else {
+		/* in this case we currently only support 10Gb/FULL */
+		u32 speed = ethtool_cmd_speed(ecmd);
+
+		if ((ecmd->autoneg == AUTONEG_ENABLE) ||
+		    (ecmd->advertising != ADVERTISED_10000baseT_Full) ||
+		    (speed + ecmd->duplex != SPEED_10000 + DUPLEX_FULL))
+			return -EINVAL;
+	}
 
-	stats->tx_pause_frames = hwstats->lxontxc + hwstats->lxofftxc;
-	stats->rx_pause_frames = hwstats->lxonrxc + hwstats->lxoffrxc;
+	return err;
 }
+#endif /* !ETHTOOL_GLINKSETTINGS */
 
 static void ixgbe_get_pauseparam(struct net_device *netdev,
 				 struct ethtool_pauseparam *pause)
@@ -575,18 +908,19 @@ static int ixgbe_set_pauseparam(struct net_device *netdev,
 	    (adapter->flags & IXGBE_FLAG_DCB_ENABLED))
 		return -EINVAL;
 
-	/* some devices do not support autoneg of link flow control */
+
+	/* some devices do not support autoneg of flow control */
 	if ((pause->autoneg == AUTONEG_ENABLE) &&
 	    !ixgbe_device_supports_autoneg_fc(hw))
-		return -EINVAL;
+	    return -EINVAL;
 
 	fc.disable_fc_autoneg = (pause->autoneg != AUTONEG_ENABLE);
 
 	if ((pause->rx_pause && pause->tx_pause) || pause->autoneg)
 		fc.requested_mode = ixgbe_fc_full;
-	else if (pause->rx_pause && !pause->tx_pause)
+	else if (pause->rx_pause)
 		fc.requested_mode = ixgbe_fc_rx_pause;
-	else if (!pause->rx_pause && pause->tx_pause)
+	else if (pause->tx_pause)
 		fc.requested_mode = ixgbe_fc_tx_pause;
 	else
 		fc.requested_mode = ixgbe_fc_none;
@@ -615,16 +949,16 @@ static void ixgbe_set_msglevel(struct net_device *netdev, u32 data)
 	adapter->msg_enable = data;
 }
 
-static int ixgbe_get_regs_len(struct net_device *netdev)
+static int ixgbe_get_regs_len(struct net_device __always_unused *netdev)
 {
 #define IXGBE_REGS_LEN  1145
 	return IXGBE_REGS_LEN * sizeof(u32);
 }
 
-#define IXGBE_GET_STAT(_A_, _R_) _A_->stats._R_
+#define IXGBE_GET_STAT(_A_, _R_)	(_A_->stats._R_)
 
-static void ixgbe_get_regs(struct net_device *netdev,
-			   struct ethtool_regs *regs, void *p)
+static void ixgbe_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
+			   void *p)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -637,186 +971,186 @@ static void ixgbe_get_regs(struct net_device *netdev,
 			hw->device_id;
 
 	/* General Registers */
-	regs_buff[0] = IXGBE_READ_REG(hw, IXGBE_CTRL);
-	regs_buff[1] = IXGBE_READ_REG(hw, IXGBE_STATUS);
-	regs_buff[2] = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
-	regs_buff[3] = IXGBE_READ_REG(hw, IXGBE_ESDP);
-	regs_buff[4] = IXGBE_READ_REG(hw, IXGBE_EODSDP);
-	regs_buff[5] = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
-	regs_buff[6] = IXGBE_READ_REG(hw, IXGBE_FRTIMER);
-	regs_buff[7] = IXGBE_READ_REG(hw, IXGBE_TCPTIMER);
+	regs_buff[0] = IXGBE_R32_Q(hw, IXGBE_CTRL);
+	regs_buff[1] = IXGBE_R32_Q(hw, IXGBE_STATUS);
+	regs_buff[2] = IXGBE_R32_Q(hw, IXGBE_CTRL_EXT);
+	regs_buff[3] = IXGBE_R32_Q(hw, IXGBE_ESDP);
+	regs_buff[4] = IXGBE_R32_Q(hw, IXGBE_EODSDP);
+	regs_buff[5] = IXGBE_R32_Q(hw, IXGBE_LEDCTL);
+	regs_buff[6] = IXGBE_R32_Q(hw, IXGBE_FRTIMER);
+	regs_buff[7] = IXGBE_R32_Q(hw, IXGBE_TCPTIMER);
 
 	/* NVM Register */
-	regs_buff[8] = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
-	regs_buff[9] = IXGBE_READ_REG(hw, IXGBE_EERD);
-	regs_buff[10] = IXGBE_READ_REG(hw, IXGBE_FLA(hw));
-	regs_buff[11] = IXGBE_READ_REG(hw, IXGBE_EEMNGCTL);
-	regs_buff[12] = IXGBE_READ_REG(hw, IXGBE_EEMNGDATA);
-	regs_buff[13] = IXGBE_READ_REG(hw, IXGBE_FLMNGCTL);
-	regs_buff[14] = IXGBE_READ_REG(hw, IXGBE_FLMNGDATA);
-	regs_buff[15] = IXGBE_READ_REG(hw, IXGBE_FLMNGCNT);
-	regs_buff[16] = IXGBE_READ_REG(hw, IXGBE_FLOP);
-	regs_buff[17] = IXGBE_READ_REG(hw, IXGBE_GRC(hw));
+	regs_buff[8] = IXGBE_R32_Q(hw, IXGBE_EEC);
+	regs_buff[9] = IXGBE_R32_Q(hw, IXGBE_EERD);
+	regs_buff[10] = IXGBE_R32_Q(hw, IXGBE_FLA);
+	regs_buff[11] = IXGBE_R32_Q(hw, IXGBE_EEMNGCTL);
+	regs_buff[12] = IXGBE_R32_Q(hw, IXGBE_EEMNGDATA);
+	regs_buff[13] = IXGBE_R32_Q(hw, IXGBE_FLMNGCTL);
+	regs_buff[14] = IXGBE_R32_Q(hw, IXGBE_FLMNGDATA);
+	regs_buff[15] = IXGBE_R32_Q(hw, IXGBE_FLMNGCNT);
+	regs_buff[16] = IXGBE_R32_Q(hw, IXGBE_FLOP);
+	regs_buff[17] = IXGBE_R32_Q(hw, IXGBE_GRC);
 
 	/* Interrupt */
 	/* don't read EICR because it can clear interrupt causes, instead
 	 * read EICS which is a shadow but doesn't clear EICR */
-	regs_buff[18] = IXGBE_READ_REG(hw, IXGBE_EICS);
-	regs_buff[19] = IXGBE_READ_REG(hw, IXGBE_EICS);
-	regs_buff[20] = IXGBE_READ_REG(hw, IXGBE_EIMS);
-	regs_buff[21] = IXGBE_READ_REG(hw, IXGBE_EIMC);
-	regs_buff[22] = IXGBE_READ_REG(hw, IXGBE_EIAC);
-	regs_buff[23] = IXGBE_READ_REG(hw, IXGBE_EIAM);
-	regs_buff[24] = IXGBE_READ_REG(hw, IXGBE_EITR(0));
-	regs_buff[25] = IXGBE_READ_REG(hw, IXGBE_IVAR(0));
-	regs_buff[26] = IXGBE_READ_REG(hw, IXGBE_MSIXT);
-	regs_buff[27] = IXGBE_READ_REG(hw, IXGBE_MSIXPBA);
-	regs_buff[28] = IXGBE_READ_REG(hw, IXGBE_PBACL(0));
-	regs_buff[29] = IXGBE_READ_REG(hw, IXGBE_GPIE);
+	regs_buff[18] = IXGBE_R32_Q(hw, IXGBE_EICS);
+	regs_buff[19] = IXGBE_R32_Q(hw, IXGBE_EICS);
+	regs_buff[20] = IXGBE_R32_Q(hw, IXGBE_EIMS);
+	regs_buff[21] = IXGBE_R32_Q(hw, IXGBE_EIMC);
+	regs_buff[22] = IXGBE_R32_Q(hw, IXGBE_EIAC);
+	regs_buff[23] = IXGBE_R32_Q(hw, IXGBE_EIAM);
+	regs_buff[24] = IXGBE_R32_Q(hw, IXGBE_EITR(0));
+	regs_buff[25] = IXGBE_R32_Q(hw, IXGBE_IVAR(0));
+	regs_buff[26] = IXGBE_R32_Q(hw, IXGBE_MSIXT);
+	regs_buff[27] = IXGBE_R32_Q(hw, IXGBE_MSIXPBA);
+	regs_buff[28] = IXGBE_R32_Q(hw, IXGBE_PBACL(0));
+	regs_buff[29] = IXGBE_R32_Q(hw, IXGBE_GPIE);
 
 	/* Flow Control */
-	regs_buff[30] = IXGBE_READ_REG(hw, IXGBE_PFCTOP);
-	for (i = 0; i < 4; i++)
-		regs_buff[31 + i] = IXGBE_READ_REG(hw, IXGBE_FCTTV(i));
+	regs_buff[30] = IXGBE_R32_Q(hw, IXGBE_PFCTOP);
+	regs_buff[31] = IXGBE_R32_Q(hw, IXGBE_FCTTV(0));
+	regs_buff[32] = IXGBE_R32_Q(hw, IXGBE_FCTTV(1));
+	regs_buff[33] = IXGBE_R32_Q(hw, IXGBE_FCTTV(2));
+	regs_buff[34] = IXGBE_R32_Q(hw, IXGBE_FCTTV(3));
 	for (i = 0; i < 8; i++) {
 		switch (hw->mac.type) {
 		case ixgbe_mac_82598EB:
-			regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL(i));
-			regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH(i));
+			regs_buff[35 + i] = IXGBE_R32_Q(hw, IXGBE_FCRTL(i));
+			regs_buff[43 + i] = IXGBE_R32_Q(hw, IXGBE_FCRTH(i));
 			break;
 		case ixgbe_mac_82599EB:
 		case ixgbe_mac_X540:
 		case ixgbe_mac_X550:
 		case ixgbe_mac_X550EM_x:
-		case ixgbe_mac_x550em_a:
-			regs_buff[35 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTL_82599(i));
-			regs_buff[43 + i] = IXGBE_READ_REG(hw, IXGBE_FCRTH_82599(i));
+			regs_buff[35 + i] = IXGBE_R32_Q(hw,
+							IXGBE_FCRTL_82599(i));
+			regs_buff[43 + i] = IXGBE_R32_Q(hw,
+							IXGBE_FCRTH_82599(i));
 			break;
 		default:
 			break;
 		}
 	}
-	regs_buff[51] = IXGBE_READ_REG(hw, IXGBE_FCRTV);
-	regs_buff[52] = IXGBE_READ_REG(hw, IXGBE_TFCS);
+	regs_buff[51] = IXGBE_R32_Q(hw, IXGBE_FCRTV);
+	regs_buff[52] = IXGBE_R32_Q(hw, IXGBE_TFCS);
 
 	/* Receive DMA */
 	for (i = 0; i < 64; i++)
-		regs_buff[53 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));
+		regs_buff[53 + i] = IXGBE_R32_Q(hw, IXGBE_RDBAL(i));
 	for (i = 0; i < 64; i++)
-		regs_buff[117 + i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));
+		regs_buff[117 + i] = IXGBE_R32_Q(hw, IXGBE_RDBAH(i));
 	for (i = 0; i < 64; i++)
-		regs_buff[181 + i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));
+		regs_buff[181 + i] = IXGBE_R32_Q(hw, IXGBE_RDLEN(i));
 	for (i = 0; i < 64; i++)
-		regs_buff[245 + i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));
+		regs_buff[245 + i] = IXGBE_R32_Q(hw, IXGBE_RDH(i));
 	for (i = 0; i < 64; i++)
-		regs_buff[309 + i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));
+		regs_buff[309 + i] = IXGBE_R32_Q(hw, IXGBE_RDT(i));
 	for (i = 0; i < 64; i++)
-		regs_buff[373 + i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
+		regs_buff[373 + i] = IXGBE_R32_Q(hw, IXGBE_RXDCTL(i));
 	for (i = 0; i < 16; i++)
-		regs_buff[437 + i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));
+		regs_buff[437 + i] = IXGBE_R32_Q(hw, IXGBE_SRRCTL(i));
 	for (i = 0; i < 16; i++)
-		regs_buff[453 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
-	regs_buff[469] = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
+		regs_buff[453 + i] = IXGBE_R32_Q(hw, IXGBE_DCA_RXCTRL(i));
+	regs_buff[469] = IXGBE_R32_Q(hw, IXGBE_RDRXCTL);
 	for (i = 0; i < 8; i++)
-		regs_buff[470 + i] = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(i));
-	regs_buff[478] = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
-	regs_buff[479] = IXGBE_READ_REG(hw, IXGBE_DROPEN);
+		regs_buff[470 + i] = IXGBE_R32_Q(hw, IXGBE_RXPBSIZE(i));
+	regs_buff[478] = IXGBE_R32_Q(hw, IXGBE_RXCTRL);
+	regs_buff[479] = IXGBE_R32_Q(hw, IXGBE_DROPEN);
 
 	/* Receive */
-	regs_buff[480] = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
-	regs_buff[481] = IXGBE_READ_REG(hw, IXGBE_RFCTL);
+	regs_buff[480] = IXGBE_R32_Q(hw, IXGBE_RXCSUM);
+	regs_buff[481] = IXGBE_R32_Q(hw, IXGBE_RFCTL);
 	for (i = 0; i < 16; i++)
-		regs_buff[482 + i] = IXGBE_READ_REG(hw, IXGBE_RAL(i));
+		regs_buff[482 + i] = IXGBE_R32_Q(hw, IXGBE_RAL(i));
 	for (i = 0; i < 16; i++)
-		regs_buff[498 + i] = IXGBE_READ_REG(hw, IXGBE_RAH(i));
-	regs_buff[514] = IXGBE_READ_REG(hw, IXGBE_PSRTYPE(0));
-	regs_buff[515] = IXGBE_READ_REG(hw, IXGBE_FCTRL);
-	regs_buff[516] = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
-	regs_buff[517] = IXGBE_READ_REG(hw, IXGBE_MCSTCTRL);
-	regs_buff[518] = IXGBE_READ_REG(hw, IXGBE_MRQC);
-	regs_buff[519] = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
+		regs_buff[498 + i] = IXGBE_R32_Q(hw, IXGBE_RAH(i));
+	regs_buff[514] = IXGBE_R32_Q(hw, IXGBE_PSRTYPE(0));
+	regs_buff[515] = IXGBE_R32_Q(hw, IXGBE_FCTRL);
+	regs_buff[516] = IXGBE_R32_Q(hw, IXGBE_VLNCTRL);
+	regs_buff[517] = IXGBE_R32_Q(hw, IXGBE_MCSTCTRL);
+	regs_buff[518] = IXGBE_R32_Q(hw, IXGBE_MRQC);
+	regs_buff[519] = IXGBE_R32_Q(hw, IXGBE_VMD_CTL);
 	for (i = 0; i < 8; i++)
-		regs_buff[520 + i] = IXGBE_READ_REG(hw, IXGBE_IMIR(i));
+		regs_buff[520 + i] = IXGBE_R32_Q(hw, IXGBE_IMIR(i));
 	for (i = 0; i < 8; i++)
-		regs_buff[528 + i] = IXGBE_READ_REG(hw, IXGBE_IMIREXT(i));
-	regs_buff[536] = IXGBE_READ_REG(hw, IXGBE_IMIRVP);
+		regs_buff[528 + i] = IXGBE_R32_Q(hw, IXGBE_IMIREXT(i));
+	regs_buff[536] = IXGBE_R32_Q(hw, IXGBE_IMIRVP);
 
 	/* Transmit */
 	for (i = 0; i < 32; i++)
-		regs_buff[537 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));
+		regs_buff[537 + i] = IXGBE_R32_Q(hw, IXGBE_TDBAL(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[569 + i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));
+		regs_buff[569 + i] = IXGBE_R32_Q(hw, IXGBE_TDBAH(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[601 + i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));
+		regs_buff[601 + i] = IXGBE_R32_Q(hw, IXGBE_TDLEN(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[633 + i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));
+		regs_buff[633 + i] = IXGBE_R32_Q(hw, IXGBE_TDH(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[665 + i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));
+		regs_buff[665 + i] = IXGBE_R32_Q(hw, IXGBE_TDT(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[697 + i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));
+		regs_buff[697 + i] = IXGBE_R32_Q(hw, IXGBE_TXDCTL(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[729 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAL(i));
+		regs_buff[729 + i] = IXGBE_R32_Q(hw, IXGBE_TDWBAL(i));
 	for (i = 0; i < 32; i++)
-		regs_buff[761 + i] = IXGBE_READ_REG(hw, IXGBE_TDWBAH(i));
-	regs_buff[793] = IXGBE_READ_REG(hw, IXGBE_DTXCTL);
+		regs_buff[761 + i] = IXGBE_R32_Q(hw, IXGBE_TDWBAH(i));
+	regs_buff[793] = IXGBE_R32_Q(hw, IXGBE_DTXCTL);
 	for (i = 0; i < 16; i++)
-		regs_buff[794 + i] = IXGBE_READ_REG(hw, IXGBE_DCA_TXCTRL(i));
-	regs_buff[810] = IXGBE_READ_REG(hw, IXGBE_TIPG);
+		regs_buff[794 + i] = IXGBE_R32_Q(hw, IXGBE_DCA_TXCTRL(i));
+	regs_buff[810] = IXGBE_R32_Q(hw, IXGBE_TIPG);
 	for (i = 0; i < 8; i++)
-		regs_buff[811 + i] = IXGBE_READ_REG(hw, IXGBE_TXPBSIZE(i));
-	regs_buff[819] = IXGBE_READ_REG(hw, IXGBE_MNGTXMAP);
+		regs_buff[811 + i] = IXGBE_R32_Q(hw, IXGBE_TXPBSIZE(i));
+	regs_buff[819] = IXGBE_R32_Q(hw, IXGBE_MNGTXMAP);
 
 	/* Wake Up */
-	regs_buff[820] = IXGBE_READ_REG(hw, IXGBE_WUC);
-	regs_buff[821] = IXGBE_READ_REG(hw, IXGBE_WUFC);
-	regs_buff[822] = IXGBE_READ_REG(hw, IXGBE_WUS);
-	regs_buff[823] = IXGBE_READ_REG(hw, IXGBE_IPAV);
-	regs_buff[824] = IXGBE_READ_REG(hw, IXGBE_IP4AT);
-	regs_buff[825] = IXGBE_READ_REG(hw, IXGBE_IP6AT);
-	regs_buff[826] = IXGBE_READ_REG(hw, IXGBE_WUPL);
-	regs_buff[827] = IXGBE_READ_REG(hw, IXGBE_WUPM);
-	regs_buff[828] = IXGBE_READ_REG(hw, IXGBE_FHFT(0));
+	regs_buff[820] = IXGBE_R32_Q(hw, IXGBE_WUC);
+	regs_buff[821] = IXGBE_R32_Q(hw, IXGBE_WUFC);
+	regs_buff[822] = IXGBE_R32_Q(hw, IXGBE_WUS);
+	regs_buff[823] = IXGBE_R32_Q(hw, IXGBE_IPAV);
+	regs_buff[824] = IXGBE_R32_Q(hw, IXGBE_IP4AT);
+	regs_buff[825] = IXGBE_R32_Q(hw, IXGBE_IP6AT);
+	regs_buff[826] = IXGBE_R32_Q(hw, IXGBE_WUPL);
+	regs_buff[827] = IXGBE_R32_Q(hw, IXGBE_WUPM);
+	regs_buff[828] = IXGBE_R32_Q(hw, IXGBE_FHFT(0));
 
 	/* DCB */
-	regs_buff[829] = IXGBE_READ_REG(hw, IXGBE_RMCS);   /* same as FCCFG  */
-	regs_buff[831] = IXGBE_READ_REG(hw, IXGBE_PDPMCS); /* same as RTTPCS */
+	regs_buff[829] = IXGBE_R32_Q(hw, IXGBE_RMCS);   /* same as FCCFG  */
+	regs_buff[831] = IXGBE_R32_Q(hw, IXGBE_PDPMCS); /* same as RTTPCS */
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
-		regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_DPMCS);
-		regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RUPPBMR);
+		regs_buff[830] = IXGBE_R32_Q(hw, IXGBE_DPMCS);
+		regs_buff[832] = IXGBE_R32_Q(hw, IXGBE_RUPPBMR);
 		for (i = 0; i < 8; i++)
 			regs_buff[833 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RT2CR(i));
+				IXGBE_R32_Q(hw, IXGBE_RT2CR(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[841 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RT2SR(i));
+				IXGBE_R32_Q(hw, IXGBE_RT2SR(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[849 + i] =
-				IXGBE_READ_REG(hw, IXGBE_TDTQ2TCCR(i));
+				IXGBE_R32_Q(hw, IXGBE_TDTQ2TCCR(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[857 + i] =
-				IXGBE_READ_REG(hw, IXGBE_TDTQ2TCSR(i));
+				IXGBE_R32_Q(hw, IXGBE_TDTQ2TCSR(i));
 		break;
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
-	case ixgbe_mac_X550:
-	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		regs_buff[830] = IXGBE_READ_REG(hw, IXGBE_RTTDCS);
-		regs_buff[832] = IXGBE_READ_REG(hw, IXGBE_RTRPCS);
+		regs_buff[830] = IXGBE_R32_Q(hw, IXGBE_RTTDCS);
+		regs_buff[832] = IXGBE_R32_Q(hw, IXGBE_RTRPCS);
 		for (i = 0; i < 8; i++)
 			regs_buff[833 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RTRPT4C(i));
+				IXGBE_R32_Q(hw, IXGBE_RTRPT4C(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[841 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RTRPT4S(i));
+				IXGBE_R32_Q(hw, IXGBE_RTRPT4S(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[849 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RTTDT2C(i));
+				IXGBE_R32_Q(hw, IXGBE_RTTDT2C(i));
 		for (i = 0; i < 8; i++)
 			regs_buff[857 + i] =
-				IXGBE_READ_REG(hw, IXGBE_RTTDT2S(i));
+				IXGBE_R32_Q(hw, IXGBE_RTTDT2S(i));
 		break;
 	default:
 		break;
@@ -824,10 +1158,10 @@ static void ixgbe_get_regs(struct net_device *netdev,
 
 	for (i = 0; i < 8; i++)
 		regs_buff[865 + i] =
-		IXGBE_READ_REG(hw, IXGBE_TDPT2TCCR(i)); /* same as RTTPT2C */
+		IXGBE_R32_Q(hw, IXGBE_TDPT2TCCR(i)); /* same as RTTPT2C */
 	for (i = 0; i < 8; i++)
 		regs_buff[873 + i] =
-		IXGBE_READ_REG(hw, IXGBE_TDPT2TCSR(i)); /* same as RTTPT2S */
+		IXGBE_R32_Q(hw, IXGBE_TDPT2TCSR(i)); /* same as RTTPT2S */
 
 	/* Statistics */
 	regs_buff[881] = IXGBE_GET_STAT(adapter, crcerrs);
@@ -861,10 +1195,8 @@ static void ixgbe_get_regs(struct net_device *netdev,
 	regs_buff[939] = IXGBE_GET_STAT(adapter, bprc);
 	regs_buff[940] = IXGBE_GET_STAT(adapter, mprc);
 	regs_buff[941] = IXGBE_GET_STAT(adapter, gptc);
-	regs_buff[942] = (u32)IXGBE_GET_STAT(adapter, gorc);
-	regs_buff[943] = (u32)(IXGBE_GET_STAT(adapter, gorc) >> 32);
-	regs_buff[944] = (u32)IXGBE_GET_STAT(adapter, gotc);
-	regs_buff[945] = (u32)(IXGBE_GET_STAT(adapter, gotc) >> 32);
+	regs_buff[942] = IXGBE_GET_STAT(adapter, gorc);
+	regs_buff[944] = IXGBE_GET_STAT(adapter, gotc);
 	for (i = 0; i < 8; i++)
 		regs_buff[946 + i] = IXGBE_GET_STAT(adapter, rnbc[i]);
 	regs_buff[954] = IXGBE_GET_STAT(adapter, ruc);
@@ -874,8 +1206,7 @@ static void ixgbe_get_regs(struct net_device *netdev,
 	regs_buff[958] = IXGBE_GET_STAT(adapter, mngprc);
 	regs_buff[959] = IXGBE_GET_STAT(adapter, mngpdc);
 	regs_buff[960] = IXGBE_GET_STAT(adapter, mngptc);
-	regs_buff[961] = (u32)IXGBE_GET_STAT(adapter, tor);
-	regs_buff[962] = (u32)(IXGBE_GET_STAT(adapter, tor) >> 32);
+	regs_buff[961] = IXGBE_GET_STAT(adapter, tor);
 	regs_buff[963] = IXGBE_GET_STAT(adapter, tpr);
 	regs_buff[964] = IXGBE_GET_STAT(adapter, tpt);
 	regs_buff[965] = IXGBE_GET_STAT(adapter, ptc64);
@@ -897,103 +1228,258 @@ static void ixgbe_get_regs(struct net_device *netdev,
 		regs_buff[1022 + i] = IXGBE_GET_STAT(adapter, qbtc[i]);
 
 	/* MAC */
-	regs_buff[1038] = IXGBE_READ_REG(hw, IXGBE_PCS1GCFIG);
-	regs_buff[1039] = IXGBE_READ_REG(hw, IXGBE_PCS1GLCTL);
-	regs_buff[1040] = IXGBE_READ_REG(hw, IXGBE_PCS1GLSTA);
-	regs_buff[1041] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG0);
-	regs_buff[1042] = IXGBE_READ_REG(hw, IXGBE_PCS1GDBG1);
-	regs_buff[1043] = IXGBE_READ_REG(hw, IXGBE_PCS1GANA);
-	regs_buff[1044] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLP);
-	regs_buff[1045] = IXGBE_READ_REG(hw, IXGBE_PCS1GANNP);
-	regs_buff[1046] = IXGBE_READ_REG(hw, IXGBE_PCS1GANLPNP);
-	regs_buff[1047] = IXGBE_READ_REG(hw, IXGBE_HLREG0);
-	regs_buff[1048] = IXGBE_READ_REG(hw, IXGBE_HLREG1);
-	regs_buff[1049] = IXGBE_READ_REG(hw, IXGBE_PAP);
-	regs_buff[1050] = IXGBE_READ_REG(hw, IXGBE_MACA);
-	regs_buff[1051] = IXGBE_READ_REG(hw, IXGBE_APAE);
-	regs_buff[1052] = IXGBE_READ_REG(hw, IXGBE_ARD);
-	regs_buff[1053] = IXGBE_READ_REG(hw, IXGBE_AIS);
-	regs_buff[1054] = IXGBE_READ_REG(hw, IXGBE_MSCA);
-	regs_buff[1055] = IXGBE_READ_REG(hw, IXGBE_MSRWD);
-	regs_buff[1056] = IXGBE_READ_REG(hw, IXGBE_MLADD);
-	regs_buff[1057] = IXGBE_READ_REG(hw, IXGBE_MHADD);
-	regs_buff[1058] = IXGBE_READ_REG(hw, IXGBE_TREG);
-	regs_buff[1059] = IXGBE_READ_REG(hw, IXGBE_PCSS1);
-	regs_buff[1060] = IXGBE_READ_REG(hw, IXGBE_PCSS2);
-	regs_buff[1061] = IXGBE_READ_REG(hw, IXGBE_XPCSS);
-	regs_buff[1062] = IXGBE_READ_REG(hw, IXGBE_SERDESC);
-	regs_buff[1063] = IXGBE_READ_REG(hw, IXGBE_MACS);
-	regs_buff[1064] = IXGBE_READ_REG(hw, IXGBE_AUTOC);
-	regs_buff[1065] = IXGBE_READ_REG(hw, IXGBE_LINKS);
-	regs_buff[1066] = IXGBE_READ_REG(hw, IXGBE_AUTOC2);
-	regs_buff[1067] = IXGBE_READ_REG(hw, IXGBE_AUTOC3);
-	regs_buff[1068] = IXGBE_READ_REG(hw, IXGBE_ANLP1);
-	regs_buff[1069] = IXGBE_READ_REG(hw, IXGBE_ANLP2);
-	regs_buff[1070] = IXGBE_READ_REG(hw, IXGBE_ATLASCTL);
+	regs_buff[1038] = IXGBE_R32_Q(hw, IXGBE_PCS1GCFIG);
+	regs_buff[1039] = IXGBE_R32_Q(hw, IXGBE_PCS1GLCTL);
+	regs_buff[1040] = IXGBE_R32_Q(hw, IXGBE_PCS1GLSTA);
+	regs_buff[1041] = IXGBE_R32_Q(hw, IXGBE_PCS1GDBG0);
+	regs_buff[1042] = IXGBE_R32_Q(hw, IXGBE_PCS1GDBG1);
+	regs_buff[1043] = IXGBE_R32_Q(hw, IXGBE_PCS1GANA);
+	regs_buff[1044] = IXGBE_R32_Q(hw, IXGBE_PCS1GANLP);
+	regs_buff[1045] = IXGBE_R32_Q(hw, IXGBE_PCS1GANNP);
+	regs_buff[1046] = IXGBE_R32_Q(hw, IXGBE_PCS1GANLPNP);
+	regs_buff[1047] = IXGBE_R32_Q(hw, IXGBE_HLREG0);
+	regs_buff[1048] = IXGBE_R32_Q(hw, IXGBE_HLREG1);
+	regs_buff[1049] = IXGBE_R32_Q(hw, IXGBE_PAP);
+	regs_buff[1050] = IXGBE_R32_Q(hw, IXGBE_MACA);
+	regs_buff[1051] = IXGBE_R32_Q(hw, IXGBE_APAE);
+	regs_buff[1052] = IXGBE_R32_Q(hw, IXGBE_ARD);
+	regs_buff[1053] = IXGBE_R32_Q(hw, IXGBE_AIS);
+	regs_buff[1054] = IXGBE_R32_Q(hw, IXGBE_MSCA);
+	regs_buff[1055] = IXGBE_R32_Q(hw, IXGBE_MSRWD);
+	regs_buff[1056] = IXGBE_R32_Q(hw, IXGBE_MLADD);
+	regs_buff[1057] = IXGBE_R32_Q(hw, IXGBE_MHADD);
+	regs_buff[1058] = IXGBE_R32_Q(hw, IXGBE_TREG);
+	regs_buff[1059] = IXGBE_R32_Q(hw, IXGBE_PCSS1);
+	regs_buff[1060] = IXGBE_R32_Q(hw, IXGBE_PCSS2);
+	regs_buff[1061] = IXGBE_R32_Q(hw, IXGBE_XPCSS);
+	regs_buff[1062] = IXGBE_R32_Q(hw, IXGBE_SERDESC);
+	regs_buff[1063] = IXGBE_R32_Q(hw, IXGBE_MACS);
+	regs_buff[1064] = IXGBE_R32_Q(hw, IXGBE_AUTOC);
+	regs_buff[1065] = IXGBE_R32_Q(hw, IXGBE_LINKS);
+	regs_buff[1066] = IXGBE_R32_Q(hw, IXGBE_AUTOC2);
+	regs_buff[1067] = IXGBE_R32_Q(hw, IXGBE_AUTOC3);
+	regs_buff[1068] = IXGBE_R32_Q(hw, IXGBE_ANLP1);
+	regs_buff[1069] = IXGBE_R32_Q(hw, IXGBE_ANLP2);
+	regs_buff[1070] = IXGBE_R32_Q(hw, IXGBE_ATLASCTL);
 
 	/* Diagnostic */
-	regs_buff[1071] = IXGBE_READ_REG(hw, IXGBE_RDSTATCTL);
-	for (i = 0; i < 8; i++)
-		regs_buff[1072 + i] = IXGBE_READ_REG(hw, IXGBE_RDSTAT(i));
-	regs_buff[1080] = IXGBE_READ_REG(hw, IXGBE_RDHMPN);
-	for (i = 0; i < 4; i++)
-		regs_buff[1081 + i] = IXGBE_READ_REG(hw, IXGBE_RIC_DW(i));
-	regs_buff[1085] = IXGBE_READ_REG(hw, IXGBE_RDPROBE);
-	regs_buff[1086] = IXGBE_READ_REG(hw, IXGBE_TDSTATCTL);
+	regs_buff[1071] = IXGBE_R32_Q(hw, IXGBE_RDSTATCTL);
 	for (i = 0; i < 8; i++)
-		regs_buff[1087 + i] = IXGBE_READ_REG(hw, IXGBE_TDSTAT(i));
-	regs_buff[1095] = IXGBE_READ_REG(hw, IXGBE_TDHMPN);
+		regs_buff[1072 + i] = IXGBE_R32_Q(hw, IXGBE_RDSTAT(i));
+	regs_buff[1080] = IXGBE_R32_Q(hw, IXGBE_RDHMPN);
 	for (i = 0; i < 4; i++)
-		regs_buff[1096 + i] = IXGBE_READ_REG(hw, IXGBE_TIC_DW(i));
-	regs_buff[1100] = IXGBE_READ_REG(hw, IXGBE_TDPROBE);
-	regs_buff[1101] = IXGBE_READ_REG(hw, IXGBE_TXBUFCTRL);
+		regs_buff[1081 + i] = IXGBE_R32_Q(hw, IXGBE_RIC_DW(i));
+	regs_buff[1085] = IXGBE_R32_Q(hw, IXGBE_RDPROBE);
+	regs_buff[1095] = IXGBE_R32_Q(hw, IXGBE_TDHMPN);
 	for (i = 0; i < 4; i++)
-		regs_buff[1102 + i] = IXGBE_READ_REG(hw, IXGBE_TXBUFDATA(i));
-	regs_buff[1106] = IXGBE_READ_REG(hw, IXGBE_RXBUFCTRL);
-	for (i = 0; i < 4; i++)
-		regs_buff[1107 + i] = IXGBE_READ_REG(hw, IXGBE_RXBUFDATA(i));
+		regs_buff[1096 + i] = IXGBE_R32_Q(hw, IXGBE_TIC_DW(i));
+	regs_buff[1100] = IXGBE_R32_Q(hw, IXGBE_TDPROBE);
+	regs_buff[1101] = IXGBE_R32_Q(hw, IXGBE_TXBUFCTRL);
+	regs_buff[1102] = IXGBE_R32_Q(hw, IXGBE_TXBUFDATA0);
+	regs_buff[1103] = IXGBE_R32_Q(hw, IXGBE_TXBUFDATA1);
+	regs_buff[1104] = IXGBE_R32_Q(hw, IXGBE_TXBUFDATA2);
+	regs_buff[1105] = IXGBE_R32_Q(hw, IXGBE_TXBUFDATA3);
+	regs_buff[1106] = IXGBE_R32_Q(hw, IXGBE_RXBUFCTRL);
+	regs_buff[1107] = IXGBE_R32_Q(hw, IXGBE_RXBUFDATA0);
+	regs_buff[1108] = IXGBE_R32_Q(hw, IXGBE_RXBUFDATA1);
+	regs_buff[1109] = IXGBE_R32_Q(hw, IXGBE_RXBUFDATA2);
+	regs_buff[1110] = IXGBE_R32_Q(hw, IXGBE_RXBUFDATA3);
 	for (i = 0; i < 8; i++)
-		regs_buff[1111 + i] = IXGBE_READ_REG(hw, IXGBE_PCIE_DIAG(i));
-	regs_buff[1119] = IXGBE_READ_REG(hw, IXGBE_RFVAL);
-	regs_buff[1120] = IXGBE_READ_REG(hw, IXGBE_MDFTC1);
-	regs_buff[1121] = IXGBE_READ_REG(hw, IXGBE_MDFTC2);
-	regs_buff[1122] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO1);
-	regs_buff[1123] = IXGBE_READ_REG(hw, IXGBE_MDFTFIFO2);
-	regs_buff[1124] = IXGBE_READ_REG(hw, IXGBE_MDFTS);
-	regs_buff[1125] = IXGBE_READ_REG(hw, IXGBE_PCIEECCCTL);
-	regs_buff[1126] = IXGBE_READ_REG(hw, IXGBE_PBTXECC);
-	regs_buff[1127] = IXGBE_READ_REG(hw, IXGBE_PBRXECC);
-
-	/* 82599 X540 specific registers  */
-	regs_buff[1128] = IXGBE_READ_REG(hw, IXGBE_MFLCN);
-
-	/* 82599 X540 specific DCB registers  */
-	regs_buff[1129] = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);
-	regs_buff[1130] = IXGBE_READ_REG(hw, IXGBE_RTTUP2TC);
+		regs_buff[1111 + i] = IXGBE_R32_Q(hw, IXGBE_PCIE_DIAG(i));
+	regs_buff[1119] = IXGBE_R32_Q(hw, IXGBE_RFVAL);
+	regs_buff[1120] = IXGBE_R32_Q(hw, IXGBE_MDFTC1);
+	regs_buff[1121] = IXGBE_R32_Q(hw, IXGBE_MDFTC2);
+	regs_buff[1122] = IXGBE_R32_Q(hw, IXGBE_MDFTFIFO1);
+	regs_buff[1123] = IXGBE_R32_Q(hw, IXGBE_MDFTFIFO2);
+	regs_buff[1124] = IXGBE_R32_Q(hw, IXGBE_MDFTS);
+	regs_buff[1125] = IXGBE_R32_Q(hw, IXGBE_PCIEECCCTL);
+	regs_buff[1126] = IXGBE_R32_Q(hw, IXGBE_PBTXECC);
+	regs_buff[1127] = IXGBE_R32_Q(hw, IXGBE_PBRXECC);
+
+	/* 82599 X540 specific registers */
+	regs_buff[1128] = IXGBE_R32_Q(hw, IXGBE_MFLCN);
+
+	/* 82599 X540 specific DCB registers */
+	regs_buff[1129] = IXGBE_R32_Q(hw, IXGBE_RTRUP2TC);
+	regs_buff[1130] = IXGBE_R32_Q(hw, IXGBE_RTTUP2TC);
 	for (i = 0; i < 4; i++)
-		regs_buff[1131 + i] = IXGBE_READ_REG(hw, IXGBE_TXLLQ(i));
-	regs_buff[1135] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRM);
-					/* same as RTTQCNRM */
-	regs_buff[1136] = IXGBE_READ_REG(hw, IXGBE_RTTBCNRD);
-					/* same as RTTQCNRR */
+		regs_buff[1131 + i] = IXGBE_R32_Q(hw, IXGBE_TXLLQ(i));
+	regs_buff[1135] = IXGBE_R32_Q(hw, IXGBE_RTTBCNRM);
+				     /* same as RTTQCNRM */
+	regs_buff[1136] = IXGBE_R32_Q(hw, IXGBE_RTTBCNRD);
+				     /* same as RTTQCNRR */
 
-	/* X540 specific DCB registers  */
-	regs_buff[1137] = IXGBE_READ_REG(hw, IXGBE_RTTQCNCR);
-	regs_buff[1138] = IXGBE_READ_REG(hw, IXGBE_RTTQCNTG);
+	/* X540 specific DCB registers */
+	regs_buff[1137] = IXGBE_R32_Q(hw, IXGBE_RTTQCNCR);
+	regs_buff[1138] = IXGBE_R32_Q(hw, IXGBE_RTTQCNTG);
 
 	/* Security config registers */
-	regs_buff[1139] = IXGBE_READ_REG(hw, IXGBE_SECTXCTRL);
-	regs_buff[1140] = IXGBE_READ_REG(hw, IXGBE_SECTXSTAT);
-	regs_buff[1141] = IXGBE_READ_REG(hw, IXGBE_SECTXBUFFAF);
-	regs_buff[1142] = IXGBE_READ_REG(hw, IXGBE_SECTXMINIFG);
-	regs_buff[1143] = IXGBE_READ_REG(hw, IXGBE_SECRXCTRL);
-	regs_buff[1144] = IXGBE_READ_REG(hw, IXGBE_SECRXSTAT);
+	regs_buff[1139] = IXGBE_R32_Q(hw, IXGBE_SECTXCTRL);
+	regs_buff[1140] = IXGBE_R32_Q(hw, IXGBE_SECTXSTAT);
+	regs_buff[1141] = IXGBE_R32_Q(hw, IXGBE_SECTXBUFFAF);
+	regs_buff[1142] = IXGBE_R32_Q(hw, IXGBE_SECTXMINIFG);
+	regs_buff[1143] = IXGBE_R32_Q(hw, IXGBE_SECRXCTRL);
+	regs_buff[1144] = IXGBE_R32_Q(hw, IXGBE_SECRXSTAT);
+
 }
 
 static int ixgbe_get_eeprom_len(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	return adapter->hw.eeprom.word_size * 2;
+	return pci_resource_len(adapter->pdev, 0);
+}
+
+static u8 ixgbe_nvmupd_get_module(u32 val)
+{
+	return (u8)(val & IXGBE_NVMUPD_MOD_PNT_MASK);
+}
+
+static int ixgbe_nvmupd_validate_offset(struct ixgbe_adapter *adapter,
+					u32 offset)
+{
+	struct net_device *netdev = adapter->netdev;
+
+	switch (offset) {
+	case IXGBE_STATUS:
+	case IXGBE_ESDP:
+	case IXGBE_MSCA:
+	case IXGBE_MSRWD:
+	case IXGBE_EEC:
+	case IXGBE_FLA:
+	case IXGBE_FLOP:
+	case IXGBE_SWSM:
+	case IXGBE_FWSM:
+	case IXGBE_FACTPS:
+	case IXGBE_GSSR:
+	case IXGBE_HICR:
+	case IXGBE_FWSTS:
+		return 0;
+	default:
+		if ((offset >= IXGBE_MAVTV(0) && offset <= IXGBE_MAVTV(7)) ||
+		    (offset >= IXGBE_RAL(0) && offset <= IXGBE_RAH(15)))
+			return 0;
+	}
+
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82599EB:
+		switch (offset) {
+		case IXGBE_AUTOC:
+		case IXGBE_EERD:
+		case IXGBE_BARCTRL:
+			return 0;
+		default:
+			if (offset >= 0x00020000 &&
+			    offset <= ixgbe_get_eeprom_len(netdev))
+				return 0;
+		}
+		break;
+	case ixgbe_mac_X540:
+		switch (offset) {
+		case IXGBE_EERD:
+		case IXGBE_EEWR:
+		case IXGBE_SRAMREL:
+		case IXGBE_BARCTRL:
+			return 0;
+		default:
+			if ((offset >= 0x00020000 &&
+			     offset <= ixgbe_get_eeprom_len(netdev)))
+				return 0;
+		}
+		break;
+	case ixgbe_mac_X550:
+		switch (offset) {
+		case IXGBE_EEWR:
+		case IXGBE_SRAMREL:
+		case IXGBE_PHYCTL_82599:
+		case IXGBE_FWRESETCNT:
+			return 0;
+		default:
+			if (offset >= IXGBE_FLEX_MNG_PTR(0) &&
+			    offset <= IXGBE_FLEX_MNG_PTR(447))
+				return 0;
+		}
+		break;
+	case ixgbe_mac_X550EM_x:
+		switch (offset) {
+		case IXGBE_PHYCTL_82599:
+		case IXGBE_NW_MNG_IF_SEL:
+		case IXGBE_FWRESETCNT:
+		case IXGBE_I2CCTL_X550:
+			return 0;
+		default:
+			if ((offset >= IXGBE_FLEX_MNG_PTR(0) &&
+			     offset <= IXGBE_FLEX_MNG_PTR(447)) ||
+			    (offset >= IXGBE_FUSES0_GROUP(0) &&
+			     offset <= IXGBE_FUSES0_GROUP(7)))
+				return 0;
+		}
+		break;
+	case ixgbe_mac_X550EM_a:
+		switch (offset) {
+		case IXGBE_PHYCTL_82599:
+		case IXGBE_NW_MNG_IF_SEL:
+		case IXGBE_FWRESETCNT:
+		case IXGBE_I2CCTL_X550:
+		case IXGBE_FLA_X550EM_a:
+		case IXGBE_SWSM_X550EM_a:
+		case IXGBE_FWSM_X550EM_a:
+		case IXGBE_SWFW_SYNC_X550EM_a:
+		case IXGBE_FACTPS_X550EM_a:
+		case IXGBE_EEC_X550EM_a:
+			return 0;
+		default:
+			if (offset >= IXGBE_FLEX_MNG_PTR(0) &&
+			    offset <= IXGBE_FLEX_MNG_PTR(447))
+				return 0;
+		}
+	default:
+		break;
+	}
+
+	return -ENOTTY;
+}
+
+static int ixgbe_nvmupd_command(struct ixgbe_hw *hw,
+				struct ixgbe_nvm_access *nvm,
+				u8 *bytes)
+{
+	u32 command;
+	int ret_val = 0;
+	u8 module;
+
+	command = nvm->command;
+	module = ixgbe_nvmupd_get_module(nvm->config);
+
+	switch (command) {
+	case IXGBE_NVMUPD_CMD_REG_READ:
+		switch (module) {
+		case IXGBE_NVMUPD_EXEC_FEATURES:
+			if (nvm->data_size == hw->nvmupd_features.size)
+				memcpy(bytes, &hw->nvmupd_features,
+				       hw->nvmupd_features.size);
+			else
+				ret_val = -ENOMEM;
+		break;
+		default:
+			if (ixgbe_nvmupd_validate_offset(hw->back, nvm->offset))
+				return -ENOTTY;
+
+			if (nvm->data_size == 1)
+				*((u8 *)bytes) = IXGBE_R8_Q(hw, nvm->offset);
+			else
+				*((u32 *)bytes) = IXGBE_R32_Q(hw, nvm->offset);
+		break;
+		}
+	break;
+	case IXGBE_NVMUPD_CMD_REG_WRITE:
+		if (ixgbe_nvmupd_validate_offset(hw->back, nvm->offset))
+			return -ENOTTY;
+
+		IXGBE_WRITE_REG(hw, nvm->offset, *((u32 *)bytes));
+	break;
+	}
+
+	return ret_val;
 }
 
 static int ixgbe_get_eeprom(struct net_device *netdev,
@@ -1003,24 +1489,34 @@ static int ixgbe_get_eeprom(struct net_device *netdev,
 	struct ixgbe_hw *hw = &adapter->hw;
 	u16 *eeprom_buff;
 	int first_word, last_word, eeprom_len;
+	struct ixgbe_nvm_access *nvm;
+	u32 magic;
 	int ret_val = 0;
 	u16 i;
 
 	if (eeprom->len == 0)
 		return -EINVAL;
 
+	magic = hw->vendor_id | (hw->device_id << 16);
+	if (eeprom->magic && eeprom->magic != magic) {
+		nvm = (struct ixgbe_nvm_access *)eeprom;
+		ret_val = ixgbe_nvmupd_command(hw, nvm, bytes);
+		return ret_val;
+	}
+
+	/* normal ethtool get_eeprom support */
 	eeprom->magic = hw->vendor_id | (hw->device_id << 16);
 
 	first_word = eeprom->offset >> 1;
 	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
 	eeprom_len = last_word - first_word + 1;
 
-	eeprom_buff = kmalloc_array(eeprom_len, sizeof(u16), GFP_KERNEL);
+	eeprom_buff = kmalloc(sizeof(u16) * eeprom_len, GFP_KERNEL);
 	if (!eeprom_buff)
 		return -ENOMEM;
 
 	ret_val = hw->eeprom.ops.read_buffer(hw, first_word, eeprom_len,
-					     eeprom_buff);
+					   eeprom_buff);
 
 	/* Device's eeprom is always little-endian, word addressable */
 	for (i = 0; i < eeprom_len; i++)
@@ -1037,14 +1533,24 @@ static int ixgbe_set_eeprom(struct net_device *netdev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
-	u16 *eeprom_buff;
-	void *ptr;
 	int max_len, first_word, last_word, ret_val = 0;
-	u16 i;
+	struct ixgbe_nvm_access *nvm;
+	u32 magic;
+	u16 *eeprom_buff, i;
+	void *ptr;
 
 	if (eeprom->len == 0)
 		return -EINVAL;
 
+	magic = hw->vendor_id | (hw->device_id << 16);
+	if (eeprom->magic && eeprom->magic != magic) {
+		nvm = (struct ixgbe_nvm_access *)eeprom;
+		ret_val = ixgbe_nvmupd_command(hw, nvm, bytes);
+		return ret_val;
+	}
+
+	/* normal ethtool set_eeprom support */
+
 	if (eeprom->magic != (hw->vendor_id | (hw->device_id << 16)))
 		return -EINVAL;
 
@@ -1069,7 +1575,7 @@ static int ixgbe_set_eeprom(struct net_device *netdev,
 
 		ptr++;
 	}
-	if ((eeprom->offset + eeprom->len) & 1) {
+	if (((eeprom->offset + eeprom->len) & 1) && (ret_val == 0)) {
 		/*
 		 * need read/modify/write of last changed EEPROM word
 		 * only the first byte of the word is being modified
@@ -1090,8 +1596,8 @@ static int ixgbe_set_eeprom(struct net_device *netdev,
 		cpu_to_le16s(&eeprom_buff[i]);
 
 	ret_val = hw->eeprom.ops.write_buffer(hw, first_word,
-					      last_word - first_word + 1,
-					      eeprom_buff);
+					    last_word - first_word + 1,
+					    eeprom_buff);
 
 	/* Update the checksum */
 	if (ret_val == 0)
@@ -1107,28 +1613,34 @@ static void ixgbe_get_drvinfo(struct net_device *netdev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
-	strlcpy(drvinfo->driver, ixgbe_driver_name, sizeof(drvinfo->driver));
+	strlcpy(drvinfo->driver, ixgbe_driver_name,
+		sizeof(drvinfo->driver));
+	strlcpy(drvinfo->version, ixgbe_driver_version,
+		sizeof(drvinfo->version));
 
 	strlcpy(drvinfo->fw_version, adapter->eeprom_id,
 		sizeof(drvinfo->fw_version));
-
 	strlcpy(drvinfo->bus_info, pci_name(adapter->pdev),
 		sizeof(drvinfo->bus_info));
+#ifdef HAVE_ETHTOOL_GET_SSET_COUNT
 
 	drvinfo->n_priv_flags = IXGBE_PRIV_FLAGS_STR_LEN;
+#endif
 }
 
 static void ixgbe_get_ringparam(struct net_device *netdev,
 				struct ethtool_ringparam *ring)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_ring *tx_ring = adapter->tx_ring[0];
-	struct ixgbe_ring *rx_ring = adapter->rx_ring[0];
 
 	ring->rx_max_pending = IXGBE_MAX_RXD;
 	ring->tx_max_pending = IXGBE_MAX_TXD;
-	ring->rx_pending = rx_ring->count;
-	ring->tx_pending = tx_ring->count;
+	ring->rx_mini_max_pending = 0;
+	ring->rx_jumbo_max_pending = 0;
+	ring->rx_pending = adapter->rx_ring_count;
+	ring->tx_pending = adapter->tx_ring_count;
+	ring->rx_mini_pending = 0;
+	ring->rx_jumbo_pending = 0;
 }
 
 static int ixgbe_set_ringparam(struct net_device *netdev,
@@ -1175,7 +1687,7 @@ static int ixgbe_set_ringparam(struct net_device *netdev,
 	/* allocate temporary buffer to store rings in */
 	i = max_t(int, adapter->num_tx_queues + adapter->num_xdp_queues,
 		  adapter->num_rx_queues);
-	temp_ring = vmalloc(array_size(i, sizeof(struct ixgbe_ring)));
+	temp_ring = vmalloc(i * sizeof(struct ixgbe_ring));
 
 	if (!temp_ring) {
 		err = -ENOMEM;
@@ -1242,10 +1754,12 @@ static int ixgbe_set_ringparam(struct net_device *netdev,
 		for (i = 0; i < adapter->num_rx_queues; i++) {
 			memcpy(&temp_ring[i], adapter->rx_ring[i],
 			       sizeof(struct ixgbe_ring));
+#ifdef HAVE_XDP_BUFF_RXQ
 
 			/* Clear copied XDP RX-queue info */
 			memset(&temp_ring[i].xdp_rxq, 0,
 			       sizeof(temp_ring[i].xdp_rxq));
+#endif
 
 			temp_ring[i].count = new_rx_count;
 			err = ixgbe_setup_rx_resources(adapter, &temp_ring[i]);
@@ -1256,9 +1770,9 @@ static int ixgbe_set_ringparam(struct net_device *netdev,
 				}
 				goto err_setup;
 			}
-
 		}
 
+
 		for (i = 0; i < adapter->num_rx_queues; i++) {
 			ixgbe_free_rx_resources(adapter->rx_ring[i]);
 
@@ -1277,8 +1791,21 @@ static int ixgbe_set_ringparam(struct net_device *netdev,
 	return err;
 }
 
+#ifndef HAVE_ETHTOOL_GET_SSET_COUNT
+static int ixgbe_get_stats_count(struct net_device *netdev)
+{
+	return IXGBE_STATS_LEN;
+}
+
+#else /* HAVE_ETHTOOL_GET_SSET_COUNT */
 static int ixgbe_get_sset_count(struct net_device *netdev, int sset)
 {
+#ifdef HAVE_TX_MQ
+#ifndef HAVE_NETDEV_SELECT_QUEUE
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#endif
+#endif
+
 	switch (sset) {
 	case ETH_SS_TEST:
 		return IXGBE_TEST_LEN;
@@ -1291,70 +1818,97 @@ static int ixgbe_get_sset_count(struct net_device *netdev, int sset)
 	}
 }
 
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
 static void ixgbe_get_ethtool_stats(struct net_device *netdev,
-				    struct ethtool_stats *stats, u64 *data)
+				    struct ethtool_stats __always_unused *stats, u64 *data)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct rtnl_link_stats64 temp;
-	const struct rtnl_link_stats64 *net_stats;
+#ifdef HAVE_NETDEV_STATS_IN_NETDEV
+	struct net_device_stats *net_stats = &netdev->stats;
+#else
+	struct net_device_stats *net_stats = &adapter->net_stats;
+#endif
+	u64 *queue_stat;
+	int stat_count, k;
+#ifdef HAVE_NDO_GET_STATS64
 	unsigned int start;
+#endif
 	struct ixgbe_ring *ring;
 	int i, j;
-	char *p = NULL;
+	char *p;
 
 	ixgbe_update_stats(adapter);
-	net_stats = dev_get_stats(netdev, &temp);
-	for (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {
-		switch (ixgbe_gstrings_stats[i].type) {
-		case NETDEV_STATS:
-			p = (char *) net_stats +
-					ixgbe_gstrings_stats[i].stat_offset;
-			break;
-		case IXGBE_STATS:
-			p = (char *) adapter +
-					ixgbe_gstrings_stats[i].stat_offset;
-			break;
-		default:
-			data[i] = 0;
-			continue;
-		}
 
-		data[i] = (ixgbe_gstrings_stats[i].sizeof_stat ==
+	for (i = 0; i < IXGBE_NETDEV_STATS_LEN; i++) {
+		p = (char *)net_stats + ixgbe_gstrings_net_stats[i].stat_offset;
+		data[i] = (ixgbe_gstrings_net_stats[i].sizeof_stat ==
+			sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
+	}
+	for (j = 0; j < IXGBE_GLOBAL_STATS_LEN; j++, i++) {
+		p = (char *)adapter + ixgbe_gstrings_stats[j].stat_offset;
+		data[i] = (ixgbe_gstrings_stats[j].sizeof_stat ==
 			   sizeof(u64)) ? *(u64 *)p : *(u32 *)p;
 	}
-	for (j = 0; j < netdev->num_tx_queues; j++) {
+	for (j = 0; j < IXGBE_NUM_TX_QUEUES; j++) {
 		ring = adapter->tx_ring[j];
 		if (!ring) {
-			data[i] = 0;
-			data[i+1] = 0;
-			i += 2;
+			data[i++] = 0;
+			data[i++] = 0;
+#ifdef BP_EXTENDED_STATS
+			data[i++] = 0;
+			data[i++] = 0;
+			data[i++] = 0;
+#endif
 			continue;
 		}
 
+#ifdef HAVE_NDO_GET_STATS64
 		do {
 			start = u64_stats_fetch_begin_irq(&ring->syncp);
+#endif
 			data[i]   = ring->stats.packets;
 			data[i+1] = ring->stats.bytes;
+#ifdef HAVE_NDO_GET_STATS64
 		} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
+#endif
 		i += 2;
+#ifdef BP_EXTENDED_STATS
+		data[i] = ring->stats.yields;
+		data[i+1] = ring->stats.misses;
+		data[i+2] = ring->stats.cleaned;
+		i += 3;
+#endif
 	}
 	for (j = 0; j < IXGBE_NUM_RX_QUEUES; j++) {
 		ring = adapter->rx_ring[j];
 		if (!ring) {
-			data[i] = 0;
-			data[i+1] = 0;
-			i += 2;
+			data[i++] = 0;
+			data[i++] = 0;
+#ifdef BP_EXTENDED_STATS
+			data[i++] = 0;
+			data[i++] = 0;
+			data[i++] = 0;
+#endif
 			continue;
 		}
 
+#ifdef HAVE_NDO_GET_STATS64
 		do {
 			start = u64_stats_fetch_begin_irq(&ring->syncp);
+#endif
 			data[i]   = ring->stats.packets;
 			data[i+1] = ring->stats.bytes;
+#ifdef HAVE_NDO_GET_STATS64
 		} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
+#endif
 		i += 2;
+#ifdef BP_EXTENDED_STATS
+		data[i] = ring->stats.yields;
+		data[i+1] = ring->stats.misses;
+		data[i+2] = ring->stats.cleaned;
+		i += 3;
+#endif
 	}
-
 	for (j = 0; j < IXGBE_MAX_PACKET_BUFFERS; j++) {
 		data[i++] = adapter->stats.pxontxc[j];
 		data[i++] = adapter->stats.pxofftxc[j];
@@ -1363,56 +1917,111 @@ static void ixgbe_get_ethtool_stats(struct net_device *netdev,
 		data[i++] = adapter->stats.pxonrxc[j];
 		data[i++] = adapter->stats.pxoffrxc[j];
 	}
+	stat_count = sizeof(struct vf_stats) / sizeof(u64);
+	for (j = 0; j < adapter->num_vfs; j++) {
+		queue_stat = (u64 *)&adapter->vfinfo[j].vfstats;
+		for (k = 0; k < stat_count; k++)
+			data[i + k] = queue_stat[k];
+		queue_stat = (u64 *)&adapter->vfinfo[j].saved_rst_vfstats;
+		for (k = 0; k < stat_count; k++)
+			data[i + k] += queue_stat[k];
+		i += k;
+	}
 }
 
 static void ixgbe_get_strings(struct net_device *netdev, u32 stringset,
 			      u8 *data)
 {
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	char *p = (char *)data;
 	unsigned int i;
 
 	switch (stringset) {
 	case ETH_SS_TEST:
-		for (i = 0; i < IXGBE_TEST_LEN; i++) {
-			memcpy(data, ixgbe_gstrings_test[i], ETH_GSTRING_LEN);
-			data += ETH_GSTRING_LEN;
-		}
+		memcpy(data, *ixgbe_gstrings_test,
+		       IXGBE_TEST_LEN * ETH_GSTRING_LEN);
 		break;
 	case ETH_SS_STATS:
+		for (i = 0; i < IXGBE_NETDEV_STATS_LEN; i++) {
+			memcpy(p, ixgbe_gstrings_net_stats[i].stat_string,
+			       ETH_GSTRING_LEN);
+			p += ETH_GSTRING_LEN;
+		}
 		for (i = 0; i < IXGBE_GLOBAL_STATS_LEN; i++) {
 			memcpy(p, ixgbe_gstrings_stats[i].stat_string,
 			       ETH_GSTRING_LEN);
 			p += ETH_GSTRING_LEN;
 		}
-		for (i = 0; i < netdev->num_tx_queues; i++) {
-			sprintf(p, "tx_queue_%u_packets", i);
+		for (i = 0; i < IXGBE_NUM_TX_QUEUES; i++) {
+			snprintf(p, ETH_GSTRING_LEN,
+				 "tx_queue_%u_packets", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "tx_queue_%u_bytes", i);
+			p += ETH_GSTRING_LEN;
+#ifdef BP_EXTENDED_STATS
+			snprintf(p, ETH_GSTRING_LEN,
+				 "tx_queue_%u_bp_napi_yield", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "tx_queue_%u_bp_misses", i);
 			p += ETH_GSTRING_LEN;
-			sprintf(p, "tx_queue_%u_bytes", i);
+			snprintf(p, ETH_GSTRING_LEN,
+				 "tx_queue_%u_bp_cleaned", i);
 			p += ETH_GSTRING_LEN;
+#endif /* BP_EXTENDED_STATS */
 		}
 		for (i = 0; i < IXGBE_NUM_RX_QUEUES; i++) {
-			sprintf(p, "rx_queue_%u_packets", i);
+			snprintf(p, ETH_GSTRING_LEN,
+				 "rx_queue_%u_packets", i);
 			p += ETH_GSTRING_LEN;
-			sprintf(p, "rx_queue_%u_bytes", i);
+			snprintf(p, ETH_GSTRING_LEN,
+				 "rx_queue_%u_bytes", i);
 			p += ETH_GSTRING_LEN;
+#ifdef BP_EXTENDED_STATS
+			snprintf(p, ETH_GSTRING_LEN,
+				 "rx_queue_%u_bp_poll_yield", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "rx_queue_%u_bp_misses", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN,
+				 "rx_queue_%u_bp_cleaned", i);
+			p += ETH_GSTRING_LEN;
+#endif /* BP_EXTENDED_STATS */
 		}
 		for (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {
-			sprintf(p, "tx_pb_%u_pxon", i);
+			snprintf(p, ETH_GSTRING_LEN, "tx_pb_%u_pxon", i);
 			p += ETH_GSTRING_LEN;
-			sprintf(p, "tx_pb_%u_pxoff", i);
+			snprintf(p, ETH_GSTRING_LEN, "tx_pb_%u_pxoff", i);
 			p += ETH_GSTRING_LEN;
 		}
 		for (i = 0; i < IXGBE_MAX_PACKET_BUFFERS; i++) {
-			sprintf(p, "rx_pb_%u_pxon", i);
+			snprintf(p, ETH_GSTRING_LEN, "rx_pb_%u_pxon", i);
 			p += ETH_GSTRING_LEN;
-			sprintf(p, "rx_pb_%u_pxoff", i);
+			snprintf(p, ETH_GSTRING_LEN, "rx_pb_%u_pxoff", i);
+			p += ETH_GSTRING_LEN;
+		}
+		for (i = 0; i < adapter->num_vfs; i++) {
+			snprintf(p, ETH_GSTRING_LEN, "VF %u Rx Packets", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN, "VF %u Rx Bytes", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN, "VF %u Tx Packets", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN, "VF %u Tx Bytes", i);
+			p += ETH_GSTRING_LEN;
+			snprintf(p, ETH_GSTRING_LEN, "VF %u MC Packets", i);
 			p += ETH_GSTRING_LEN;
 		}
 		/* BUG_ON(p - data != IXGBE_STATS_LEN * ETH_GSTRING_LEN); */
 		break;
+#ifdef HAVE_ETHTOOL_GET_SSET_COUNT
 	case ETH_SS_PRIV_FLAGS:
 		memcpy(data, ixgbe_priv_flags_strings,
 		       IXGBE_PRIV_FLAGS_STR_LEN * ETH_GSTRING_LEN);
+		break;
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
 	}
 }
 
@@ -1422,13 +2031,12 @@ static int ixgbe_link_test(struct ixgbe_adapter *adapter, u64 *data)
 	bool link_up;
 	u32 link_speed = 0;
 
-	if (ixgbe_removed(hw->hw_addr)) {
+	if (IXGBE_REMOVED(hw->hw_addr)) {
 		*data = 1;
 		return 1;
 	}
 	*data = 0;
-
-	hw->mac.ops.check_link(hw, &link_speed, &link_up, true);
+       hw->mac.ops.check_link(hw, &link_speed, &link_up, true);
 	if (link_up)
 		return *data;
 	else
@@ -1463,7 +2071,7 @@ struct ixgbe_reg_test {
 #define TABLE64_TEST_HI	6
 
 /* default 82599 register test */
-static const struct ixgbe_reg_test reg_test_82599[] = {
+static struct ixgbe_reg_test reg_test_82599[] = {
 	{ IXGBE_FCRTL_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
 	{ IXGBE_FCRTH_82599(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
 	{ IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
@@ -1487,7 +2095,7 @@ static const struct ixgbe_reg_test reg_test_82599[] = {
 };
 
 /* default 82598 register test */
-static const struct ixgbe_reg_test reg_test_82598[] = {
+static struct ixgbe_reg_test reg_test_82598[] = {
 	{ IXGBE_FCRTL(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
 	{ IXGBE_FCRTH(0), 1, PATTERN_TEST, 0x8007FFF0, 0x8007FFF0 },
 	{ IXGBE_PFCTOP, 1, PATTERN_TEST, 0xFFFFFFFF, 0xFFFFFFFF },
@@ -1514,29 +2122,32 @@ static const struct ixgbe_reg_test reg_test_82598[] = {
 	{ .reg = 0 }
 };
 
+
 static bool reg_pattern_test(struct ixgbe_adapter *adapter, u64 *data, int reg,
 			     u32 mask, u32 write)
 {
 	u32 pat, val, before;
 	static const u32 test_pattern[] = {
-		0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF};
+		0x5A5A5A5A, 0xA5A5A5A5, 0x00000000, 0xFFFFFFFF
+	};
 
-	if (ixgbe_removed(adapter->hw.hw_addr)) {
+	if (IXGBE_REMOVED(adapter->hw.hw_addr)) {
 		*data = 1;
 		return true;
 	}
 	for (pat = 0; pat < ARRAY_SIZE(test_pattern); pat++) {
-		before = ixgbe_read_reg(&adapter->hw, reg);
-		ixgbe_write_reg(&adapter->hw, reg, test_pattern[pat] & write);
-		val = ixgbe_read_reg(&adapter->hw, reg);
+		before = IXGBE_READ_REG(&adapter->hw, reg);
+		IXGBE_WRITE_REG(&adapter->hw, reg, test_pattern[pat] & write);
+		val = IXGBE_READ_REG(&adapter->hw, reg);
 		if (val != (test_pattern[pat] & write & mask)) {
-			e_err(drv, "pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",
-			      reg, val, (test_pattern[pat] & write & mask));
+			e_err(drv,
+			      "pattern test reg %04X failed: got 0x%08X expected 0x%08X\n",
+			      reg, val, test_pattern[pat] & write & mask);
 			*data = reg;
-			ixgbe_write_reg(&adapter->hw, reg, before);
+			IXGBE_WRITE_REG(&adapter->hw, reg, before);
 			return true;
 		}
-		ixgbe_write_reg(&adapter->hw, reg, before);
+		IXGBE_WRITE_REG(&adapter->hw, reg, before);
 	}
 	return false;
 }
@@ -1546,36 +2157,38 @@ static bool reg_set_and_check(struct ixgbe_adapter *adapter, u64 *data, int reg,
 {
 	u32 val, before;
 
-	if (ixgbe_removed(adapter->hw.hw_addr)) {
+	if (IXGBE_REMOVED(adapter->hw.hw_addr)) {
 		*data = 1;
 		return true;
 	}
-	before = ixgbe_read_reg(&adapter->hw, reg);
-	ixgbe_write_reg(&adapter->hw, reg, write & mask);
-	val = ixgbe_read_reg(&adapter->hw, reg);
+	before = IXGBE_READ_REG(&adapter->hw, reg);
+	IXGBE_WRITE_REG(&adapter->hw, reg, write & mask);
+	val = IXGBE_READ_REG(&adapter->hw, reg);
 	if ((write & mask) != (val & mask)) {
-		e_err(drv, "set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",
+		e_err(drv,
+		      "set/check reg %04X test failed: got 0x%08X expected 0x%08X\n",
 		      reg, (val & mask), (write & mask));
 		*data = reg;
-		ixgbe_write_reg(&adapter->hw, reg, before);
+		IXGBE_WRITE_REG(&adapter->hw, reg, before);
 		return true;
 	}
-	ixgbe_write_reg(&adapter->hw, reg, before);
+	IXGBE_WRITE_REG(&adapter->hw, reg, before);
 	return false;
 }
 
-static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
+static bool ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
 {
-	const struct ixgbe_reg_test *test;
+	struct ixgbe_reg_test *test;
+	struct ixgbe_hw *hw = &adapter->hw;
 	u32 value, before, after;
 	u32 i, toggle;
 
-	if (ixgbe_removed(adapter->hw.hw_addr)) {
+	if (IXGBE_REMOVED(hw->hw_addr)) {
 		e_err(drv, "Adapter removed - register test blocked\n");
 		*data = 1;
-		return 1;
+		return true;
 	}
-	switch (adapter->hw.mac.type) {
+	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
 		toggle = 0x7FFFF3FF;
 		test = reg_test_82598;
@@ -1584,13 +2197,13 @@ static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		toggle = 0x7FFFF30F;
 		test = reg_test_82599;
 		break;
 	default:
 		*data = 1;
-		return 1;
+		return true;
 	}
 
 	/*
@@ -1599,18 +2212,19 @@ static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
 	 * tests.  Some bits are read-only, some toggle, and some
 	 * are writeable on newer MACs.
 	 */
-	before = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS);
-	value = (ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle);
-	ixgbe_write_reg(&adapter->hw, IXGBE_STATUS, toggle);
-	after = ixgbe_read_reg(&adapter->hw, IXGBE_STATUS) & toggle;
+	before = IXGBE_READ_REG(hw, IXGBE_STATUS);
+	value = IXGBE_READ_REG(hw, IXGBE_STATUS) & toggle;
+	IXGBE_WRITE_REG(hw, IXGBE_STATUS, toggle);
+	after = IXGBE_READ_REG(hw, IXGBE_STATUS) & toggle;
 	if (value != after) {
-		e_err(drv, "failed STATUS register test got: 0x%08X expected: 0x%08X\n",
+		e_err(drv,
+		      "failed STATUS register test got: 0x%08X expected: 0x%08X\n",
 		      after, value);
 		*data = 1;
-		return 1;
+		return true;
 	}
 	/* restore previous status */
-	ixgbe_write_reg(&adapter->hw, IXGBE_STATUS, before);
+	IXGBE_WRITE_REG(hw, IXGBE_STATUS, before);
 
 	/*
 	 * Perform the remainder of the register test, looping through
@@ -1623,61 +2237,63 @@ static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
 			switch (test->test_type) {
 			case PATTERN_TEST:
 				b = reg_pattern_test(adapter, data,
-						     test->reg + (i * 0x40),
-						     test->mask,
-						     test->write);
-				break;
-			case SET_READ_TEST:
-				b = reg_set_and_check(adapter, data,
 						      test->reg + (i * 0x40),
 						      test->mask,
 						      test->write);
 				break;
+			case SET_READ_TEST:
+				b = reg_set_and_check(adapter, data,
+						       test->reg + (i * 0x40),
+						       test->mask,
+						       test->write);
+				break;
 			case WRITE_NO_TEST:
-				ixgbe_write_reg(&adapter->hw,
-						test->reg + (i * 0x40),
+				IXGBE_WRITE_REG(hw, test->reg + (i * 0x40),
 						test->write);
 				break;
 			case TABLE32_TEST:
 				b = reg_pattern_test(adapter, data,
-						     test->reg + (i * 4),
-						     test->mask,
-						     test->write);
+						      test->reg + (i * 4),
+						      test->mask,
+						      test->write);
 				break;
 			case TABLE64_TEST_LO:
 				b = reg_pattern_test(adapter, data,
-						     test->reg + (i * 8),
-						     test->mask,
-						     test->write);
+						      test->reg + (i * 8),
+						      test->mask,
+						      test->write);
 				break;
 			case TABLE64_TEST_HI:
 				b = reg_pattern_test(adapter, data,
-						     (test->reg + 4) + (i * 8),
-						     test->mask,
-						     test->write);
+						      (test->reg + 4) + (i * 8),
+						      test->mask,
+						      test->write);
 				break;
 			}
 			if (b)
-				return 1;
+				return true;
 		}
 		test++;
 	}
 
 	*data = 0;
-	return 0;
+	return false;
 }
 
-static int ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)
+static bool ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	if (hw->eeprom.ops.validate_checksum(hw, NULL))
+
+	if (hw->eeprom.ops.validate_checksum(hw, NULL)) {
 		*data = 1;
-	else
+		return true;
+	} else {
 		*data = 0;
-	return *data;
+		return false;
+	}
 }
 
-static irqreturn_t ixgbe_test_intr(int irq, void *data)
+static irqreturn_t ixgbe_test_intr(int __always_unused irq, void *data)
 {
 	struct net_device *netdev = (struct net_device *) data;
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
@@ -1693,6 +2309,10 @@ static int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)
 	u32 mask, i = 0, shared_int = true;
 	u32 irq = adapter->pdev->irq;
 
+	if (IXGBE_REMOVED(adapter->hw.hw_addr)) {
+		*data = 1;
+		return -1;
+	}
 	*data = 0;
 
 	/* Hook up test interrupt handler just for this test */
@@ -1701,21 +2321,21 @@ static int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)
 		return 0;
 	} else if (adapter->flags & IXGBE_FLAG_MSI_ENABLED) {
 		shared_int = false;
-		if (request_irq(irq, ixgbe_test_intr, 0, netdev->name,
+		if (request_irq(irq, &ixgbe_test_intr, 0, netdev->name,
 				netdev)) {
 			*data = 1;
 			return -1;
 		}
-	} else if (!request_irq(irq, ixgbe_test_intr, IRQF_PROBE_SHARED,
+	} else if (!request_irq(irq, &ixgbe_test_intr, IRQF_PROBE_SHARED,
 				netdev->name, netdev)) {
 		shared_int = false;
-	} else if (request_irq(irq, ixgbe_test_intr, IRQF_SHARED,
+	} else if (request_irq(irq, &ixgbe_test_intr, IRQF_SHARED,
 			       netdev->name, netdev)) {
 		*data = 1;
 		return -1;
 	}
-	e_info(hw, "testing %s interrupt\n", shared_int ?
-	       "shared" : "unshared");
+	e_info(hw, "testing %s interrupt\n",
+	       (shared_int ? "shared" : "unshared"));
 
 	/* Disable all the interrupts */
 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFFFFFF);
@@ -1725,7 +2345,7 @@ static int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)
 	/* Test each interrupt */
 	for (; i < 10; i++) {
 		/* Interrupt to test */
-		mask = BIT(i);
+		mask = 1 << i;
 
 		if (!shared_int) {
 			/*
@@ -1809,10 +2429,10 @@ static void ixgbe_free_desc_rings(struct ixgbe_adapter *adapter)
 	 */
 
 	/* first Rx */
-	ixgbe_disable_rx(adapter);
+	ixgbe_disable_rx_queue(adapter);
 
 	/* now Tx */
-	ixgbe_disable_tx(adapter);
+	ixgbe_disable_tx_queue(adapter);
 
 	ixgbe_reset(adapter);
 
@@ -1824,7 +2444,6 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_ring *tx_ring = &adapter->test_tx_ring;
 	struct ixgbe_ring *rx_ring = &adapter->test_rx_ring;
-	struct ixgbe_hw *hw = &adapter->hw;
 	u32 rctl, reg_data;
 	int ret_val;
 	int err;
@@ -1832,7 +2451,7 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 	/* Setup Tx descriptor ring and Tx buffers */
 	tx_ring->count = IXGBE_DEFAULT_TXD;
 	tx_ring->queue_index = 0;
-	tx_ring->dev = &adapter->pdev->dev;
+	tx_ring->dev = pci_dev_to_dev(adapter->pdev);
 	tx_ring->netdev = adapter->netdev;
 	tx_ring->reg_idx = adapter->tx_ring[0]->reg_idx;
 
@@ -1845,7 +2464,7 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		reg_data = IXGBE_READ_REG(&adapter->hw, IXGBE_DMATXCTL);
 		reg_data |= IXGBE_DMATXCTL_TE;
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_DMATXCTL, reg_data);
@@ -1859,9 +2478,12 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 	/* Setup Rx Descriptor ring and Rx buffers */
 	rx_ring->count = IXGBE_DEFAULT_RXD;
 	rx_ring->queue_index = 0;
-	rx_ring->dev = &adapter->pdev->dev;
+	rx_ring->dev = pci_dev_to_dev(adapter->pdev);
 	rx_ring->netdev = adapter->netdev;
 	rx_ring->reg_idx = adapter->rx_ring[0]->reg_idx;
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	rx_ring->rx_buf_len = IXGBE_RXBUFFER_2K;
+#endif
 
 	err = ixgbe_setup_rx_resources(adapter, rx_ring);
 	if (err) {
@@ -1869,15 +2491,14 @@ static int ixgbe_setup_desc_rings(struct ixgbe_adapter *adapter)
 		goto err_nomem;
 	}
 
-	hw->mac.ops.disable_rx(hw);
+	ixgbe_disable_rx(&adapter->hw);
 
 	ixgbe_configure_rx_ring(adapter, rx_ring);
 
-	rctl = IXGBE_READ_REG(&adapter->hw, IXGBE_RXCTRL);
+	rctl = IXGBE_READ_REG(&adapter->hw, IXGBE_RXCTRL); 
 	rctl |= IXGBE_RXCTRL_DMBYPS;
 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_RXCTRL, rctl);
-
-	hw->mac.ops.enable_rx(hw);
+	ixgbe_enable_rx(&adapter->hw);
 
 	return 0;
 
@@ -1901,12 +2522,12 @@ static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)
 	reg_data |= IXGBE_FCTRL_BAM | IXGBE_FCTRL_SBP | IXGBE_FCTRL_MPE;
 	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, reg_data);
 
-	/* X540 and X550 needs to set the MACC.FLU bit to force link up */
+	/* X540 needs to set the MACC.FLU bit to force link up */
 	switch (adapter->hw.mac.type) {
-	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
+	case ixgbe_mac_X540:
 		reg_data = IXGBE_READ_REG(hw, IXGBE_MACC);
 		reg_data |= IXGBE_MACC_FLU;
 		IXGBE_WRITE_REG(hw, IXGBE_MACC, reg_data);
@@ -1961,8 +2582,8 @@ static void ixgbe_create_lbtest_frame(struct sk_buff *skb,
 	memset(skb->data, 0xFF, frame_size);
 	frame_size >>= 1;
 	memset(&skb->data[frame_size], 0xAA, frame_size / 2 - 1);
-	skb->data[frame_size + 10] = 0xBE;
-	skb->data[frame_size + 12] = 0xAF;
+	memset(&skb->data[frame_size + 10], 0xBE, 1);
+	memset(&skb->data[frame_size + 12], 0xAF, 1);
 }
 
 static bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer,
@@ -1973,15 +2594,21 @@ static bool ixgbe_check_lbtest_frame(struct ixgbe_rx_buffer *rx_buffer,
 
 	frame_size >>= 1;
 
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	data = rx_buffer->skb->data;
+#else
 	data = kmap(rx_buffer->page) + rx_buffer->page_offset;
+#endif
 
 	if (data[3] != 0xFF ||
 	    data[frame_size + 10] != 0xBE ||
 	    data[frame_size + 12] != 0xAF)
 		match = false;
 
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	kunmap(rx_buffer->page);
 
+#endif
 	return match;
 }
 
@@ -1990,6 +2617,11 @@ static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,
 				  unsigned int size)
 {
 	union ixgbe_adv_rx_desc *rx_desc;
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	const int bufsz = rx_ring->rx_buf_len;
+#else
+	const int bufsz = ixgbe_rx_bufsz(rx_ring);
+#endif
 	u16 rx_ntc, tx_ntc, count = 0;
 
 	/* initialize next to clean and descriptor values */
@@ -2035,7 +2667,7 @@ static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,
 		/* sync Rx buffer for CPU read */
 		dma_sync_single_for_cpu(rx_ring->dev,
 					rx_buffer->dma,
-					ixgbe_rx_bufsz(rx_ring),
+					bufsz,
 					DMA_FROM_DEVICE);
 
 		/* verify contents of skb */
@@ -2047,7 +2679,7 @@ static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,
 		/* sync Rx buffer for device write */
 		dma_sync_single_for_device(rx_ring->dev,
 					   rx_buffer->dma,
-					   ixgbe_rx_bufsz(rx_ring),
+					   bufsz,
 					   DMA_FROM_DEVICE);
 
 		/* increment Rx next to clean counter */
@@ -2059,8 +2691,6 @@ static u16 ixgbe_clean_test_rings(struct ixgbe_ring *rx_ring,
 		rx_desc = IXGBE_RX_DESC(rx_ring, rx_ntc);
 	}
 
-	netdev_tx_reset_queue(txring_txq(tx_ring));
-
 	/* re-map buffers to ring, store next to clean values */
 	ixgbe_alloc_rx_buffers(rx_ring, count);
 	rx_ring->next_to_clean = rx_ntc;
@@ -2073,7 +2703,7 @@ static int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_ring *tx_ring = &adapter->test_tx_ring;
 	struct ixgbe_ring *rx_ring = &adapter->test_rx_ring;
-	int i, j, lc, good_cnt, ret_val = 0;
+	int i, j, lc, ret_val = 0;
 	unsigned int size = 1024;
 	netdev_tx_t tx_ret_val;
 	struct sk_buff *skb;
@@ -2103,6 +2733,8 @@ static int ixgbe_run_loopback_test(struct ixgbe_adapter *adapter)
 		lc = ((rx_ring->count / 64) * 2) + 1;
 
 	for (j = 0; j <= lc; j++) {
+		unsigned int good_cnt;
+
 		/* reset count of good packets */
 		good_cnt = 0;
 
@@ -2155,13 +2787,21 @@ static int ixgbe_loopback_test(struct ixgbe_adapter *adapter, u64 *data)
 	return *data;
 }
 
+#ifndef HAVE_ETHTOOL_GET_SSET_COUNT
+static int ixgbe_diag_test_count(struct net_device __always_unused *netdev)
+{
+	return IXGBE_TEST_LEN;
+}
+
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
 static void ixgbe_diag_test(struct net_device *netdev,
 			    struct ethtool_test *eth_test, u64 *data)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	bool if_running = netif_running(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
 
-	if (ixgbe_removed(adapter->hw.hw_addr)) {
+	if (IXGBE_REMOVED(hw->hw_addr)) {
 		e_err(hw, "Adapter removed - test blocked\n");
 		data[0] = 1;
 		data[1] = 1;
@@ -2173,13 +2813,14 @@ static void ixgbe_diag_test(struct net_device *netdev,
 	}
 	set_bit(__IXGBE_TESTING, &adapter->state);
 	if (eth_test->flags == ETH_TEST_FL_OFFLINE) {
-		struct ixgbe_hw *hw = &adapter->hw;
-
 		if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
 			int i;
 			for (i = 0; i < adapter->num_vfs; i++) {
 				if (adapter->vfinfo[i].clear_to_send) {
-					netdev_warn(netdev, "offline diagnostic is not supported when VFs are present\n");
+					e_warn(drv, "Please take active VFS "
+					       "offline and restart the "
+					       "adapter before running NIC "
+					       "diagnostics\n");
 					data[0] = 1;
 					data[1] = 1;
 					data[2] = 1;
@@ -2188,7 +2829,7 @@ static void ixgbe_diag_test(struct net_device *netdev,
 					eth_test->flags |= ETH_TEST_FL_FAILED;
 					clear_bit(__IXGBE_TESTING,
 						  &adapter->state);
-					return;
+					goto skip_ol_tests;
 				}
 			}
 		}
@@ -2197,8 +2838,7 @@ static void ixgbe_diag_test(struct net_device *netdev,
 		e_info(hw, "offline testing starting\n");
 
 		/* Link test performed before hardware reset so autoneg doesn't
-		 * interfere with test result
-		 */
+		 * interfere with test result */
 		if (ixgbe_link_test(adapter, &data[4]))
 			eth_test->flags |= ETH_TEST_FL_FAILED;
 
@@ -2226,7 +2866,7 @@ static void ixgbe_diag_test(struct net_device *netdev,
 		 * loopback diagnostic. */
 		if (adapter->flags & (IXGBE_FLAG_SRIOV_ENABLED |
 				      IXGBE_FLAG_VMDQ_ENABLED)) {
-			e_info(hw, "Skip MAC loopback diagnostic in VT mode\n");
+			e_info(hw, "skip MAC loopback diagnostic in VT mode\n");
 			data[3] = 0;
 			goto skip_loopback;
 		}
@@ -2260,6 +2900,9 @@ static void ixgbe_diag_test(struct net_device *netdev,
 
 		clear_bit(__IXGBE_TESTING, &adapter->state);
 	}
+
+skip_ol_tests:
+	msleep_interruptible(4 * 1000);
 }
 
 static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter,
@@ -2288,7 +2931,7 @@ static void ixgbe_get_wol(struct net_device *netdev,
 	wol->wolopts = 0;
 
 	if (ixgbe_wol_exclusion(adapter, wol) ||
-	    !device_can_wakeup(&adapter->pdev->dev))
+	    !device_can_wakeup(pci_dev_to_dev(adapter->pdev)))
 		return;
 
 	if (adapter->wol & IXGBE_WUFC_EX)
@@ -2304,6 +2947,7 @@ static void ixgbe_get_wol(struct net_device *netdev,
 static int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
 
 	if (wol->wolopts & (WAKE_PHY | WAKE_ARP | WAKE_MAGICSECURE |
 			    WAKE_FILTER))
@@ -2323,7 +2967,9 @@ static int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
 	if (wol->wolopts & WAKE_MAGIC)
 		adapter->wol |= IXGBE_WUFC_MAG;
 
-	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
+	hw->wol_enabled = !!(adapter->wol);
+
+	device_set_wakeup_enable(pci_dev_to_dev(adapter->pdev), adapter->wol);
 
 	return 0;
 }
@@ -2338,6 +2984,7 @@ static int ixgbe_nway_reset(struct net_device *netdev)
 	return 0;
 }
 
+#ifdef HAVE_ETHTOOL_SET_PHYS_ID
 static int ixgbe_set_phys_id(struct net_device *netdev,
 			     enum ethtool_phys_id_state state)
 {
@@ -2353,11 +3000,13 @@ static int ixgbe_set_phys_id(struct net_device *netdev,
 		return 2;
 
 	case ETHTOOL_ID_ON:
-		hw->mac.ops.led_on(hw, hw->mac.led_link_act);
+		if (hw->mac.ops.led_on(hw, hw->mac.led_link_act))
+			return -EINVAL;
 		break;
 
 	case ETHTOOL_ID_OFF:
-		hw->mac.ops.led_off(hw, hw->mac.led_link_act);
+		if (hw->mac.ops.led_off(hw, hw->mac.led_link_act))
+			return -EINVAL;
 		break;
 
 	case ETHTOOL_ID_INACTIVE:
@@ -2366,14 +3015,44 @@ static int ixgbe_set_phys_id(struct net_device *netdev,
 		break;
 	}
 
-	return 0;
+	return 0;
+}
+#else
+static int ixgbe_phys_id(struct net_device *netdev, u32 data)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 led_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
+	u32 i;
+
+	if (!hw->mac.ops.led_on || !hw->mac.ops.led_off)
+		return -EOPNOTSUPP;
+
+	if (!data || data > 300)
+		data = 300;
+
+	for (i = 0; i < (data * 1000); i += 400) {
+		if (hw->mac.ops.led_on(hw, hw->mac.led_link_act))
+			return -EINVAL;
+		msleep_interruptible(200);
+		if (hw->mac.ops.led_off(hw, hw->mac.led_link_act))
+			return -EINVAL;
+		msleep_interruptible(200);
+	}
+
+	/* Restore LED settings */
+	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, led_reg);
+
+	return IXGBE_SUCCESS;
 }
+#endif /* HAVE_ETHTOOL_SET_PHYS_ID */
 
 static int ixgbe_get_coalesce(struct net_device *netdev,
 			      struct ethtool_coalesce *ec)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+	ec->tx_max_coalesced_frames_irq = adapter->tx_work_limit;
 	/* only valid if in constant ITR mode */
 	if (adapter->rx_itr_setting <= 1)
 		ec->rx_coalesce_usecs = adapter->rx_itr_setting;
@@ -2411,7 +3090,8 @@ static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter)
 	    adapter->rx_itr_setting > IXGBE_MIN_RSC_ITR) {
 		if (!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)) {
 			adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
-			e_info(probe, "rx-usecs value high enough to re-enable RSC\n");
+			e_info(probe, "rx-usecs value high enough "
+				      "to re-enable RSC\n");
 			return true;
 		}
 	/* if interrupt rate is too high then disable RSC */
@@ -2427,9 +3107,9 @@ static int ixgbe_set_coalesce(struct net_device *netdev,
 			      struct ethtool_coalesce *ec)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_q_vector *q_vector;
 	int i;
-	u16 tx_itr_param, rx_itr_param, tx_itr_prev;
+	u16 tx_itr_param, rx_itr_param;
+	u16  tx_itr_prev;
 	bool need_reset = false;
 
 	if (adapter->q_vector[0]->tx.count && adapter->q_vector[0]->rx.count) {
@@ -2441,6 +3121,9 @@ static int ixgbe_set_coalesce(struct net_device *netdev,
 		tx_itr_prev = adapter->tx_itr_setting;
 	}
 
+	if (ec->tx_max_coalesced_frames_irq)
+		adapter->tx_work_limit = ec->tx_max_coalesced_frames_irq;
+
 	if ((ec->rx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)) ||
 	    (ec->tx_coalesce_usecs > (IXGBE_MAX_EITR >> 2)))
 		return -EINVAL;
@@ -2484,8 +3167,18 @@ static int ixgbe_set_coalesce(struct net_device *netdev,
 	/* check the old value and enable RSC if necessary */
 	need_reset |= ixgbe_update_rsc(adapter);
 
+	if (adapter->hw.mac.dmac_config.watchdog_timer &&
+	    (!adapter->rx_itr_setting && !adapter->tx_itr_setting)) {
+		e_info(probe,
+		       "Disabling DMA coalescing because interrupt throttling is disabled\n");
+		adapter->hw.mac.dmac_config.watchdog_timer = 0;
+		ixgbe_dmac_config(&adapter->hw);
+	}
+
 	for (i = 0; i < adapter->num_q_vectors; i++) {
-		q_vector = adapter->q_vector[i];
+		struct ixgbe_q_vector *q_vector = adapter->q_vector[i];
+
+		q_vector->tx.work_limit = adapter->tx_work_limit;
 		if (q_vector->tx.count && !q_vector->rx.count)
 			/* tx only */
 			q_vector->itr = tx_itr_param;
@@ -2506,6 +3199,253 @@ static int ixgbe_set_coalesce(struct net_device *netdev,
 	return 0;
 }
 
+#ifndef HAVE_NDO_SET_FEATURES
+static u32 ixgbe_get_rx_csum(struct net_device *netdev)
+{
+	return !!(netdev->features & NETIF_F_RXCSUM);
+}
+
+static int ixgbe_set_rx_csum(struct net_device *netdev, u32 data)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	bool need_reset = false;
+
+	if (data)
+		netdev->features |= NETIF_F_RXCSUM;
+	else
+		netdev->features &= ~NETIF_F_RXCSUM;
+
+	/* LRO and RSC both depend on RX checksum to function */
+	if (!data && (netdev->features & NETIF_F_LRO)) {
+		netdev->features &= ~NETIF_F_LRO;
+
+		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
+			adapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;
+			need_reset = true;
+		}
+	}
+
+#ifdef HAVE_VXLAN_RX_OFFLOAD
+	if (adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE && data) {
+		netdev->hw_enc_features |= NETIF_F_RXCSUM |
+					   NETIF_F_IP_CSUM |
+					   NETIF_F_IPV6_CSUM;
+		if (!need_reset)
+			adapter->flags2 |= IXGBE_FLAG2_VXLAN_REREG_NEEDED;
+	} else {
+		netdev->hw_enc_features &= ~(NETIF_F_RXCSUM |
+					     NETIF_F_IP_CSUM |
+					     NETIF_F_IPV6_CSUM);
+		ixgbe_clear_udp_tunnel_port(adapter,
+					    IXGBE_VXLANCTRL_ALL_UDPPORT_MASK);
+	}
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
+
+	if (need_reset)
+		ixgbe_do_reset(netdev);
+
+	return 0;
+}
+
+static int ixgbe_set_tx_csum(struct net_device *netdev, u32 data)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#ifdef NETIF_F_IPV6_CSUM
+	u32 feature_list = NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+#else
+	u32 feature_list = NETIF_F_IP_CSUM;
+#endif
+
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+#ifdef HAVE_ENCAP_TSO_OFFLOAD
+		if (data)
+			netdev->hw_enc_features |= NETIF_F_GSO_UDP_TUNNEL;
+		else
+			netdev->hw_enc_features &= ~NETIF_F_GSO_UDP_TUNNEL;
+		feature_list |= NETIF_F_GSO_UDP_TUNNEL;
+#endif /* HAVE_ENCAP_TSO_OFFLOAD */
+		feature_list |= NETIF_F_SCTP_CSUM;
+		break;
+	default:
+		break;
+	}
+
+	if (data)
+		netdev->features |= feature_list;
+	else
+		netdev->features &= ~feature_list;
+
+	return 0;
+}
+
+#ifdef NETIF_F_TSO
+static int ixgbe_set_tso(struct net_device *netdev, u32 data)
+{
+#ifdef NETIF_F_TSO6
+	u32 feature_list = NETIF_F_TSO | NETIF_F_TSO6;
+#else
+	u32 feature_list = NETIF_F_TSO;
+#endif
+
+	if (data)
+		netdev->features |= feature_list;
+	else
+		netdev->features &= ~feature_list;
+
+#ifndef HAVE_NETDEV_VLAN_FEATURES
+	if (!data) {
+		struct ixgbe_adapter *adapter = netdev_priv(netdev);
+		struct net_device *v_netdev;
+		int i;
+
+		/* disable TSO on all VLANs if they're present */
+		if (!adapter->vlgrp)
+			goto tso_out;
+
+		for (i = 0; i < VLAN_GROUP_ARRAY_LEN; i++) {
+			v_netdev = vlan_group_get_device(adapter->vlgrp, i);
+			if (!v_netdev)
+				continue;
+
+			v_netdev->features &= ~feature_list;
+			vlan_group_set_device(adapter->vlgrp, i, v_netdev);
+		}
+	}
+
+tso_out:
+
+#endif /* HAVE_NETDEV_VLAN_FEATURES */
+	return 0;
+}
+
+#endif /* NETIF_F_TSO */
+#ifdef ETHTOOL_GFLAGS
+static int ixgbe_set_flags(struct net_device *netdev, u32 data)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	u32 supported_flags = ETH_FLAG_RXVLAN | ETH_FLAG_TXVLAN;
+	u32 changed = netdev->features ^ data;
+	bool need_reset = false;
+	int rc;
+
+#ifndef HAVE_VLAN_RX_REGISTER
+	if ((adapter->flags & IXGBE_FLAG_DCB_ENABLED) &&
+	    !(data & ETH_FLAG_RXVLAN))
+		return -EINVAL;
+
+#endif
+	if (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)
+		supported_flags |= ETH_FLAG_LRO;
+
+#ifdef ETHTOOL_GRXRINGS
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_82599EB:
+		supported_flags |= ETH_FLAG_NTUPLE;
+	default:
+		break;
+	}
+
+#endif
+#ifdef NETIF_F_RXHASH
+	supported_flags |= ETH_FLAG_RXHASH;
+
+#endif
+	rc = ethtool_op_set_flags(netdev, data, supported_flags);
+	if (rc)
+		return rc;
+
+#ifndef HAVE_VLAN_RX_REGISTER
+	if (changed & ETH_FLAG_RXVLAN)
+		ixgbe_vlan_mode(netdev, netdev->features);
+#endif
+
+#ifdef HAVE_VXLAN_RX_OFFLOAD
+	if (adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE &&
+	    netdev->features & NETIF_F_RXCSUM) {
+		vxlan_get_rx_port(netdev);
+	else
+		ixgbe_clear_udp_tunnel_port(adapter,
+					    IXGBE_VXLANCTRL_ALL_UDPPORT_MASK);
+	}
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
+
+	/* if state changes we need to update adapter->flags and reset */
+	if (!(netdev->features & NETIF_F_LRO)) {
+		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)
+			need_reset = true;
+		adapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;
+	} else if ((adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) &&
+		   !(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)) {
+		if (adapter->rx_itr_setting == 1 ||
+		    adapter->rx_itr_setting > IXGBE_MIN_RSC_ITR) {
+			adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
+			need_reset = true;
+		} else if (changed & ETH_FLAG_LRO) {
+			e_info(probe, "rx-usecs set too low, "
+			       "disabling RSC\n");
+		}
+	}
+
+#ifdef ETHTOOL_GRXRINGS
+	/*
+	 * Check if Flow Director n-tuple support was enabled or disabled.  If
+	 * the state changed, we need to reset.
+	 */
+	switch (netdev->features & NETIF_F_NTUPLE) {
+	case NETIF_F_NTUPLE:
+		/* turn off ATR, enable perfect filters and reset */
+		if (!(adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE))
+			need_reset = true;
+
+		adapter->flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
+		adapter->flags |= IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
+		break;
+	default:
+		/* turn off perfect filters, enable ATR and reset */
+		if (adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
+			need_reset = true;
+
+		adapter->flags &= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
+
+		/* We cannot enable ATR if VMDq is enabled */
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED)
+			break;
+
+		/* We cannot enable ATR if we have 2 or more traffic classes */
+		if (netdev_get_num_tc(netdev) > 1)
+			break;
+
+		/* We cannot enable ATR if RSS is disabled */
+		if (adapter->ring_feature[RING_F_RSS].limit <= 1)
+			break;
+
+		/* A sample rate of 0 indicates ATR disabled */
+		if (!adapter->atr_sample_rate)
+			break;
+
+		adapter->flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
+		break;
+	}
+
+#endif /* ETHTOOL_GRXRINGS */
+	if (need_reset)
+		ixgbe_do_reset(netdev);
+
+	return 0;
+}
+
+#endif /* ETHTOOL_GFLAGS */
+#endif /* HAVE_NDO_SET_FEATURES */
+#ifdef ETHTOOL_GRXRINGS
 static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 					struct ethtool_rxnfc *cmd)
 {
@@ -2537,6 +3477,12 @@ static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 	case IXGBE_ATR_FLOW_TYPE_UDPV4:
 		fsp->flow_type = UDP_V4_FLOW;
 		break;
+	case IXGBE_ATR_FLOW_TYPE_TCPV6:
+		fsp->flow_type = TCP_V6_FLOW;
+		break;
+	case IXGBE_ATR_FLOW_TYPE_UDPV6:
+		fsp->flow_type = UDP_V6_FLOW;
+		break;
 	case IXGBE_ATR_FLOW_TYPE_SCTPV4:
 		fsp->flow_type = SCTP_V4_FLOW;
 		break;
@@ -2550,14 +3496,26 @@ static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 		return -EINVAL;
 	}
 
-	fsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;
-	fsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;
-	fsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;
-	fsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;
-	fsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];
-	fsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];
-	fsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];
-	fsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];
+#ifdef HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+	if (rule->filter.formatted.flow_type & IXGBE_ATR_L4TYPE_IPV6_MASK) {
+		fsp->h_u.tcp_ip6_spec.psrc = rule->filter.formatted.src_port;
+		fsp->m_u.tcp_ip6_spec.psrc = mask->formatted.src_port;
+		fsp->h_u.tcp_ip6_spec.pdst = rule->filter.formatted.dst_port;
+		fsp->m_u.tcp_ip6_spec.pdst = mask->formatted.dst_port;
+	} else {
+#endif
+		fsp->h_u.tcp_ip4_spec.psrc = rule->filter.formatted.src_port;
+		fsp->m_u.tcp_ip4_spec.psrc = mask->formatted.src_port;
+		fsp->h_u.tcp_ip4_spec.pdst = rule->filter.formatted.dst_port;
+		fsp->m_u.tcp_ip4_spec.pdst = mask->formatted.dst_port;
+		fsp->h_u.tcp_ip4_spec.ip4src = rule->filter.formatted.src_ip[0];
+		fsp->m_u.tcp_ip4_spec.ip4src = mask->formatted.src_ip[0];
+		fsp->h_u.tcp_ip4_spec.ip4dst = rule->filter.formatted.dst_ip[0];
+		fsp->m_u.tcp_ip4_spec.ip4dst = mask->formatted.dst_ip[0];
+#ifdef HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+	}
+#endif
+
 	fsp->h_ext.vlan_tci = rule->filter.formatted.vlan_id;
 	fsp->m_ext.vlan_tci = mask->formatted.vlan_id;
 	fsp->h_ext.vlan_etype = rule->filter.formatted.flex_bytes;
@@ -2608,11 +3566,11 @@ static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,
 	switch (cmd->flow_type) {
 	case TCP_V4_FLOW:
 		cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		fallthrough;
+		/* fall through */
 	case UDP_V4_FLOW:
 		if (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV4_UDP)
 			cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		fallthrough;
+		/* fall through */
 	case SCTP_V4_FLOW:
 	case AH_ESP_V4_FLOW:
 	case AH_V4_FLOW:
@@ -2622,11 +3580,11 @@ static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,
 		break;
 	case TCP_V6_FLOW:
 		cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		fallthrough;
+		/* fall through */
 	case UDP_V6_FLOW:
 		if (adapter->flags2 & IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)
 			cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
-		fallthrough;
+		/* fall through */
 	case SCTP_V6_FLOW:
 	case AH_ESP_V6_FLOW:
 	case AH_V6_FLOW:
@@ -2642,7 +3600,11 @@ static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,
 }
 
 static int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+#ifdef HAVE_ETHTOOL_GET_RXNFC_VOID_RULE_LOCS
+			   void *rule_locs)
+#else
 			   u32 *rule_locs)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	int ret = -EOPNOTSUPP;
@@ -2660,7 +3622,8 @@ static int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
 		ret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);
 		break;
 	case ETHTOOL_GRXCLSRLALL:
-		ret = ixgbe_get_ethtool_fdir_all(adapter, cmd, rule_locs);
+		ret = ixgbe_get_ethtool_fdir_all(adapter, cmd,
+						 (u32 *)rule_locs);
 		break;
 	case ETHTOOL_GRXFH:
 		ret = ixgbe_get_rss_hash_opts(adapter, cmd);
@@ -2679,7 +3642,8 @@ int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct hlist_node *node2;
 	struct ixgbe_fdir_filter *rule, *parent;
-	int err = -EINVAL;
+	bool deleted = false;
+	s32 err;
 
 	parent = NULL;
 	rule = NULL;
@@ -2694,24 +3658,32 @@ int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 
 	/* if there is an old rule occupying our place remove it */
 	if (rule && (rule->sw_idx == sw_idx)) {
-		if (!input || (rule->filter.formatted.bkt_hash !=
-			       input->filter.formatted.bkt_hash)) {
+		/* hardware filters are only configured when interface is up,
+		 * and we should not issue filter commands while the interface
+		 * is down
+		 */
+		if (netif_running(adapter->netdev) &&
+		    (!input || (rule->filter.formatted.bkt_hash !=
+				input->filter.formatted.bkt_hash))) {
 			err = ixgbe_fdir_erase_perfect_filter_82599(hw,
 								&rule->filter,
 								sw_idx);
+			if (err)
+				return -EINVAL;
 		}
 
 		hlist_del(&rule->fdir_node);
 		kfree(rule);
 		adapter->fdir_filter_count--;
+		deleted = true;
 	}
 
-	/*
-	 * If no input this was a delete, err should be 0 if a rule was
-	 * successfully found and removed from the list else -EINVAL
+	/* If we weren't given an input, then this was a request to delete a
+	 * filter. We should return -EINVAL if the filter wasn't found, but
+	 * return 0 if the rule was successfully deleted.
 	 */
 	if (!input)
-		return err;
+		return deleted ? 0 : -EINVAL;
 
 	/* initialize node and set software index */
 	INIT_HLIST_NODE(&input->fdir_node);
@@ -2739,6 +3711,12 @@ static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,
 	case UDP_V4_FLOW:
 		*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV4;
 		break;
+	case TCP_V6_FLOW:
+		*flow_type = IXGBE_ATR_FLOW_TYPE_TCPV6;
+		break;
+	case UDP_V6_FLOW:
+		*flow_type = IXGBE_ATR_FLOW_TYPE_UDPV6;
+		break;
 	case SCTP_V4_FLOW:
 		*flow_type = IXGBE_ATR_FLOW_TYPE_SCTPV4;
 		break;
@@ -2758,7 +3736,7 @@ static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,
 				*flow_type = IXGBE_ATR_FLOW_TYPE_IPV4;
 				break;
 			}
-			fallthrough;
+			/* fall through */
 		default:
 			return 0;
 		}
@@ -2770,6 +3748,24 @@ static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,
 	return 1;
 }
 
+static bool ixgbe_match_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
+					   struct ixgbe_fdir_filter *input)
+{
+	struct hlist_node *node2;
+	struct ixgbe_fdir_filter *rule = NULL;
+
+	hlist_for_each_entry_safe(rule, node2,
+				  &adapter->fdir_filter_list, fdir_node) {
+		if (rule->filter.formatted.bkt_hash ==
+		    input->filter.formatted.bkt_hash &&
+		    rule->action == input->action) {
+			e_info(drv, "FDIR entry already exist\n");
+			return true;
+		}
+	}
+	return false;
+}
+
 static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 					struct ethtool_rxnfc *cmd)
 {
@@ -2785,7 +3781,7 @@ static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 		return -EOPNOTSUPP;
 
 	/* ring_cookie is a masked into a set of queues and ixgbe pools or
-	 * we use the drop index.
+	 * we use drop index
 	 */
 	if (fsp->ring_cookie == RX_CLS_FLOW_DISC) {
 		queue = IXGBE_FDIR_DROP_QUEUE;
@@ -2793,7 +3789,7 @@ static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 		u32 ring = ethtool_get_flow_spec_ring(fsp->ring_cookie);
 		u8 vf = ethtool_get_flow_spec_ring_vf(fsp->ring_cookie);
 
-		if (!vf && (ring >= adapter->num_rx_queues))
+		if (!vf && ring >= adapter->num_rx_queues)
 			return -EINVAL;
 		else if (vf &&
 			 ((vf > adapter->num_vfs) ||
@@ -2836,15 +3832,46 @@ static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 	if (input->filter.formatted.flow_type == IXGBE_ATR_FLOW_TYPE_IPV4)
 		mask.formatted.flow_type &= IXGBE_ATR_L4TYPE_IPV6_MASK;
 
-	/* Copy input into formatted structures */
-	input->filter.formatted.src_ip[0] = fsp->h_u.tcp_ip4_spec.ip4src;
-	mask.formatted.src_ip[0] = fsp->m_u.tcp_ip4_spec.ip4src;
-	input->filter.formatted.dst_ip[0] = fsp->h_u.tcp_ip4_spec.ip4dst;
-	mask.formatted.dst_ip[0] = fsp->m_u.tcp_ip4_spec.ip4dst;
-	input->filter.formatted.src_port = fsp->h_u.tcp_ip4_spec.psrc;
-	mask.formatted.src_port = fsp->m_u.tcp_ip4_spec.psrc;
-	input->filter.formatted.dst_port = fsp->h_u.tcp_ip4_spec.pdst;
-	mask.formatted.dst_port = fsp->m_u.tcp_ip4_spec.pdst;
+#ifdef HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+	/* not support full IPV6 address filtering */
+	if (input->filter.formatted.flow_type & IXGBE_ATR_L4TYPE_IPV6_MASK) {
+		if (fsp->m_u.tcp_ip6_spec.ip6src[0] ||
+		    fsp->m_u.tcp_ip6_spec.ip6src[1] ||
+		    fsp->m_u.tcp_ip6_spec.ip6src[2] ||
+		    fsp->m_u.tcp_ip6_spec.ip6src[3] ||
+		    fsp->m_u.tcp_ip6_spec.ip6dst[0] ||
+		    fsp->m_u.tcp_ip6_spec.ip6dst[1] ||
+		    fsp->m_u.tcp_ip6_spec.ip6dst[2] ||
+		    fsp->m_u.tcp_ip6_spec.ip6dst[3]) {
+			e_err(drv, "Error not support IPv6 address fitlers\n");
+			goto err_out;
+		}
+		input->filter.formatted.src_port = fsp->h_u.tcp_ip6_spec.psrc;
+		mask.formatted.src_port = fsp->m_u.tcp_ip6_spec.psrc;
+		input->filter.formatted.dst_port = fsp->h_u.tcp_ip6_spec.pdst;
+		mask.formatted.dst_port = fsp->m_u.tcp_ip6_spec.pdst;
+	} else {
+#endif
+		/* Copy input into formatted structures */
+		input->filter.formatted.src_ip[0] =
+			fsp->h_u.tcp_ip4_spec.ip4src;
+		mask.formatted.src_ip[0] =
+			fsp->m_u.tcp_ip4_spec.ip4src;
+		input->filter.formatted.dst_ip[0] =
+			fsp->h_u.tcp_ip4_spec.ip4dst;
+		mask.formatted.dst_ip[0] =
+			fsp->m_u.tcp_ip4_spec.ip4dst;
+		input->filter.formatted.src_port =
+			fsp->h_u.tcp_ip4_spec.psrc;
+		mask.formatted.src_port =
+			fsp->m_u.tcp_ip4_spec.psrc;
+		input->filter.formatted.dst_port =
+			fsp->h_u.tcp_ip4_spec.pdst;
+		mask.formatted.dst_port =
+			fsp->m_u.tcp_ip4_spec.pdst;
+#ifdef HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+	}
+#endif
 
 	if (fsp->flow_type & FLOW_EXT) {
 		input->filter.formatted.vm_pool =
@@ -2869,30 +3896,40 @@ static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 	if (hlist_empty(&adapter->fdir_filter_list)) {
 		/* save mask and program input mask into HW */
 		memcpy(&adapter->fdir_mask, &mask, sizeof(mask));
-		err = ixgbe_fdir_set_input_mask_82599(hw, &mask);
+		err = ixgbe_fdir_set_input_mask_82599(hw, &mask, adapter->cloud_mode);
 		if (err) {
 			e_err(drv, "Error writing mask\n");
 			goto err_out_w_lock;
 		}
 	} else if (memcmp(&adapter->fdir_mask, &mask, sizeof(mask))) {
-		e_err(drv, "Only one mask supported per port\n");
+		e_err(drv, "Hardware only supports one mask per port. To change the mask you must first delete all the rules.\n");
 		goto err_out_w_lock;
 	}
 
 	/* apply mask and compute/store hash */
 	ixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);
 
-	/* program filters to filter memory */
-	err = ixgbe_fdir_write_perfect_filter_82599(hw,
-				&input->filter, input->sw_idx, queue);
-	if (err)
+	/* check if new entry does not exist on filter list */
+	if (ixgbe_match_ethtool_fdir_entry(adapter, input))
 		goto err_out_w_lock;
 
+	/* only program filters to hardware if the net device is running, as
+	 * we store the filters in the Rx buffer which is not allocated when
+	 * the device is down
+	 */
+	if (netif_running(adapter->netdev)) {
+		err = ixgbe_fdir_write_perfect_filter_82599(hw,
+					&input->filter, input->sw_idx, queue,
+					adapter->cloud_mode);
+		if (err)
+			goto err_out_w_lock;
+	}
+
 	ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
 
 	spin_unlock(&adapter->fdir_perfect_lock);
 
-	return err;
+	return 0;
 err_out_w_lock:
 	spin_unlock(&adapter->fdir_perfect_lock);
 err_out:
@@ -2914,6 +3951,19 @@ static int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
 	return err;
 }
 
+#ifdef ETHTOOL_SRXNTUPLE
+/*
+ * We need to keep this around for kernels 2.6.33 - 2.6.39 in order to avoid
+ * a null pointer dereference as it was assumend if the NETIF_F_NTUPLE flag
+ * was defined that this function was present.
+ */
+static int ixgbe_set_rx_ntuple(struct net_device __always_unused *dev,
+			       struct ethtool_rx_ntuple __always_unused *cmd)
+{
+	return -EOPNOTSUPP;
+}
+
+#endif
 #define UDP_RSS_FLAGS (IXGBE_FLAG2_RSS_FIELD_IPV4_UDP | \
 		       IXGBE_FLAG2_RSS_FIELD_IPV6_UDP)
 static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter,
@@ -3000,7 +4050,8 @@ static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter,
 
 		if ((flags2 & UDP_RSS_FLAGS) &&
 		    !(adapter->flags2 & UDP_RSS_FLAGS))
-			e_warn(drv, "enabling UDP RSS: fragmented packets may arrive out of order to the stack above\n");
+			e_warn(drv, "enabling UDP RSS: fragmented packets"
+			       " may arrive out of order to the stack above\n");
 
 		adapter->flags2 = flags2;
 
@@ -3051,6 +4102,7 @@ static int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
 	return ret;
 }
 
+#if defined(ETHTOOL_GRSSH) && defined(ETHTOOL_SRSSH)
 static int ixgbe_rss_indir_tbl_max(struct ixgbe_adapter *adapter)
 {
 	if (adapter->hw.mac.type < ixgbe_mac_X550)
@@ -3083,13 +4135,19 @@ static void ixgbe_get_reta(struct ixgbe_adapter *adapter, u32 *indir)
 		indir[i] = adapter->rss_indir_tbl[i] & rss_m;
 }
 
+#ifdef HAVE_RXFH_HASHFUNC
 static int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
 			  u8 *hfunc)
+#else
+static int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+#ifdef HAVE_RXFH_HASHFUNC
 	if (hfunc)
 		*hfunc = ETH_RSS_HASH_TOP;
+#endif
 
 	if (indir)
 		ixgbe_get_reta(adapter, indir);
@@ -3100,15 +4158,26 @@ static int ixgbe_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
 	return 0;
 }
 
+#ifdef HAVE_RXFH_HASHFUNC
 static int ixgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
 			  const u8 *key, const u8 hfunc)
+#else
+#ifdef HAVE_RXFH_NONCONST
+static int ixgbe_set_rxfh(struct net_device *netdev, u32 *indir, u8 *key)
+#else
+static int ixgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
+			  const u8 *key)
+#endif /* HAVE_RXFH_NONCONST */
+#endif /* HAVE_RXFH_HASHFUNC */
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	int i;
 	u32 reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
 
+#ifdef HAVE_RXFH_HASHFUNC
 	if (hfunc)
 		return -EINVAL;
+#endif
 
 	/* Fill out the redirection table */
 	if (indir) {
@@ -3139,7 +4208,9 @@ static int ixgbe_set_rxfh(struct net_device *netdev, const u32 *indir,
 
 	return 0;
 }
+#endif /* ETHTOOL_GRSSH && ETHTOOL_SRSSH */
 
+#ifdef HAVE_ETHTOOL_GET_TS_INFO
 static int ixgbe_get_ts_info(struct net_device *dev,
 			     struct ethtool_ts_info *info)
 {
@@ -3149,9 +4220,10 @@ static int ixgbe_get_ts_info(struct net_device *dev,
 	info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
 
 	switch (adapter->hw.mac.type) {
+#ifdef HAVE_PTP_1588_CLOCK
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		info->rx_filters |= BIT(HWTSTAMP_FILTER_ALL);
 		break;
 	case ixgbe_mac_X540:
@@ -3161,17 +4233,19 @@ static int ixgbe_get_ts_info(struct net_device *dev,
 			BIT(HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ) |
 			BIT(HWTSTAMP_FILTER_PTP_V2_EVENT);
 		break;
+#endif /* HAVE_PTP_1588_CLOCK */
 	default:
 		return ethtool_op_get_ts_info(dev, info);
 	}
+#ifdef HAVE_PTP_1588_CLOCK
 
 	info->so_timestamping =
-		SOF_TIMESTAMPING_TX_SOFTWARE |
-		SOF_TIMESTAMPING_RX_SOFTWARE |
-		SOF_TIMESTAMPING_SOFTWARE |
-		SOF_TIMESTAMPING_TX_HARDWARE |
-		SOF_TIMESTAMPING_RX_HARDWARE |
-		SOF_TIMESTAMPING_RAW_HARDWARE;
+			SOF_TIMESTAMPING_TX_SOFTWARE |
+			SOF_TIMESTAMPING_RX_SOFTWARE |
+			SOF_TIMESTAMPING_SOFTWARE |
+			SOF_TIMESTAMPING_TX_HARDWARE |
+			SOF_TIMESTAMPING_RX_HARDWARE |
+			SOF_TIMESTAMPING_RAW_HARDWARE;
 
 	if (adapter->ptp_clock)
 		info->phc_index = ptp_clock_index(adapter->ptp_clock);
@@ -3183,12 +4257,16 @@ static int ixgbe_get_ts_info(struct net_device *dev,
 		BIT(HWTSTAMP_TX_ON);
 
 	return 0;
+#endif /* HAVE_PTP_1588_CLOCK */
 }
+#endif /* HAVE_ETHTOOL_GET_TS_INFO */
 
+#endif /* ETHTOOL_GRXRINGS */
+#ifdef ETHTOOL_SCHANNELS
 static unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter)
 {
 	unsigned int max_combined;
-	u8 tcs = adapter->hw_tcs;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
 
 	if (!(adapter->flags & IXGBE_FLAG_MSIX_ENABLED)) {
 		/* We only support one q_vector without MSI-X */
@@ -3212,7 +4290,7 @@ static unsigned int ixgbe_max_channels(struct ixgbe_adapter *adapter)
 		/* support up to 64 queues with ATR */
 		max_combined = IXGBE_MAX_FDIR_INDICES;
 	} else {
-		/* support up to 16 queues with RSS */
+		/* support up to max allowed queues with RSS */
 		max_combined = ixgbe_max_rss_indices(adapter);
 	}
 
@@ -3245,7 +4323,7 @@ static void ixgbe_get_channels(struct net_device *dev,
 		return;
 
 	/* same thing goes for being DCB enabled */
-	if (adapter->hw_tcs > 1)
+	if (netdev_get_num_tc(dev) > 1)
 		return;
 
 	/* if ATR is disabled we can exit */
@@ -3283,41 +4361,40 @@ static int ixgbe_set_channels(struct net_device *dev,
 		count = max_rss_indices;
 	adapter->ring_feature[RING_F_RSS].limit = count;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* cap FCoE limit at 8 */
 	if (count > IXGBE_FCRETA_SIZE)
 		count = IXGBE_FCRETA_SIZE;
 	adapter->ring_feature[RING_F_FCOE].limit = count;
+#endif /* CONFIG_FCOE */
 
-#endif
 	/* use setup TC to update any traffic class queue mapping */
-	return ixgbe_setup_tc(dev, adapter->hw_tcs);
+	return ixgbe_setup_tc(dev, netdev_get_num_tc(dev));
 }
+#endif /* ETHTOOL_SCHANNELS */
 
+#ifdef ETHTOOL_GMODULEINFO
 static int ixgbe_get_module_info(struct net_device *dev,
 				       struct ethtool_modinfo *modinfo)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_hw *hw = &adapter->hw;
-	s32 status;
+	u32 status;
 	u8 sff8472_rev, addr_mode;
 	bool page_swap = false;
 
-	if (hw->phy.type == ixgbe_phy_fw)
-		return -ENXIO;
-
 	/* Check whether we support SFF-8472 or not */
 	status = hw->phy.ops.read_i2c_eeprom(hw,
 					     IXGBE_SFF_SFF_8472_COMP,
 					     &sff8472_rev);
-	if (status)
+	if (status != 0)
 		return -EIO;
 
 	/* addressing mode is not supported */
 	status = hw->phy.ops.read_i2c_eeprom(hw,
 					     IXGBE_SFF_SFF_8472_SWAP,
 					     &addr_mode);
-	if (status)
+	if (status != 0)
 		return -EIO;
 
 	if (addr_mode & IXGBE_SFF_ADDRESSING_MODE) {
@@ -3325,8 +4402,7 @@ static int ixgbe_get_module_info(struct net_device *dev,
 		page_swap = true;
 	}
 
-	if (sff8472_rev == IXGBE_SFF_SFF_8472_UNSUP || page_swap ||
-	    !(addr_mode & IXGBE_SFF_DDM_IMPLEMENTED)) {
+	if (sff8472_rev == IXGBE_SFF_SFF_8472_UNSUP || page_swap) {
 		/* We have a SFP, but it does not support SFF-8472 */
 		modinfo->type = ETH_MODULE_SFF_8079;
 		modinfo->eeprom_len = ETH_MODULE_SFF_8079_LEN;
@@ -3345,16 +4421,13 @@ static int ixgbe_get_module_eeprom(struct net_device *dev,
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_hw *hw = &adapter->hw;
-	s32 status = IXGBE_ERR_PHY_ADDR_INVALID;
+	u32 status = IXGBE_ERR_PHY_ADDR_INVALID;
 	u8 databyte = 0xFF;
 	int i = 0;
 
 	if (ee->len == 0)
 		return -EINVAL;
 
-	if (hw->phy.type == ixgbe_phy_fw)
-		return -ENXIO;
-
 	for (i = ee->offset; i < ee->offset + ee->len; i++) {
 		/* I2C reads can take long time */
 		if (test_bit(__IXGBE_IN_SFP_INIT, &adapter->state))
@@ -3365,7 +4438,7 @@ static int ixgbe_get_module_eeprom(struct net_device *dev,
 		else
 			status = hw->phy.ops.read_i2c_sff8472(hw, i, &databyte);
 
-		if (status)
+		if (status != 0)
 			return -EIO;
 
 		data[i - ee->offset] = databyte;
@@ -3373,6 +4446,9 @@ static int ixgbe_get_module_eeprom(struct net_device *dev,
 
 	return 0;
 }
+#endif /* ETHTOOL_GMODULEINFO */
+
+#ifdef ETHTOOL_GEEE
 
 static const struct {
 	ixgbe_link_speed mac_speed;
@@ -3440,6 +4516,9 @@ static int ixgbe_get_eee(struct net_device *netdev, struct ethtool_eee *edata)
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
 
+	if (!hw->mac.ops.setup_eee)
+		return -EOPNOTSUPP;
+
 	if (!(adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE))
 		return -EOPNOTSUPP;
 
@@ -3448,7 +4527,9 @@ static int ixgbe_get_eee(struct net_device *netdev, struct ethtool_eee *edata)
 
 	return -EOPNOTSUPP;
 }
+#endif /* ETHTOOL_GEEE */
 
+#ifdef ETHTOOL_SEEE
 static int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
@@ -3456,7 +4537,8 @@ static int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
 	struct ethtool_eee eee_data;
 	s32 ret_val;
 
-	if (!(adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE))
+	if (!(hw->mac.ops.setup_eee &&
+	    (adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE)))
 		return -EOPNOTSUPP;
 
 	memset(&eee_data, 0, sizeof(struct ethtool_eee));
@@ -3465,26 +4547,23 @@ static int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
 	if (ret_val)
 		return ret_val;
 
-	if (eee_data.eee_enabled && !edata->eee_enabled) {
-		if (eee_data.tx_lpi_enabled != edata->tx_lpi_enabled) {
-			e_err(drv, "Setting EEE tx-lpi is not supported\n");
-			return -EINVAL;
-		}
+	if (eee_data.tx_lpi_enabled != edata->tx_lpi_enabled) {
+		e_dev_err("Setting EEE tx-lpi is not supported\n");
+		return -EINVAL;
+	}
 
-		if (eee_data.tx_lpi_timer != edata->tx_lpi_timer) {
-			e_err(drv,
-			      "Setting EEE Tx LPI timer is not supported\n");
-			return -EINVAL;
-		}
+	if (eee_data.tx_lpi_timer != edata->tx_lpi_timer) {
+		e_dev_err("Setting EEE Tx LPI timer is not supported\n");
+		return -EINVAL;
+	}
 
-		if (eee_data.advertised != edata->advertised) {
-			e_err(drv,
-			      "Setting EEE advertised speeds is not supported\n");
-			return -EINVAL;
-		}
+	if (eee_data.advertised != edata->advertised) {
+		e_dev_err("Setting EEE advertised speeds is not supported\n");
+		return -EINVAL;
 	}
 
 	if (eee_data.eee_enabled != edata->eee_enabled) {
+
 		if (edata->eee_enabled) {
 			adapter->flags2 |= IXGBE_FLAG2_EEE_ENABLED;
 			hw->phy.eee_speeds_advertised =
@@ -3503,91 +4582,235 @@ static int ixgbe_set_eee(struct net_device *netdev, struct ethtool_eee *edata)
 
 	return 0;
 }
+#endif /* ETHTOOL_SEEE */
 
+#ifdef HAVE_ETHTOOL_GET_SSET_COUNT
+/**
+ * ixgbe_get_priv_flags - report device private flags
+ * @netdev: network interface device structure
+ *
+ * The get string set count and the string set should be matched for each
+ * flag returned.  Add new strings for each flag to the ixgbe_priv_flags_strings
+ * array.
+ *
+ * Returns a u32 bitmap of flags.
+ **/
 static u32 ixgbe_get_priv_flags(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	u32 priv_flags = 0;
 
+	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE)
+		priv_flags |= IXGBE_PRIV_FLAGS_FD_ATR;
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
+
 	if (adapter->flags2 & IXGBE_FLAG2_RX_LEGACY)
 		priv_flags |= IXGBE_PRIV_FLAGS_LEGACY_RX;
-
-	if (adapter->flags2 & IXGBE_FLAG2_VF_IPSEC_ENABLED)
-		priv_flags |= IXGBE_PRIV_FLAGS_VF_IPSEC_EN;
+#endif
 
 	return priv_flags;
 }
 
+/**
+ * ixgbe_set_priv_flags - set private flags
+ * @netdev: network interface device structure
+ * @priv_flags: bit flags to be set
+ **/
 static int ixgbe_set_priv_flags(struct net_device *netdev, u32 priv_flags)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
 	unsigned int flags2 = adapter->flags2;
+#endif
+	unsigned int flags = adapter->flags;
+
+	/* allow the user to control the state of the Flow
+	 * Director ATR (Application Targeted Routing) feature
+	 * of the driver
+	 */
+	flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
+	if (priv_flags & IXGBE_PRIV_FLAGS_FD_ATR) {
+		/* We cannot enable ATR if VMDq is enabled */
+		if (flags & IXGBE_FLAG_VMDQ_ENABLED)
+			return -EINVAL;
+		/* We cannot enable ATR if we have 2 or more traffic classes */
+		if (netdev_get_num_tc(netdev) > 1)
+			return -EINVAL;
+		/* We cannot enable ATR if RSS is disabled */
+		if (adapter->ring_feature[RING_F_RSS].limit <= 1)
+			return -EINVAL;
+		/* A sample rate of 0 indicates ATR disabled */
+		if (!adapter->atr_sample_rate)
+			return -EINVAL;
+		flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
+	}
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
 
 	flags2 &= ~IXGBE_FLAG2_RX_LEGACY;
 	if (priv_flags & IXGBE_PRIV_FLAGS_LEGACY_RX)
 		flags2 |= IXGBE_FLAG2_RX_LEGACY;
+#endif
 
-	flags2 &= ~IXGBE_FLAG2_VF_IPSEC_ENABLED;
-	if (priv_flags & IXGBE_PRIV_FLAGS_VF_IPSEC_EN)
-		flags2 |= IXGBE_FLAG2_VF_IPSEC_ENABLED;
+	if (flags != adapter->flags) {
+		adapter->flags = flags;
 
-	if (flags2 != adapter->flags2) {
+		/* ATR state change requires a reset */
+		ixgbe_do_reset(netdev);
+#ifndef HAVE_SWIOTLB_SKIP_CPU_SYNC
+	}
+#else
+	} else if (flags2 != adapter->flags2) {
 		adapter->flags2 = flags2;
 
 		/* reset interface to repopulate queues */
 		if (netif_running(netdev))
 			ixgbe_reinit_locked(adapter);
 	}
+#endif
 
 	return 0;
 }
 
-static const struct ethtool_ops ixgbe_ethtool_ops = {
-	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
-	.get_drvinfo            = ixgbe_get_drvinfo,
-	.get_regs_len           = ixgbe_get_regs_len,
-	.get_regs               = ixgbe_get_regs,
-	.get_wol                = ixgbe_get_wol,
-	.set_wol                = ixgbe_set_wol,
-	.nway_reset             = ixgbe_nway_reset,
-	.get_link               = ethtool_op_get_link,
-	.get_eeprom_len         = ixgbe_get_eeprom_len,
-	.get_eeprom             = ixgbe_get_eeprom,
-	.set_eeprom             = ixgbe_set_eeprom,
-	.get_ringparam          = ixgbe_get_ringparam,
-	.set_ringparam          = ixgbe_set_ringparam,
-	.get_pause_stats	= ixgbe_get_pause_stats,
-	.get_pauseparam         = ixgbe_get_pauseparam,
-	.set_pauseparam         = ixgbe_set_pauseparam,
-	.get_msglevel           = ixgbe_get_msglevel,
-	.set_msglevel           = ixgbe_set_msglevel,
-	.self_test              = ixgbe_diag_test,
-	.get_strings            = ixgbe_get_strings,
-	.set_phys_id            = ixgbe_set_phys_id,
-	.get_sset_count         = ixgbe_get_sset_count,
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
+static struct ethtool_ops ixgbe_ethtool_ops = {
+#ifdef ETHTOOL_GLINKSETTINGS
+	.get_link_ksettings	= ixgbe_get_link_ksettings,
+	.set_link_ksettings	= ixgbe_set_link_ksettings,
+#else
+	.get_settings		= ixgbe_get_settings,
+	.set_settings		= ixgbe_set_settings,
+#endif
+	.get_drvinfo		= ixgbe_get_drvinfo,
+	.get_regs_len		= ixgbe_get_regs_len,
+	.get_regs		= ixgbe_get_regs,
+	.get_wol		= ixgbe_get_wol,
+	.set_wol		= ixgbe_set_wol,
+	.nway_reset		= ixgbe_nway_reset,
+	.get_link		= ethtool_op_get_link,
+	.get_eeprom_len		= ixgbe_get_eeprom_len,
+	.get_eeprom		= ixgbe_get_eeprom,
+	.set_eeprom		= ixgbe_set_eeprom,
+	.get_ringparam		= ixgbe_get_ringparam,
+	.set_ringparam		= ixgbe_set_ringparam,
+	.get_pauseparam		= ixgbe_get_pauseparam,
+	.set_pauseparam		= ixgbe_set_pauseparam,
+	.get_msglevel		= ixgbe_get_msglevel,
+	.set_msglevel		= ixgbe_set_msglevel,
+#ifndef HAVE_ETHTOOL_GET_SSET_COUNT
+	.self_test_count	= ixgbe_diag_test_count,
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
+	.self_test		= ixgbe_diag_test,
+	.get_strings		= ixgbe_get_strings,
+#ifndef HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT
+#ifdef HAVE_ETHTOOL_SET_PHYS_ID
+	.set_phys_id		= ixgbe_set_phys_id,
+#else
+	.phys_id		= ixgbe_phys_id,
+#endif /* HAVE_ETHTOOL_SET_PHYS_ID */
+#endif /* HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT */
+#ifndef HAVE_ETHTOOL_GET_SSET_COUNT
+	.get_stats_count	= ixgbe_get_stats_count,
+#else /* HAVE_ETHTOOL_GET_SSET_COUNT */
+	.get_sset_count		= ixgbe_get_sset_count,
+	.get_priv_flags		= ixgbe_get_priv_flags,
+	.set_priv_flags		= ixgbe_set_priv_flags,
+#endif /* HAVE_ETHTOOL_GET_SSET_COUNT */
 	.get_ethtool_stats      = ixgbe_get_ethtool_stats,
-	.get_coalesce           = ixgbe_get_coalesce,
-	.set_coalesce           = ixgbe_set_coalesce,
+#ifdef HAVE_ETHTOOL_GET_PERM_ADDR
+	.get_perm_addr		= ethtool_op_get_perm_addr,
+#endif
+	.get_coalesce		= ixgbe_get_coalesce,
+	.set_coalesce		= ixgbe_set_coalesce,
+#ifdef ETHTOOL_COALESCE_USECS
+	.supported_coalesce_params = ETHTOOL_COALESCE_USECS,
+#endif
+#ifndef HAVE_NDO_SET_FEATURES
+	.get_rx_csum		= ixgbe_get_rx_csum,
+	.set_rx_csum		= ixgbe_set_rx_csum,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+	.set_tx_csum		= ixgbe_set_tx_csum,
+	.get_sg			= ethtool_op_get_sg,
+	.set_sg			= ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+	.get_tso		= ethtool_op_get_tso,
+	.set_tso		= ixgbe_set_tso,
+#endif
+#ifdef ETHTOOL_GFLAGS
+	.get_flags		= ethtool_op_get_flags,
+	.set_flags		= ixgbe_set_flags,
+#endif
+#endif /* HAVE_NDO_SET_FEATURES */
+#ifdef ETHTOOL_GRXRINGS
 	.get_rxnfc		= ixgbe_get_rxnfc,
 	.set_rxnfc		= ixgbe_set_rxnfc,
+#ifdef ETHTOOL_SRXNTUPLE
+	.set_rx_ntuple		= ixgbe_set_rx_ntuple,
+#endif
+#endif /* ETHTOOL_GRXRINGS */
+#ifndef HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT
+#ifdef ETHTOOL_GEEE
+	.get_eee		= ixgbe_get_eee,
+#endif /* ETHTOOL_GEEE */
+#ifdef ETHTOOL_SEEE
+	.set_eee		= ixgbe_set_eee,
+#endif /* ETHTOOL_SEEE */
+#ifdef ETHTOOL_SCHANNELS
+	.get_channels		= ixgbe_get_channels,
+	.set_channels		= ixgbe_set_channels,
+#endif
+#ifdef ETHTOOL_GMODULEINFO
+	.get_module_info	= ixgbe_get_module_info,
+	.get_module_eeprom	= ixgbe_get_module_eeprom,
+#endif
+#ifdef HAVE_ETHTOOL_GET_TS_INFO
+	.get_ts_info		= ixgbe_get_ts_info,
+#endif
+#if defined(ETHTOOL_GRSSH) && defined(ETHTOOL_SRSSH)
 	.get_rxfh_indir_size	= ixgbe_rss_indir_size,
 	.get_rxfh_key_size	= ixgbe_get_rxfh_key_size,
 	.get_rxfh		= ixgbe_get_rxfh,
 	.set_rxfh		= ixgbe_set_rxfh,
-	.get_eee		= ixgbe_get_eee,
-	.set_eee		= ixgbe_set_eee,
+#endif /* ETHTOOL_GRSSH && ETHTOOL_SRSSH */
+#endif /* HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT */
+};
+
+#ifdef HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT
+static const struct ethtool_ops_ext ixgbe_ethtool_ops_ext = {
+	.size			= sizeof(struct ethtool_ops_ext),
+	.get_ts_info		= ixgbe_get_ts_info,
+	.set_phys_id		= ixgbe_set_phys_id,
 	.get_channels		= ixgbe_get_channels,
 	.set_channels		= ixgbe_set_channels,
-	.get_priv_flags		= ixgbe_get_priv_flags,
-	.set_priv_flags		= ixgbe_set_priv_flags,
-	.get_ts_info		= ixgbe_get_ts_info,
+#ifdef ETHTOOL_GMODULEINFO
 	.get_module_info	= ixgbe_get_module_info,
 	.get_module_eeprom	= ixgbe_get_module_eeprom,
-	.get_link_ksettings     = ixgbe_get_link_ksettings,
-	.set_link_ksettings     = ixgbe_set_link_ksettings,
+#endif
+#if defined(ETHTOOL_GRSSH) && defined(ETHTOOL_SRSSH)
+	.get_rxfh_indir_size	= ixgbe_rss_indir_size,
+	.get_rxfh_key_size	= ixgbe_get_rxfh_key_size,
+	.get_rxfh		= ixgbe_get_rxfh,
+	.set_rxfh		= ixgbe_set_rxfh,
+#endif /* ETHTOOL_GRSSH && ETHTOOL_SRSSH */
+#ifdef ETHTOOL_GEEE
+	.get_eee		= ixgbe_get_eee,
+#endif /* ETHTOOL_GEEE */
+#ifdef ETHTOOL_SEEE
+	.set_eee		= ixgbe_set_eee,
+#endif /* ETHTOOL_SEEE */
 };
 
+#endif /* HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT */
 void ixgbe_set_ethtool_ops(struct net_device *netdev)
 {
+#ifndef ETHTOOL_OPS_COMPAT
 	netdev->ethtool_ops = &ixgbe_ethtool_ops;
+#else
+	SET_ETHTOOL_OPS(netdev, &ixgbe_ethtool_ops);
+#endif
+
+#ifdef HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT
+	set_ethtool_ops_ext(netdev, &ixgbe_ethtool_ops_ext);
+#endif /* HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT */
 }
+#endif /* SIOCETHTOOL */
+
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
index 0fcd82036d4e..79ed5068bb08 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.c
@@ -1,11 +1,13 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #include "ixgbe.h"
+
+#if IS_ENABLED(CONFIG_FCOE)
+#if IS_ENABLED(CONFIG_DCB)
+#include "ixgbe_dcb_82599.h"
+#endif /* CONFIG_DCB */
 #include <linux/if_ether.h>
-#include <linux/gfp.h>
-#include <linux/if_vlan.h>
-#include <generated/utsrelease.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/fc/fc_fs.h>
@@ -43,72 +45,76 @@ static inline void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)
  */
 int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)
 {
-	int len;
+	int len = 0;
 	struct ixgbe_fcoe *fcoe;
 	struct ixgbe_adapter *adapter;
-	struct ixgbe_fcoe_ddp *ddp;
 	struct ixgbe_hw *hw;
+	struct ixgbe_fcoe_ddp *ddp;
 	u32 fcbuff;
 
 	if (!netdev)
-		return 0;
+		goto out_ddp_put;
 
-	if (xid >= netdev->fcoe_ddp_xid)
-		return 0;
+	if (xid > netdev->fcoe_ddp_xid)
+		goto out_ddp_put;
 
 	adapter = netdev_priv(netdev);
+	hw = &adapter->hw;
 	fcoe = &adapter->fcoe;
 	ddp = &fcoe->ddp[xid];
 	if (!ddp->udl)
-		return 0;
+		goto out_ddp_put;
 
-	hw = &adapter->hw;
 	len = ddp->len;
-	/* if no error then skip ddp context invalidation */
-	if (!ddp->err)
-		goto skip_ddpinv;
-
-	if (hw->mac.type == ixgbe_mac_X550) {
-		/* X550 does not require DDP FCoE lock */
-
-		IXGBE_WRITE_REG(hw, IXGBE_FCDFC(0, xid), 0);
-		IXGBE_WRITE_REG(hw, IXGBE_FCDFC(3, xid),
-				(xid | IXGBE_FCFLTRW_WE));
-
-		/* program FCBUFF */
-		IXGBE_WRITE_REG(hw, IXGBE_FCDDC(2, xid), 0);
-
-		/* program FCDMARW */
-		IXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),
-				(xid | IXGBE_FCDMARW_WE));
-
-		/* read FCBUFF to check context invalidated */
-		IXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),
-				(xid | IXGBE_FCDMARW_RE));
-		fcbuff = IXGBE_READ_REG(hw, IXGBE_FCDDC(2, xid));
-	} else {
-		/* other hardware requires DDP FCoE lock */
-		spin_lock_bh(&fcoe->lock);
-		IXGBE_WRITE_REG(hw, IXGBE_FCFLT, 0);
-		IXGBE_WRITE_REG(hw, IXGBE_FCFLTRW,
-				(xid | IXGBE_FCFLTRW_WE));
-		IXGBE_WRITE_REG(hw, IXGBE_FCBUFF, 0);
-		IXGBE_WRITE_REG(hw, IXGBE_FCDMARW,
-				(xid | IXGBE_FCDMARW_WE));
-
-		/* guaranteed to be invalidated after 100us */
-		IXGBE_WRITE_REG(hw, IXGBE_FCDMARW,
-				(xid | IXGBE_FCDMARW_RE));
-		fcbuff = IXGBE_READ_REG(hw, IXGBE_FCBUFF);
-		spin_unlock_bh(&fcoe->lock);
+	/* if there an error, force to invalidate ddp context */
+	if (ddp->err) {
+		switch (hw->mac.type) {
+		case ixgbe_mac_X550:
+			/* X550 does not require DDP FCoE lock */
+
+			IXGBE_WRITE_REG(hw, IXGBE_FCDFC(0, xid), 0);
+			IXGBE_WRITE_REG(hw, IXGBE_FCDFC(3, xid),
+					(xid | IXGBE_FCFLTRW_WE));
+
+			/* program FCBUFF */
+			IXGBE_WRITE_REG(hw, IXGBE_FCDDC(2, xid), 0);
+
+			/* program FCDMARW */
+			IXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),
+					(xid | IXGBE_FCDMARW_WE));
+
+			/* read FCBUFF to check context invalidated */
+			IXGBE_WRITE_REG(hw, IXGBE_FCDDC(3, xid),
+					(xid | IXGBE_FCDMARW_RE));
+			fcbuff = IXGBE_READ_REG(hw,
+						 IXGBE_FCDDC(2, xid));
+			break;
+		default:
+			/* other hardware requires DDP FCoE lock */
+			spin_lock_bh(&fcoe->lock);
+
+			IXGBE_WRITE_REG(hw, IXGBE_FCFLT, 0);
+			IXGBE_WRITE_REG(hw, IXGBE_FCFLTRW,
+					(xid | IXGBE_FCFLTRW_WE));
+			IXGBE_WRITE_REG(hw, IXGBE_FCBUFF, 0);
+			IXGBE_WRITE_REG(hw, IXGBE_FCDMARW,
+					(xid | IXGBE_FCDMARW_WE));
+
+			/* read FCBUFF to check context invalidated */
+			IXGBE_WRITE_REG(hw, IXGBE_FCDMARW,
+					(xid | IXGBE_FCDMARW_RE));
+			fcbuff = IXGBE_READ_REG(hw, IXGBE_FCBUFF);
+
+			spin_unlock_bh(&fcoe->lock);
+			break;
 		}
 
-	if (fcbuff & IXGBE_FCBUFF_VALID)
-		usleep_range(100, 150);
-
-skip_ddpinv:
+		/* guaranteed to be invalidated after 100us */
+		if (fcbuff & IXGBE_FCBUFF_VALID)
+			udelay(100);
+	}
 	if (ddp->sgl)
-		dma_unmap_sg(&adapter->pdev->dev, ddp->sgl, ddp->sgc,
+		dma_unmap_sg(pci_dev_to_dev(adapter->pdev), ddp->sgl, ddp->sgc,
 			     DMA_FROM_DEVICE);
 	if (ddp->pool) {
 		dma_pool_free(ddp->pool, ddp->udl, ddp->udp);
@@ -117,6 +123,7 @@ int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid)
 
 	ixgbe_fcoe_clear_ddp(ddp);
 
+out_ddp_put:
 	return len;
 }
 
@@ -150,11 +157,11 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 	u32 fcbuff, fcdmarw, fcfltrw, fcrxctl;
 	dma_addr_t addr = 0;
 
-	if (!netdev || !sgl)
+	if (!netdev || !sgl || !sgc)
 		return 0;
 
 	adapter = netdev_priv(netdev);
-	if (xid >= netdev->fcoe_ddp_xid) {
+	if (xid > netdev->fcoe_ddp_xid) {
 		e_warn(drv, "xid=0x%x out-of-range\n", xid);
 		return 0;
 	}
@@ -168,7 +175,7 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 	ddp = &fcoe->ddp[xid];
 	if (ddp->sgl) {
 		e_err(drv, "xid 0x%x w/ non-null sgl=%p nents=%d\n",
-		      xid, ddp->sgl, ddp->sgc);
+			xid, ddp->sgl, ddp->sgc);
 		return 0;
 	}
 	ixgbe_fcoe_clear_ddp(ddp);
@@ -186,14 +193,14 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 	}
 
 	/* setup dma from scsi command sgl */
-	dmacount = dma_map_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);
+	dmacount = dma_map_sg(pci_dev_to_dev(adapter->pdev), sgl, sgc, DMA_FROM_DEVICE);
 	if (dmacount == 0) {
 		e_err(drv, "xid 0x%x DMA map error\n", xid);
 		goto out_noddp;
 	}
 
 	/* alloc the udl from per cpu ddp pool */
-	ddp->udl = dma_pool_alloc(ddp_pool->pool, GFP_ATOMIC, &ddp->udp);
+	ddp->udl = dma_pool_alloc(ddp_pool->pool, GFP_KERNEL, &ddp->udp);
 	if (!ddp->udl) {
 		e_err(drv, "failed allocated ddp context\n");
 		goto out_noddp_unmap;
@@ -244,8 +251,9 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 	lastsize = thisoff + thislen;
 
 	/*
-	 * lastsize can not be buffer len.
+	 * lastsize can not be bufflen.
 	 * If it is then adding another buffer with lastsize = 1.
+	 * Since lastsize is 1 there will be no HW access to this buffer.
 	 */
 	if (lastsize == bufflen) {
 		if (j >= IXGBE_BUFFCNT_MAX) {
@@ -286,7 +294,8 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 		IXGBE_WRITE_REG(hw, IXGBE_FCRXCTRL, fcrxctl);
 	}
 
-	if (hw->mac.type == ixgbe_mac_X550) {
+	switch (hw->mac.type) {
+	case ixgbe_mac_X550:
 		/* X550 does not require DDP lock */
 
 		IXGBE_WRITE_REG(hw, IXGBE_FCDDC(0, xid),
@@ -298,8 +307,14 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 		IXGBE_WRITE_REG(hw, IXGBE_FCDFC(0, xid), IXGBE_FCFLT_VALID);
 		IXGBE_WRITE_REG(hw, IXGBE_FCDFC(1, xid), 0);
 		IXGBE_WRITE_REG(hw, IXGBE_FCDFC(3, xid), fcfltrw);
-	} else {
-		/* DDP lock for indirect DDP context access */
+		/*
+		 * TBD: SMAC and FCID info not available with current
+		 * netdev APIs, add code to pull that from skb later
+		 * and then program that here before enabling DDP context.
+		 */
+		break;
+	default:
+		/* other devices require DDP lock with direct DDP context access */
 		spin_lock_bh(&fcoe->lock);
 
 		IXGBE_WRITE_REG(hw, IXGBE_FCPTRL, ddp->udp & DMA_BIT_MASK(32));
@@ -312,6 +327,7 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 		IXGBE_WRITE_REG(hw, IXGBE_FCFLTRW, fcfltrw);
 
 		spin_unlock_bh(&fcoe->lock);
+		break;
 	}
 
 	return 1;
@@ -321,7 +337,7 @@ static int ixgbe_fcoe_ddp_setup(struct net_device *netdev, u16 xid,
 	ixgbe_fcoe_clear_ddp(ddp);
 
 out_noddp_unmap:
-	dma_unmap_sg(&adapter->pdev->dev, sgl, sgc, DMA_FROM_DEVICE);
+	dma_unmap_sg(pci_dev_to_dev(adapter->pdev), sgl, sgc, DMA_FROM_DEVICE);
 out_noddp:
 	put_cpu();
 	return 0;
@@ -347,6 +363,7 @@ int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,
 	return ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 0);
 }
 
+#ifdef HAVE_NETDEV_OPS_FCOE_DDP_TARGET
 /**
  * ixgbe_fcoe_ddp_target - called to set up ddp context in target mode
  * @netdev: the corresponding net_device
@@ -363,11 +380,12 @@ int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,
  * Returns : 1 for success and 0 for no ddp
  */
 int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,
-			    struct scatterlist *sgl, unsigned int sgc)
+			  struct scatterlist *sgl, unsigned int sgc)
 {
 	return ixgbe_fcoe_ddp_setup(netdev, xid, sgl, sgc, 1);
 }
 
+#endif /* HAVE_NETDEV_OPS_FCOE_DDP_TARGET */
 /**
  * ixgbe_fcoe_ddp - check ddp status and mark it done
  * @adapter: ixgbe adapter
@@ -376,7 +394,7 @@ int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,
  *
  * This checks ddp status.
  *
- * Returns : < 0 indicates an error or not a FCiE ddp, 0 indicates
+ * Returns : < 0 indicates an error or not a FCoE ddp, 0 indicates
  * not passing the skb to ULD, > 0 indicates is the length of data
  * being ddped.
  */
@@ -384,14 +402,12 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 		   union ixgbe_adv_rx_desc *rx_desc,
 		   struct sk_buff *skb)
 {
-	int rc = -EINVAL;
-	struct ixgbe_fcoe *fcoe;
+	struct ixgbe_fcoe *fcoe = &adapter->fcoe;
 	struct ixgbe_fcoe_ddp *ddp;
 	struct fc_frame_header *fh;
-	struct fcoe_crc_eof *crc;
+	int rc = -EINVAL, ddp_max;
 	__le32 fcerr = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCERR);
 	__le32 ddp_err;
-	int ddp_max;
 	u32 fctl;
 	u16 xid;
 
@@ -400,35 +416,36 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 	else
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-	if (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q))
-		fh = (struct fc_frame_header *)(skb->data +
-			sizeof(struct vlan_hdr) + sizeof(struct fcoe_hdr));
-	else
-		fh = (struct fc_frame_header *)(skb->data +
-			sizeof(struct fcoe_hdr));
+	/* verify header contains at least the FCOE header */
+	BUG_ON(skb_headlen(skb) < FCOE_HEADER_LEN);
+
+	fh = (struct fc_frame_header *)(skb->data + sizeof(struct fcoe_hdr));
+
+	if (skb->protocol == htons(ETH_P_8021Q))
+		fh = (struct fc_frame_header *)((char *)fh + VLAN_HLEN);
 
 	fctl = ntoh24(fh->fh_f_ctl);
 	if (fctl & FC_FC_EX_CTX)
-		xid =  be16_to_cpu(fh->fh_ox_id);
+		xid =  ntohs(fh->fh_ox_id);
 	else
-		xid =  be16_to_cpu(fh->fh_rx_id);
+		xid =  ntohs(fh->fh_rx_id);
 
 	ddp_max = IXGBE_FCOE_DDP_MAX;
 	/* X550 has different DDP Max limit */
 	if (adapter->hw.mac.type == ixgbe_mac_X550)
 		ddp_max = IXGBE_FCOE_DDP_MAX_X550;
+
 	if (xid >= ddp_max)
-		return -EINVAL;
+		goto ddp_out;
 
-	fcoe = &adapter->fcoe;
 	ddp = &fcoe->ddp[xid];
 	if (!ddp->udl)
-		return -EINVAL;
+		goto ddp_out;
 
 	ddp_err = ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_FCEOFE |
 					      IXGBE_RXDADV_ERR_FCERR);
 	if (ddp_err)
-		return -EINVAL;
+		goto ddp_out;
 
 	switch (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_STAT_FCSTAT)) {
 	/* return 0 to bypass going to ULD for DDPed data */
@@ -439,12 +456,12 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 		break;
 	/* unmap the sg list when FCPRSP is received */
 	case cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_FCPRSP):
-		dma_unmap_sg(&adapter->pdev->dev, ddp->sgl,
+		dma_unmap_sg(pci_dev_to_dev(adapter->pdev), ddp->sgl,
 			     ddp->sgc, DMA_FROM_DEVICE);
-		ddp->err = (__force u32)ddp_err;
+		ddp->err = ddp_err;
 		ddp->sgl = NULL;
 		ddp->sgc = 0;
-		fallthrough;
+		/* fall through */
 	/* if DDP length is present pass it through to ULD */
 	case cpu_to_le32(IXGBE_RXDADV_STAT_FCSTAT_NODDP):
 		/* update length of DDPed data */
@@ -467,11 +484,12 @@ int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
 	 */
 	if ((fh->fh_r_ctl == FC_RCTL_DD_SOL_DATA) &&
 	    (fctl & FC_FC_END_SEQ)) {
+		struct fcoe_crc_eof *crc;
 		skb_linearize(skb);
-		crc = skb_put(skb, sizeof(*crc));
+		crc = (struct fcoe_crc_eof *)skb_put(skb, sizeof(*crc));
 		crc->fcoe_eof = FC_EOF_T;
 	}
-
+ddp_out:
 	return rc;
 }
 
@@ -494,15 +512,17 @@ int ixgbe_fso(struct ixgbe_ring *tx_ring,
 	u32 vlan_macip_lens;
 	u32 fcoe_sof_eof = 0;
 	u32 mss_l4len_idx;
-	u32 type_tucmd = IXGBE_ADVTXT_TUCMD_FCOE;
 	u8 sof, eof;
+	u32 type_tucmd = IXGBE_ADVTXT_TUCMD_FCOE;
 
-	if (skb_is_gso(skb) && (skb_shinfo(skb)->gso_type != SKB_GSO_FCOE)) {
-		dev_err(tx_ring->dev, "Wrong gso type %d:expecting SKB_GSO_FCOE\n",
-			skb_shinfo(skb)->gso_type);
+#ifdef NETIF_F_FSO
+	if (skb_is_gso(skb) && skb_shinfo(skb)->gso_type != SKB_GSO_FCOE) {
+		dev_err(tx_ring->dev, "Wrong gso type %d:expecting "
+			"SKB_GSO_FCOE\n", skb_shinfo(skb)->gso_type);
 		return -EINVAL;
 	}
 
+#endif
 	/* resets the header to point fcoe/fc */
 	skb_set_network_header(skb, skb->mac_len);
 	skb_set_transport_header(skb, skb->mac_len +
@@ -612,7 +632,7 @@ static int ixgbe_fcoe_dma_pool_alloc(struct ixgbe_fcoe *fcoe,
 	struct dma_pool *pool;
 	char pool_name[32];
 
-	snprintf(pool_name, 32, "ixgbe_fcoe_ddp_%u", cpu);
+	snprintf(pool_name, 32, "ixgbe_fcoe_ddp_%d", cpu);
 
 	pool = dma_pool_create(pool_name, dev, IXGBE_FCPTR_MAX,
 			       IXGBE_FCPTR_ALIGN, PAGE_SIZE);
@@ -639,11 +659,12 @@ void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_ring_feature *fcoe = &adapter->ring_feature[RING_F_FCOE];
 	struct ixgbe_hw *hw = &adapter->hw;
-	int i, fcoe_q, fcoe_i, fcoe_q_h = 0;
-	int fcreta_size;
+	int i, fcoe_i;
+	u32 fcoe_q, fcoe_q_h = 0;
 	u32 etqf;
+	int fcreta_size;
 
-	/* Minimal functionality for FCoE requires at least CRC offloads */
+	/* Minimal funcionality for FCoE requires at least CRC offloads */
 	if (!(adapter->netdev->features & NETIF_F_FCOE_CRC))
 		return;
 
@@ -656,7 +677,7 @@ void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)
 	IXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FCOE), etqf);
 	IXGBE_WRITE_REG(hw, IXGBE_ETQS(IXGBE_ETQF_FILTER_FCOE), 0);
 
-	/* leave registers un-configured if FCoE is disabled */
+	/* leave remaining registers unconfigued if FCoE is disabled */
 	if (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
 		return;
 
@@ -673,9 +694,9 @@ void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter)
 			fcoe_q_h = (fcoe_q_h << IXGBE_FCRETA_ENTRY_HIGH_SHIFT) &
 				   IXGBE_FCRETA_ENTRY_HIGH_MASK;
 		}
-
 		fcoe_i = fcoe->offset + (i % fcoe->indices);
-		fcoe_i &= IXGBE_FCRETA_ENTRY_MASK;
+		if (fcoe_i >= MAX_RX_QUEUES)
+			fcoe_i = MAX_RX_QUEUES - 1;
 		fcoe_q = adapter->rx_ring[fcoe_i]->reg_idx;
 		fcoe_q |= fcoe_q_h;
 		IXGBE_WRITE_REG(hw, IXGBE_FCRETA(i), fcoe_q);
@@ -730,7 +751,7 @@ void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
 	for_each_possible_cpu(cpu)
 		ixgbe_fcoe_dma_pool_free(fcoe, cpu);
 
-	dma_unmap_single(&adapter->pdev->dev,
+	dma_unmap_single(pci_dev_to_dev(adapter->pdev),
 			 fcoe->extra_ddp_buffer_dma,
 			 IXGBE_FCBUFF_MIN,
 			 DMA_FROM_DEVICE);
@@ -751,7 +772,7 @@ void ixgbe_free_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
 int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_fcoe *fcoe = &adapter->fcoe;
-	struct device *dev = &adapter->pdev->dev;
+	struct device *dev = pci_dev_to_dev(adapter->pdev);
 	void *buffer;
 	dma_addr_t dma;
 	unsigned int cpu;
@@ -762,8 +783,10 @@ int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
 
 	/* Extra buffer to be shared by all DDPs for HW work around */
 	buffer = kmalloc(IXGBE_FCBUFF_MIN, GFP_KERNEL);
-	if (!buffer)
+	if (!buffer) {
+		e_err(drv, "failed to allocate extra DDP buffer\n");
 		return -ENOMEM;
+	}
 
 	dma = dma_map_single(dev, buffer, IXGBE_FCBUFF_MIN, DMA_FROM_DEVICE);
 	if (dma_mapping_error(dev, dma)) {
@@ -789,7 +812,11 @@ int ixgbe_setup_fcoe_ddp_resources(struct ixgbe_adapter *adapter)
 	return 0;
 }
 
+#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE
+int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)
+#else
 static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)
+#endif
 {
 	struct ixgbe_fcoe *fcoe = &adapter->fcoe;
 
@@ -804,6 +831,7 @@ static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)
 	}
 
 	adapter->netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;
+
 	/* X550 has different DDP Max limit */
 	if (adapter->hw.mac.type == ixgbe_mac_X550)
 		adapter->netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX_X550 - 1;
@@ -811,7 +839,11 @@ static int ixgbe_fcoe_ddp_enable(struct ixgbe_adapter *adapter)
 	return 0;
 }
 
+#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE
+void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)
+#else
 static void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)
+#endif
 {
 	struct ixgbe_fcoe *fcoe = &adapter->fcoe;
 
@@ -824,6 +856,7 @@ static void ixgbe_fcoe_ddp_disable(struct ixgbe_adapter *adapter)
 	fcoe->ddp_pool = NULL;
 }
 
+#ifdef HAVE_NETDEV_OPS_FCOE_ENABLE
 /**
  * ixgbe_fcoe_enable - turn on FCoE offload feature
  * @netdev: the corresponding netdev
@@ -911,7 +944,28 @@ int ixgbe_fcoe_disable(struct net_device *netdev)
 
 	return 0;
 }
+#endif /* HAVE_NETDEV_OPS_FCOE_ENABLE */
 
+#if IS_ENABLED(CONFIG_DCB)
+#ifdef HAVE_DCBNL_OPS_GETAPP
+/**
+ * ixgbe_fcoe_getapp - retrieves current user priority bitmap for FCoE
+ * @netdev: the corresponding net_device
+ *
+ * Finds out the corresponding user priority bitmap from the current
+ * traffic class that FCoE belongs to. Returns 0 as the invalid user
+ * priority bitmap to indicate an error.
+ *
+ * Returns : 802.1p user priority bitmap for FCoE
+ */
+u8 ixgbe_fcoe_getapp(struct net_device *netdev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	return 1 << adapter->fcoe.up;
+}
+#endif /* HAVE_DCBNL_OPS_GETAPP */
+#endif /* CONFIG_DCB */
+#ifdef HAVE_NETDEV_OPS_FCOE_GETWWN
 /**
  * ixgbe_fcoe_get_wwn - get world wide name for the node or the port
  * @netdev : ixgbe adapter
@@ -926,6 +980,7 @@ int ixgbe_fcoe_disable(struct net_device *netdev)
  */
 int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)
 {
+	int rc = -EINVAL;
 	u16 prefix = 0xffff;
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_mac_info *mac = &adapter->hw.mac;
@@ -950,87 +1005,12 @@ int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type)
 		       ((u64) mac->san_addr[3] << 16) |
 		       ((u64) mac->san_addr[4] << 8)  |
 		       ((u64) mac->san_addr[5]);
-		return 0;
-	}
-	return -EINVAL;
-}
-
-/**
- * ixgbe_fcoe_get_hbainfo - get FCoE HBA information
- * @netdev : ixgbe adapter
- * @info : HBA information
- *
- * Returns ixgbe HBA information
- *
- * Returns : 0 on success
- */
-int ixgbe_fcoe_get_hbainfo(struct net_device *netdev,
-			   struct netdev_fcoe_hbainfo *info)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw *hw = &adapter->hw;
-	u64 dsn;
-
-	if (!info)
-		return -EINVAL;
-
-	/* Don't return information on unsupported devices */
-	if (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
-		return -EINVAL;
-
-	/* Manufacturer */
-	snprintf(info->manufacturer, sizeof(info->manufacturer),
-		 "Intel Corporation");
-
-	/* Serial Number */
-
-	/* Get the PCI-e Device Serial Number Capability */
-	dsn = pci_get_dsn(adapter->pdev);
-	if (dsn)
-		snprintf(info->serial_number, sizeof(info->serial_number),
-			 "%016llX", dsn);
-	else
-		snprintf(info->serial_number, sizeof(info->serial_number),
-			 "Unknown");
-
-	/* Hardware Version */
-	snprintf(info->hardware_version,
-		 sizeof(info->hardware_version),
-		 "Rev %d", hw->revision_id);
-	/* Driver Name/Version */
-	snprintf(info->driver_version,
-		 sizeof(info->driver_version),
-		 "%s v%s",
-		 ixgbe_driver_name,
-		 UTS_RELEASE);
-	/* Firmware Version */
-	strlcpy(info->firmware_version, adapter->eeprom_id,
-		sizeof(info->firmware_version));
-
-	/* Model */
-	if (hw->mac.type == ixgbe_mac_82599EB) {
-		snprintf(info->model,
-			 sizeof(info->model),
-			 "Intel 82599");
-	} else if (hw->mac.type == ixgbe_mac_X550) {
-		snprintf(info->model,
-			 sizeof(info->model),
-			 "Intel X550");
-	} else {
-		snprintf(info->model,
-			 sizeof(info->model),
-			 "Intel X540");
+		rc = 0;
 	}
-
-	/* Model Description */
-	snprintf(info->model_description,
-		 sizeof(info->model_description),
-		 "%s",
-		 ixgbe_default_device_descr);
-
-	return 0;
+	return rc;
 }
 
+#endif /* HAVE_NETDEV_OPS_FCOE_GETWWN */
 /**
  * ixgbe_fcoe_get_tc - get the current TC that fcoe is mapped to
  * @adapter: pointer to the device adapter structure
@@ -1039,9 +1019,6 @@ int ixgbe_fcoe_get_hbainfo(struct net_device *netdev,
  */
 u8 ixgbe_fcoe_get_tc(struct ixgbe_adapter *adapter)
 {
-#ifdef CONFIG_IXGBE_DCB
 	return netdev_get_prio_tc_map(adapter->netdev, adapter->fcoe.up);
-#else
-	return 0;
-#endif
 }
+#endif /* CONFIG_FCOE */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h
index 724f5382329f..32ce69ad50b7 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_fcoe.h
@@ -1,8 +1,10 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#ifndef _IXGBE_FCOE_H
-#define _IXGBE_FCOE_H
+#ifndef _IXGBE_FCOE_H_
+#define _IXGBE_FCOE_H_
+
+#if IS_ENABLED(CONFIG_FCOE)
 
 #include <scsi/fc/fc_fs.h>
 #include <scsi/fc/fc_fcoe.h>
@@ -13,7 +15,7 @@
 /* ddp user buffer */
 #define IXGBE_BUFFCNT_MAX	256	/* 8 bits bufcnt */
 #define IXGBE_FCPTR_ALIGN	16
-#define IXGBE_FCPTR_MAX	(IXGBE_BUFFCNT_MAX * sizeof(dma_addr_t))
+#define IXGBE_FCPTR_MAX		(IXGBE_BUFFCNT_MAX * sizeof(dma_addr_t))
 #define IXGBE_FCBUFF_4KB	0x0
 #define IXGBE_FCBUFF_8KB	0x1
 #define IXGBE_FCBUFF_16KB	0x2
@@ -23,11 +25,16 @@
 #define IXGBE_FCOE_DDP_MAX	512	/* 9 bits xid */
 #define IXGBE_FCOE_DDP_MAX_X550	2048	/* 11 bits xid */
 
-/* Default traffic class to use for FCoE */
-#define IXGBE_FCOE_DEFTC	3
+/* Default user priority to use for FCoE */
+#define IXGBE_FCOE_DEFUP	3
 
 /* fcerr */
-#define IXGBE_FCERR_BADCRC       0x00100000
+#define IXGBE_FCERR_BADCRC	0x00100000
+#define IXGBE_FCERR_EOFSOF	0x00200000
+#define IXGBE_FCERR_NOFIRST	0x00300000
+#define IXGBE_FCERR_OOOSEQ	0x00400000
+#define IXGBE_FCERR_NODMA	0x00500000
+#define IXGBE_FCERR_PKTLOST	0x00600000
 
 /* FCoE DDP for target mode */
 #define __IXGBE_FCOE_TARGET	1
@@ -58,6 +65,8 @@ struct ixgbe_fcoe {
 	dma_addr_t extra_ddp_buffer_dma;
 	unsigned long mode;
 	u8 up;
+	u8 up_set;
 };
+#endif /* CONFIG_FCOE */
 
 #endif /* _IXGBE_FCOE_H */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.c
new file mode 100644
index 000000000000..79e2d35b403a
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.c
@@ -0,0 +1,206 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#include "ixgbe_hv_vf.h"
+
+/**
+ * Hyper-V variant - just a stub.
+ * @hw: unused
+ * @mc_addr_list: unused
+ * @mc_addr_count: unused
+ * @next: unused
+ * @clear: unused
+ */
+s32 ixgbevf_hv_update_mc_addr_list_vf(struct ixgbe_hw *hw, u8 *mc_addr_list,
+				 u32 mc_addr_count, ixgbe_mc_addr_itr next,
+				 bool clear)
+{
+	UNREFERENCED_5PARAMETER(hw, mc_addr_list, mc_addr_count, next, clear);
+
+	return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
+}
+
+/**
+ * Hyper-V variant - just a stub.
+ * @hw: unused
+ * @xcast_mode: unused
+ */
+s32 ixgbevf_hv_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode)
+{
+	UNREFERENCED_2PARAMETER(hw, xcast_mode);
+
+	return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
+}
+
+/**
+ * Hyper-V variant - just a stub.
+ * @hw: unused
+ * @vlan: unused
+ * @vind: unused
+ * @vlan_on: unused
+ * @vlvf_bypass: unused
+ */
+s32 ixgbevf_hv_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+				  bool vlan_on, bool vlvf_bypass)
+{
+	UNREFERENCED_5PARAMETER(hw, vlan, vind, vlan_on, vlvf_bypass);
+
+	return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
+}
+
+s32 ixgbevf_hv_set_uc_addr_vf(struct ixgbe_hw *hw, u32 index, u8 *addr)
+{
+	UNREFERENCED_3PARAMETER(hw, index, addr);
+
+	return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
+}
+
+/**
+ * Hyper-V variant; there is no mailbox communication.
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @link_up: true is link is up, false otherwise
+ * @autoneg_wait_to_complete: unused
+ *
+ */
+s32 ixgbevf_hv_check_mac_link_vf(struct ixgbe_hw *hw,
+					ixgbe_link_speed *speed,
+					bool *link_up,
+					bool autoneg_wait_to_complete)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	struct ixgbe_mac_info *mac = &hw->mac;
+	u32 links_reg;
+	UNREFERENCED_1PARAMETER(autoneg_wait_to_complete);
+
+	/* If we were hit with a reset drop the link */
+	if (!mbx->ops[0].check_for_rst(hw, 0) || !mbx->timeout)
+		mac->get_link_status = true;
+
+	if (!mac->get_link_status)
+		goto out;
+
+	/* if link status is down no point in checking to see if pf is up */
+	links_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);
+	if (!(links_reg & IXGBE_LINKS_UP))
+		goto out;
+
+	/* for SFP+ modules and DA cables on 82599 it can take up to 500usecs
+	 * before the link status is correct
+	 */
+	if (mac->type == ixgbe_mac_82599_vf) {
+		int i;
+
+		for (i = 0; i < 5; i++) {
+			udelay(100);
+			links_reg = IXGBE_READ_REG(hw, IXGBE_VFLINKS);
+
+			if (!(links_reg & IXGBE_LINKS_UP))
+				goto out;
+		}
+	}
+
+	switch (links_reg & IXGBE_LINKS_SPEED_82599) {
+	case IXGBE_LINKS_SPEED_10G_82599:
+		*speed = IXGBE_LINK_SPEED_10GB_FULL;
+		if (hw->mac.type >= ixgbe_mac_X550) {
+			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
+				*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
+		}
+		break;
+	case IXGBE_LINKS_SPEED_1G_82599:
+		*speed = IXGBE_LINK_SPEED_1GB_FULL;
+		break;
+	case IXGBE_LINKS_SPEED_100_82599:
+		*speed = IXGBE_LINK_SPEED_100_FULL;
+		if (hw->mac.type == ixgbe_mac_X550) {
+			if (links_reg & IXGBE_LINKS_SPEED_NON_STD)
+				*speed = IXGBE_LINK_SPEED_5GB_FULL;
+		}
+		break;
+	case IXGBE_LINKS_SPEED_10_X550EM_A:
+		*speed = IXGBE_LINK_SPEED_UNKNOWN;
+		/* Reserved for pre-x550 devices */
+		if (hw->mac.type >= ixgbe_mac_X550)
+			*speed = IXGBE_LINK_SPEED_10_FULL;
+		break;
+	default:
+		*speed = IXGBE_LINK_SPEED_UNKNOWN;
+	}
+
+	/* if we passed all the tests above then the link is up and we no
+	 * longer need to check for link
+	 */
+	mac->get_link_status = false;
+
+out:
+	*link_up = !mac->get_link_status;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbevf_hv_set_rlpml_vf - Set the maximum receive packet length
+ * @hw: pointer to the HW structure
+ * @max_size: value to assign to max frame size
+ * Hyper-V variant.
+ **/
+s32 ixgbevf_hv_set_rlpml_vf(struct ixgbe_hw *hw, u16 max_size)
+{
+	u32 reg;
+
+	/* If we are on Hyper-V, we implement this functionality
+	 * differently.
+	 */
+	reg =  IXGBE_READ_REG(hw, IXGBE_VFRXDCTL(0));
+	/* CRC == 4 */
+	reg |= ((max_size + 4) | IXGBE_RXDCTL_RLPML_EN);
+	IXGBE_WRITE_REG(hw, IXGBE_VFRXDCTL(0), reg);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbevf_hv_negotiate_api_version_vf - Negotiate supported API version
+ * @hw: pointer to the HW structure
+ * @api: integer containing requested API version
+ * Hyper-V version - only ixgbe_mbox_api_10 supported.
+ **/
+int ixgbevf_hv_negotiate_api_version_vf(struct ixgbe_hw *hw, int api)
+{
+	UNREFERENCED_1PARAMETER(hw);
+
+	/* Hyper-V only supports api version ixgbe_mbox_api_10 */
+	if (api != ixgbe_mbox_api_10)
+		return IXGBE_ERR_INVALID_ARGUMENT;
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbevf_hv_init_ops_vf - Initialize the pointers for vf
+ * @hw: pointer to hardware structure
+ *
+ * This will assign function pointers, adapter-specific functions can
+ * override the assignment of generic function pointers by assigning
+ * their own adapter-specific function pointers.
+ * Does not touch the hardware.
+ **/
+s32 ixgbevf_hv_init_ops_vf(struct ixgbe_hw *hw)
+{
+	/* Set defaults for VF then override applicable Hyper-V
+	 * specific functions
+	 */
+	ixgbe_init_ops_vf(hw);
+
+	hw->mac.ops.reset_hw = ixgbevf_hv_reset_hw_vf;
+	hw->mac.ops.check_link = ixgbevf_hv_check_mac_link_vf;
+	hw->mac.ops.negotiate_api_version = ixgbevf_hv_negotiate_api_version_vf;
+	hw->mac.ops.set_rar = ixgbevf_hv_set_rar_vf;
+	hw->mac.ops.update_mc_addr_list = ixgbevf_hv_update_mc_addr_list_vf;
+	hw->mac.ops.update_xcast_mode = ixgbevf_hv_update_xcast_mode;
+	hw->mac.ops.set_uc_addr = ixgbevf_hv_set_uc_addr_vf;
+	hw->mac.ops.set_vfta = ixgbevf_hv_set_vfta_vf;
+	hw->mac.ops.set_rlpml = ixgbevf_hv_set_rlpml_vf;
+
+	return IXGBE_SUCCESS;
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.h
new file mode 100644
index 000000000000..f035a574e58c
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_hv_vf.h
@@ -0,0 +1,30 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_HV_VF_H_
+#define _IXGBE_HV_VF_H_
+
+/* On Hyper-V, to reset, we need to read from this offset
+ * from the PCI config space. This is the mechanism used on
+ * Hyper-V to support PF/VF communication.
+ */
+#define IXGBE_HV_RESET_OFFSET           0x201
+
+#include "ixgbe_vf.h"
+
+s32 ixgbevf_hv_check_mac_link_vf(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+				 bool *link_up, bool autoneg_wait_to_complete);
+s32 ixgbevf_hv_set_uc_addr_vf(struct ixgbe_hw *hw, u32 index, u8 *addr);
+s32 ixgbevf_hv_update_mc_addr_list_vf(struct ixgbe_hw *hw, u8 *mc_addr_list,
+				      u32 mc_addr_count, ixgbe_mc_addr_itr,
+				      bool clear);
+s32 ixgbevf_hv_update_xcast_mode(struct ixgbe_hw *hw, int xcast_mode);
+s32 ixgbevf_hv_set_vfta_vf(struct ixgbe_hw *hw, u32 vlan, u32 vind,
+			   bool vlan_on, bool vlvf_bypass);
+s32 ixgbevf_hv_set_rlpml_vf(struct ixgbe_hw *hw, u16 max_size);
+int ixgbevf_hv_negotiate_api_version_vf(struct ixgbe_hw *hw, int api);
+
+extern s32 ixgbevf_hv_reset_hw_vf(struct ixgbe_hw *hw);
+extern s32 ixgbevf_hv_set_rar_vf(struct ixgbe_hw *hw, u32 index, u8 *addr,
+				 u32 vmdq, u32 enable_addr);
+#endif /* _IXGBE_HV_VF_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
index df389a11d3af..cb9e3fee75d9 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_lib.c
@@ -1,58 +1,83 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #include "ixgbe.h"
 #include "ixgbe_sriov.h"
 
-#ifdef CONFIG_IXGBE_DCB
+#ifdef HAVE_TX_MQ
 /**
- * ixgbe_cache_ring_dcb_sriov - Descriptor ring to register mapping for SR-IOV
+ * ixgbe_cache_ring_dcb_vmdq - Descriptor ring to register mapping for VMDq
  * @adapter: board private structure to initialize
  *
- * Cache the descriptor ring offsets for SR-IOV to the assigned rings.  It
+ * Cache the descriptor ring offsets for VMDq to the assigned rings.  It
  * will also try to cache the proper offsets if RSS/FCoE are enabled along
  * with VMDq.
  *
  **/
-static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter)
+static bool ixgbe_cache_ring_dcb_vmdq(struct ixgbe_adapter *adapter)
 {
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	struct ixgbe_ring_feature *fcoe = &adapter->ring_feature[RING_F_FCOE];
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	int i;
-	u16 reg_idx, pool;
-	u8 tcs = adapter->hw_tcs;
+	u16 reg_idx;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
 
-	/* verify we have DCB queueing enabled before proceeding */
+	/* verify we have DCB enabled before proceeding */
 	if (tcs <= 1)
 		return false;
 
 	/* verify we have VMDq enabled before proceeding */
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+	if (!(adapter->flags & IXGBE_FLAG_VMDQ_ENABLED))
 		return false;
 
-	/* start at VMDq register offset for SR-IOV enabled setups */
-	reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
-	for (i = 0, pool = 0; i < adapter->num_rx_queues; i++, reg_idx++) {
-		/* If we are greater than indices move to next pool */
-		if ((reg_idx & ~vmdq->mask) >= tcs) {
-			pool++;
-			reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask);
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82598EB:
+		/*
+		 * The bits on the 82598 are reversed compared to the other
+		 * adapters.  The DCB bits are the higher order bits and the
+		 * lower bits belong to the VMDq pool.  In order to sort
+		 * this out we have to swap the bits to get the correct layout
+		 */
+		for (i = 0; i < adapter->num_rx_queues; i++) {
+			reg_idx = ((i >> 3) | (i << 3)) & 0x3F;
+			adapter->rx_ring[i]->reg_idx = reg_idx;
+		}
+		for (i = 0; i < adapter->num_tx_queues; i++) {
+			reg_idx = ((i >> 4) | (i << 2)) & 0x1F;
+			adapter->tx_ring[i]->reg_idx = reg_idx;
+		}
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		/* start at VMDq register offset for SR-IOV enabled setups */
+		reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
+		for (i = 0; i < adapter->num_rx_queues; i++, reg_idx++) {
+			/* If we are greater than indices move to next pool */
+			if ((reg_idx & ~vmdq->mask) >= tcs) {
+				reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask);
+			}
+			adapter->rx_ring[i]->reg_idx = reg_idx;
 		}
-		adapter->rx_ring[i]->reg_idx = reg_idx;
-		adapter->rx_ring[i]->netdev = pool ? NULL : adapter->netdev;
-	}
 
-	reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
-	for (i = 0; i < adapter->num_tx_queues; i++, reg_idx++) {
-		/* If we are greater than indices move to next pool */
-		if ((reg_idx & ~vmdq->mask) >= tcs)
-			reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask);
-		adapter->tx_ring[i]->reg_idx = reg_idx;
+		reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
+		for (i = 0; i < adapter->num_tx_queues; i++, reg_idx++) {
+			/* If we are greater than indices move to next pool */
+			if ((reg_idx & ~vmdq->mask) >= tcs)
+				reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask);
+			adapter->tx_ring[i]->reg_idx = reg_idx;
+		}
+
+		break;
+	default:
+		break;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* nothing to do if FCoE is disabled */
 	if (!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
 		return true;
@@ -70,7 +95,6 @@ static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter)
 		for (i = fcoe->offset; i < adapter->num_rx_queues; i++) {
 			reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask) + fcoe_tc;
 			adapter->rx_ring[i]->reg_idx = reg_idx;
-			adapter->rx_ring[i]->netdev = adapter->netdev;
 			reg_idx++;
 		}
 
@@ -81,8 +105,8 @@ static bool ixgbe_cache_ring_dcb_sriov(struct ixgbe_adapter *adapter)
 			reg_idx++;
 		}
 	}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 	return true;
 }
 
@@ -91,7 +115,8 @@ static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc,
 				    unsigned int *tx, unsigned int *rx)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u8 num_tcs = adapter->hw_tcs;
+	struct net_device *dev = adapter->netdev;
+	u8 num_tcs = netdev_get_num_tc(dev);
 
 	*tx = 0;
 	*rx = 0;
@@ -106,7 +131,7 @@ static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+case ixgbe_mac_X550EM_a:
 		if (num_tcs > 4) {
 			/*
 			 * TCs    : TC0/1 TC2/3 TC4-7
@@ -146,11 +171,11 @@ static void ixgbe_get_first_reg_idx(struct ixgbe_adapter *adapter, u8 tc,
  **/
 static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter)
 {
-	u8 num_tcs = adapter->hw_tcs;
-	unsigned int tx_idx, rx_idx;
 	int tc, offset, rss_i, i;
+	unsigned int tx_idx, rx_idx;
+	struct net_device *dev = adapter->netdev;
+	u8 num_tcs = netdev_get_num_tc(dev);
 
-	/* verify we have DCB queueing enabled before proceeding */
 	if (num_tcs <= 1)
 		return false;
 
@@ -161,7 +186,6 @@ static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter)
 		for (i = 0; i < rss_i; i++, tx_idx++, rx_idx++) {
 			adapter->tx_ring[offset + i]->reg_idx = tx_idx;
 			adapter->rx_ring[offset + i]->reg_idx = rx_idx;
-			adapter->rx_ring[offset + i]->netdev = adapter->netdev;
 			adapter->tx_ring[offset + i]->dcb_tc = tc;
 			adapter->rx_ring[offset + i]->dcb_tc = tc;
 		}
@@ -170,23 +194,24 @@ static bool ixgbe_cache_ring_dcb(struct ixgbe_adapter *adapter)
 	return true;
 }
 
-#endif
+#endif /* HAVE_TX_MQ */
 /**
- * ixgbe_cache_ring_sriov - Descriptor ring to register mapping for sriov
+ * ixgbe_cache_ring_vmdq - Descriptor ring to register mapping for VMDq
  * @adapter: board private structure to initialize
  *
- * SR-IOV doesn't use any descriptor rings but changes the default if
- * no other mapping is used.
+ * Cache the descriptor ring offsets for VMDq to the assigned rings.  It
+ * will also try to cache the proper offsets if RSS/FCoE/SRIOV are enabled along
+ * with VMDq.
  *
- */
-static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter)
+ **/
+static bool ixgbe_cache_ring_vmdq(struct ixgbe_adapter *adapter)
 {
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	struct ixgbe_ring_feature *fcoe = &adapter->ring_feature[RING_F_FCOE];
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	struct ixgbe_ring_feature *rss = &adapter->ring_feature[RING_F_RSS];
-	u16 reg_idx, pool;
+	u16 reg_idx;
 	int i;
 
 	/* only proceed if VMDq is enabled */
@@ -194,34 +219,30 @@ static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter)
 		return false;
 
 	/* start at VMDq register offset for SR-IOV enabled setups */
-	pool = 0;
 	reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
 	for (i = 0; i < adapter->num_rx_queues; i++, reg_idx++) {
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		/* Allow first FCoE queue to be mapped as RSS */
 		if (fcoe->offset && (i > fcoe->offset))
 			break;
-#endif
+#endif /* CONFIG_FCOE */
 		/* If we are greater than indices move to next pool */
 		if ((reg_idx & ~vmdq->mask) >= rss->indices) {
-			pool++;
 			reg_idx = __ALIGN_MASK(reg_idx, ~vmdq->mask);
 		}
 		adapter->rx_ring[i]->reg_idx = reg_idx;
-		adapter->rx_ring[i]->netdev = pool ? NULL : adapter->netdev;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* FCoE uses a linear block of queues so just assigning 1:1 */
 	for (; i < adapter->num_rx_queues; i++, reg_idx++) {
 		adapter->rx_ring[i]->reg_idx = reg_idx;
-		adapter->rx_ring[i]->netdev = adapter->netdev;
 	}
+#endif /* CONFIG_FCOE */
 
-#endif
 	reg_idx = vmdq->offset * __ALIGN_MASK(1, ~vmdq->mask);
 	for (i = 0; i < adapter->num_tx_queues; i++, reg_idx++) {
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		/* Allow first FCoE queue to be mapped as RSS */
 		if (fcoe->offset && (i > fcoe->offset))
 			break;
@@ -232,12 +253,11 @@ static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter)
 		adapter->tx_ring[i]->reg_idx = reg_idx;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* FCoE uses a linear block of queues so just assigning 1:1 */
 	for (; i < adapter->num_tx_queues; i++, reg_idx++)
 		adapter->tx_ring[i]->reg_idx = reg_idx;
-
-#endif
+#endif /* CONFIG_FCOE */
 
 	return true;
 }
@@ -246,7 +266,7 @@ static bool ixgbe_cache_ring_sriov(struct ixgbe_adapter *adapter)
  * ixgbe_cache_ring_rss - Descriptor ring to register mapping for RSS
  * @adapter: board private structure to initialize
  *
- * Cache the descriptor ring offsets for RSS to the assigned rings.
+ * Cache the descriptor ring offsets for RSS, ATR, FCoE, and SR-IOV.
  *
  **/
 static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter)
@@ -255,7 +275,6 @@ static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter)
 
 	for (i = 0; i < adapter->num_rx_queues; i++) {
 		adapter->rx_ring[i]->reg_idx = i;
-		adapter->rx_ring[i]->netdev = adapter->netdev;
 	}
 	for (i = 0, reg_idx = 0; i < adapter->num_tx_queues; i++, reg_idx++)
 		adapter->tx_ring[i]->reg_idx = reg_idx;
@@ -278,19 +297,15 @@ static bool ixgbe_cache_ring_rss(struct ixgbe_adapter *adapter)
  **/
 static void ixgbe_cache_ring_register(struct ixgbe_adapter *adapter)
 {
-	/* start with default case */
-	adapter->rx_ring[0]->reg_idx = 0;
-	adapter->tx_ring[0]->reg_idx = 0;
-
-#ifdef CONFIG_IXGBE_DCB
-	if (ixgbe_cache_ring_dcb_sriov(adapter))
+#ifdef HAVE_TX_MQ
+	if (ixgbe_cache_ring_dcb_vmdq(adapter))
 		return;
 
 	if (ixgbe_cache_ring_dcb(adapter))
 		return;
 
 #endif
-	if (ixgbe_cache_ring_sriov(adapter))
+	if (ixgbe_cache_ring_vmdq(adapter))
 		return;
 
 	ixgbe_cache_ring_rss(adapter);
@@ -298,7 +313,11 @@ static void ixgbe_cache_ring_register(struct ixgbe_adapter *adapter)
 
 static int ixgbe_xdp_queues(struct ixgbe_adapter *adapter)
 {
+#ifdef HAVE_XDP_SUPPORT
 	return adapter->xdp_prog ? nr_cpu_ids : 0;
+#else
+	return 0;
+#endif
 }
 
 #define IXGBE_RSS_64Q_MASK	0x3F
@@ -308,57 +327,74 @@ static int ixgbe_xdp_queues(struct ixgbe_adapter *adapter)
 #define IXGBE_RSS_2Q_MASK	0x1
 #define IXGBE_RSS_DISABLED_MASK	0x0
 
-#ifdef CONFIG_IXGBE_DCB
+#ifdef HAVE_TX_MQ
 /**
- * ixgbe_set_dcb_sriov_queues: Allocate queues for SR-IOV devices w/ DCB
+ * ixgbe_set_dcb_vmdq_queues: Allocate queues for VMDq devices w/ DCB
  * @adapter: board private structure to initialize
  *
- * When SR-IOV (Single Root IO Virtualiztion) is enabled, allocate queues
+ * When VMDq (Virtual Machine Devices queue) is enabled, allocate queues
  * and VM pools where appropriate.  Also assign queues based on DCB
  * priorities and map accordingly..
  *
  **/
-static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
+static bool ixgbe_set_dcb_vmdq_queues(struct ixgbe_adapter *adapter)
 {
 	int i;
 	u16 vmdq_i = adapter->ring_feature[RING_F_VMDQ].limit;
 	u16 vmdq_m = 0;
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	u16 fcoe_i = 0;
 #endif
-	u8 tcs = adapter->hw_tcs;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
 
-	/* verify we have DCB queueing enabled before proceeding */
+	/* verify we have DCB enabled before proceeding */
 	if (tcs <= 1)
 		return false;
 
 	/* verify we have VMDq enabled before proceeding */
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+	if (!(adapter->flags & IXGBE_FLAG_VMDQ_ENABLED))
 		return false;
 
-	/* limit VMDq instances on the PF by number of Tx queues */
-	vmdq_i = min_t(u16, vmdq_i, MAX_TX_QUEUES / tcs);
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82598EB:
+		/* 4 pools w/ 8TC per pool */
+		vmdq_i = min_t(u16, vmdq_i, 4);
+		vmdq_m = 0x7;
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
 
-	/* Add starting offset to total pool count */
-	vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
+		/* Add starting offset to total pool count */
+		vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
 
-	/* 16 pools w/ 8 TC per pool */
-	if (tcs > 4) {
-		vmdq_i = min_t(u16, vmdq_i, 16);
-		vmdq_m = IXGBE_82599_VMDQ_8Q_MASK;
-	/* 32 pools w/ 4 TC per pool */
-	} else {
-		vmdq_i = min_t(u16, vmdq_i, 32);
-		vmdq_m = IXGBE_82599_VMDQ_4Q_MASK;
-	}
+		/* 16 pools w/ 8 TC per pool */
+		if (tcs > 4) {
+			vmdq_i = min_t(u16, vmdq_i, 16);
+			vmdq_m = IXGBE_82599_VMDQ_8Q_MASK;
+		/* 32 pools w/ 4 TC per pool */
+		} else {
+			vmdq_i = min_t(u16, vmdq_i, 32);
+			vmdq_m = IXGBE_82599_VMDQ_4Q_MASK;
+		}
 
-#ifdef IXGBE_FCOE
-	/* queues in the remaining pools are available for FCoE */
-	fcoe_i = (128 / __ALIGN_MASK(1, ~vmdq_m)) - vmdq_i;
+#if IS_ENABLED(CONFIG_FCOE)
+		/* queues in the remaining pools are available for FCoE */
+		fcoe_i = (128 / __ALIGN_MASK(1, ~vmdq_m)) - vmdq_i;
+#endif /* CONFIG_FCOE */
 
-#endif
-	/* remove the starting offset from the pool count */
-	vmdq_i -= adapter->ring_feature[RING_F_VMDQ].offset;
+		/* remove the starting offset from the pool count */
+		vmdq_i -= adapter->ring_feature[RING_F_VMDQ].offset;
+
+		break;
+	default:
+		/* unknown hardware, only support one pool w/ one queue */
+		vmdq_i = 1;
+		tcs = 1;
+		break;
+	}
 
 	/* save features for later use */
 	adapter->ring_feature[RING_F_VMDQ].indices = vmdq_i;
@@ -371,9 +407,6 @@ static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
 	adapter->ring_feature[RING_F_RSS].indices = 1;
 	adapter->ring_feature[RING_F_RSS].mask = IXGBE_RSS_DISABLED_MASK;
 
-	/* disable ATR as it is not supported when VMDq is enabled */
-	adapter->flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
-
 	adapter->num_rx_pools = vmdq_i;
 	adapter->num_rx_queues_per_pool = tcs;
 
@@ -381,7 +414,10 @@ static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
 	adapter->num_xdp_queues = 0;
 	adapter->num_rx_queues = vmdq_i * tcs;
 
-#ifdef IXGBE_FCOE
+	/* disable ATR as it is not supported when VMDq is enabled */
+	adapter->flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
+
+#if IS_ENABLED(CONFIG_FCOE)
 	if (adapter->flags & IXGBE_FLAG_FCOE_ENABLED) {
 		struct ixgbe_ring_feature *fcoe;
 
@@ -409,8 +445,8 @@ static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
 			fcoe->offset = 0;
 		}
 	}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 	/* configure TC to queue mapping */
 	for (i = 0; i < tcs; i++)
 		netdev_set_tc_queue(adapter->netdev, i, 1, i);
@@ -418,6 +454,17 @@ static bool ixgbe_set_dcb_sriov_queues(struct ixgbe_adapter *adapter)
 	return true;
 }
 
+/**
+ * ixgbe_set_dcb_queues: Allocate queues for a DCB-enabled device
+ * @adapter: board private structure to initialize
+ *
+ * When DCB (Data Center Bridging) is enabled, allocate queues for
+ * each traffic class.  If multiqueue isn't available,then abort DCB
+ * initialization.
+ *
+ * This function handles all combinations of DCB, RSS, and FCoE.
+ *
+ **/
 static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
 {
 	struct net_device *dev = adapter->netdev;
@@ -426,14 +473,17 @@ static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
 	int tcs;
 
 	/* Map queue offset and counts onto allocated tx queues */
-	tcs = adapter->hw_tcs;
+	tcs = netdev_get_num_tc(dev);
 
-	/* verify we have DCB queueing enabled before proceeding */
 	if (tcs <= 1)
 		return false;
 
 	/* determine the upper limit for our current DCB mode */
+#ifndef HAVE_NETDEV_SELECT_QUEUE
+	rss_i = adapter->indices;
+#else
 	rss_i = dev->num_tx_queues / tcs;
+#endif
 	if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
 		/* 8 TC w/ 4 queues per TC */
 		rss_i = min_t(u16, rss_i, 4);
@@ -450,16 +500,17 @@ static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
 
 	/* set RSS mask and indices */
 	f = &adapter->ring_feature[RING_F_RSS];
-	rss_i = min_t(int, rss_i, f->limit);
+	rss_i = min_t(u16, rss_i, f->limit);
 	f->indices = rss_i;
 	f->mask = rss_m;
 
-	/* disable ATR as it is not supported when multiple TCs are enabled */
+	/* disable ATR as it is not supported when DCB is enabled */
 	adapter->flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
 
-#ifdef IXGBE_FCOE
-	/* FCoE enabled queues require special configuration indexed
-	 * by feature specific indices and offset. Here we map FCoE
+#if IS_ENABLED(CONFIG_FCOE)
+	/*
+	 * FCoE enabled queues require special configuration indexed
+	 * by feature specific indices and mask. Here we map FCoE
 	 * indices onto the DCB queue pairs allowing FCoE to own
 	 * configuration later.
 	 */
@@ -470,8 +521,8 @@ static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
 		f->indices = min_t(u16, rss_i, f->limit);
 		f->offset = rss_i * tc;
 	}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 	for (i = 0; i < tcs; i++)
 		netdev_set_tc_queue(dev, i, rss_i, rss_i * i);
 
@@ -484,57 +535,82 @@ static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
 
 #endif
 /**
- * ixgbe_set_sriov_queues - Allocate queues for SR-IOV devices
+ * ixgbe_set_vmdq_queues: Allocate queues for VMDq devices
  * @adapter: board private structure to initialize
  *
- * When SR-IOV (Single Root IO Virtualiztion) is enabled, allocate queues
+ * When VMDq (Virtual Machine Devices queue) is enabled, allocate queues
  * and VM pools where appropriate.  If RSS is available, then also try and
  * enable RSS and map accordingly.
  *
  **/
-static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
+static bool ixgbe_set_vmdq_queues(struct ixgbe_adapter *adapter)
 {
 	u16 vmdq_i = adapter->ring_feature[RING_F_VMDQ].limit;
 	u16 vmdq_m = 0;
 	u16 rss_i = adapter->ring_feature[RING_F_RSS].limit;
 	u16 rss_m = IXGBE_RSS_DISABLED_MASK;
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	u16 fcoe_i = 0;
 #endif
 
-	/* only proceed if SR-IOV is enabled */
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+	/* only proceed if VMDq is enabled */
+	if (!(adapter->flags & IXGBE_FLAG_VMDQ_ENABLED))
 		return false;
 
-	/* limit l2fwd RSS based on total Tx queue limit */
-	rss_i = min_t(u16, rss_i, MAX_TX_QUEUES / vmdq_i);
-
-	/* Add starting offset to total pool count */
-	vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82598EB:
+		vmdq_i = min_t(u16, vmdq_i, 16);
+		/* 16 pool mode with 1 queue per pool */
+		if ((vmdq_i > 4) || (rss_i == 1)) {
+			vmdq_m = 0x0F;
+			rss_i = 1;
+		/* 4 pool mode with 8 queue per pool */
+		} else {
+			vmdq_m = 0x18;
+			rss_m = IXGBE_RSS_8Q_MASK;
+			rss_i = min_t(u16, rss_i, 8);
+		}
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
 
-	/* double check we are limited to maximum pools */
-	vmdq_i = min_t(u16, IXGBE_MAX_VMDQ_INDICES, vmdq_i);
+		/* Add starting offset to total pool count */
+		vmdq_i += adapter->ring_feature[RING_F_VMDQ].offset;
 
-	/* 64 pool mode with 2 queues per pool */
-	if (vmdq_i > 32) {
-		vmdq_m = IXGBE_82599_VMDQ_2Q_MASK;
-		rss_m = IXGBE_RSS_2Q_MASK;
-		rss_i = min_t(u16, rss_i, 2);
-	/* 32 pool mode with up to 4 queues per pool */
-	} else {
-		vmdq_m = IXGBE_82599_VMDQ_4Q_MASK;
-		rss_m = IXGBE_RSS_4Q_MASK;
-		/* We can support 4, 2, or 1 queues */
-		rss_i = (rss_i > 3) ? 4 : (rss_i > 1) ? 2 : 1;
-	}
+		/* double check we are limited to maximum pools */
+		vmdq_i = min_t(u16, IXGBE_MAX_VMDQ_INDICES, vmdq_i);
 
-#ifdef IXGBE_FCOE
-	/* queues in the remaining pools are available for FCoE */
-	fcoe_i = 128 - (vmdq_i * __ALIGN_MASK(1, ~vmdq_m));
+		/* 64 pool mode with 2 queues per pool */
+		if (vmdq_i > 32) {
+			vmdq_m = IXGBE_82599_VMDQ_2Q_MASK;
+			rss_m = IXGBE_RSS_2Q_MASK;
+			rss_i = min_t(u16, rss_i, 2);
+		/* 32 pool mode with up to 4 queues per pool */
+		} else {
+			vmdq_m = IXGBE_82599_VMDQ_4Q_MASK;
+			rss_m = IXGBE_RSS_4Q_MASK;
+			/* We can support 4, 2, or 1 queues */
+			rss_i = (rss_i > 3) ? 4 : (rss_i > 1) ? 2 : 1;
+		}
 
+#if IS_ENABLED(CONFIG_FCOE)
+		/* queues in the remaining pools are available for FCoE */
+		fcoe_i = 128 - (vmdq_i * __ALIGN_MASK(1, ~vmdq_m));
 #endif
-	/* remove the starting offset from the pool count */
-	vmdq_i -= adapter->ring_feature[RING_F_VMDQ].offset;
+
+		/* remove the starting offset from the pool count */
+		vmdq_i -= adapter->ring_feature[RING_F_VMDQ].offset;
+
+		break;
+	default:
+		/* unknown hardware, support one pool w/ one queue */
+		vmdq_i = 1;
+		rss_i = 1;
+		break;
+	}
 
 	/* save features for later use */
 	adapter->ring_feature[RING_F_VMDQ].indices = vmdq_i;
@@ -548,13 +624,17 @@ static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 	adapter->num_rx_queues_per_pool = rss_i;
 
 	adapter->num_rx_queues = vmdq_i * rss_i;
+#ifdef HAVE_TX_MQ
 	adapter->num_tx_queues = vmdq_i * rss_i;
+#else
+	adapter->num_tx_queues = vmdq_i;
+#endif /* HAVE_TX_MQ */
 	adapter->num_xdp_queues = 0;
 
 	/* disable ATR as it is not supported when VMDq is enabled */
 	adapter->flags &= ~IXGBE_FLAG_FDIR_HASH_CAPABLE;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/*
 	 * FCoE can use rings from adjacent buffers to allow RSS
 	 * like behavior.  To account for this we need to add the
@@ -583,7 +663,6 @@ static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 			/* attempt to reserve some queues for just FCoE */
 			fcoe->indices = min_t(u16, fcoe_i, fcoe->limit);
 			fcoe->offset = fcoe_i - fcoe->indices;
-
 			fcoe_i -= rss_i;
 		}
 
@@ -591,25 +670,12 @@ static bool ixgbe_set_sriov_queues(struct ixgbe_adapter *adapter)
 		adapter->num_tx_queues += fcoe_i;
 		adapter->num_rx_queues += fcoe_i;
 	}
-
-#endif
-	/* To support macvlan offload we have to use num_tc to
-	 * restrict the queues that can be used by the device.
-	 * By doing this we can avoid reporting a false number of
-	 * queues.
-	 */
-	if (vmdq_i > 1)
-		netdev_set_num_tc(adapter->netdev, 1);
-
-	/* populate TC0 for use by pool 0 */
-	netdev_set_tc_queue(adapter->netdev, 0,
-			    adapter->num_rx_queues_per_pool, 0);
-
+#endif /* CONFIG_FCOE */
 	return true;
 }
 
 /**
- * ixgbe_set_rss_queues - Allocate queues for RSS
+ * ixgbe_set_rss_queues: Allocate queues for RSS
  * @adapter: board private structure to initialize
  *
  * This is our "base" multiqueue mode.  RSS (Receive Side Scaling) will try
@@ -627,7 +693,6 @@ static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter)
 	rss_i = f->limit;
 
 	f->indices = rss_i;
-
 	if (hw->mac.type < ixgbe_mac_X550)
 		f->mask = IXGBE_RSS_16Q_MASK;
 	else
@@ -650,7 +715,7 @@ static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter)
 			adapter->flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/*
 	 * FCoE can exist on the same rings as standard network traffic
 	 * however it is preferred to avoid that if possible.  In order
@@ -678,17 +743,19 @@ static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter)
 		f->offset = fcoe_i - f->indices;
 		rss_i = max_t(u16, fcoe_i, rss_i);
 	}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 	adapter->num_rx_queues = rss_i;
+#ifdef HAVE_TX_MQ
 	adapter->num_tx_queues = rss_i;
+#endif
 	adapter->num_xdp_queues = ixgbe_xdp_queues(adapter);
 
 	return true;
 }
 
-/**
- * ixgbe_set_num_queues - Allocate queues for device, feature dependent
+/*
+ * ixgbe_set_num_queues: Allocate queues for device, feature dependent
  * @adapter: board private structure to initialize
  *
  * This is the top level queue allocation routine.  The order here is very
@@ -704,18 +771,18 @@ static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter)
 	adapter->num_rx_queues = 1;
 	adapter->num_tx_queues = 1;
 	adapter->num_xdp_queues = 0;
-	adapter->num_rx_pools = 1;
+	adapter->num_rx_pools = adapter->num_rx_queues;
 	adapter->num_rx_queues_per_pool = 1;
 
-#ifdef CONFIG_IXGBE_DCB
-	if (ixgbe_set_dcb_sriov_queues(adapter))
+#ifdef HAVE_TX_MQ
+	if (ixgbe_set_dcb_vmdq_queues(adapter))
 		return;
 
 	if (ixgbe_set_dcb_queues(adapter))
 		return;
 
 #endif
-	if (ixgbe_set_sriov_queues(adapter))
+	if (ixgbe_set_vmdq_queues(adapter))
 		return;
 
 	ixgbe_set_rss_queues(adapter);
@@ -734,6 +801,9 @@ static int ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 	int i, vectors, vector_threshold;
 
+	if (!(adapter->flags & IXGBE_FLAG_MSIX_CAPABLE))
+		return -EOPNOTSUPP;
+
 	/* We start by asking for one vector per queue pair with XDP queues
 	 * being stacked with TX queues.
 	 */
@@ -777,8 +847,7 @@ static int ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter)
 
 	if (vectors < 0) {
 		/* A negative count of allocated vectors indicates an error in
-		 * acquiring within the specified range of MSI-X vectors
-		 */
+		 * acquiring within the specified range of MSI-X vectors */
 		e_dev_warn("Failed to allocate MSI-X interrupts. Err: %d\n",
 			   vectors);
 
@@ -809,7 +878,6 @@ static void ixgbe_add_ring(struct ixgbe_ring *ring,
 	ring->next = head->ring;
 	head->ring = ring;
 	head->count++;
-	head->next_update = jiffies + 1;
 }
 
 /**
@@ -827,32 +895,40 @@ static void ixgbe_add_ring(struct ixgbe_ring *ring,
  * We allocate one q_vector.  If allocation fails we return -ENOMEM.
  **/
 static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
-				int v_count, int v_idx,
-				int txr_count, int txr_idx,
-				int xdp_count, int xdp_idx,
-				int rxr_count, int rxr_idx)
+				unsigned int v_count, unsigned int v_idx,
+				unsigned int txr_count, unsigned int txr_idx,
+				unsigned int xdp_count, unsigned int xdp_idx,
+				unsigned int rxr_count, unsigned int rxr_idx)
 {
-	int node = dev_to_node(&adapter->pdev->dev);
 	struct ixgbe_q_vector *q_vector;
 	struct ixgbe_ring *ring;
+	int node = -1;
+#ifdef HAVE_IRQ_AFFINITY_HINT
 	int cpu = -1;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
+#endif
 	int ring_count;
-	u8 tcs = adapter->hw_tcs;
 
+	/* note this will allocate space for the ring structure as well! */
 	ring_count = txr_count + rxr_count + xdp_count;
 
+#ifdef HAVE_IRQ_AFFINITY_HINT
 	/* customize cpu for Flow Director mapping */
-	if ((tcs <= 1) && !(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)) {
+	if ((tcs <= 1) && !(adapter->flags & IXGBE_FLAG_VMDQ_ENABLED)) {
 		u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
 		if (rss_i > 1 && adapter->atr_sample_rate) {
-			cpu = cpumask_local_spread(v_idx, node);
-			node = cpu_to_node(cpu);
+			if (cpu_online(v_idx)) {
+				cpu = v_idx;
+				node = cpu_to_node(cpu);
+			}
 		}
 	}
 
+#endif
 	/* allocate q_vector and rings */
 	q_vector = kzalloc_node(struct_size(q_vector, ring, ring_count),
 				GFP_KERNEL, node);
+
 	if (!q_vector)
 		q_vector = kzalloc(struct_size(q_vector, ring, ring_count),
 				   GFP_KERNEL);
@@ -860,19 +936,29 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 		return -ENOMEM;
 
 	/* setup affinity mask and node */
+#ifdef HAVE_IRQ_AFFINITY_HINT
 	if (cpu != -1)
 		cpumask_set_cpu(cpu, &q_vector->affinity_mask);
-	q_vector->numa_node = node;
+#endif
+	q_vector->node = node;
 
-#ifdef CONFIG_IXGBE_DCA
 	/* initialize CPU for DCA */
 	q_vector->cpu = -1;
 
-#endif
 	/* initialize NAPI */
 	netif_napi_add(adapter->netdev, &q_vector->napi,
 		       ixgbe_poll, 64);
+#ifndef HAVE_NETIF_NAPI_ADD_CALLS_NAPI_HASH_ADD
+#ifdef HAVE_NDO_BUSY_POLL
+	napi_hash_add(&q_vector->napi);
+#endif
+#endif
+
+#ifdef HAVE_NDO_BUSY_POLL
+	/* initialize busy poll */
+	atomic_set(&q_vector->state, IXGBE_QV_STATE_DISABLE);
 
+#endif
 	/* tie q_vector and adapter together */
 	adapter->q_vector[v_idx] = q_vector;
 	q_vector->adapter = adapter;
@@ -907,7 +993,7 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 
 	while (txr_count) {
 		/* assign generic ring traits */
-		ring->dev = &adapter->pdev->dev;
+		ring->dev = pci_dev_to_dev(adapter->pdev);
 		ring->netdev = adapter->netdev;
 
 		/* configure backlink on ring */
@@ -921,7 +1007,7 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 		ring->queue_index = txr_idx;
 
 		/* assign ring to adapter */
-		WRITE_ONCE(adapter->tx_ring[txr_idx], ring);
+		adapter->tx_ring[txr_idx] = ring;
 
 		/* update count and index */
 		txr_count--;
@@ -948,7 +1034,7 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 		set_ring_xdp(ring);
 
 		/* assign ring to adapter */
-		WRITE_ONCE(adapter->xdp_ring[xdp_idx], ring);
+		adapter->xdp_ring[xdp_idx] = ring;
 
 		/* update count and index */
 		xdp_count--;
@@ -957,10 +1043,9 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 		/* push pointer to next ring */
 		ring++;
 	}
-
 	while (rxr_count) {
 		/* assign generic ring traits */
-		ring->dev = &adapter->pdev->dev;
+		ring->dev = pci_dev_to_dev(adapter->pdev);
 		ring->netdev = adapter->netdev;
 
 		/* configure backlink on ring */
@@ -976,22 +1061,24 @@ static int ixgbe_alloc_q_vector(struct ixgbe_adapter *adapter,
 		if (adapter->hw.mac.type == ixgbe_mac_82599EB)
 			set_bit(__IXGBE_RX_CSUM_UDP_ZERO_ERR, &ring->state);
 
-#ifdef IXGBE_FCOE
-		if (adapter->netdev->features & NETIF_F_FCOE_MTU) {
+#if IS_ENABLED(CONFIG_FCOE)
+		if (adapter->flags & IXGBE_FLAG_FCOE_ENABLED) {
 			struct ixgbe_ring_feature *f;
 			f = &adapter->ring_feature[RING_F_FCOE];
+
 			if ((rxr_idx >= f->offset) &&
-			    (rxr_idx < f->offset + f->indices))
+			    (rxr_idx < f->offset + f->indices)) {
 				set_bit(__IXGBE_RX_FCOE, &ring->state);
+			}
 		}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 		/* apply Rx specific ring traits */
 		ring->count = adapter->rx_ring_count;
 		ring->queue_index = rxr_idx;
 
 		/* assign ring to adapter */
-		WRITE_ONCE(adapter->rx_ring[rxr_idx], ring);
+		adapter->rx_ring[rxr_idx] = ring;
 
 		/* update count and index */
 		rxr_count--;
@@ -1020,22 +1107,19 @@ static void ixgbe_free_q_vector(struct ixgbe_adapter *adapter, int v_idx)
 
 	ixgbe_for_each_ring(ring, q_vector->tx) {
 		if (ring_is_xdp(ring))
-			WRITE_ONCE(adapter->xdp_ring[ring->queue_index], NULL);
+			adapter->xdp_ring[ring->queue_index] = NULL;
 		else
-			WRITE_ONCE(adapter->tx_ring[ring->queue_index], NULL);
+			adapter->tx_ring[ring->queue_index] = NULL;
 	}
 
 	ixgbe_for_each_ring(ring, q_vector->rx)
-		WRITE_ONCE(adapter->rx_ring[ring->queue_index], NULL);
+		adapter->rx_ring[ring->queue_index] = NULL;
 
 	adapter->q_vector[v_idx] = NULL;
-	__netif_napi_del(&q_vector->napi);
-
-	/*
-	 * after a call to __netif_napi_del() napi may still be used and
-	 * ixgbe_get_stats64() might access the rings on this vector,
-	 * we must wait a grace period before freeing it.
-	 */
+#ifdef HAVE_NDO_BUSY_POLL
+	napi_hash_del(&q_vector->napi);
+#endif
+	netif_napi_del(&q_vector->napi);
 	kfree_rcu(q_vector, rcu);
 }
 
@@ -1048,22 +1132,20 @@ static void ixgbe_free_q_vector(struct ixgbe_adapter *adapter, int v_idx)
  **/
 static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter)
 {
-	int q_vectors = adapter->num_q_vectors;
-	int rxr_remaining = adapter->num_rx_queues;
-	int txr_remaining = adapter->num_tx_queues;
-	int xdp_remaining = adapter->num_xdp_queues;
-	int rxr_idx = 0, txr_idx = 0, xdp_idx = 0, v_idx = 0;
-	int err, i;
-
-	/* only one q_vector if MSI-X is disabled. */
-	if (!(adapter->flags & IXGBE_FLAG_MSIX_ENABLED))
-		q_vectors = 1;
+	unsigned int q_vectors = adapter->num_q_vectors;
+	unsigned int rxr_remaining = adapter->num_rx_queues;
+	unsigned int txr_remaining = adapter->num_tx_queues;
+	unsigned int xdp_remaining = adapter->num_xdp_queues;
+	unsigned int rxr_idx = 0, txr_idx = 0, xdp_idx = 0, v_idx = 0;
+	int err;
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	int i;
+#endif
 
 	if (q_vectors >= (rxr_remaining + txr_remaining + xdp_remaining)) {
 		for (; rxr_remaining; v_idx++) {
 			err = ixgbe_alloc_q_vector(adapter, q_vectors, v_idx,
 						   0, 0, 0, 0, 1, rxr_idx);
-
 			if (err)
 				goto err_out;
 
@@ -1095,6 +1177,7 @@ static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter)
 		xdp_idx += xqpv;
 	}
 
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 	for (i = 0; i < adapter->num_rx_queues; i++) {
 		if (adapter->rx_ring[i])
 			adapter->rx_ring[i]->ring_idx = i;
@@ -1110,7 +1193,8 @@ static int ixgbe_alloc_q_vectors(struct ixgbe_adapter *adapter)
 			adapter->xdp_ring[i]->ring_idx = i;
 	}
 
-	return 0;
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
+	return IXGBE_SUCCESS;
 
 err_out:
 	adapter->num_tx_queues = 0;
@@ -1145,7 +1229,7 @@ static void ixgbe_free_q_vectors(struct ixgbe_adapter *adapter)
 		ixgbe_free_q_vector(adapter, v_idx);
 }
 
-static void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter)
+void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter)
 {
 	if (adapter->flags & IXGBE_FLAG_MSIX_ENABLED) {
 		adapter->flags &= ~IXGBE_FLAG_MSIX_ENABLED;
@@ -1165,7 +1249,7 @@ static void ixgbe_reset_interrupt_capability(struct ixgbe_adapter *adapter)
  * Attempt to configure the interrupts using the best available
  * capabilities of the hardware and the kernel.
  **/
-static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
+void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
 {
 	int err;
 
@@ -1179,7 +1263,7 @@ static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
 	 */
 
 	/* Disable DCB unless we only have a single traffic class */
-	if (adapter->hw_tcs > 1) {
+	if (netdev_get_num_tc(adapter->netdev) > 1) {
 		e_dev_warn("Number of DCB TCs exceeds number of available queues. Disabling DCB support.\n");
 		netdev_reset_tc(adapter->netdev);
 
@@ -1191,13 +1275,18 @@ static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
 		adapter->dcb_cfg.pfc_mode_enable = false;
 	}
 
-	adapter->hw_tcs = 0;
 	adapter->dcb_cfg.num_tcs.pg_tcs = 1;
 	adapter->dcb_cfg.num_tcs.pfc_tcs = 1;
 
+	/* Disable VMDq support */
+	e_dev_warn("Disabling VMQd support\n");
+	adapter->flags &= ~IXGBE_FLAG_VMDQ_ENABLED;
+
+#ifdef CONFIG_PCI_IOV
 	/* Disable SR-IOV support */
 	e_dev_warn("Disabling SR-IOV support\n");
 	ixgbe_disable_sriov(adapter);
+#endif /* CONFIG_PCI_IOV */
 
 	/* Disable RSS */
 	e_dev_warn("Disabling RSS support\n");
@@ -1209,6 +1298,9 @@ static void ixgbe_set_interrupt_capability(struct ixgbe_adapter *adapter)
 	ixgbe_set_num_queues(adapter);
 	adapter->num_q_vectors = 1;
 
+	if (!(adapter->flags & IXGBE_FLAG_MSI_CAPABLE))
+		return;
+
 	err = pci_enable_msi(adapter->pdev);
 	if (err)
 		e_dev_warn("Failed to allocate MSI interrupt, falling back to legacy. Error: %d\n",
@@ -1237,26 +1329,29 @@ int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter)
 	/* Set interrupt mode */
 	ixgbe_set_interrupt_capability(adapter);
 
+	/* Allocate memory for queues */
 	err = ixgbe_alloc_q_vectors(adapter);
 	if (err) {
-		e_dev_err("Unable to allocate memory for queue vectors\n");
-		goto err_alloc_q_vectors;
+		e_err(probe, "Unable to allocate memory for queue vectors\n");
+		ixgbe_reset_interrupt_capability(adapter);
+		return err;
 	}
 
 	ixgbe_cache_ring_register(adapter);
 
+#ifdef HAVE_XDP_SUPPORT
 	e_dev_info("Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u XDP Queue count = %u\n",
 		   (adapter->num_rx_queues > 1) ? "Enabled" : "Disabled",
 		   adapter->num_rx_queues, adapter->num_tx_queues,
 		   adapter->num_xdp_queues);
-
+#else
+	e_dev_info("Multiqueue %s: Rx Queue count = %u, Tx Queue count = %u\n",
+		   (adapter->num_rx_queues > 1) ? "Enabled" : "Disabled",
+		   adapter->num_rx_queues, adapter->num_tx_queues);
+#endif
 	set_bit(__IXGBE_DOWN, &adapter->state);
 
-	return 0;
-
-err_alloc_q_vectors:
-	ixgbe_reset_interrupt_capability(adapter);
-	return err;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -1277,7 +1372,7 @@ void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter)
 }
 
 void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring, u32 vlan_macip_lens,
-		       u32 fceof_saidx, u32 type_tucmd, u32 mss_l4len_idx)
+		       u32 fcoe_sof_eof, u32 type_tucmd, u32 mss_l4len_idx)
 {
 	struct ixgbe_adv_tx_context_desc *context_desc;
 	u16 i = tx_ring->next_to_use;
@@ -1291,7 +1386,7 @@ void ixgbe_tx_ctxtdesc(struct ixgbe_ring *tx_ring, u32 vlan_macip_lens,
 	type_tucmd |= IXGBE_TXD_CMD_DEXT | IXGBE_ADVTXD_DTYP_CTXT;
 
 	context_desc->vlan_macip_lens	= cpu_to_le32(vlan_macip_lens);
-	context_desc->fceof_saidx	= cpu_to_le32(fceof_saidx);
+	context_desc->seqnum_seed	= cpu_to_le32(fcoe_sof_eof);
 	context_desc->type_tucmd_mlhl	= cpu_to_le32(type_tucmd);
 	context_desc->mss_l4len_idx	= cpu_to_le32(mss_l4len_idx);
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
index 278fc866fad4..1123fe5b12b1 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
@@ -1,77 +1,88 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
+/******************************************************************************
+ Copyright (c)2006 - 2007 Myricom, Inc. for some LRO specific code
+******************************************************************************/
 #include <linux/types.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/netdevice.h>
 #include <linux/vmalloc.h>
+#include <linux/highmem.h>
 #include <linux/string.h>
 #include <linux/in.h>
-#include <linux/interrupt.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
-#include <linux/sctp.h>
 #include <linux/pkt_sched.h>
 #include <linux/ipv6.h>
-#include <linux/slab.h>
+#ifdef NETIF_F_TSO
 #include <net/checksum.h>
+#ifdef NETIF_F_TSO6
+#include <net/ipv6.h>
 #include <net/ip6_checksum.h>
-#include <linux/etherdevice.h>
+#endif /* NETIF_F_TSO6 */
+#endif /* NETIF_F_TSO */
+#ifdef SIOCETHTOOL
 #include <linux/ethtool.h>
-#include <linux/if.h>
-#include <linux/if_vlan.h>
-#include <linux/if_macvlan.h>
+#endif
+
 #include <linux/if_bridge.h>
-#include <linux/prefetch.h>
+#include "ixgbe.h"
+#ifdef HAVE_XDP_SUPPORT
 #include <linux/bpf.h>
 #include <linux/bpf_trace.h>
 #include <linux/atomic.h>
-#include <linux/numa.h>
-#include <generated/utsrelease.h>
-#include <scsi/fc/fc_fcoe.h>
+#endif
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+#include <net/xdp_sock.h>
+#endif
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+#include <net/vxlan.h>
 #include <net/udp_tunnel.h>
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
+#ifdef HAVE_VXLAN_RX_OFFLOAD
+#include <net/vxlan.h>
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
+#ifdef NETIF_F_HW_TC
 #include <net/pkt_cls.h>
 #include <net/tc_act/tc_gact.h>
 #include <net/tc_act/tc_mirred.h>
-#include <net/vxlan.h>
-#include <net/mpls.h>
-#include <net/xdp_sock_drv.h>
-#include <net/xfrm.h>
+#endif /* NETIF_F_HW_TC */
 
-#include "ixgbe.h"
-#include "ixgbe_common.h"
 #include "ixgbe_dcb_82599.h"
-#include "ixgbe_phy.h"
 #include "ixgbe_sriov.h"
-#include "ixgbe_model.h"
 #include "ixgbe_txrx_common.h"
+#ifdef HAVE_TC_SETUP_CLSU32
+#include "ixgbe_model.h"
+#endif /* HAVE_TC_SETUP_CLSU32 */
+
+#define DRV_HW_PERF
+
+#define FPGA
+
+#define DRIVERIOV
+
+#define BYPASS_TAG
+
+#define RELEASE_TAG
 
+#define DRV_VERSION	"5.9.4" \
+			DRIVERIOV DRV_HW_PERF FPGA \
+			BYPASS_TAG RELEASE_TAG
+#define DRV_SUMMARY	"Intel(R) 10GbE PCI Express Linux Network Driver"
+const char ixgbe_driver_version[] = DRV_VERSION;
+#ifdef HAVE_NON_CONST_PCI_DRIVER_NAME
 char ixgbe_driver_name[] = "ixgbe";
-static const char ixgbe_driver_string[] =
-			      "Intel(R) 10 Gigabit PCI Express Network Driver";
-#ifdef IXGBE_FCOE
-char ixgbe_default_device_descr[] =
-			      "Intel(R) 10 Gigabit Network Connection";
-#else
-static char ixgbe_default_device_descr[] =
-			      "Intel(R) 10 Gigabit Network Connection";
-#endif
-static const char ixgbe_copyright[] =
-				"Copyright (c) 1999-2016 Intel Corporation.";
-
-static const char ixgbe_overheat_msg[] = "Network adapter has been stopped because it has over heated. Restart the computer. If the problem persists, power off the system and replace the adapter";
-
-static const struct ixgbe_info *ixgbe_info_tbl[] = {
-	[board_82598]		= &ixgbe_82598_info,
-	[board_82599]		= &ixgbe_82599_info,
-	[board_X540]		= &ixgbe_X540_info,
-	[board_X550]		= &ixgbe_X550_info,
-	[board_X550EM_x]	= &ixgbe_X550EM_x_info,
-	[board_x550em_x_fw]	= &ixgbe_x550em_x_fw_info,
-	[board_x550em_a]	= &ixgbe_x550em_a_info,
-	[board_x550em_a_fw]	= &ixgbe_x550em_a_fw_info,
-};
+#else
+const char ixgbe_driver_name[] = "ixgbe";
+#endif
+static const char ixgbe_driver_string[] = DRV_SUMMARY;
+static const char ixgbe_copyright[] = "Copyright(c) 1999 - 2020 Intel Corporation.";
+static const char ixgbe_overheat_msg[] =
+		"Network adapter has been stopped because it has over heated. "
+		"Restart the computer. If the problem persists, "
+		"power off the system and replace the adapter";
 
 /* ixgbe_pci_tbl - PCI Device ID Table
  *
@@ -82,128 +93,118 @@ static const struct ixgbe_info *ixgbe_info_tbl[] = {
  *   Class, Class Mask, private data (not used) }
  */
 static const struct pci_device_id ixgbe_pci_tbl[] = {
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AF_DUAL_PORT), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AF_SINGLE_PORT), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AT), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AT2), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_CX4), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_CX4_DUAL_PORT), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_DA_DUAL_PORT), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_XF_LR), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_SFP_LOM), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_BX), board_82598 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KX4), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_XAUI_LOM), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KR), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_EM), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KX4_MEZZ), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_CX4), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_BACKPLANE_FCOE), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_FCOE), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_T3_LOM), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_COMBO_BACKPLANE), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T), board_X540 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_SF2), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_LS), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_QSFP_SF_QP), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599EN_SFP), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_SF_QP), board_82599 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T1), board_X540 },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550T), board_X550},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550T1), board_X550},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_KX4), board_X550EM_x},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_XFI), board_X550EM_x},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_KR), board_X550EM_x},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_10G_T), board_X550EM_x},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_SFP), board_X550EM_x},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_1G_T), board_x550em_x_fw},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_KR), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_KR_L), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SFP_N), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SGMII), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SGMII_L), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_10G_T), board_x550em_a},
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SFP), board_x550em_a },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_1G_T), board_x550em_a_fw },
-	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_1G_T_L), board_x550em_a_fw },
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AF_DUAL_PORT), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AF_SINGLE_PORT), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AT), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598AT2), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_CX4), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_CX4_DUAL_PORT), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_DA_DUAL_PORT), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_XF_LR), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598EB_SFP_LOM), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82598_BX), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KX4), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_XAUI_LOM), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KR), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_EM), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_KX4_MEZZ), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_CX4), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_BACKPLANE_FCOE), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_FCOE), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_T3_LOM), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_COMBO_BACKPLANE), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_SF2), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599EN_SFP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_SF_QP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_QSFP_SF_QP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T1), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550T1), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_KX4), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_XFI), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_KR), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_SFP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_10G_T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_X_1G_T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_KR), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_KR_L), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SFP_N), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SGMII), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SGMII_L), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_10G_T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_QSFP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_QSFP_N), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_SFP), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_1G_T), 0},
+	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X550EM_A_1G_T_L), 0},
 	/* required last entry */
-	{0, }
+	{ .device = 0 }
 };
 MODULE_DEVICE_TABLE(pci, ixgbe_pci_tbl);
 
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 static int ixgbe_notify_dca(struct notifier_block *, unsigned long event,
 			    void *p);
 static struct notifier_block dca_notifier = {
-	.notifier_call = ixgbe_notify_dca,
-	.next          = NULL,
-	.priority      = 0
+	.notifier_call	= ixgbe_notify_dca,
+	.next		= NULL,
+	.priority	= 0
 };
-#endif
-
-#ifdef CONFIG_PCI_IOV
-static unsigned int max_vfs;
-module_param(max_vfs, uint, 0);
-MODULE_PARM_DESC(max_vfs,
-		 "Maximum number of virtual functions to allocate per physical function - default is zero and maximum value is 63. (Deprecated)");
-#endif /* CONFIG_PCI_IOV */
-
-static unsigned int allow_unsupported_sfp;
-module_param(allow_unsupported_sfp, uint, 0);
-MODULE_PARM_DESC(allow_unsupported_sfp,
-		 "Allow unsupported and untested SFP+ modules on 82599-based adapters");
-
-#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)
-static int debug = -1;
-module_param(debug, int, 0);
-MODULE_PARM_DESC(debug, "Debug level (0=none,...,16=all)");
+#endif /* CONFIG_DCA */
+static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *);
 
 MODULE_AUTHOR("Intel Corporation, <linux.nics@intel.com>");
-MODULE_DESCRIPTION("Intel(R) 10 Gigabit PCI Express Network Driver");
-MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_SUMMARY);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+#define DEFAULT_DEBUG_LEVEL_SHIFT 3
 
 static struct workqueue_struct *ixgbe_wq;
 
+static bool ixgbe_is_sfp(struct ixgbe_hw *hw);
 static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw, struct pci_dev *pdev);
-static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *);
-
-static const struct net_device_ops ixgbe_netdev_ops;
-
-static bool netif_is_ixgbe(struct net_device *dev)
-{
-	return dev && (dev->netdev_ops == &ixgbe_netdev_ops);
-}
 
-static int ixgbe_read_pci_cfg_word_parent(struct ixgbe_adapter *adapter,
+static int ixgbe_read_pci_cfg_word_parent(struct ixgbe_hw *hw,
 					  u32 reg, u16 *value)
 {
+	struct ixgbe_adapter *adapter = hw->back;
 	struct pci_dev *parent_dev;
 	struct pci_bus *parent_bus;
+	int pos;
 
 	parent_bus = adapter->pdev->bus->parent;
 	if (!parent_bus)
-		return -1;
+		return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
 
 	parent_dev = parent_bus->self;
 	if (!parent_dev)
-		return -1;
+		return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
 
-	if (!pci_is_pcie(parent_dev))
-		return -1;
+	pos = pci_find_capability(parent_dev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
 
-	pcie_capability_read_word(parent_dev, reg, value);
+	pci_read_config_word(parent_dev, pos + reg, value);
 	if (*value == IXGBE_FAILED_READ_CFG_WORD &&
-	    ixgbe_check_cfg_remove(&adapter->hw, parent_dev))
-		return -1;
-	return 0;
+	    ixgbe_check_cfg_remove(hw, parent_dev))
+		return IXGBE_ERR_FEATURE_NOT_SUPPORTED;
+	return IXGBE_SUCCESS;
 }
 
-static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter)
+/**
+ * ixgbe_get_parent_bus_info - Set PCI bus info beyond switch
+ * @hw: pointer to hardware structure
+ *
+ * Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
+ * when the device is behind a switch.
+ **/
+static s32 ixgbe_get_parent_bus_info(struct ixgbe_hw *hw)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
 	u16 link_status = 0;
 	int err;
 
@@ -212,40 +213,37 @@ static s32 ixgbe_get_parent_bus_info(struct ixgbe_adapter *adapter)
 	/* Get the negotiated link width and speed from PCI config space of the
 	 * parent, as this device is behind a switch
 	 */
-	err = ixgbe_read_pci_cfg_word_parent(adapter, 18, &link_status);
+	err = ixgbe_read_pci_cfg_word_parent(hw, 18, &link_status);
 
-	/* assume caller will handle error case */
+	/* If the read fails, fallback to default */
 	if (err)
-		return err;
+		link_status = IXGBE_READ_PCIE_WORD(hw, IXGBE_PCI_LINK_STATUS);
 
-	hw->bus.width = ixgbe_convert_bus_width(link_status);
-	hw->bus.speed = ixgbe_convert_bus_speed(link_status);
+	ixgbe_set_pci_config_data_generic(hw, link_status);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- * ixgbe_check_from_parent - Determine whether PCIe info should come from parent
+ * ixgbe_check_from_parent - determine whether to use parent for PCIe info
  * @hw: hw specific details
  *
- * This function is used by probe to determine whether a device's PCI-Express
- * bandwidth details should be gathered from the parent bus instead of from the
- * device. Used to ensure that various locations all have the correct device ID
- * checks.
+ * This function is used by probe to determine whether a device's PCIe info
+ * (speed, width, etc) should be obtained from the parent bus or directly. This
+ * is useful for specialized device configurations containing PCIe bridges.
  */
 static inline bool ixgbe_pcie_from_parent(struct ixgbe_hw *hw)
 {
 	switch (hw->device_id) {
-	case IXGBE_DEV_ID_82599_SFP_SF_QP:
 	case IXGBE_DEV_ID_82599_QSFP_SF_QP:
+	case IXGBE_DEV_ID_82599_SFP_SF_QP:
 		return true;
 	default:
 		return false;
 	}
 }
 
-static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter,
-				     int expected_gts)
+static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct pci_dev *pdev;
@@ -266,6 +264,51 @@ static void ixgbe_check_minimum_link(struct ixgbe_adapter *adapter,
 	pcie_print_link_status(pdev);
 }
 
+/**
+ * ixgbe_enumerate_functions - Get the number of ports this device has
+ * @adapter: adapter structure
+ *
+ * This function enumerates the phsyical functions co-located on a single slot,
+ * in order to determine how many ports a device has. This is most useful in
+ * determining the required GT/s of PCIe bandwidth necessary for optimal
+ * performance.
+ **/
+static inline int ixgbe_enumerate_functions(struct ixgbe_adapter *adapter)
+{
+	struct pci_dev *entry, *pdev = adapter->pdev;
+	int physfns = 0;
+
+	/* Some cards can not use the generic count PCIe functions method,
+	 * because they are behind a parent switch, so we hardcode these to
+	 * correct number of ports.
+	 */
+	if (ixgbe_pcie_from_parent(&adapter->hw)) {
+		physfns = 4;
+	} else {
+		list_for_each_entry(entry, &pdev->bus->devices, bus_list) {
+#ifdef CONFIG_PCI_IOV
+			/* don't count virtual functions */
+			if (entry->is_virtfn)
+				continue;
+#endif
+
+			/* When the devices on the bus don't all match our device ID,
+			 * we can't reliably determine the correct number of
+			 * functions. This can occur if a function has been direct 
+			 * attached to a virtual machine using VT-d, for example. In
+			 * this case, simply return -1 to indicate this.
+			 */
+			if ((entry->vendor != pdev->vendor) ||
+			    (entry->device != pdev->device))
+				return -1;
+
+			physfns++;
+		}
+	}
+
+	return physfns;
+}
+
 static void ixgbe_service_event_schedule(struct ixgbe_adapter *adapter)
 {
 	if (!test_bit(__IXGBE_DOWN, &adapter->state) &&
@@ -274,6 +317,15 @@ static void ixgbe_service_event_schedule(struct ixgbe_adapter *adapter)
 		queue_work(ixgbe_wq, &adapter->service_task);
 }
 
+static void ixgbe_service_event_complete(struct ixgbe_adapter *adapter)
+{
+	BUG_ON(!test_bit(__IXGBE_SERVICE_SCHED, &adapter->state));
+
+	/* flush memory to make sure state is correct before next watchog */
+	smp_mb__before_atomic();
+	clear_bit(__IXGBE_SERVICE_SCHED, &adapter->state);
+}
+
 static void ixgbe_remove_adapter(struct ixgbe_hw *hw)
 {
 	struct ixgbe_adapter *adapter = hw->back;
@@ -286,21 +338,22 @@ static void ixgbe_remove_adapter(struct ixgbe_hw *hw)
 		ixgbe_service_event_schedule(adapter);
 }
 
-static u32 ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)
+static u32
+ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)
 {
 	u8 __iomem *reg_addr;
 	u32 value;
 	int i;
 
 	reg_addr = READ_ONCE(hw->hw_addr);
-	if (ixgbe_removed(reg_addr))
+	if (IXGBE_REMOVED(reg_addr))
 		return IXGBE_FAILED_READ_REG;
 
-	/* Register read of 0xFFFFFFF can indicate the adapter has been removed,
-	 * so perform several status register reads to determine if the adapter
-	 * has been removed.
+	/* Register read of 0xFFFFFFFF can indicate the adapter has been
+	 * removed, so perform several status register reads to determine if
+	 * the adapter has been removed.
 	 */
-	for (i = 0; i < IXGBE_FAILED_READ_RETRIES; i++) {
+	for (i = 0; i < IXGBE_FAILED_READ_RETRIES; ++i) {
 		value = readl(reg_addr + IXGBE_STATUS);
 		if (value != IXGBE_FAILED_READ_REG)
 			break;
@@ -314,25 +367,39 @@ static u32 ixgbe_check_remove(struct ixgbe_hw *hw, u32 reg)
 	return value;
 }
 
-/**
- * ixgbe_read_reg - Read from device register
- * @hw: hw specific details
- * @reg: offset of register to read
- *
- * Returns : value read or IXGBE_FAILED_READ_REG if removed
- *
- * This function is used to read device registers. It checks for device
- * removal by confirming any read that returns all ones by checking the
- * status register value for all ones. This function avoids reading from
- * the hardware if a removal was previously detected in which case it
- * returns IXGBE_FAILED_READ_REG (all ones).
- */
-u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg)
+static u32
+ixgbe_validate_register_read(struct ixgbe_hw *_hw, u32 reg, bool quiet)
+{
+	int i;
+	u32 value;
+	u8 __iomem *reg_addr;
+	struct ixgbe_adapter *adapter = _hw->back;
+
+	reg_addr = READ_ONCE(_hw->hw_addr);
+	if (IXGBE_REMOVED(reg_addr))
+		return IXGBE_FAILED_READ_REG;
+	for (i = 0; i < IXGBE_DEAD_READ_RETRIES; ++i) {
+		value = readl(reg_addr + reg);
+		if (value != IXGBE_DEAD_READ_REG)
+			break;
+	}
+	if (quiet)
+		return value;
+	if (value == IXGBE_DEAD_READ_REG)
+		e_err(drv, "%s: register %x read unchanged\n", __func__, reg);
+	else
+		e_warn(hw, "%s: register %x read recovered after %d retries\n",
+			__func__, reg, i + 1);
+	return value;
+}
+
+u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg, bool quiet)
 {
-	u8 __iomem *reg_addr = READ_ONCE(hw->hw_addr);
 	u32 value;
+	u8 __iomem *reg_addr;
 
-	if (ixgbe_removed(reg_addr))
+	reg_addr = READ_ONCE(hw->hw_addr);
+	if (IXGBE_REMOVED(reg_addr))
 		return IXGBE_FAILED_READ_REG;
 	if (unlikely(hw->phy.nw_mng_if_sel &
 		     IXGBE_NW_MNG_IF_SEL_SGMII_ENABLE)) {
@@ -358,471 +425,11 @@ u32 ixgbe_read_reg(struct ixgbe_hw *hw, u32 reg)
 	value = readl(reg_addr + reg);
 	if (unlikely(value == IXGBE_FAILED_READ_REG))
 		value = ixgbe_check_remove(hw, reg);
+	if (unlikely(value == IXGBE_DEAD_READ_REG))
+		value = ixgbe_validate_register_read(hw, reg, quiet);
 	return value;
 }
 
-static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw, struct pci_dev *pdev)
-{
-	u16 value;
-
-	pci_read_config_word(pdev, PCI_VENDOR_ID, &value);
-	if (value == IXGBE_FAILED_READ_CFG_WORD) {
-		ixgbe_remove_adapter(hw);
-		return true;
-	}
-	return false;
-}
-
-u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg)
-{
-	struct ixgbe_adapter *adapter = hw->back;
-	u16 value;
-
-	if (ixgbe_removed(hw->hw_addr))
-		return IXGBE_FAILED_READ_CFG_WORD;
-	pci_read_config_word(adapter->pdev, reg, &value);
-	if (value == IXGBE_FAILED_READ_CFG_WORD &&
-	    ixgbe_check_cfg_remove(hw, adapter->pdev))
-		return IXGBE_FAILED_READ_CFG_WORD;
-	return value;
-}
-
-#ifdef CONFIG_PCI_IOV
-static u32 ixgbe_read_pci_cfg_dword(struct ixgbe_hw *hw, u32 reg)
-{
-	struct ixgbe_adapter *adapter = hw->back;
-	u32 value;
-
-	if (ixgbe_removed(hw->hw_addr))
-		return IXGBE_FAILED_READ_CFG_DWORD;
-	pci_read_config_dword(adapter->pdev, reg, &value);
-	if (value == IXGBE_FAILED_READ_CFG_DWORD &&
-	    ixgbe_check_cfg_remove(hw, adapter->pdev))
-		return IXGBE_FAILED_READ_CFG_DWORD;
-	return value;
-}
-#endif /* CONFIG_PCI_IOV */
-
-void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value)
-{
-	struct ixgbe_adapter *adapter = hw->back;
-
-	if (ixgbe_removed(hw->hw_addr))
-		return;
-	pci_write_config_word(adapter->pdev, reg, value);
-}
-
-static void ixgbe_service_event_complete(struct ixgbe_adapter *adapter)
-{
-	BUG_ON(!test_bit(__IXGBE_SERVICE_SCHED, &adapter->state));
-
-	/* flush memory to make sure state is correct before next watchdog */
-	smp_mb__before_atomic();
-	clear_bit(__IXGBE_SERVICE_SCHED, &adapter->state);
-}
-
-struct ixgbe_reg_info {
-	u32 ofs;
-	char *name;
-};
-
-static const struct ixgbe_reg_info ixgbe_reg_info_tbl[] = {
-
-	/* General Registers */
-	{IXGBE_CTRL, "CTRL"},
-	{IXGBE_STATUS, "STATUS"},
-	{IXGBE_CTRL_EXT, "CTRL_EXT"},
-
-	/* Interrupt Registers */
-	{IXGBE_EICR, "EICR"},
-
-	/* RX Registers */
-	{IXGBE_SRRCTL(0), "SRRCTL"},
-	{IXGBE_DCA_RXCTRL(0), "DRXCTL"},
-	{IXGBE_RDLEN(0), "RDLEN"},
-	{IXGBE_RDH(0), "RDH"},
-	{IXGBE_RDT(0), "RDT"},
-	{IXGBE_RXDCTL(0), "RXDCTL"},
-	{IXGBE_RDBAL(0), "RDBAL"},
-	{IXGBE_RDBAH(0), "RDBAH"},
-
-	/* TX Registers */
-	{IXGBE_TDBAL(0), "TDBAL"},
-	{IXGBE_TDBAH(0), "TDBAH"},
-	{IXGBE_TDLEN(0), "TDLEN"},
-	{IXGBE_TDH(0), "TDH"},
-	{IXGBE_TDT(0), "TDT"},
-	{IXGBE_TXDCTL(0), "TXDCTL"},
-
-	/* List Terminator */
-	{ .name = NULL }
-};
-
-
-/*
- * ixgbe_regdump - register printout routine
- */
-static void ixgbe_regdump(struct ixgbe_hw *hw, struct ixgbe_reg_info *reginfo)
-{
-	int i;
-	char rname[16];
-	u32 regs[64];
-
-	switch (reginfo->ofs) {
-	case IXGBE_SRRCTL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_SRRCTL(i));
-		break;
-	case IXGBE_DCA_RXCTRL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_DCA_RXCTRL(i));
-		break;
-	case IXGBE_RDLEN(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RDLEN(i));
-		break;
-	case IXGBE_RDH(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RDH(i));
-		break;
-	case IXGBE_RDT(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RDT(i));
-		break;
-	case IXGBE_RXDCTL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RXDCTL(i));
-		break;
-	case IXGBE_RDBAL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RDBAL(i));
-		break;
-	case IXGBE_RDBAH(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_RDBAH(i));
-		break;
-	case IXGBE_TDBAL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TDBAL(i));
-		break;
-	case IXGBE_TDBAH(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TDBAH(i));
-		break;
-	case IXGBE_TDLEN(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TDLEN(i));
-		break;
-	case IXGBE_TDH(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TDH(i));
-		break;
-	case IXGBE_TDT(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TDT(i));
-		break;
-	case IXGBE_TXDCTL(0):
-		for (i = 0; i < 64; i++)
-			regs[i] = IXGBE_READ_REG(hw, IXGBE_TXDCTL(i));
-		break;
-	default:
-		pr_info("%-15s %08x\n",
-			reginfo->name, IXGBE_READ_REG(hw, reginfo->ofs));
-		return;
-	}
-
-	i = 0;
-	while (i < 64) {
-		int j;
-		char buf[9 * 8 + 1];
-		char *p = buf;
-
-		snprintf(rname, 16, "%s[%d-%d]", reginfo->name, i, i + 7);
-		for (j = 0; j < 8; j++)
-			p += sprintf(p, " %08x", regs[i++]);
-		pr_err("%-15s%s\n", rname, buf);
-	}
-
-}
-
-static void ixgbe_print_buffer(struct ixgbe_ring *ring, int n)
-{
-	struct ixgbe_tx_buffer *tx_buffer;
-
-	tx_buffer = &ring->tx_buffer_info[ring->next_to_clean];
-	pr_info(" %5d %5X %5X %016llX %08X %p %016llX\n",
-		n, ring->next_to_use, ring->next_to_clean,
-		(u64)dma_unmap_addr(tx_buffer, dma),
-		dma_unmap_len(tx_buffer, len),
-		tx_buffer->next_to_watch,
-		(u64)tx_buffer->time_stamp);
-}
-
-/*
- * ixgbe_dump - Print registers, tx-rings and rx-rings
- */
-static void ixgbe_dump(struct ixgbe_adapter *adapter)
-{
-	struct net_device *netdev = adapter->netdev;
-	struct ixgbe_hw *hw = &adapter->hw;
-	struct ixgbe_reg_info *reginfo;
-	int n = 0;
-	struct ixgbe_ring *ring;
-	struct ixgbe_tx_buffer *tx_buffer;
-	union ixgbe_adv_tx_desc *tx_desc;
-	struct my_u0 { u64 a; u64 b; } *u0;
-	struct ixgbe_ring *rx_ring;
-	union ixgbe_adv_rx_desc *rx_desc;
-	struct ixgbe_rx_buffer *rx_buffer_info;
-	int i = 0;
-
-	if (!netif_msg_hw(adapter))
-		return;
-
-	/* Print netdevice Info */
-	if (netdev) {
-		dev_info(&adapter->pdev->dev, "Net device Info\n");
-		pr_info("Device Name     state            "
-			"trans_start\n");
-		pr_info("%-15s %016lX %016lX\n",
-			netdev->name,
-			netdev->state,
-			dev_trans_start(netdev));
-	}
-
-	/* Print Registers */
-	dev_info(&adapter->pdev->dev, "Register Dump\n");
-	pr_info(" Register Name   Value\n");
-	for (reginfo = (struct ixgbe_reg_info *)ixgbe_reg_info_tbl;
-	     reginfo->name; reginfo++) {
-		ixgbe_regdump(hw, reginfo);
-	}
-
-	/* Print TX Ring Summary */
-	if (!netdev || !netif_running(netdev))
-		return;
-
-	dev_info(&adapter->pdev->dev, "TX Rings Summary\n");
-	pr_info(" %s     %s              %s        %s\n",
-		"Queue [NTU] [NTC] [bi(ntc)->dma  ]",
-		"leng", "ntw", "timestamp");
-	for (n = 0; n < adapter->num_tx_queues; n++) {
-		ring = adapter->tx_ring[n];
-		ixgbe_print_buffer(ring, n);
-	}
-
-	for (n = 0; n < adapter->num_xdp_queues; n++) {
-		ring = adapter->xdp_ring[n];
-		ixgbe_print_buffer(ring, n);
-	}
-
-	/* Print TX Rings */
-	if (!netif_msg_tx_done(adapter))
-		goto rx_ring_summary;
-
-	dev_info(&adapter->pdev->dev, "TX Rings Dump\n");
-
-	/* Transmit Descriptor Formats
-	 *
-	 * 82598 Advanced Transmit Descriptor
-	 *   +--------------------------------------------------------------+
-	 * 0 |         Buffer Address [63:0]                                |
-	 *   +--------------------------------------------------------------+
-	 * 8 |  PAYLEN  | POPTS  | IDX | STA | DCMD  |DTYP |  RSV |  DTALEN |
-	 *   +--------------------------------------------------------------+
-	 *   63       46 45    40 39 36 35 32 31   24 23 20 19              0
-	 *
-	 * 82598 Advanced Transmit Descriptor (Write-Back Format)
-	 *   +--------------------------------------------------------------+
-	 * 0 |                          RSV [63:0]                          |
-	 *   +--------------------------------------------------------------+
-	 * 8 |            RSV           |  STA  |          NXTSEQ           |
-	 *   +--------------------------------------------------------------+
-	 *   63                       36 35   32 31                         0
-	 *
-	 * 82599+ Advanced Transmit Descriptor
-	 *   +--------------------------------------------------------------+
-	 * 0 |         Buffer Address [63:0]                                |
-	 *   +--------------------------------------------------------------+
-	 * 8 |PAYLEN  |POPTS|CC|IDX  |STA  |DCMD  |DTYP |MAC  |RSV  |DTALEN |
-	 *   +--------------------------------------------------------------+
-	 *   63     46 45 40 39 38 36 35 32 31  24 23 20 19 18 17 16 15     0
-	 *
-	 * 82599+ Advanced Transmit Descriptor (Write-Back Format)
-	 *   +--------------------------------------------------------------+
-	 * 0 |                          RSV [63:0]                          |
-	 *   +--------------------------------------------------------------+
-	 * 8 |            RSV           |  STA  |           RSV             |
-	 *   +--------------------------------------------------------------+
-	 *   63                       36 35   32 31                         0
-	 */
-
-	for (n = 0; n < adapter->num_tx_queues; n++) {
-		ring = adapter->tx_ring[n];
-		pr_info("------------------------------------\n");
-		pr_info("TX QUEUE INDEX = %d\n", ring->queue_index);
-		pr_info("------------------------------------\n");
-		pr_info("%s%s    %s              %s        %s          %s\n",
-			"T [desc]     [address 63:0  ] ",
-			"[PlPOIdStDDt Ln] [bi->dma       ] ",
-			"leng", "ntw", "timestamp", "bi->skb");
-
-		for (i = 0; ring->desc && (i < ring->count); i++) {
-			tx_desc = IXGBE_TX_DESC(ring, i);
-			tx_buffer = &ring->tx_buffer_info[i];
-			u0 = (struct my_u0 *)tx_desc;
-			if (dma_unmap_len(tx_buffer, len) > 0) {
-				const char *ring_desc;
-
-				if (i == ring->next_to_use &&
-				    i == ring->next_to_clean)
-					ring_desc = " NTC/U";
-				else if (i == ring->next_to_use)
-					ring_desc = " NTU";
-				else if (i == ring->next_to_clean)
-					ring_desc = " NTC";
-				else
-					ring_desc = "";
-				pr_info("T [0x%03X]    %016llX %016llX %016llX %08X %p %016llX %p%s",
-					i,
-					le64_to_cpu((__force __le64)u0->a),
-					le64_to_cpu((__force __le64)u0->b),
-					(u64)dma_unmap_addr(tx_buffer, dma),
-					dma_unmap_len(tx_buffer, len),
-					tx_buffer->next_to_watch,
-					(u64)tx_buffer->time_stamp,
-					tx_buffer->skb,
-					ring_desc);
-
-				if (netif_msg_pktdata(adapter) &&
-				    tx_buffer->skb)
-					print_hex_dump(KERN_INFO, "",
-						DUMP_PREFIX_ADDRESS, 16, 1,
-						tx_buffer->skb->data,
-						dma_unmap_len(tx_buffer, len),
-						true);
-			}
-		}
-	}
-
-	/* Print RX Rings Summary */
-rx_ring_summary:
-	dev_info(&adapter->pdev->dev, "RX Rings Summary\n");
-	pr_info("Queue [NTU] [NTC]\n");
-	for (n = 0; n < adapter->num_rx_queues; n++) {
-		rx_ring = adapter->rx_ring[n];
-		pr_info("%5d %5X %5X\n",
-			n, rx_ring->next_to_use, rx_ring->next_to_clean);
-	}
-
-	/* Print RX Rings */
-	if (!netif_msg_rx_status(adapter))
-		return;
-
-	dev_info(&adapter->pdev->dev, "RX Rings Dump\n");
-
-	/* Receive Descriptor Formats
-	 *
-	 * 82598 Advanced Receive Descriptor (Read) Format
-	 *    63                                           1        0
-	 *    +-----------------------------------------------------+
-	 *  0 |       Packet Buffer Address [63:1]           |A0/NSE|
-	 *    +----------------------------------------------+------+
-	 *  8 |       Header Buffer Address [63:1]           |  DD  |
-	 *    +-----------------------------------------------------+
-	 *
-	 *
-	 * 82598 Advanced Receive Descriptor (Write-Back) Format
-	 *
-	 *   63       48 47    32 31  30      21 20 16 15   4 3     0
-	 *   +------------------------------------------------------+
-	 * 0 |       RSS Hash /  |SPH| HDR_LEN  | RSV |Packet|  RSS |
-	 *   | Packet   | IP     |   |          |     | Type | Type |
-	 *   | Checksum | Ident  |   |          |     |      |      |
-	 *   +------------------------------------------------------+
-	 * 8 | VLAN Tag | Length | Extended Error | Extended Status |
-	 *   +------------------------------------------------------+
-	 *   63       48 47    32 31            20 19               0
-	 *
-	 * 82599+ Advanced Receive Descriptor (Read) Format
-	 *    63                                           1        0
-	 *    +-----------------------------------------------------+
-	 *  0 |       Packet Buffer Address [63:1]           |A0/NSE|
-	 *    +----------------------------------------------+------+
-	 *  8 |       Header Buffer Address [63:1]           |  DD  |
-	 *    +-----------------------------------------------------+
-	 *
-	 *
-	 * 82599+ Advanced Receive Descriptor (Write-Back) Format
-	 *
-	 *   63       48 47    32 31  30      21 20 17 16   4 3     0
-	 *   +------------------------------------------------------+
-	 * 0 |RSS / Frag Checksum|SPH| HDR_LEN  |RSC- |Packet|  RSS |
-	 *   |/ RTT / PCoE_PARAM |   |          | CNT | Type | Type |
-	 *   |/ Flow Dir Flt ID  |   |          |     |      |      |
-	 *   +------------------------------------------------------+
-	 * 8 | VLAN Tag | Length |Extended Error| Xtnd Status/NEXTP |
-	 *   +------------------------------------------------------+
-	 *   63       48 47    32 31          20 19                 0
-	 */
-
-	for (n = 0; n < adapter->num_rx_queues; n++) {
-		rx_ring = adapter->rx_ring[n];
-		pr_info("------------------------------------\n");
-		pr_info("RX QUEUE INDEX = %d\n", rx_ring->queue_index);
-		pr_info("------------------------------------\n");
-		pr_info("%s%s%s\n",
-			"R  [desc]      [ PktBuf     A0] ",
-			"[  HeadBuf   DD] [bi->dma       ] [bi->skb       ] ",
-			"<-- Adv Rx Read format");
-		pr_info("%s%s%s\n",
-			"RWB[desc]      [PcsmIpSHl PtRs] ",
-			"[vl er S cks ln] ---------------- [bi->skb       ] ",
-			"<-- Adv Rx Write-Back format");
-
-		for (i = 0; i < rx_ring->count; i++) {
-			const char *ring_desc;
-
-			if (i == rx_ring->next_to_use)
-				ring_desc = " NTU";
-			else if (i == rx_ring->next_to_clean)
-				ring_desc = " NTC";
-			else
-				ring_desc = "";
-
-			rx_buffer_info = &rx_ring->rx_buffer_info[i];
-			rx_desc = IXGBE_RX_DESC(rx_ring, i);
-			u0 = (struct my_u0 *)rx_desc;
-			if (rx_desc->wb.upper.length) {
-				/* Descriptor Done */
-				pr_info("RWB[0x%03X]     %016llX %016llX ---------------- %p%s\n",
-					i,
-					le64_to_cpu((__force __le64)u0->a),
-					le64_to_cpu((__force __le64)u0->b),
-					rx_buffer_info->skb,
-					ring_desc);
-			} else {
-				pr_info("R  [0x%03X]     %016llX %016llX %016llX %p%s\n",
-					i,
-					le64_to_cpu((__force __le64)u0->a),
-					le64_to_cpu((__force __le64)u0->b),
-					(u64)rx_buffer_info->dma,
-					rx_buffer_info->skb,
-					ring_desc);
-
-				if (netif_msg_pktdata(adapter) &&
-				    rx_buffer_info->dma) {
-					print_hex_dump(KERN_INFO, "",
-					   DUMP_PREFIX_ADDRESS, 16, 1,
-					   page_address(rx_buffer_info->page) +
-						    rx_buffer_info->page_offset,
-					   ixgbe_rx_bufsz(rx_ring), true);
-				}
-			}
-		}
-	}
-}
-
 static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter)
 {
 	u32 ctrl_ext;
@@ -843,7 +450,7 @@ static void ixgbe_get_hw_control(struct ixgbe_adapter *adapter)
 			ctrl_ext | IXGBE_CTRL_EXT_DRV_LOAD);
 }
 
-/**
+/*
  * ixgbe_set_ivar - set the IVAR registers, mapping interrupt causes to vectors
  * @adapter: pointer to adapter struct
  * @direction: 0 for Rx, 1 for Tx, -1 for other causes
@@ -871,7 +478,7 @@ static void ixgbe_set_ivar(struct ixgbe_adapter *adapter, s8 direction,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		if (direction == -1) {
 			/* other causes */
 			msix_vector |= IXGBE_IVAR_ALLOC_VAL;
@@ -910,7 +517,7 @@ void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		mask = (qmask & 0xFFFFFFFF);
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_EICS_EX(0), mask);
 		mask = (qmask >> 32);
@@ -948,7 +555,6 @@ static void ixgbe_update_xoff_rx_lfc(struct ixgbe_adapter *adapter)
 	for (i = 0; i < adapter->num_tx_queues; i++)
 		clear_bit(__IXGBE_HANG_CHECK_ARMED,
 			  &adapter->tx_ring[i]->state);
-
 	for (i = 0; i < adapter->num_xdp_queues; i++)
 		clear_bit(__IXGBE_HANG_CHECK_ARMED,
 			  &adapter->xdp_ring[i]->state);
@@ -963,9 +569,11 @@ static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter)
 	int i;
 	bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
 
+#ifdef HAVE_DCBNL_IEEE
 	if (adapter->ixgbe_ieee_pfc)
 		pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
 
+#endif
 	if (!(adapter->flags & IXGBE_FLAG_DCB_ENABLED) || !pfc_en) {
 		ixgbe_update_xoff_rx_lfc(adapter);
 		return;
@@ -993,17 +601,16 @@ static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter)
 		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
 
 		tc = tx_ring->dcb_tc;
-		if (xoff[tc])
+		if ((tc <= 7) && (xoff[tc]))
 			clear_bit(__IXGBE_HANG_CHECK_ARMED, &tx_ring->state);
 	}
-
 	for (i = 0; i < adapter->num_xdp_queues; i++) {
 		struct ixgbe_ring *xdp_ring = adapter->xdp_ring[i];
 
 		tc = xdp_ring->dcb_tc;
-		if (xoff[tc])
+		if (tc <= 7 && xoff[tc])
 			clear_bit(__IXGBE_HANG_CHECK_ARMED, &xdp_ring->state);
-	}
+		}
 }
 
 static u64 ixgbe_get_tx_completed(struct ixgbe_ring *ring)
@@ -1021,11 +628,12 @@ static u64 ixgbe_get_tx_pending(struct ixgbe_ring *ring)
 	return ((head <= tail) ? tail : tail + ring->count) - head;
 }
 
-static inline bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
+static bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
 {
 	u32 tx_done = ixgbe_get_tx_completed(tx_ring);
 	u32 tx_done_old = tx_ring->tx_stats.tx_done_old;
 	u32 tx_pending = ixgbe_get_tx_pending(tx_ring);
+	bool ret = false;
 
 	clear_check_for_tx_hang(tx_ring);
 
@@ -1037,20 +645,22 @@ static inline bool ixgbe_check_tx_hang(struct ixgbe_ring *tx_ring)
 	 * bit is cleared if a pause frame is received to remove
 	 * false hang detection due to PFC or 802.3x frames. By
 	 * requiring this to fail twice we avoid races with
-	 * pfc clearing the ARMED bit and conditions where we
+	 * PFC clearing the ARMED bit and conditions where we
 	 * run the check_tx_hang logic with a transmit completion
 	 * pending but without time to complete it yet.
 	 */
-	if (tx_done_old == tx_done && tx_pending)
+	if ((tx_done_old == tx_done) && tx_pending) {
 		/* make sure it is true for two checks in a row */
-		return test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
-					&tx_ring->state);
-	/* update completed stats and continue */
-	tx_ring->tx_stats.tx_done_old = tx_done;
-	/* reset the countdown */
-	clear_bit(__IXGBE_HANG_CHECK_ARMED, &tx_ring->state);
+		ret = test_and_set_bit(__IXGBE_HANG_CHECK_ARMED,
+				       &tx_ring->state);
+	} else {
+		/* update completed stats and continue */
+		tx_ring->tx_stats.tx_done_old = tx_done;
+		/* reset the countdown */
+		clear_bit(__IXGBE_HANG_CHECK_ARMED, &tx_ring->state);
+	}
 
-	return false;
+	return ret;
 }
 
 /**
@@ -1063,42 +673,42 @@ static void ixgbe_tx_timeout_reset(struct ixgbe_adapter *adapter)
 	/* Do the reset outside of interrupt context */
 	if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
 		set_bit(__IXGBE_RESET_REQUESTED, &adapter->state);
-		e_warn(drv, "initiating reset due to tx timeout\n");
 		ixgbe_service_event_schedule(adapter);
 	}
 }
 
 /**
- * ixgbe_tx_maxrate - callback to set the maximum per-queue bitrate
+ * ixgbe_tx_timeout - Respond to a Tx Hang
  * @netdev: network interface device structure
- * @queue_index: Tx queue to set
- * @maxrate: desired maximum transmit bitrate
+ * @txqueue: specific tx queue
  **/
-static int ixgbe_tx_maxrate(struct net_device *netdev,
-			    int queue_index, u32 maxrate)
+#ifdef HAVE_TX_TIMEOUT_TXQUEUE
+static void ixgbe_tx_timeout(struct net_device *netdev, unsigned int txqueue)
+#else
+static void ixgbe_tx_timeout(struct net_device *netdev)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 bcnrc_val = ixgbe_link_mbps(adapter);
-
-	if (!maxrate)
-		return 0;
-
-	/* Calculate the rate factor values to set */
-	bcnrc_val <<= IXGBE_RTTBCNRC_RF_INT_SHIFT;
-	bcnrc_val /= maxrate;
-
-	/* clear everything but the rate factor */
-	bcnrc_val &= IXGBE_RTTBCNRC_RF_INT_MASK |
-	IXGBE_RTTBCNRC_RF_DEC_MASK;
+	bool real_tx_hang = false;
+	int i;
 
-	/* enable the rate scheduler */
-	bcnrc_val |= IXGBE_RTTBCNRC_RS_ENA;
+#define TX_TIMEO_LIMIT 16000
+	for (i = 0; i < adapter->num_tx_queues; i++) {
+		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
+		if (check_for_tx_hang(tx_ring) && ixgbe_check_tx_hang(tx_ring))
+			real_tx_hang = true;
+	}
 
-	IXGBE_WRITE_REG(hw, IXGBE_RTTDQSEL, queue_index);
-	IXGBE_WRITE_REG(hw, IXGBE_RTTBCNRC, bcnrc_val);
+	if (real_tx_hang) {
+		ixgbe_tx_timeout_reset(adapter);
+	} else {
+		e_info(drv, "Fake Tx hang detected with timeout of %d "
+			"seconds\n", netdev->watchdog_timeo/HZ);
 
-	return 0;
+		/* fake Tx hang - increase the kernel timeout */
+		if (netdev->watchdog_timeo < TX_TIMEO_LIMIT)
+			netdev->watchdog_timeo *= 2;
+	}
 }
 
 /**
@@ -1113,7 +723,7 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 	struct ixgbe_adapter *adapter = q_vector->adapter;
 	struct ixgbe_tx_buffer *tx_buffer;
 	union ixgbe_adv_tx_desc *tx_desc;
-	unsigned int total_bytes = 0, total_packets = 0, total_ipsec = 0;
+	unsigned int total_bytes = 0, total_packets = 0;
 	unsigned int budget = q_vector->tx.work_limit;
 	unsigned int i = tx_ring->next_to_clean;
 
@@ -1144,14 +754,20 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 		/* update the statistics for this packet */
 		total_bytes += tx_buffer->bytecount;
 		total_packets += tx_buffer->gso_segs;
-		if (tx_buffer->tx_flags & IXGBE_TX_FLAGS_IPSEC)
-			total_ipsec++;
 
 		/* free the skb */
+#ifdef HAVE_XDP_SUPPORT
 		if (ring_is_xdp(tx_ring))
+#ifdef HAVE_XDP_FRAME_STRUCT
 			xdp_return_frame(tx_buffer->xdpf);
+#else
+			page_frag_free(tx_buffer->data);
+#endif
 		else
 			napi_consume_skb(tx_buffer->skb, napi_budget);
+#else
+		napi_consume_skb(tx_buffer->skb, napi_budget);
+#endif
 
 		/* unmap skb header data */
 		dma_unmap_single(tx_ring->dev,
@@ -1208,12 +824,12 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 	u64_stats_update_end(&tx_ring->syncp);
 	q_vector->tx.total_bytes += total_bytes;
 	q_vector->tx.total_packets += total_packets;
-	adapter->tx_ipsec += total_ipsec;
 
 	if (check_for_tx_hang(tx_ring) && ixgbe_check_tx_hang(tx_ring)) {
 		/* schedule immediate reset if we believe we hung */
 		struct ixgbe_hw *hw = &adapter->hw;
-		e_err(drv, "Detected Tx Unit Hang %s\n"
+
+		e_err(drv, "Detected Tx Unit Hang%s\n"
 			"  Tx Queue             <%d>\n"
 			"  TDH, TDT             <%x>, <%x>\n"
 			"  next_to_use          <%x>\n"
@@ -1221,7 +837,7 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 			"tx_buffer_info[next_to_clean]\n"
 			"  time_stamp           <%lx>\n"
 			"  jiffies              <%lx>\n",
-			ring_is_xdp(tx_ring) ? "(XDP)" : "",
+			ring_is_xdp(tx_ring) ? " (XDP)" : "",
 			tx_ring->queue_index,
 			IXGBE_READ_REG(hw, IXGBE_TDH(tx_ring->reg_idx)),
 			IXGBE_READ_REG(hw, IXGBE_TDT(tx_ring->reg_idx)),
@@ -1234,9 +850,8 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 
 		e_info(probe,
 		       "tx hang %d detected on queue %d, resetting adapter\n",
-			adapter->tx_timeout_count + 1, tx_ring->queue_index);
+		       adapter->tx_timeout_count + 1, tx_ring->queue_index);
 
-		/* schedule immediate reset if we believe we hung */
 		ixgbe_tx_timeout_reset(adapter);
 
 		/* the adapter is about to reset, no point in enabling stuff */
@@ -1245,30 +860,37 @@ static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,
 
 	if (ring_is_xdp(tx_ring))
 		return !!budget;
-
 	netdev_tx_completed_queue(txring_txq(tx_ring),
 				  total_packets, total_bytes);
 
 #define TX_WAKE_THRESHOLD (DESC_NEEDED * 2)
-	if (unlikely(total_packets && netif_carrier_ok(tx_ring->netdev) &&
+	if (unlikely(total_packets && netif_carrier_ok(netdev_ring(tx_ring)) &&
 		     (ixgbe_desc_unused(tx_ring) >= TX_WAKE_THRESHOLD))) {
 		/* Make sure that anybody stopping the queue after this
 		 * sees the new next_to_clean.
 		 */
 		smp_mb();
-		if (__netif_subqueue_stopped(tx_ring->netdev,
-					     tx_ring->queue_index)
-		    && !test_bit(__IXGBE_DOWN, &adapter->state)) {
-			netif_wake_subqueue(tx_ring->netdev,
-					    tx_ring->queue_index);
+#ifdef HAVE_TX_MQ
+		if (__netif_subqueue_stopped(netdev_ring(tx_ring),
+					     ring_queue_index(tx_ring))
+		    && !test_bit(__IXGBE_DOWN, &q_vector->adapter->state)) {
+			netif_wake_subqueue(netdev_ring(tx_ring),
+					    ring_queue_index(tx_ring));
 			++tx_ring->tx_stats.restart_queue;
 		}
+#else
+		if (netif_queue_stopped(netdev_ring(tx_ring)) &&
+		    !test_bit(__IXGBE_DOWN, &q_vector->adapter->state)) {
+			netif_wake_queue(netdev_ring(tx_ring));
+			++tx_ring->tx_stats.restart_queue;
+		}
+#endif
 	}
 
 	return !!budget;
 }
 
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 static void ixgbe_update_tx_dca(struct ixgbe_adapter *adapter,
 				struct ixgbe_ring *tx_ring,
 				int cpu)
@@ -1360,7 +982,7 @@ static void ixgbe_update_dca(struct ixgbe_q_vector *q_vector)
 
 static void ixgbe_setup_dca(struct ixgbe_adapter *adapter)
 {
-	int i;
+	int v_idx;
 
 	/* always use CB2 mode, difference is masked in the CB driver */
 	if (adapter->flags & IXGBE_FLAG_DCA_ENABLED)
@@ -1370,9 +992,9 @@ static void ixgbe_setup_dca(struct ixgbe_adapter *adapter)
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_DCA_CTRL,
 				IXGBE_DCA_CTRL_DCA_DISABLE);
 
-	for (i = 0; i < adapter->num_q_vectors; i++) {
-		adapter->q_vector[i]->cpu = -1;
-		ixgbe_update_dca(adapter->q_vector[i]);
+	for (v_idx = 0; v_idx < adapter->num_q_vectors; v_idx++) {
+		adapter->q_vector[v_idx]->cpu = -1;
+		ixgbe_update_dca(adapter->q_vector[v_idx]);
 	}
 }
 
@@ -1389,13 +1011,13 @@ static int __ixgbe_notify_dca(struct device *dev, void *data)
 		/* if we're already enabled, don't do it again */
 		if (adapter->flags & IXGBE_FLAG_DCA_ENABLED)
 			break;
-		if (dca_add_requester(dev) == 0) {
+		if (dca_add_requester(dev) == IXGBE_SUCCESS) {
 			adapter->flags |= IXGBE_FLAG_DCA_ENABLED;
 			IXGBE_WRITE_REG(&adapter->hw, IXGBE_DCA_CTRL,
 					IXGBE_DCA_CTRL_DCA_MODE_CB2);
 			break;
 		}
-		fallthrough; /* DCA is disabled. */
+		/* fall through - DCA is disabled */
 	case DCA_PROVIDER_REMOVE:
 		if (adapter->flags & IXGBE_FLAG_DCA_ENABLED) {
 			dca_remove_requester(dev);
@@ -1406,24 +1028,26 @@ static int __ixgbe_notify_dca(struct device *dev, void *data)
 		break;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
+#endif /* CONFIG_DCA */
 
-#endif /* CONFIG_IXGBE_DCA */
-
+#ifdef NETIF_F_RXHASH
 #define IXGBE_RSS_L4_TYPES_MASK \
 	((1ul << IXGBE_RXDADV_RSSTYPE_IPV4_TCP) | \
 	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV4_UDP) | \
 	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV6_TCP) | \
-	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV6_UDP))
+	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV6_UDP) | \
+	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV6_TCP_EX) | \
+	 (1ul << IXGBE_RXDADV_RSSTYPE_IPV6_UDP_EX))
 
 static inline void ixgbe_rx_hash(struct ixgbe_ring *ring,
 				 union ixgbe_adv_rx_desc *rx_desc,
 				 struct sk_buff *skb)
 {
-	u16 rss_type;
+	u16 rss_type; 
 
-	if (!(ring->netdev->features & NETIF_F_RXHASH))
+	if (!(netdev_ring(ring)->features & NETIF_F_RXHASH))
 		return;
 
 	rss_type = le16_to_cpu(rx_desc->wb.lower.lo_dword.hs_rss.pkt_info) &
@@ -1436,8 +1060,9 @@ static inline void ixgbe_rx_hash(struct ixgbe_ring *ring,
 		     (IXGBE_RSS_L4_TYPES_MASK & (1ul << rss_type)) ?
 		     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
 }
+#endif /* NETIF_F_RXHASH */
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 /**
  * ixgbe_rx_is_fcoe - check the rx desc for incoming pkt type
  * @ring: structure containing ring specific data
@@ -1455,8 +1080,8 @@ static inline bool ixgbe_rx_is_fcoe(struct ixgbe_ring *ring,
 		(cpu_to_le16(IXGBE_ETQF_FILTER_FCOE <<
 			     IXGBE_RXDADV_PKTTYPE_ETQF_SHIFT)));
 }
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 /**
  * ixgbe_rx_checksum - indicate in skb if hw indicated a good cksum
  * @ring: structure containing ring specific data
@@ -1473,13 +1098,16 @@ static inline void ixgbe_rx_checksum(struct ixgbe_ring *ring,
 	skb_checksum_none_assert(skb);
 
 	/* Rx csum disabled */
-	if (!(ring->netdev->features & NETIF_F_RXCSUM))
+	if (!(netdev_ring(ring)->features & NETIF_F_RXCSUM))
 		return;
 
-	/* check for VXLAN and Geneve packets */
+	/* check for VXLAN or Geneve packet type */
 	if (pkt_info & cpu_to_le16(IXGBE_RXDADV_PKTTYPE_VXLAN)) {
 		encap_pkt = true;
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
 		skb->encapsulation = 1;
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
+		skb->ip_summed = CHECKSUM_NONE;
 	}
 
 	/* if IP and error */
@@ -1493,6 +1121,7 @@ static inline void ixgbe_rx_checksum(struct ixgbe_ring *ring,
 		return;
 
 	if (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_TCPE)) {
+
 		/*
 		 * 82599 errata, UDP frames with a 0 checksum can be marked as
 		 * checksum errors.
@@ -1510,19 +1139,90 @@ static inline void ixgbe_rx_checksum(struct ixgbe_ring *ring,
 	if (encap_pkt) {
 		if (!ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_OUTERIPCS))
 			return;
-
+		
 		if (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_ERR_OUTERIPER)) {
 			skb->ip_summed = CHECKSUM_NONE;
 			return;
 		}
+#ifdef HAVE_SKBUFF_CSUM_LEVEL
 		/* If we checked the outer header let the stack know */
 		skb->csum_level = 1;
+#endif /* HAVE_SKBUFF_CSUM_LEVEL */
+	}
+}
+
+static inline void ixgbe_release_rx_desc(struct ixgbe_ring *rx_ring, u32 val)
+{
+	rx_ring->next_to_use = val;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+
+	/* update next to alloc since we have filled the ring */
+	rx_ring->next_to_alloc = val;
+#endif
+	/*
+	 * Force memory writes to complete before letting h/w
+	 * know there are new descriptors to fetch.  (Only
+	 * applicable for weak-ordered memory model archs,
+	 * such as IA-64).
+	 */
+	wmb();
+	writel(val, rx_ring->tail);
+}
+
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+static bool ixgbe_alloc_mapped_skb(struct ixgbe_ring *rx_ring,
+				   struct ixgbe_rx_buffer *bi)
+{
+	struct sk_buff *skb = bi->skb;
+	dma_addr_t dma = bi->dma;
+
+	if (unlikely(dma))
+		return true;
+
+	if (likely(!skb)) {
+		skb = netdev_alloc_skb_ip_align(netdev_ring(rx_ring),
+						rx_ring->rx_buf_len);
+		if (unlikely(!skb)) {
+			rx_ring->rx_stats.alloc_rx_buff_failed++;
+			return false;
+		}
+
+		bi->skb = skb;
+
+	}
+
+	dma = dma_map_single(rx_ring->dev, skb->data,
+			     rx_ring->rx_buf_len, DMA_FROM_DEVICE);
+
+	/*
+	 * if mapping failed free memory back to system since
+	 * there isn't much point in holding memory we can't use
+	 */
+	if (dma_mapping_error(rx_ring->dev, dma)) {
+		dev_kfree_skb_any(skb);
+		bi->skb = NULL;
+
+		rx_ring->rx_stats.alloc_rx_buff_failed++;
+		return false;
 	}
+
+	bi->dma = dma;
+	return true;
 }
 
+#else /* !CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 static inline unsigned int ixgbe_rx_offset(struct ixgbe_ring *rx_ring)
 {
-	return ring_uses_build_skb(rx_ring) ? IXGBE_SKB_PAD : 0;
+	unsigned int res;
+
+	res = ring_uses_build_skb(rx_ring) ? IXGBE_SKB_PAD : 0;
+
+#ifdef HAVE_XDP_SUPPORT
+	if (rx_ring->xdp_prog && res < XDP_PACKET_HEADROOM)
+		res = XDP_PACKET_HEADROOM;
+#endif
+
+	return res;
 }
 
 static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring,
@@ -1530,6 +1230,12 @@ static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring,
 {
 	struct page *page = bi->page;
 	dma_addr_t dma;
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+	DEFINE_DMA_ATTRS(attrs);
+
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
+#endif
 
 	/* since we are recycling buffers we should seldom need to alloc */
 	if (likely(page))
@@ -1546,7 +1252,11 @@ static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring,
 	dma = dma_map_page_attrs(rx_ring->dev, page, 0,
 				 ixgbe_rx_pg_size(rx_ring),
 				 DMA_FROM_DEVICE,
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+				 &attrs);
+#else
 				 IXGBE_RX_DMA_ATTR);
+#endif
 
 	/*
 	 * if mapping failed free memory back to system since
@@ -1562,13 +1272,18 @@ static bool ixgbe_alloc_mapped_page(struct ixgbe_ring *rx_ring,
 	bi->dma = dma;
 	bi->page = page;
 	bi->page_offset = ixgbe_rx_offset(rx_ring);
+#ifdef HAVE_PAGE_COUNT_BULK_UPDATE
 	page_ref_add(page, USHRT_MAX - 1);
 	bi->pagecnt_bias = USHRT_MAX;
+#else
+	bi->pagecnt_bias = 1;
+#endif
 	rx_ring->rx_stats.alloc_rx_page++;
 
 	return true;
 }
 
+#endif /* !CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 /**
  * ixgbe_alloc_rx_buffers - Replace used receive buffers
  * @rx_ring: ring to place buffers on
@@ -1579,7 +1294,9 @@ void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count)
 	union ixgbe_adv_rx_desc *rx_desc;
 	struct ixgbe_rx_buffer *bi;
 	u16 i = rx_ring->next_to_use;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	u16 bufsz;
+#endif
 
 	/* nothing to do */
 	if (!cleaned_count)
@@ -1588,10 +1305,16 @@ void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count)
 	rx_desc = IXGBE_RX_DESC(rx_ring, i);
 	bi = &rx_ring->rx_buffer_info[i];
 	i -= rx_ring->count;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 
 	bufsz = ixgbe_rx_bufsz(rx_ring);
+#endif
 
 	do {
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+		if (!ixgbe_alloc_mapped_skb(rx_ring, bi))
+			break;
+#else
 		if (!ixgbe_alloc_mapped_page(rx_ring, bi))
 			break;
 
@@ -1599,12 +1322,17 @@ void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count)
 		dma_sync_single_range_for_device(rx_ring->dev, bi->dma,
 						 bi->page_offset, bufsz,
 						 DMA_FROM_DEVICE);
+#endif
 
 		/*
 		 * Refresh the desc even if buffer_addrs didn't change
 		 * because each write-back erases this info.
 		 */
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+		rx_desc->read.pkt_addr = cpu_to_le64(bi->dma);
+#else
 		rx_desc->read.pkt_addr = cpu_to_le64(bi->dma + bi->page_offset);
+#endif
 
 		rx_desc++;
 		bi++;
@@ -1623,26 +1351,121 @@ void ixgbe_alloc_rx_buffers(struct ixgbe_ring *rx_ring, u16 cleaned_count)
 
 	i += rx_ring->count;
 
-	if (rx_ring->next_to_use != i) {
-		rx_ring->next_to_use = i;
+	if (rx_ring->next_to_use != i)
+		ixgbe_release_rx_desc(rx_ring, i);
+}
+
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+/**
+ * ixgbe_merge_active_tail - merge active tail into lro skb
+ * @tail: pointer to active tail in frag_list
+ *
+ * This function merges the length and data of an active tail into the
+ * skb containing the frag_list.  It resets the tail's pointer to the head,
+ * but it leaves the heads pointer to tail intact.
+ **/
+static inline struct sk_buff *ixgbe_merge_active_tail(struct sk_buff *tail)
+{
+	struct sk_buff *head = IXGBE_CB(tail)->head;
 
-		/* update next to alloc since we have filled the ring */
-		rx_ring->next_to_alloc = i;
+	if (!head)
+		return tail;
 
-		/* Force memory writes to complete before letting h/w
-		 * know there are new descriptors to fetch.  (Only
-		 * applicable for weak-ordered memory model archs,
-		 * such as IA-64).
-		 */
-		wmb();
-		writel(i, rx_ring->tail);
+	head->len += tail->len;
+	head->data_len += tail->len;
+	head->truesize += tail->truesize;
+
+	IXGBE_CB(tail)->head = NULL;
+
+	return head;
+}
+
+/**
+ * ixgbe_add_active_tail - adds an active tail into the skb frag_list
+ * @head: pointer to the start of the skb
+ * @tail: pointer to active tail to add to frag_list
+ *
+ * This function adds an active tail to the end of the frag list.  This tail
+ * will still be receiving data so we cannot yet ad it's stats to the main
+ * skb.  That is done via ixgbe_merge_active_tail.
+ **/
+static inline void ixgbe_add_active_tail(struct sk_buff *head,
+					 struct sk_buff *tail)
+{
+	struct sk_buff *old_tail = IXGBE_CB(head)->tail;
+
+	if (old_tail) {
+		ixgbe_merge_active_tail(old_tail);
+		old_tail->next = tail;
+	} else {
+		skb_shinfo(head)->frag_list = tail;
+	}
+
+	IXGBE_CB(tail)->head = head;
+	IXGBE_CB(head)->tail = tail;
+}
+
+/**
+ * ixgbe_close_active_frag_list - cleanup pointers on a frag_list skb
+ * @head: pointer to head of an active frag list
+ *
+ * This function will clear the frag_tail_tracker pointer on an active
+ * frag_list and returns true if the pointer was actually set
+ **/
+static inline bool ixgbe_close_active_frag_list(struct sk_buff *head)
+{
+	struct sk_buff *tail = IXGBE_CB(head)->tail;
+
+	if (!tail)
+		return false;
+
+	ixgbe_merge_active_tail(tail);
+
+	IXGBE_CB(head)->tail = NULL;
+
+	return true;
+}
+
+#endif
+#ifdef HAVE_VLAN_RX_REGISTER
+/**
+ * ixgbe_receive_skb - Send a completed packet up the stack
+ * @q_vector: structure containing interrupt and ring information
+ * @skb: packet to send up
+ **/
+static void ixgbe_receive_skb(struct ixgbe_q_vector *q_vector,
+			      struct sk_buff *skb)
+{
+	u16 vlan_tag = IXGBE_CB(skb)->vid;
+
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+	if (vlan_tag & VLAN_VID_MASK) {
+		/* by placing vlgrp at start of structure we can alias it */
+		struct vlan_group **vlgrp = netdev_priv(skb->dev);
+		if (!*vlgrp)
+			dev_kfree_skb_any(skb);
+		else if (q_vector->netpoll_rx)
+			vlan_hwaccel_rx(skb, *vlgrp, vlan_tag);
+		else
+			vlan_gro_receive(&q_vector->napi,
+					 *vlgrp, vlan_tag, skb);
+	} else {
+#endif /* NETIF_F_HW_VLAN_TX || NETIF_F_HW_VLAN_CTAG_TX */
+		if (q_vector->netpoll_rx)
+			netif_rx(skb);
+		else
+			napi_gro_receive(&q_vector->napi, skb);
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
 	}
+#endif /* NETIF_F_HW_VLAN_TX || NETIF_F_HW_VLAN_CTAG_TX */
 }
 
-static void ixgbe_set_rsc_gso_size(struct ixgbe_ring *ring,
+#endif /* HAVE_VLAN_RX_REGISTER */
+#ifdef NETIF_F_GSO
+static void ixgbe_set_rsc_gso_size(struct ixgbe_ring __maybe_unused *ring,
 				   struct sk_buff *skb)
 {
-	u16 hdr_len = skb_headlen(skb);
+	u16 hdr_len = eth_get_headlen(skb->dev, skb->data, skb_headlen(skb));
 
 	/* set gso_size to avoid messing up TCP MSS */
 	skb_shinfo(skb)->gso_size = DIV_ROUND_UP((skb->len - hdr_len),
@@ -1650,6 +1473,7 @@ static void ixgbe_set_rsc_gso_size(struct ixgbe_ring *ring,
 	skb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;
 }
 
+#endif /* NETIF_F_GSO */
 static void ixgbe_update_rsc_stats(struct ixgbe_ring *rx_ring,
 				   struct sk_buff *skb)
 {
@@ -1660,12 +1484,35 @@ static void ixgbe_update_rsc_stats(struct ixgbe_ring *rx_ring,
 	rx_ring->rx_stats.rsc_count += IXGBE_CB(skb)->append_cnt;
 	rx_ring->rx_stats.rsc_flush++;
 
+#ifdef NETIF_F_GSO
 	ixgbe_set_rsc_gso_size(rx_ring, skb);
 
+#endif
 	/* gso_size is computed using append_cnt so always clear it last */
 	IXGBE_CB(skb)->append_cnt = 0;
 }
 
+static void ixgbe_rx_vlan(struct ixgbe_ring *ring,
+			  union ixgbe_adv_rx_desc *rx_desc,
+			  struct sk_buff *skb)
+{
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
+	if ((netdev_ring(ring)->features & NETIF_F_HW_VLAN_CTAG_RX) &&
+#else
+	if ((netdev_ring(ring)->features & NETIF_F_HW_VLAN_RX) &&
+#endif
+	    ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_VP))
+#ifndef HAVE_VLAN_RX_REGISTER
+		__vlan_hwaccel_put_tag(skb,
+				       htons(ETH_P_8021Q),
+				       le16_to_cpu(rx_desc->wb.upper.vlan));
+#else
+		IXGBE_CB(skb)->vid = le16_to_cpu(rx_desc->wb.upper.vlan);
+	else
+		IXGBE_CB(skb)->vid = 0;
+#endif
+}
+
 /**
  * ixgbe_process_skb_fields - Populate skb header fields from Rx descriptor
  * @rx_ring: rx descriptor ring packet is being transacted on
@@ -1680,41 +1527,52 @@ void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring,
 			      union ixgbe_adv_rx_desc *rx_desc,
 			      struct sk_buff *skb)
 {
-	struct net_device *dev = rx_ring->netdev;
+#ifdef HAVE_PTP_1588_CLOCK
 	u32 flags = rx_ring->q_vector->adapter->flags;
 
+#endif
 	ixgbe_update_rsc_stats(rx_ring, skb);
 
+#ifdef NETIF_F_RXHASH
 	ixgbe_rx_hash(rx_ring, rx_desc, skb);
 
+#endif /* NETIF_F_RXHASH */
 	ixgbe_rx_checksum(rx_ring, rx_desc, skb);
-
+#ifdef HAVE_PTP_1588_CLOCK
 	if (unlikely(flags & IXGBE_FLAG_RX_HWTSTAMP_ENABLED))
 		ixgbe_ptp_rx_hwtstamp(rx_ring, rx_desc, skb);
 
-	if ((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&
-	    ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_VP)) {
-		u16 vid = le16_to_cpu(rx_desc->wb.upper.vlan);
-		__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), vid);
-	}
-
-	if (ixgbe_test_staterr(rx_desc, IXGBE_RXDADV_STAT_SECP))
-		ixgbe_ipsec_rx(rx_ring, rx_desc, skb);
-
-	/* record Rx queue, or update MACVLAN statistics */
-	if (netif_is_ixgbe(dev))
-		skb_record_rx_queue(skb, rx_ring->queue_index);
-	else
-		macvlan_count_rx(netdev_priv(dev), skb->len + ETH_HLEN, true,
-				 false);
+#endif
+	ixgbe_rx_vlan(rx_ring, rx_desc, skb);
 
-	skb->protocol = eth_type_trans(skb, dev);
+	skb_record_rx_queue(skb, ring_queue_index(rx_ring));
+	skb->protocol = eth_type_trans(skb, netdev_ring(rx_ring));
 }
 
 void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector,
+		  struct ixgbe_ring *rx_ring,
+		  union ixgbe_adv_rx_desc *rx_desc,
 		  struct sk_buff *skb)
 {
-	napi_gro_receive(&q_vector->napi, skb);
+#ifdef HAVE_NDO_BUSY_POLL
+	skb_mark_napi_id(skb, &q_vector->napi);
+
+	if (ixgbe_qv_busy_polling(q_vector) || q_vector->netpoll_rx) {
+		netif_receive_skb(skb);
+		/* exit early if we busy polled */
+		return;
+	}
+#endif
+
+#ifdef HAVE_VLAN_RX_REGISTER
+		ixgbe_receive_skb(q_vector, skb);
+#else
+		napi_gro_receive(&q_vector->napi, skb);
+#endif
+#ifndef NETIF_F_GRO
+
+	netdev_ring(rx_ring)->last_rx = jiffies;
+#endif
 }
 
 /**
@@ -1732,6 +1590,9 @@ static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring,
 			     union ixgbe_adv_rx_desc *rx_desc,
 			     struct sk_buff *skb)
 {
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	struct sk_buff *next_skb;
+#endif
 	u32 ntc = rx_ring->next_to_clean + 1;
 
 	/* fetch, update, and store next to clean */
@@ -1763,15 +1624,22 @@ static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring,
 		return false;
 
 	/* place skb in next buffer to be received */
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	next_skb = rx_ring->rx_buffer_info[ntc].skb;
+
+	ixgbe_add_active_tail(skb, next_skb);
+	IXGBE_CB(next_skb)->head = skb;
+#else
 	rx_ring->rx_buffer_info[ntc].skb = skb;
+#endif
 	rx_ring->rx_stats.non_eop_descs++;
 
 	return true;
 }
 
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 /**
  * ixgbe_pull_tail - ixgbe specific version of skb_pull_tail
- * @rx_ring: rx descriptor ring packet is being transacted on
  * @skb: pointer to current skb being adjusted
  *
  * This function is an ixgbe specific version of __pskb_pull_tail.  The
@@ -1781,8 +1649,7 @@ static bool ixgbe_is_non_eop(struct ixgbe_ring *rx_ring,
  * As a result we can do things like drop a frag and maintain an accurate
  * truesize for the skb.
  */
-static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring,
-			    struct sk_buff *skb)
+static void ixgbe_pull_tail(struct sk_buff *skb)
 {
 	skb_frag_t *frag = &skb_shinfo(skb)->frags[0];
 	unsigned char *va;
@@ -1824,7 +1691,24 @@ static void ixgbe_pull_tail(struct ixgbe_ring *rx_ring,
 static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,
 				struct sk_buff *skb)
 {
-	if (ring_uses_build_skb(rx_ring)) {
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+	DEFINE_DMA_ATTRS(attrs);
+
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
+
+#endif
+	/* if the page was released unmap it, else just sync our portion */
+	if (unlikely(IXGBE_CB(skb)->page_released)) {
+		dma_unmap_page_attrs(rx_ring->dev, IXGBE_CB(skb)->dma,
+				     ixgbe_rx_pg_size(rx_ring),
+				     DMA_FROM_DEVICE,
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+				     &attrs);
+#else
+				     IXGBE_RX_DMA_ATTR);
+#endif
+	} else if (ring_uses_build_skb(rx_ring)) {
 		unsigned long offset = (unsigned long)(skb->data) & ~PAGE_MASK;
 
 		dma_sync_single_range_for_cpu(rx_ring->dev,
@@ -1841,14 +1725,6 @@ static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,
 					      skb_frag_size(frag),
 					      DMA_FROM_DEVICE);
 	}
-
-	/* If the page was released, just unmap it. */
-	if (unlikely(IXGBE_CB(skb)->page_released)) {
-		dma_unmap_page_attrs(rx_ring->dev, IXGBE_CB(skb)->dma,
-				     ixgbe_rx_pg_size(rx_ring),
-				     DMA_FROM_DEVICE,
-				     IXGBE_RX_DMA_ATTR);
-	}
 }
 
 /**
@@ -1857,7 +1733,7 @@ static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,
  * @rx_desc: pointer to the EOP Rx descriptor
  * @skb: pointer to current skb being fixed
  *
- * Check if the skb is valid in the XDP case it will be an error pointer.
+ * Check if the skb is valid. In the XDP case it will be an error pointer.
  * Return true in this case to abort processing and advance to next
  * descriptor.
  *
@@ -1873,37 +1749,31 @@ static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,
  *
  * Returns true if an error was encountered and skb was freed.
  **/
-bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring,
+bool ixgbe_cleanup_headers(struct ixgbe_ring __maybe_unused *rx_ring,
 			   union ixgbe_adv_rx_desc *rx_desc,
 			   struct sk_buff *skb)
 {
-	struct net_device *netdev = rx_ring->netdev;
-
 	/* XDP packets use error pointer so abort at this point */
 	if (IS_ERR(skb))
 		return true;
 
-	/* Verify netdev is present, and that packet does not have any
-	 * errors that would be unacceptable to the netdev.
-	 */
-	if (!netdev ||
-	    (unlikely(ixgbe_test_staterr(rx_desc,
-					 IXGBE_RXDADV_ERR_FRAME_ERR_MASK) &&
-	     !(netdev->features & NETIF_F_RXALL)))) {
+	/* verify that the packet does not have any known errors */
+	if (unlikely(ixgbe_test_staterr(rx_desc,
+					IXGBE_RXDADV_ERR_FRAME_ERR_MASK))) {
 		dev_kfree_skb_any(skb);
 		return true;
 	}
 
 	/* place header in linear portion of buffer */
 	if (!skb_headlen(skb))
-		ixgbe_pull_tail(rx_ring, skb);
+		ixgbe_pull_tail(skb);
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* do not attempt to pad FCoE Frames as this will disrupt DDP */
 	if (ixgbe_rx_is_fcoe(rx_ring, rx_desc))
 		return false;
-
 #endif
+
 	/* if eth_skb_pad returns an error the skb was freed */
 	if (eth_skb_pad(skb))
 		return true;
@@ -1945,8 +1815,7 @@ static inline bool ixgbe_page_is_reserved(struct page *page)
 	return (page_to_nid(page) != numa_mem_id()) || page_is_pfmemalloc(page);
 }
 
-static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer,
-				    int rx_buffer_pgcnt)
+static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer)
 {
 	unsigned int pagecnt_bias = rx_buffer->pagecnt_bias;
 	struct page *page = rx_buffer->page;
@@ -1957,7 +1826,11 @@ static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer,
 
 #if (PAGE_SIZE < 8192)
 	/* if we are only owner of page we can reuse it */
-	if (unlikely((rx_buffer_pgcnt - pagecnt_bias) > 1))
+#ifdef HAVE_PAGE_COUNT_BULK_UPDATE
+	if (unlikely((page_ref_count(page) - pagecnt_bias) > 1))
+#else
+	if (unlikely((page_count(page) - pagecnt_bias) > 1))
+#endif
 		return false;
 #else
 	/* The last offset is a bit aggressive in that we assume the
@@ -1971,6 +1844,7 @@ static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer,
 		return false;
 #endif
 
+#ifdef HAVE_PAGE_COUNT_BULK_UPDATE
 	/* If we have drained the page fragment pool we need to update
 	 * the pagecnt_bias and page count so that we fully restock the
 	 * number of references the driver holds.
@@ -1979,6 +1853,15 @@ static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer,
 		page_ref_add(page, USHRT_MAX - 1);
 		rx_buffer->pagecnt_bias = USHRT_MAX;
 	}
+#else
+	/* Even if we own the page, we are not allowed to use atomic_set()
+	 * This would break get_page_unless_zero() users.
+	 */
+	if (likely(!pagecnt_bias)) {
+		page_ref_inc(page);
+		rx_buffer->pagecnt_bias = 1;
+	}
+#endif
 
 	return true;
 }
@@ -1988,7 +1871,7 @@ static bool ixgbe_can_reuse_rx_page(struct ixgbe_rx_buffer *rx_buffer,
  * @rx_ring: rx descriptor ring to transact packets on
  * @rx_buffer: buffer containing page to add
  * @skb: sk_buff to place the data into
- * @size: size of data in rx_buffer
+ * @size: size of data
  *
  * This function will add the data contained in rx_buffer->page to the skb.
  * This is done either through a direct copy if the data in the buffer is
@@ -2010,8 +1893,10 @@ static void ixgbe_add_rx_frag(struct ixgbe_ring *rx_ring,
 				SKB_DATA_ALIGN(IXGBE_SKB_PAD + size) :
 				SKB_DATA_ALIGN(size);
 #endif
+
 	skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, rx_buffer->page,
 			rx_buffer->page_offset, size, truesize);
+
 #if (PAGE_SIZE < 8192)
 	rx_buffer->page_offset ^= truesize;
 #else
@@ -2019,21 +1904,14 @@ static void ixgbe_add_rx_frag(struct ixgbe_ring *rx_ring,
 #endif
 }
 
-static struct ixgbe_rx_buffer *ixgbe_get_rx_buffer(struct ixgbe_ring *rx_ring,
-						   union ixgbe_adv_rx_desc *rx_desc,
-						   struct sk_buff **skb,
-						   const unsigned int size,
-						   int *rx_buffer_pgcnt)
+static struct ixgbe_rx_buffer *
+ixgbe_get_rx_buffer(struct ixgbe_ring *rx_ring,
+		    union ixgbe_adv_rx_desc *rx_desc, struct sk_buff **skb,
+		    const unsigned int size)
 {
 	struct ixgbe_rx_buffer *rx_buffer;
 
 	rx_buffer = &rx_ring->rx_buffer_info[rx_ring->next_to_clean];
-	*rx_buffer_pgcnt =
-#if (PAGE_SIZE < 8192)
-		page_count(rx_buffer->page);
-#else
-		0;
-#endif
 	prefetchw(rx_buffer->page);
 	*skb = rx_buffer->skb;
 
@@ -2063,10 +1941,16 @@ static struct ixgbe_rx_buffer *ixgbe_get_rx_buffer(struct ixgbe_ring *rx_ring,
 
 static void ixgbe_put_rx_buffer(struct ixgbe_ring *rx_ring,
 				struct ixgbe_rx_buffer *rx_buffer,
-				struct sk_buff *skb,
-				int rx_buffer_pgcnt)
+				struct sk_buff *skb)
 {
-	if (ixgbe_can_reuse_rx_page(rx_buffer, rx_buffer_pgcnt)) {
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+	DEFINE_DMA_ATTRS(attrs);
+
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
+
+#endif
+	if (ixgbe_can_reuse_rx_page(rx_buffer)) {
 		/* hand second half of page back to the ring */
 		ixgbe_reuse_rx_page(rx_ring, rx_buffer);
 	} else {
@@ -2078,7 +1962,11 @@ static void ixgbe_put_rx_buffer(struct ixgbe_ring *rx_ring,
 			dma_unmap_page_attrs(rx_ring->dev, rx_buffer->dma,
 					     ixgbe_rx_pg_size(rx_ring),
 					     DMA_FROM_DEVICE,
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+					     &attrs);
+#else
 					     IXGBE_RX_DMA_ATTR);
+#endif
 		}
 		__page_frag_cache_drain(rx_buffer->page,
 					rx_buffer->pagecnt_bias);
@@ -2104,8 +1992,10 @@ static struct sk_buff *ixgbe_construct_skb(struct ixgbe_ring *rx_ring,
 	struct sk_buff *skb;
 
 	/* prefetch first cache line of first page */
-	net_prefetch(xdp->data);
-
+	prefetch(xdp->data);
+#if L1_CACHE_BYTES < 128
+	prefetch(xdp->data + L1_CACHE_BYTES);
+#endif
 	/* Note, we get here by enabling legacy-rx via:
 	 *
 	 *    ethtool --set-priv-flags <dev> legacy-rx on
@@ -2148,12 +2038,18 @@ static struct sk_buff *ixgbe_construct_skb(struct ixgbe_ring *rx_ring,
 	return skb;
 }
 
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
 static struct sk_buff *ixgbe_build_skb(struct ixgbe_ring *rx_ring,
 				       struct ixgbe_rx_buffer *rx_buffer,
 				       struct xdp_buff *xdp,
 				       union ixgbe_adv_rx_desc *rx_desc)
 {
+#ifdef HAVE_XDP_BUFF_DATA_META
 	unsigned int metasize = xdp->data - xdp->data_meta;
+	void *va = xdp->data_meta;
+#else
+	void *va = xdp->data;
+#endif
 #if (PAGE_SIZE < 8192)
 	unsigned int truesize = ixgbe_rx_pg_size(rx_ring) / 2;
 #else
@@ -2163,14 +2059,13 @@ static struct sk_buff *ixgbe_build_skb(struct ixgbe_ring *rx_ring,
 #endif
 	struct sk_buff *skb;
 
-	/* Prefetch first cache line of first page. If xdp->data_meta
-	 * is unused, this points extactly as xdp->data, otherwise we
-	 * likely have a consumer accessing first few bytes of meta
-	 * data, and then actual data.
-	 */
-	net_prefetch(xdp->data_meta);
+	/* prefetch first cache line of first page */
+	prefetch(va);
+#if L1_CACHE_BYTES < 128
+	prefetch(va + L1_CACHE_BYTES);
+#endif
 
-	/* build an skb to around the page buffer */
+	/* build an skb around the page buffer */
 	skb = build_skb(xdp->data_hard_start, truesize);
 	if (unlikely(!skb))
 		return NULL;
@@ -2178,8 +2073,10 @@ static struct sk_buff *ixgbe_build_skb(struct ixgbe_ring *rx_ring,
 	/* update pointers within the skb to store the data */
 	skb_reserve(skb, xdp->data - xdp->data_hard_start);
 	__skb_put(skb, xdp->data_end - xdp->data);
+#ifdef HAVE_XDP_BUFF_DATA_META
 	if (metasize)
 		skb_metadata_set(skb, metasize);
+#endif
 
 	/* record DMA address if this is the start of a chain of buffers */
 	if (!ixgbe_test_staterr(rx_desc, IXGBE_RXD_STAT_EOP))
@@ -2195,13 +2092,20 @@ static struct sk_buff *ixgbe_build_skb(struct ixgbe_ring *rx_ring,
 	return skb;
 }
 
-static struct sk_buff *ixgbe_run_xdp(struct ixgbe_adapter *adapter,
-				     struct ixgbe_ring *rx_ring,
-				     struct xdp_buff *xdp)
+#endif  /* HAVE_SWIOTLB_SKIP_CPU_SYNC */
+
+static struct sk_buff *
+ixgbe_run_xdp(struct ixgbe_adapter __maybe_unused *adapter,
+	      struct ixgbe_ring __maybe_unused *rx_ring,
+	      struct xdp_buff __maybe_unused *xdp)
 {
-	int err, result = IXGBE_XDP_PASS;
+	int result = IXGBE_XDP_PASS;
+#ifdef HAVE_XDP_SUPPORT
 	struct bpf_prog *xdp_prog;
+#ifdef HAVE_XDP_FRAME_STRUCT
 	struct xdp_frame *xdpf;
+#endif
+	int err;
 	u32 act;
 
 	rcu_read_lock();
@@ -2210,66 +2114,64 @@ static struct sk_buff *ixgbe_run_xdp(struct ixgbe_adapter *adapter,
 	if (!xdp_prog)
 		goto xdp_out;
 
+#ifdef HAVE_XDP_FRAME_STRUCT
 	prefetchw(xdp->data_hard_start); /* xdp_frame write */
+#endif
 
 	act = bpf_prog_run_xdp(xdp_prog, xdp);
 	switch (act) {
 	case XDP_PASS:
 		break;
 	case XDP_TX:
+#ifdef HAVE_XDP_FRAME_STRUCT
 		xdpf = xdp_convert_buff_to_frame(xdp);
 		if (unlikely(!xdpf)) {
 			result = IXGBE_XDP_CONSUMED;
 			break;
 		}
 		result = ixgbe_xmit_xdp_ring(adapter, xdpf);
+#else
+		result = ixgbe_xmit_xdp_ring(adapter, xdp);
+#endif /* !HAVE_XDP_FRAME_STRUCT */
 		break;
 	case XDP_REDIRECT:
 		err = xdp_do_redirect(adapter->netdev, xdp, xdp_prog);
-		if (!err)
+		if (!err) {
 			result = IXGBE_XDP_REDIR;
-		else
+		} else {
 			result = IXGBE_XDP_CONSUMED;
+		}
 		break;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		fallthrough;
+		/* fallthrough */
 	case XDP_ABORTED:
 		trace_xdp_exception(rx_ring->netdev, xdp_prog, act);
-		fallthrough; /* handle aborts by dropping packet */
+		/* fallthrough -- handle aborts by dropping packet */
 	case XDP_DROP:
 		result = IXGBE_XDP_CONSUMED;
 		break;
 	}
 xdp_out:
 	rcu_read_unlock();
-	return ERR_PTR(-result);
-}
-
-static unsigned int ixgbe_rx_frame_truesize(struct ixgbe_ring *rx_ring,
-					    unsigned int size)
-{
-	unsigned int truesize;
+#endif /* HAVE_XDP_SUPPORT */
 
-#if (PAGE_SIZE < 8192)
-	truesize = ixgbe_rx_pg_size(rx_ring) / 2; /* Must be power-of-2 */
-#else
-	truesize = ring_uses_build_skb(rx_ring) ?
-		SKB_DATA_ALIGN(IXGBE_SKB_PAD + size) +
-		SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) :
-		SKB_DATA_ALIGN(size);
-#endif
-	return truesize;
+	return ERR_PTR(-result);
 }
 
 static void ixgbe_rx_buffer_flip(struct ixgbe_ring *rx_ring,
 				 struct ixgbe_rx_buffer *rx_buffer,
 				 unsigned int size)
 {
-	unsigned int truesize = ixgbe_rx_frame_truesize(rx_ring, size);
 #if (PAGE_SIZE < 8192)
+	unsigned int truesize = ixgbe_rx_pg_size(rx_ring) / 2;
+
 	rx_buffer->page_offset ^= truesize;
 #else
+	unsigned int truesize = ring_uses_build_skb(rx_ring) ?
+				SKB_DATA_ALIGN(IXGBE_SKB_PAD + size) :
+				SKB_DATA_ALIGN(size);
+
 	rx_buffer->page_offset += truesize;
 #endif
 }
@@ -2285,34 +2187,32 @@ static void ixgbe_rx_buffer_flip(struct ixgbe_ring *rx_ring,
  * expensive overhead for IOMMU access this provides a means of avoiding
  * it by maintaining the mapping of the page to the syste.
  *
- * Returns amount of work completed
+ * Returns amount of work completed.
  **/
 static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 			       struct ixgbe_ring *rx_ring,
-			       const int budget)
+			       int budget)
 {
 	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
 	struct ixgbe_adapter *adapter = q_vector->adapter;
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	int ddp_bytes;
 	unsigned int mss = 0;
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
 	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
 	unsigned int xdp_xmit = 0;
 	struct xdp_buff xdp;
 
+	xdp.data = NULL;
+	xdp.data_end = NULL;
+#ifdef HAVE_XDP_BUFF_RXQ
 	xdp.rxq = &rx_ring->xdp_rxq;
-
-	/* Frame size depend on rx_ring setup when PAGE_SIZE=4K */
-#if (PAGE_SIZE < 8192)
-	xdp.frame_sz = ixgbe_rx_frame_truesize(rx_ring, 0);
 #endif
 
 	while (likely(total_rx_packets < budget)) {
 		union ixgbe_adv_rx_desc *rx_desc;
 		struct ixgbe_rx_buffer *rx_buffer;
 		struct sk_buff *skb;
-		int rx_buffer_pgcnt;
 		unsigned int size;
 
 		/* return some buffers to hardware, one at a time is too slow */
@@ -2332,20 +2232,19 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 		 */
 		dma_rmb();
 
-		rx_buffer = ixgbe_get_rx_buffer(rx_ring, rx_desc, &skb, size, &rx_buffer_pgcnt);
+		rx_buffer = ixgbe_get_rx_buffer(rx_ring, rx_desc, &skb, size);
 
 		/* retrieve a buffer from the ring */
 		if (!skb) {
 			xdp.data = page_address(rx_buffer->page) +
 				   rx_buffer->page_offset;
+#ifdef HAVE_XDP_BUFF_DATA_META
 			xdp.data_meta = xdp.data;
+#endif
 			xdp.data_hard_start = xdp.data -
 					      ixgbe_rx_offset(rx_ring);
 			xdp.data_end = xdp.data + size;
-#if (PAGE_SIZE > 4096)
-			/* At larger PAGE_SIZE, frame_sz depend on len size */
-			xdp.frame_sz = ixgbe_rx_frame_truesize(rx_ring, size);
-#endif
+
 			skb = ixgbe_run_xdp(adapter, rx_ring, &xdp);
 		}
 
@@ -2362,9 +2261,11 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 			total_rx_bytes += size;
 		} else if (skb) {
 			ixgbe_add_rx_frag(rx_ring, rx_buffer, skb, size);
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
 		} else if (ring_uses_build_skb(rx_ring)) {
 			skb = ixgbe_build_skb(rx_ring, rx_buffer,
 					      &xdp, rx_desc);
+#endif
 		} else {
 			skb = ixgbe_construct_skb(rx_ring, rx_buffer,
 						  &xdp, rx_desc);
@@ -2377,7 +2278,7 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 			break;
 		}
 
-		ixgbe_put_rx_buffer(rx_ring, rx_buffer, skb, rx_buffer_pgcnt);
+		ixgbe_put_rx_buffer(rx_ring, rx_buffer, skb);
 		cleaned_count++;
 
 		/* place incomplete frames back on ring for completion */
@@ -2394,14 +2295,15 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 		/* populate checksum, timestamp, VLAN, and protocol */
 		ixgbe_process_skb_fields(rx_ring, rx_desc, skb);
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		/* if ddp, not passing to ULD unless for FCP_RSP or error */
 		if (ixgbe_rx_is_fcoe(rx_ring, rx_desc)) {
-			ddp_bytes = ixgbe_fcoe_ddp(adapter, rx_desc, skb);
+			ddp_bytes = ixgbe_fcoe_ddp(q_vector->adapter,
+						   rx_desc, skb);
 			/* include DDPed FCoE data */
 			if (ddp_bytes > 0) {
 				if (!mss) {
-					mss = rx_ring->netdev->mtu -
+					mss = netdev_ring(rx_ring)->mtu -
 						sizeof(struct fcoe_hdr) -
 						sizeof(struct fc_frame_header) -
 						sizeof(struct fcoe_crc_eof);
@@ -2414,12 +2316,15 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 			}
 			if (!ddp_bytes) {
 				dev_kfree_skb_any(skb);
+#ifndef NETIF_F_GRO
+				netdev_ring(rx_ring)->last_rx = jiffies;
+#endif
 				continue;
 			}
 		}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
-		ixgbe_rx_skb(q_vector, skb);
+		ixgbe_rx_skb(q_vector, rx_ring, rx_desc, skb);
 
 		/* update budget accounting */
 		total_rx_packets++;
@@ -2448,22 +2353,211 @@ static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
 	return total_rx_packets;
 }
 
+#else /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 /**
- * ixgbe_configure_msix - Configure MSI-X hardware
- * @adapter: board private structure
+ * ixgbe_clean_rx_irq - Clean completed descriptors from Rx ring - legacy
+ * @q_vector: structure containing interrupt and ring information
+ * @rx_ring: rx descriptor ring to transact packets on
+ * @budget: Total limit on number of packets to process
  *
- * ixgbe_configure_msix sets up the hardware to properly generate MSI-X
- * interrupts.
+ * This function provides a legacy approach to Rx interrupt
+ * handling.  This version will perform better on systems with a low cost
+ * dma mapping API.
+ *
+ * Returns amount of work completed.
  **/
-static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
+static int ixgbe_clean_rx_irq(struct ixgbe_q_vector *q_vector,
+			       struct ixgbe_ring *rx_ring,
+			       int budget)
+{
+	unsigned int total_rx_bytes = 0, total_rx_packets = 0;
+#if IS_ENABLED(CONFIG_FCOE)
+	int ddp_bytes;
+	unsigned int mss = 0;
+#endif /* CONFIG_FCOE */
+	u16 len = 0;
+	u16 cleaned_count = ixgbe_desc_unused(rx_ring);
+
+	while (likely(total_rx_packets < budget)) {
+		struct ixgbe_rx_buffer *rx_buffer;
+		union ixgbe_adv_rx_desc *rx_desc;
+		struct sk_buff *skb;
+		u16 ntc;
+
+		/* return some buffers to hardware, one at a time is too slow */
+		if (cleaned_count >= IXGBE_RX_BUFFER_WRITE) {
+			ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
+			cleaned_count = 0;
+		}
+
+		ntc = rx_ring->next_to_clean;
+		rx_desc = IXGBE_RX_DESC(rx_ring, ntc);
+		rx_buffer = &rx_ring->rx_buffer_info[ntc];
+
+		if (!rx_desc->wb.upper.length)
+			break;
+
+		/* This memory barrier is needed to keep us from reading
+		 * any other fields out of the rx_desc until we know the
+		 * descriptor has been written back
+		 */
+		dma_rmb();
+
+		skb = rx_buffer->skb;
+
+		prefetch(skb->data);
+
+		len = le16_to_cpu(rx_desc->wb.upper.length);
+		/* pull the header of the skb in */
+		__skb_put(skb, len);
+
+		/*
+		 * Delay unmapping of the first packet. It carries the
+		 * header information, HW may still access the header after
+		 * the writeback.  Only unmap it when EOP is reached
+		 */
+		if (!IXGBE_CB(skb)->head) {
+			IXGBE_CB(skb)->dma = rx_buffer->dma;
+		} else {
+			skb = ixgbe_merge_active_tail(skb);
+			dma_unmap_single(rx_ring->dev,
+					 rx_buffer->dma,
+					 rx_ring->rx_buf_len,
+					 DMA_FROM_DEVICE);
+		}
+
+		/* clear skb reference in buffer info structure */
+		rx_buffer->skb = NULL;
+		rx_buffer->dma = 0;
+
+		cleaned_count++;
+
+		if (ixgbe_is_non_eop(rx_ring, rx_desc, skb))
+			continue;
+
+		dma_unmap_single(rx_ring->dev,
+				 IXGBE_CB(skb)->dma,
+				 rx_ring->rx_buf_len,
+				 DMA_FROM_DEVICE);
+
+		IXGBE_CB(skb)->dma = 0;
+
+		if (ixgbe_close_active_frag_list(skb) &&
+		    !IXGBE_CB(skb)->append_cnt) {
+			/* if we got here without RSC the packet is invalid */
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		/* ERR_MASK will only have valid bits if EOP set */
+		if (unlikely(ixgbe_test_staterr(rx_desc,
+					   IXGBE_RXDADV_ERR_FRAME_ERR_MASK))) {
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+
+		/* probably a little skewed due to removing CRC */
+		total_rx_bytes += skb->len;
+
+		/* populate checksum, timestamp, VLAN, and protocol */
+		ixgbe_process_skb_fields(rx_ring, rx_desc, skb);
+
+#if IS_ENABLED(CONFIG_FCOE)
+		/* if ddp, not passing to ULD unless for FCP_RSP or error */
+		if (ixgbe_rx_is_fcoe(rx_ring, rx_desc)) {
+			ddp_bytes = ixgbe_fcoe_ddp(q_vector->adapter,
+						   rx_desc, skb);
+			/* include DDPed FCoE data */
+			if (ddp_bytes > 0) {
+				if (!mss) {
+					mss = netdev_ring(rx_ring)->mtu -
+						sizeof(struct fcoe_hdr) -
+						sizeof(struct fc_frame_header) -
+						sizeof(struct fcoe_crc_eof);
+					if (mss > 512)
+						mss &= ~511;
+				}
+				total_rx_bytes += ddp_bytes;
+				total_rx_packets += DIV_ROUND_UP(ddp_bytes,
+								 mss);
+			}
+			if (!ddp_bytes) {
+				dev_kfree_skb_any(skb);
+#ifndef NETIF_F_GRO
+				netdev_ring(rx_ring)->last_rx = jiffies;
+#endif
+				continue;
+			}
+		}
+
+#endif /* CONFIG_FCOE */
+		ixgbe_rx_skb(q_vector, rx_ring, rx_desc, skb);
+
+		/* update budget accounting */
+		total_rx_packets++;
+	}
+
+	rx_ring->stats.packets += total_rx_packets;
+	rx_ring->stats.bytes += total_rx_bytes;
+	q_vector->rx.total_packets += total_rx_packets;
+	q_vector->rx.total_bytes += total_rx_bytes;
+
+	if (cleaned_count)
+		ixgbe_alloc_rx_buffers(rx_ring, cleaned_count);
+
+	return total_rx_packets;
+}
+
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+#ifdef HAVE_NDO_BUSY_POLL
+/* must be called with local_bh_disable()d */
+static int ixgbe_busy_poll_recv(struct napi_struct *napi)
+{
+	struct ixgbe_q_vector *q_vector =
+			container_of(napi, struct ixgbe_q_vector, napi);
+	struct ixgbe_adapter *adapter = q_vector->adapter;
+	struct ixgbe_ring  *ring;
+	int found = 0;
+
+	if (test_bit(__IXGBE_DOWN, &adapter->state))
+		return LL_FLUSH_FAILED;
+
+	if (!ixgbe_qv_lock_poll(q_vector))
+		return LL_FLUSH_BUSY;
+
+	ixgbe_for_each_ring(ring, q_vector->rx) {
+		found = ixgbe_clean_rx_irq(q_vector, ring, 4);
+#ifdef BP_EXTENDED_STATS
+		if (found)
+			ring->stats.cleaned += found;
+		else
+			ring->stats.misses++;
+#endif
+		if (found)
+			break;
+	}
+
+	ixgbe_qv_unlock_poll(q_vector);
+
+	return found;
+}
+
+#endif /* HAVE_NDO_BUSY_POLL */
+/**
+ * ixgbe_configure_msix - Configure MSI-X hardware
+ * @adapter: board private structure
+ *
+ * ixgbe_configure_msix sets up the hardware to properly generate MSI-X
+ * interrupts.
+ **/
+static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
 {
-	struct ixgbe_q_vector *q_vector;
 	int v_idx;
 	u32 mask;
 
 	/* Populate MSIX to EITR Select */
-	if (adapter->num_vfs > 32) {
-		u32 eitrsel = BIT(adapter->num_vfs - 32) - 1;
+	if (adapter->num_vfs >= 32) {
+		u32 eitrsel = (1 << (adapter->num_vfs - 32)) - 1;
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_EITRSEL, eitrsel);
 	}
 
@@ -2472,8 +2566,8 @@ static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
 	 * corresponding register.
 	 */
 	for (v_idx = 0; v_idx < adapter->num_q_vectors; v_idx++) {
+		struct ixgbe_q_vector *q_vector = adapter->q_vector[v_idx];
 		struct ixgbe_ring *ring;
-		q_vector = adapter->q_vector[v_idx];
 
 		ixgbe_for_each_ring(ring, q_vector->rx)
 			ixgbe_set_ivar(adapter, 0, ring->reg_idx, v_idx);
@@ -2493,7 +2587,7 @@ static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		ixgbe_set_ivar(adapter, -1, 1, v_idx);
 		break;
 	default:
@@ -2510,6 +2604,12 @@ static void ixgbe_configure_msix(struct ixgbe_adapter *adapter)
 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIAC, mask);
 }
 
+static inline bool ixgbe_container_is_rx(struct ixgbe_q_vector *q_vector,
+					 struct ixgbe_ring_container *rc)
+{
+	return &q_vector->rx == rc;
+}
+
 /**
  * ixgbe_update_itr - update the dynamic ITR value based on statistics
  * @q_vector: structure containing interrupt and ring information
@@ -2546,35 +2646,24 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 		goto clear_counts;
 
 	packets = ring_container->total_packets;
-
-	/* We have no packets to actually measure against. This means
-	 * either one of the other queues on this vector is active or
-	 * we are a Tx queue doing TSO with too high of an interrupt rate.
-	 *
-	 * When this occurs just tick up our delay by the minimum value
-	 * and hope that this extra delay will prevent us from being called
-	 * without any work on our queue.
-	 */
-	if (!packets) {
-		itr = (q_vector->itr >> 2) + IXGBE_ITR_ADAPTIVE_MIN_INC;
-		if (itr > IXGBE_ITR_ADAPTIVE_MAX_USECS)
-			itr = IXGBE_ITR_ADAPTIVE_MAX_USECS;
-		itr += ring_container->itr & IXGBE_ITR_ADAPTIVE_LATENCY;
-		goto clear_counts;
-	}
-
 	bytes = ring_container->total_bytes;
 
-	/* If packets are less than 4 or bytes are less than 9000 assume
-	 * insufficient data to use bulk rate limiting approach. We are
-	 * likely latency driven.
-	 */
-	if (packets < 4 && bytes < 9000) {
-		itr = IXGBE_ITR_ADAPTIVE_LATENCY;
-		goto adjust_by_size;
+	if (ixgbe_container_is_rx(q_vector, ring_container)) {
+		/* If Rx and there are 1 to 23 packets and bytes are less than
+		 * 12112 assume insufficient data to use bulk rate limiting
+		 * approach. Instead we will focus on simply trying to target
+		 * receiving 8 times as much data in the next interrupt.
+		 */
+		if (packets && packets < 24 && bytes < 12112) {
+			itr = IXGBE_ITR_ADAPTIVE_LATENCY;
+			avg_wire_size = (bytes + packets * 24) * 2;
+			avg_wire_size = clamp_t(unsigned int,
+						avg_wire_size, 2560, 12800);
+			goto adjust_for_speed;
+		}
 	}
 
-	/* Between 4 and 48 we can assume that our current interrupt delay
+	/* Less than 48 packets we can assume that our current interrupt delay
 	 * is only slightly too low. As such we should increase it by a small
 	 * fixed amount.
 	 */
@@ -2582,6 +2671,20 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 		itr = (q_vector->itr >> 2) + IXGBE_ITR_ADAPTIVE_MIN_INC;
 		if (itr > IXGBE_ITR_ADAPTIVE_MAX_USECS)
 			itr = IXGBE_ITR_ADAPTIVE_MAX_USECS;
+
+		/* If sample size is 0 - 7 we should probably switch
+		 * to latency mode instead of trying to control
+		 * things as though we are in bulk.
+		 *
+		 * Otherwise if the number of packets is less than 48
+		 * we should maintain whatever mode we are currently
+		 * in. The range between 8 and 48 is the cross-over
+		 * point between latency and bulk traffic.
+		 */
+		if (packets < 8)
+			itr += IXGBE_ITR_ADAPTIVE_LATENCY;
+		else
+			itr += ring_container->itr & IXGBE_ITR_ADAPTIVE_LATENCY;
 		goto clear_counts;
 	}
 
@@ -2612,7 +2715,6 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 	 */
 	itr = IXGBE_ITR_ADAPTIVE_BULK;
 
-adjust_by_size:
 	/* If packet counts are 256 or greater we can assume we have a gross
 	 * overestimation of what the rate should be. Instead of trying to fine
 	 * tune it just use the formula below to try and dial in an exact value
@@ -2646,7 +2748,7 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 		/* 16K ints/sec to 9.2K ints/sec */
 		avg_wire_size *= 15;
 		avg_wire_size += 11452;
-	} else if (avg_wire_size < 1968) {
+	} else if (avg_wire_size <= 1980) {
 		/* 9.2K ints/sec to 8K ints/sec */
 		avg_wire_size *= 5;
 		avg_wire_size += 22420;
@@ -2655,12 +2757,7 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 		avg_wire_size = 32256;
 	}
 
-	/* If we are in low latency mode half our delay which doubles the rate
-	 * to somewhere between 100K to 16K ints/sec
-	 */
-	if (itr & IXGBE_ITR_ADAPTIVE_LATENCY)
-		avg_wire_size >>= 1;
-
+adjust_for_speed:
 	/* Resultant value is 256 times larger than it needs to be. This
 	 * gives us room to adjust the value as needed to either increase
 	 * or decrease the value based on link speeds of 10G, 2.5G, 1G, etc.
@@ -2679,14 +2776,21 @@ static void ixgbe_update_itr(struct ixgbe_q_vector *q_vector,
 	case IXGBE_LINK_SPEED_2_5GB_FULL:
 	case IXGBE_LINK_SPEED_1GB_FULL:
 	case IXGBE_LINK_SPEED_10_FULL:
-		if (avg_wire_size > 8064)
-			avg_wire_size = 8064;
 		itr += DIV_ROUND_UP(avg_wire_size,
 				    IXGBE_ITR_ADAPTIVE_MIN_INC * 64) *
 		       IXGBE_ITR_ADAPTIVE_MIN_INC;
 		break;
 	}
 
+	/* In the case of a latency specific workload only allow us to
+	 * reduce the ITR by at most 2us. By doing this we should dial
+	 * in so that our number of interrupts is no more than 2x the number
+	 * of packets for the least busy workload. So for example in the case
+	 * of a TCP worload the ack packets being received would set the
+	 * the interrupt rate as they are a latency specific workload.
+	 */
+	if ((itr & IXGBE_ITR_ADAPTIVE_LATENCY) && itr < ring_container->itr)
+		itr = ring_container->itr - IXGBE_ITR_ADAPTIVE_MIN_INC;
 clear_counts:
 	/* write back value */
 	ring_container->itr = itr;
@@ -2722,7 +2826,7 @@ void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		/*
 		 * set the WDIS bit to not clear the timer bits and cause an
 		 * immediate assertion of the interrupt
@@ -2746,7 +2850,7 @@ static void ixgbe_set_itr(struct ixgbe_q_vector *q_vector)
 	new_itr = min(q_vector->rx.itr, q_vector->tx.itr);
 
 	/* Clear latency flag if set, shift into correct position */
-	new_itr &= ~IXGBE_ITR_ADAPTIVE_LATENCY;
+	new_itr &= IXGBE_ITR_ADAPTIVE_MASK_USECS;
 	new_itr <<= 2;
 
 	if (new_itr != q_vector->itr) {
@@ -2784,7 +2888,7 @@ static void ixgbe_check_overtemp_subtask(struct ixgbe_adapter *adapter)
 		 *  - We may have missed the interrupt so always have to
 		 *    check if we  got a LSC
 		 */
-		if (!(eicr & IXGBE_EICR_GPI_SDP0_8259X) &&
+		if (!(eicr & IXGBE_EICR_GPI_SDP0) &&
 		    !(eicr & IXGBE_EICR_LSC))
 			return;
 
@@ -2812,7 +2916,7 @@ static void ixgbe_check_overtemp_subtask(struct ixgbe_adapter *adapter)
 	default:
 		if (adapter->hw.mac.type >= ixgbe_mac_X540)
 			return;
-		if (!(eicr & IXGBE_EICR_GPI_SDP0(hw)))
+		if (!(eicr & IXGBE_EICR_GPI_SDP0_BY_MAC(hw)))
 			return;
 		break;
 	}
@@ -2826,17 +2930,15 @@ static void ixgbe_check_fan_failure(struct ixgbe_adapter *adapter, u32 eicr)
 	struct ixgbe_hw *hw = &adapter->hw;
 
 	if ((adapter->flags & IXGBE_FLAG_FAN_FAIL_CAPABLE) &&
-	    (eicr & IXGBE_EICR_GPI_SDP1(hw))) {
+	    (eicr & IXGBE_EICR_GPI_SDP1)) {
 		e_crit(probe, "Fan has stopped, replace the adapter\n");
 		/* write to clear the interrupt */
-		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1(hw));
+		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
 	}
 }
 
 static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter, u32 eicr)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
-
 	if (!(adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE))
 		return;
 
@@ -2846,8 +2948,7 @@ static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter, u32 eicr)
 		 * Need to check link state so complete overtemp check
 		 * on service task
 		 */
-		if (((eicr & IXGBE_EICR_GPI_SDP0(hw)) ||
-		     (eicr & IXGBE_EICR_LSC)) &&
+		if (((eicr & IXGBE_EICR_GPI_SDP0) || (eicr & IXGBE_EICR_LSC)) &&
 		    (!test_bit(__IXGBE_DOWN, &adapter->state))) {
 			adapter->interrupt_event = eicr;
 			adapter->flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
@@ -2855,7 +2956,7 @@ static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter, u32 eicr)
 			return;
 		}
 		return;
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		if (eicr & IXGBE_EICR_GPI_SDP0_X550EM_a) {
 			adapter->interrupt_event = eicr;
 			adapter->flags2 |= IXGBE_FLAG2_TEMP_SENSOR_EVENT;
@@ -2878,37 +2979,13 @@ static void ixgbe_check_overtemp_event(struct ixgbe_adapter *adapter, u32 eicr)
 	e_crit(drv, "%s\n", ixgbe_overheat_msg);
 }
 
-static inline bool ixgbe_is_sfp(struct ixgbe_hw *hw)
-{
-	switch (hw->mac.type) {
-	case ixgbe_mac_82598EB:
-		if (hw->phy.type == ixgbe_phy_nl)
-			return true;
-		return false;
-	case ixgbe_mac_82599EB:
-	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		switch (hw->mac.ops.get_media_type(hw)) {
-		case ixgbe_media_type_fiber:
-		case ixgbe_media_type_fiber_qsfp:
-			return true;
-		default:
-			return false;
-		}
-	default:
-		return false;
-	}
-}
-
 static void ixgbe_check_sfp_event(struct ixgbe_adapter *adapter, u32 eicr)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u32 eicr_mask = IXGBE_EICR_GPI_SDP2(hw);
+	u32 eicr_mask = IXGBE_EICR_GPI_SDP2_BY_MAC(hw);
 
 	if (!ixgbe_is_sfp(hw))
 		return;
-
-	/* Later MAC's use different SDP */
 	if (hw->mac.type >= ixgbe_mac_X540)
 		eicr_mask = IXGBE_EICR_GPI_SDP0_X540;
 
@@ -2923,9 +3000,9 @@ static void ixgbe_check_sfp_event(struct ixgbe_adapter *adapter, u32 eicr)
 	}
 
 	if (adapter->hw.mac.type == ixgbe_mac_82599EB &&
-	    (eicr & IXGBE_EICR_GPI_SDP1(hw))) {
+	    (eicr & IXGBE_EICR_GPI_SDP1_BY_MAC(hw))) {
 		/* Clear the interrupt */
-		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1(hw));
+		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1_BY_MAC(hw));
 		if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
 			adapter->flags |= IXGBE_FLAG_NEED_LINK_CONFIG;
 			ixgbe_service_event_schedule(adapter);
@@ -2947,8 +3024,7 @@ static void ixgbe_check_lsc(struct ixgbe_adapter *adapter)
 	}
 }
 
-static inline void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter,
-					   u64 qmask)
+static void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter, u64 qmask)
 {
 	u32 mask;
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -2962,7 +3038,7 @@ static inline void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter,
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		mask = (qmask & 0xFFFFFFFF);
 		if (mask)
 			IXGBE_WRITE_REG(hw, IXGBE_EIMS_EX(0), mask);
@@ -2985,7 +3061,6 @@ static inline void ixgbe_irq_enable_queues(struct ixgbe_adapter *adapter,
 static inline void ixgbe_irq_enable(struct ixgbe_adapter *adapter, bool queues,
 				    bool flush)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
 	u32 mask = (IXGBE_EIMS_ENABLE_MASK & ~IXGBE_EIMS_RTX_QUEUE);
 
 	/* don't reenable LSC while waiting for link */
@@ -2995,36 +3070,39 @@ static inline void ixgbe_irq_enable(struct ixgbe_adapter *adapter, bool queues,
 	if (adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
 		switch (adapter->hw.mac.type) {
 		case ixgbe_mac_82599EB:
-			mask |= IXGBE_EIMS_GPI_SDP0(hw);
+		case ixgbe_mac_X550EM_a:
+			mask |= IXGBE_EIMS_GPI_SDP0_BY_MAC(&adapter->hw);
 			break;
 		case ixgbe_mac_X540:
 		case ixgbe_mac_X550:
-		case ixgbe_mac_X550EM_x:
-		case ixgbe_mac_x550em_a:
 			mask |= IXGBE_EIMS_TS;
 			break;
 		default:
 			break;
 		}
 	if (adapter->flags & IXGBE_FLAG_FAN_FAIL_CAPABLE)
-		mask |= IXGBE_EIMS_GPI_SDP1(hw);
+		mask |= IXGBE_EIMS_GPI_SDP1;
 	switch (adapter->hw.mac.type) {
 	case ixgbe_mac_82599EB:
-		mask |= IXGBE_EIMS_GPI_SDP1(hw);
-		mask |= IXGBE_EIMS_GPI_SDP2(hw);
-		fallthrough;
+		mask |= IXGBE_EIMS_GPI_SDP1;
+		mask |= IXGBE_EIMS_GPI_SDP2;
+		/* fall through */
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		if (adapter->hw.device_id == IXGBE_DEV_ID_X550EM_X_SFP ||
 		    adapter->hw.device_id == IXGBE_DEV_ID_X550EM_A_SFP ||
 		    adapter->hw.device_id == IXGBE_DEV_ID_X550EM_A_SFP_N)
-			mask |= IXGBE_EIMS_GPI_SDP0(&adapter->hw);
+			mask |= IXGBE_EIMS_GPI_SDP0_BY_MAC(&adapter->hw);
 		if (adapter->hw.phy.type == ixgbe_phy_x550em_ext_t)
 			mask |= IXGBE_EICR_GPI_SDP0_X540;
 		mask |= IXGBE_EIMS_ECC;
 		mask |= IXGBE_EIMS_MAILBOX;
+#ifdef HAVE_PTP_1588_CLOCK
+		mask |= IXGBE_EIMS_TIMESYNC;
+#endif
+
 		break;
 	default:
 		break;
@@ -3041,22 +3119,22 @@ static inline void ixgbe_irq_enable(struct ixgbe_adapter *adapter, bool queues,
 		IXGBE_WRITE_FLUSH(&adapter->hw);
 }
 
-static irqreturn_t ixgbe_msix_other(int irq, void *data)
+static irqreturn_t ixgbe_msix_other(int __always_unused irq, void *data)
 {
 	struct ixgbe_adapter *adapter = data;
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 eicr;
 
 	/*
-	 * Workaround for Silicon errata.  Use clear-by-write instead
-	 * of clear-by-read.  Reading with EICS will return the
+	 * Workaround for Silicon errata #26 on 82598.  Use clear-by-write
+	 * instead of clear-by-read.  Reading with EICS will return the
 	 * interrupt causes without clearing, which later be done
 	 * with the write to EICR.
 	 */
 	eicr = IXGBE_READ_REG(hw, IXGBE_EICS);
 
 	/* The lower 16bits of the EICR register are for the queue interrupts
-	 * which should be masked here in order to not accidentally clear them if
+	 * which should be masked here in order to not accidently clear them if
 	 * the bits are high when ixgbe_msix_other is called. There is a race
 	 * condition otherwise which results in possible performance loss
 	 * especially if the ixgbe_msix_other interrupt is triggering
@@ -3077,7 +3155,7 @@ static irqreturn_t ixgbe_msix_other(int irq, void *data)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		if (hw->phy.type == ixgbe_phy_x550em_ext_t &&
 		    (eicr & IXGBE_EICR_GPI_SDP0_X540)) {
 			adapter->flags2 |= IXGBE_FLAG2_PHY_INTERRUPT;
@@ -3086,28 +3164,36 @@ static irqreturn_t ixgbe_msix_other(int irq, void *data)
 					IXGBE_EICR_GPI_SDP0_X540);
 		}
 		if (eicr & IXGBE_EICR_ECC) {
-			e_info(link, "Received ECC Err, initiating reset\n");
+			e_info(link, "Received unrecoverable ECC Err,"
+			       "initiating reset.\n");
 			set_bit(__IXGBE_RESET_REQUESTED, &adapter->state);
 			ixgbe_service_event_schedule(adapter);
 			IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_ECC);
 		}
+#ifdef HAVE_TX_MQ
 		/* Handle Flow Director Full threshold interrupt */
 		if (eicr & IXGBE_EICR_FLOW_DIR) {
 			int reinit_count = 0;
 			int i;
 			for (i = 0; i < adapter->num_tx_queues; i++) {
 				struct ixgbe_ring *ring = adapter->tx_ring[i];
-				if (test_and_clear_bit(__IXGBE_TX_FDIR_INIT_DONE,
-						       &ring->state))
+				if (test_and_clear_bit(
+						      __IXGBE_TX_FDIR_INIT_DONE,
+						      &ring->state))
 					reinit_count++;
 			}
 			if (reinit_count) {
-				/* no more flow director interrupts until after init */
-				IXGBE_WRITE_REG(hw, IXGBE_EIMC, IXGBE_EIMC_FLOW_DIR);
-				adapter->flags2 |= IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
+				/* no more flow director interrupts until
+				 * after init
+				 */
+				IXGBE_WRITE_REG(hw, IXGBE_EIMC,
+						IXGBE_EIMC_FLOW_DIR);
+				adapter->flags2 |=
+					IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
 				ixgbe_service_event_schedule(adapter);
 			}
 		}
+#endif
 		ixgbe_check_sfp_event(adapter, eicr);
 		ixgbe_check_overtemp_event(adapter, eicr);
 		break;
@@ -3117,8 +3203,10 @@ static irqreturn_t ixgbe_msix_other(int irq, void *data)
 
 	ixgbe_check_fan_failure(adapter, eicr);
 
+#ifdef HAVE_PTP_1588_CLOCK
 	if (unlikely(eicr & IXGBE_EICR_TIMESYNC))
-		ixgbe_ptp_check_pps_event(adapter);
+	    ixgbe_ptp_check_pps_event(adapter);
+#endif
 
 	/* re-enable the original interrupt state, no lsc, no queues */
 	if (!test_bit(__IXGBE_DOWN, &adapter->state))
@@ -3127,7 +3215,7 @@ static irqreturn_t ixgbe_msix_other(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t ixgbe_msix_clean_rings(int irq, void *data)
+static irqreturn_t ixgbe_msix_clean_rings(int __always_unused irq, void *data)
 {
 	struct ixgbe_q_vector *q_vector = data;
 
@@ -3140,38 +3228,50 @@ static irqreturn_t ixgbe_msix_clean_rings(int irq, void *data)
 }
 
 /**
- * ixgbe_poll - NAPI Rx polling callback
- * @napi: structure for representing this polling device
- * @budget: how many packets driver is allowed to clean
+ * ixgbe_poll - NAPI polling RX/TX cleanup routine
+ * @napi: napi struct with our devices info in it
+ * @budget: amount of work driver is allowed to do this pass, in packets
  *
- * This function is used for legacy and MSI, NAPI mode
+ * This function will clean all queues associated with a q_vector.
  **/
 int ixgbe_poll(struct napi_struct *napi, int budget)
 {
 	struct ixgbe_q_vector *q_vector =
-				container_of(napi, struct ixgbe_q_vector, napi);
+			       container_of(napi, struct ixgbe_q_vector, napi);
 	struct ixgbe_adapter *adapter = q_vector->adapter;
 	struct ixgbe_ring *ring;
 	int per_ring_budget, work_done = 0;
 	bool clean_complete = true;
 
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 	if (adapter->flags & IXGBE_FLAG_DCA_ENABLED)
 		ixgbe_update_dca(q_vector);
-#endif
+#endif /* CONFIG_DCA */
 
 	ixgbe_for_each_ring(ring, q_vector->tx) {
-		bool wd = ring->xsk_pool ?
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+		bool wd = ring->xsk_umem ?
 			  ixgbe_clean_xdp_tx_irq(q_vector, ring, budget) :
 			  ixgbe_clean_tx_irq(q_vector, ring, budget);
-
 		if (!wd)
+#else
+		if (!ixgbe_clean_tx_irq(q_vector, ring, budget))
+#endif
 			clean_complete = false;
 	}
 
+#ifdef HAVE_NDO_BUSY_POLL
+	if (test_bit(NAPI_STATE_NPSVC, &napi->state))
+		return budget;
+
+	/* Exit if we are called by netpoll or busy polling is active */
+	if ((budget <= 0) || !ixgbe_qv_lock_napi(q_vector))
+		return budget;
+#else
 	/* Exit if we are called by netpoll */
 	if (budget <= 0)
 		return budget;
+#endif
 
 	/* attempt to distribute budget to each queue fairly, but don't allow
 	 * the budget to go below 1 because we'll exit polling */
@@ -3181,30 +3281,41 @@ int ixgbe_poll(struct napi_struct *napi, int budget)
 		per_ring_budget = budget;
 
 	ixgbe_for_each_ring(ring, q_vector->rx) {
-		int cleaned = ring->xsk_pool ?
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+		int cleaned = ring->xsk_umem ?
 			      ixgbe_clean_rx_irq_zc(q_vector, ring,
 						    per_ring_budget) :
 			      ixgbe_clean_rx_irq(q_vector, ring,
 						 per_ring_budget);
-
+#else
+		int cleaned = ixgbe_clean_rx_irq(q_vector, ring,
+						 per_ring_budget);
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
 		work_done += cleaned;
 		if (cleaned >= per_ring_budget)
 			clean_complete = false;
 	}
 
+#ifdef HAVE_NDO_BUSY_POLL
+	ixgbe_qv_unlock_napi(q_vector);
+
+#endif
+#ifndef HAVE_NETDEV_NAPI_LIST
+	if (!netif_running(adapter->netdev))
+		clean_complete = true;
+
+#endif
 	/* If all work not completed, return budget and keep polling */
 	if (!clean_complete)
 		return budget;
-
 	/* all work done, exit the polling mode */
 	if (likely(napi_complete_done(napi, work_done))) {
-		if (adapter->rx_itr_setting & 1)
+		if (adapter->rx_itr_setting == 1)
 			ixgbe_set_itr(q_vector);
 		if (!test_bit(__IXGBE_DOWN, &adapter->state))
 			ixgbe_irq_enable_queues(adapter,
-						BIT_ULL(q_vector->v_idx));
+						((u64)1 << q_vector->v_idx));
 	}
-
 	return min(work_done, budget - 1);
 }
 
@@ -3242,16 +3353,18 @@ static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)
 		err = request_irq(entry->vector, &ixgbe_msix_clean_rings, 0,
 				  q_vector->name, q_vector);
 		if (err) {
-			e_err(probe, "request_irq failed for MSIX interrupt "
-			      "Error: %d\n", err);
+			e_err(probe, "request_irq failed for MSIX interrupt '%s' "
+			      "Error: %d\n", q_vector->name, err);
 			goto free_queue_irqs;
 		}
+#ifdef HAVE_IRQ_AFFINITY_HINT
 		/* If Flow Director is enabled, set interrupt affinity */
 		if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE) {
 			/* assign the mask for this irq */
 			irq_set_affinity_hint(entry->vector,
 					      &q_vector->affinity_mask);
 		}
+#endif /* HAVE_IRQ_AFFINITY_HINT */
 	}
 
 	err = request_irq(adapter->msix_entries[vector].vector,
@@ -3261,13 +3374,15 @@ static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)
 		goto free_queue_irqs;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 
 free_queue_irqs:
 	while (vector) {
 		vector--;
+#ifdef HAVE_IRQ_AFFINITY_HINT
 		irq_set_affinity_hint(adapter->msix_entries[vector].vector,
 				      NULL);
+#endif
 		free_irq(adapter->msix_entries[vector].vector,
 			 adapter->q_vector[vector]);
 	}
@@ -3283,7 +3398,7 @@ static int ixgbe_request_msix_irqs(struct ixgbe_adapter *adapter)
  * @irq: interrupt number
  * @data: pointer to a network interface device structure
  **/
-static irqreturn_t ixgbe_intr(int irq, void *data)
+static irqreturn_t ixgbe_intr(int __always_unused irq, void *data)
 {
 	struct ixgbe_adapter *adapter = data;
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -3317,18 +3432,19 @@ static irqreturn_t ixgbe_intr(int irq, void *data)
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
-		ixgbe_check_sfp_event(adapter, eicr);
-		fallthrough;
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
+
 		if (eicr & IXGBE_EICR_ECC) {
-			e_info(link, "Received ECC Err, initiating reset\n");
+			e_info(link, "Received unrecoverable ECC Err,"
+			       "initiating reset.\n");
 			set_bit(__IXGBE_RESET_REQUESTED, &adapter->state);
 			ixgbe_service_event_schedule(adapter);
 			IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_ECC);
 		}
+		ixgbe_check_sfp_event(adapter, eicr);
 		ixgbe_check_overtemp_event(adapter, eicr);
 		break;
 	default:
@@ -3336,8 +3452,10 @@ static irqreturn_t ixgbe_intr(int irq, void *data)
 	}
 
 	ixgbe_check_fan_failure(adapter, eicr);
+#ifdef HAVE_PTP_1588_CLOCK
 	if (unlikely(eicr & IXGBE_EICR_TIMESYNC))
-		ixgbe_ptp_check_pps_event(adapter);
+	    ixgbe_ptp_check_pps_event(adapter);
+#endif
 
 	/* would disable interrupts here but EIAM disabled it */
 	napi_schedule_irqoff(&q_vector->napi);
@@ -3367,10 +3485,10 @@ static int ixgbe_request_irq(struct ixgbe_adapter *adapter)
 	if (adapter->flags & IXGBE_FLAG_MSIX_ENABLED)
 		err = ixgbe_request_msix_irqs(adapter);
 	else if (adapter->flags & IXGBE_FLAG_MSI_ENABLED)
-		err = request_irq(adapter->pdev->irq, ixgbe_intr, 0,
+		err = request_irq(adapter->pdev->irq, &ixgbe_intr, 0,
 				  netdev->name, adapter);
 	else
-		err = request_irq(adapter->pdev->irq, ixgbe_intr, IRQF_SHARED,
+		err = request_irq(adapter->pdev->irq, &ixgbe_intr, IRQF_SHARED,
 				  netdev->name, adapter);
 
 	if (err)
@@ -3399,9 +3517,11 @@ static void ixgbe_free_irq(struct ixgbe_adapter *adapter)
 		if (!q_vector->rx.ring && !q_vector->tx.ring)
 			continue;
 
+#ifdef HAVE_IRQ_AFFINITY_HINT
 		/* clear the affinity_mask in the IRQ descriptor */
 		irq_set_affinity_hint(entry->vector, NULL);
 
+#endif
 		free_irq(entry->vector, q_vector);
 	}
 
@@ -3422,7 +3542,7 @@ static inline void ixgbe_irq_disable(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC, 0xFFFF0000);
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC_EX(0), ~0);
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_EIMC_EX(1), ~0);
@@ -3476,23 +3596,33 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
 	u32 txdctl = IXGBE_TXDCTL_ENABLE;
 	u8 reg_idx = ring->reg_idx;
 
-	ring->xsk_pool = NULL;
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	ring->xsk_umem = NULL;
 	if (ring_is_xdp(ring))
-		ring->xsk_pool = ixgbe_xsk_pool(adapter, ring);
-
+		ring->xsk_umem = ixgbe_xsk_umem(adapter, ring);
+#endif
 	/* disable queue to avoid issues while updating state */
-	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), 0);
+	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), IXGBE_TXDCTL_SWFLSH);
 	IXGBE_WRITE_FLUSH(hw);
 
-	IXGBE_WRITE_REG(hw, IXGBE_TDBAL(reg_idx),
-			(tdba & DMA_BIT_MASK(32)));
-	IXGBE_WRITE_REG(hw, IXGBE_TDBAH(reg_idx), (tdba >> 32));
+	IXGBE_WRITE_REG(hw, IXGBE_TDBAL(reg_idx), tdba & DMA_BIT_MASK(32));
+	IXGBE_WRITE_REG(hw, IXGBE_TDBAH(reg_idx), tdba >> 32);
 	IXGBE_WRITE_REG(hw, IXGBE_TDLEN(reg_idx),
 			ring->count * sizeof(union ixgbe_adv_tx_desc));
+
+	/* disable head writeback */
+	IXGBE_WRITE_REG(hw, IXGBE_TDWBAH(reg_idx), 0);
+	IXGBE_WRITE_REG(hw, IXGBE_TDWBAL(reg_idx), 0);
+
+	/* reset head and tail pointers */
 	IXGBE_WRITE_REG(hw, IXGBE_TDH(reg_idx), 0);
 	IXGBE_WRITE_REG(hw, IXGBE_TDT(reg_idx), 0);
 	ring->tail = adapter->io_addr + IXGBE_TDT(reg_idx);
 
+	/* reset ntu and ntc to place SW in sync with hardwdare */
+	ring->next_to_clean = 0;
+	ring->next_to_use = 0;
+
 	/*
 	 * set WTHRESH to encourage burst writeback, it should not be set
 	 * higher than 1 when:
@@ -3504,15 +3634,15 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
 	 * currently 40.
 	 */
 	if (!ring->q_vector || (ring->q_vector->itr < IXGBE_100K_ITR))
-		txdctl |= 1u << 16;	/* WTHRESH = 1 */
+		txdctl |= (1 << 16);	/* WTHRESH = 1 */
 	else
-		txdctl |= 8u << 16;	/* WTHRESH = 8 */
+		txdctl |= (8 << 16);	/* WTHRESH = 8 */
 
 	/*
 	 * Setting PTHRESH to 32 both improves performance
 	 * and avoids a TX hang with DFP enabled
 	 */
-	txdctl |= (1u << 8) |	/* HTHRESH = 1 */
+	txdctl |= (1 << 8) |	/* HTHRESH = 1 */
 		   32;		/* PTHRESH = 32 */
 
 	/* reinitialize flowdirector state */
@@ -3529,7 +3659,7 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
 		struct ixgbe_q_vector *q_vector = ring->q_vector;
 
 		if (q_vector)
-			netif_set_xps_queue(ring->netdev,
+			netif_set_xps_queue(adapter->netdev,
 					    &q_vector->affinity_mask,
 					    ring->queue_index);
 	}
@@ -3550,7 +3680,7 @@ void ixgbe_configure_tx_ring(struct ixgbe_adapter *adapter,
 
 	/* poll to verify queue is enabled */
 	do {
-		usleep_range(1000, 2000);
+		msleep(1);
 		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
 	} while (--wait_loop && !(txdctl & IXGBE_TXDCTL_ENABLE));
 	if (!wait_loop)
@@ -3561,7 +3691,7 @@ static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 rttdcs, mtqc;
-	u8 tcs = adapter->hw_tcs;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
 
 	if (hw->mac.type == ixgbe_mac_82598EB)
 		return;
@@ -3572,7 +3702,7 @@ static void ixgbe_setup_mtqc(struct ixgbe_adapter *adapter)
 	IXGBE_WRITE_REG(hw, IXGBE_RTTDCS, rttdcs);
 
 	/* set transmit pool layout */
-	if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
+	if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED) {
 		mtqc = IXGBE_MTQC_VT_ENA;
 		if (tcs > 4)
 			mtqc |= IXGBE_MTQC_RT_ENA | IXGBE_MTQC_8TC_8TQ;
@@ -3624,6 +3754,13 @@ static void ixgbe_configure_tx(struct ixgbe_adapter *adapter)
 	u32 dmatxctl;
 	u32 i;
 
+#ifdef CONFIG_NETDEVICES_MULTIQUEUE
+	if (adapter->num_tx_queues > 1)
+		adapter->netdev->features |= NETIF_F_MULTI_QUEUE;
+	else
+		adapter->netdev->features &= ~NETIF_F_MULTI_QUEUE;
+
+#endif
 	ixgbe_setup_mtqc(adapter);
 
 	if (hw->mac.type != ixgbe_mac_82598EB) {
@@ -3664,18 +3801,16 @@ static void ixgbe_disable_rx_drop(struct ixgbe_adapter *adapter,
 	IXGBE_WRITE_REG(hw, IXGBE_SRRCTL(reg_idx), srrctl);
 }
 
-#ifdef CONFIG_IXGBE_DCB
 void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter)
-#else
-static void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter)
-#endif
 {
 	int i;
 	bool pfc_en = adapter->dcb_cfg.pfc_mode_enable;
 
+#ifdef HAVE_DCBNL_IEEE
 	if (adapter->ixgbe_ieee_pfc)
 		pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
 
+#endif
 	/*
 	 * We should set the drop enable bit if:
 	 *  SR-IOV is enabled
@@ -3695,8 +3830,6 @@ static void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter)
 	}
 }
 
-#define IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT 2
-
 static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter,
 				   struct ixgbe_ring *rx_ring)
 {
@@ -3707,19 +3840,33 @@ static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter,
 	if (hw->mac.type == ixgbe_mac_82598EB) {
 		u16 mask = adapter->ring_feature[RING_F_RSS].mask;
 
+		/* program one srrctl register per VMDq index */
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED)
+			mask = adapter->ring_feature[RING_F_VMDQ].mask;
+
 		/*
 		 * if VMDq is not active we must program one srrctl register
 		 * per RSS queue since we have enabled RDRXCTL.MVMEN
 		 */
 		reg_idx &= mask;
+
+		/* divide by the first bit of the mask to get the indices */
+		if (reg_idx)
+			reg_idx /= ((~mask) + 1) & mask;
 	}
 
 	/* configure header buffer length, needed for RSC */
 	srrctl = IXGBE_RX_HDR_SIZE << IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT;
 
 	/* configure the packet buffer length */
-	if (rx_ring->xsk_pool) {
-		u32 xsk_buf_len = xsk_pool_get_rx_frame_size(rx_ring->xsk_pool);
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	srrctl |= ALIGN(rx_ring->rx_buf_len, 1024) >>
+		  IXGBE_SRRCTL_BSIZEPKT_SHIFT;
+#else
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (rx_ring->xsk_umem) {
+		u32 xsk_buf_len = rx_ring->xsk_umem->chunk_size_nohr -
+				  XDP_PACKET_HEADROOM;
 
 		/* If the MAC support setting RXDCTL.RLPML, the
 		 * SRRCTL[n].BSIZEPKT is set to PAGE_SIZE and
@@ -3734,10 +3881,14 @@ static void ixgbe_configure_srrctl(struct ixgbe_adapter *adapter,
 		else
 			srrctl |= xsk_buf_len >> IXGBE_SRRCTL_BSIZEPKT_SHIFT;
 	} else if (test_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state)) {
+#else
+	if (test_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state)) {
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
 		srrctl |= IXGBE_RXBUFFER_3K >> IXGBE_SRRCTL_BSIZEPKT_SHIFT;
 	} else {
 		srrctl |= IXGBE_RXBUFFER_2K >> IXGBE_SRRCTL_BSIZEPKT_SHIFT;
 	}
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 
 	/* configure descriptor type */
 	srrctl |= IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF;
@@ -3850,20 +4001,16 @@ static void ixgbe_store_vfreta(struct ixgbe_adapter *adapter)
 	u32 i, reta_entries = ixgbe_rss_indir_tbl_entries(adapter);
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 vfreta = 0;
+	unsigned int pf_pool = adapter->num_vfs;
 
 	/* Write redirection table to HW */
 	for (i = 0; i < reta_entries; i++) {
-		u16 pool = adapter->num_rx_pools;
-
 		vfreta |= (u32)adapter->rss_indir_tbl[i] << (i & 0x3) * 8;
-		if ((i & 3) != 3)
-			continue;
-
-		while (pool--)
-			IXGBE_WRITE_REG(hw,
-					IXGBE_PFVFRETA(i >> 2, VMDQ_P(pool)),
+		if ((i & 3) == 3) {
+			IXGBE_WRITE_REG(hw, IXGBE_PFVFRETA(i >> 2, pf_pool),
 					vfreta);
-		vfreta = 0;
+			vfreta = 0;
+		}
 	}
 }
 
@@ -3900,17 +4047,13 @@ static void ixgbe_setup_vfreta(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
+	unsigned int pf_pool = adapter->num_vfs;
 	int i, j;
 
 	/* Fill out hash function seeds */
-	for (i = 0; i < 10; i++) {
-		u16 pool = adapter->num_rx_pools;
-
-		while (pool--)
-			IXGBE_WRITE_REG(hw,
-					IXGBE_PFVFRSSRK(i, VMDQ_P(pool)),
-					*(adapter->rss_key + i));
-	}
+	for (i = 0; i < 10; i++)
+		IXGBE_WRITE_REG(hw, IXGBE_PFVFRSSRK(i, pf_pool),
+				*(adapter->rss_key + i));
 
 	/* Fill out the redirection table */
 	for (i = 0, j = 0; i < 64; i++, j++) {
@@ -3923,11 +4066,13 @@ static void ixgbe_setup_vfreta(struct ixgbe_adapter *adapter)
 	ixgbe_store_vfreta(adapter);
 }
 
+
 static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u32 mrqc = 0, rss_field = 0, vfmrqc = 0;
 	u32 rxcsum;
+	u32 mrqc = 0, rss_field = 0;
+	u32 vfmrqc = 0;
 
 	/* Disable indicating checksum in descriptor, enables RSS hash */
 	rxcsum = IXGBE_READ_REG(hw, IXGBE_RXCSUM);
@@ -3938,9 +4083,9 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 		if (adapter->ring_feature[RING_F_RSS].mask)
 			mrqc = IXGBE_MRQC_RSSEN;
 	} else {
-		u8 tcs = adapter->hw_tcs;
+		u8 tcs = netdev_get_num_tc(adapter->netdev);
 
-		if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED) {
 			if (tcs > 4)
 				mrqc = IXGBE_MRQC_VMDQRT8TCEN;	/* 8 TCs */
 			else if (tcs > 1)
@@ -3950,12 +4095,6 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 				mrqc = IXGBE_MRQC_VMDQRSS32EN;
 			else
 				mrqc = IXGBE_MRQC_VMDQRSS64EN;
-
-			/* Enable L3/L4 for Tx Switched packets only for X550,
-			 * older devices do not support this feature
-			 */
-			if (hw->mac.type >= ixgbe_mac_X550)
-				mrqc |= IXGBE_MRQC_L3L4TXSWEN;
 		} else {
 			if (tcs > 4)
 				mrqc = IXGBE_MRQC_RTRSS8TCEN;
@@ -3964,10 +4103,13 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 			else
 				mrqc = IXGBE_MRQC_RSSEN;
 		}
+
+		/* Enable L3/L4 for Tx Switched packets */
+		mrqc |= IXGBE_MRQC_L3L4TXSWEN;
 	}
 
 	/* Perform hash on these packet types */
-	rss_field |= IXGBE_MRQC_RSS_FIELD_IPV4 |
+	rss_field = IXGBE_MRQC_RSS_FIELD_IPV4 |
 		     IXGBE_MRQC_RSS_FIELD_IPV4_TCP |
 		     IXGBE_MRQC_RSS_FIELD_IPV6 |
 		     IXGBE_MRQC_RSS_FIELD_IPV6_TCP;
@@ -3979,7 +4121,7 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 
 	if ((hw->mac.type >= ixgbe_mac_X550) &&
 	    (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)) {
-		u16 pool = adapter->num_rx_pools;
+		unsigned int pf_pool = adapter->num_vfs;
 
 		/* Enable VF RSS mode */
 		mrqc |= IXGBE_MRQC_MULTIPLE_RSS;
@@ -3989,11 +4131,7 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 		ixgbe_setup_vfreta(adapter);
 		vfmrqc = IXGBE_MRQC_RSSEN;
 		vfmrqc |= rss_field;
-
-		while (pool--)
-			IXGBE_WRITE_REG(hw,
-					IXGBE_PFVFMRQC(VMDQ_P(pool)),
-					vfmrqc);
+		IXGBE_WRITE_REG(hw, IXGBE_PFVFMRQC(pf_pool), vfmrqc);
 	} else {
 		ixgbe_setup_reta(adapter);
 		mrqc |= rss_field;
@@ -4002,12 +4140,31 @@ static void ixgbe_setup_mrqc(struct ixgbe_adapter *adapter)
 }
 
 /**
- * ixgbe_configure_rscctl - enable RSC for the indicated ring
+ * ixgbe_clear_rscctl - disable RSC for the indicated ring
  * @adapter: address of board private structure
  * @ring: structure containing ring specific data
  **/
-static void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter,
-				   struct ixgbe_ring *ring)
+void ixgbe_clear_rscctl(struct ixgbe_adapter *adapter,
+			struct ixgbe_ring *ring)
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 rscctrl;
+	u8 reg_idx = ring->reg_idx;
+
+	rscctrl = IXGBE_READ_REG(hw, IXGBE_RSCCTL(reg_idx));
+	rscctrl &= ~IXGBE_RSCCTL_RSCEN;
+	IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
+
+	clear_ring_rsc_enabled(ring);
+}
+
+/**
+ * ixgbe_configure_rscctl - enable RSC for the indicated ring
+ * @adapter:    address of board private structure
+ * @ring: structure containing ring specific data
+ **/
+void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter,
+			    struct ixgbe_ring *ring)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 rscctrl;
@@ -4023,11 +4180,27 @@ static void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter,
 	 * total size of max desc * buf_len is not greater
 	 * than 65536
 	 */
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+#if (MAX_SKB_FRAGS >= 16)
 	rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
+#elif (MAX_SKB_FRAGS >= 8)
+	rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
+#elif (MAX_SKB_FRAGS >= 4)
+	rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
+#else
+	rscctrl |= IXGBE_RSCCTL_MAXDESC_1;
+#endif
+#else /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+	if (ring->rx_buf_len <= IXGBE_RXBUFFER_4K)
+		rscctrl |= IXGBE_RSCCTL_MAXDESC_16;
+	else if (ring->rx_buf_len <= IXGBE_RXBUFFER_8K)
+		rscctrl |= IXGBE_RSCCTL_MAXDESC_8;
+	else
+		rscctrl |= IXGBE_RSCCTL_MAXDESC_4;
+#endif /* !CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 	IXGBE_WRITE_REG(hw, IXGBE_RSCCTL(reg_idx), rscctrl);
 }
 
-#define IXGBE_MAX_RX_DESC_POLL 10
 static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter,
 				       struct ixgbe_ring *ring)
 {
@@ -4036,7 +4209,7 @@ static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter,
 	u32 rxdctl;
 	u8 reg_idx = ring->reg_idx;
 
-	if (ixgbe_removed(hw->hw_addr))
+	if (IXGBE_REMOVED(hw->hw_addr))
 		return;
 	/* RXDCTL.EN will return 0 on 82598 if link is down, so skip it */
 	if (hw->mac.type == ixgbe_mac_82598EB &&
@@ -4044,13 +4217,13 @@ static void ixgbe_rx_desc_queue_enable(struct ixgbe_adapter *adapter,
 		return;
 
 	do {
-		usleep_range(1000, 2000);
+		msleep(1);
 		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
 	} while (--wait_loop && !(rxdctl & IXGBE_RXDCTL_ENABLE));
 
 	if (!wait_loop) {
-		e_err(drv, "RXDCTL.ENABLE on Rx queue %d not set within "
-		      "the polling period\n", reg_idx);
+		e_err(drv, "RXDCTL.ENABLE on Rx queue %d "
+		      "not set within the polling period\n", reg_idx);
 	}
 }
 
@@ -4063,18 +4236,21 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
 	u32 rxdctl;
 	u8 reg_idx = ring->reg_idx;
 
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 	xdp_rxq_info_unreg_mem_model(&ring->xdp_rxq);
-	ring->xsk_pool = ixgbe_xsk_pool(adapter, ring);
-	if (ring->xsk_pool) {
+	ring->xsk_umem = ixgbe_xsk_umem(adapter, ring);
+	if (ring->xsk_umem) {
+		ring->zca.free = ixgbe_zca_free;
 		WARN_ON(xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,
-						   MEM_TYPE_XSK_BUFF_POOL,
-						   NULL));
-		xsk_pool_set_rxq_info(ring->xsk_pool, &ring->xdp_rxq);
+						   MEM_TYPE_ZERO_COPY,
+						   &ring->zca));
+
 	} else {
 		WARN_ON(xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,
 						   MEM_TYPE_PAGE_SHARED, NULL));
 	}
 
+#endif
 	/* disable queue to avoid use of these values while updating state */
 	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
 	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
@@ -4083,21 +4259,31 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
 	IXGBE_WRITE_FLUSH(hw);
 
-	IXGBE_WRITE_REG(hw, IXGBE_RDBAL(reg_idx), (rdba & DMA_BIT_MASK(32)));
-	IXGBE_WRITE_REG(hw, IXGBE_RDBAH(reg_idx), (rdba >> 32));
+	IXGBE_WRITE_REG(hw, IXGBE_RDBAL(reg_idx), rdba & DMA_BIT_MASK(32));
+	IXGBE_WRITE_REG(hw, IXGBE_RDBAH(reg_idx), rdba >> 32);
 	IXGBE_WRITE_REG(hw, IXGBE_RDLEN(reg_idx),
 			ring->count * sizeof(union ixgbe_adv_rx_desc));
 	/* Force flushing of IXGBE_RDLEN to prevent MDD */
 	IXGBE_WRITE_FLUSH(hw);
 
+	/* reset head and tail pointers */
 	IXGBE_WRITE_REG(hw, IXGBE_RDH(reg_idx), 0);
 	IXGBE_WRITE_REG(hw, IXGBE_RDT(reg_idx), 0);
 	ring->tail = adapter->io_addr + IXGBE_RDT(reg_idx);
 
+	/* reset ntu and ntc to place SW in sync with hardwdare */
+	ring->next_to_clean = 0;
+	ring->next_to_use = 0;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	ring->next_to_alloc = 0;
+#endif
+
 	ixgbe_configure_srrctl(adapter, ring);
+        /* In ESX, RSCCTL configuration is done by on demand */
 	ixgbe_configure_rscctl(adapter, ring);
 
-	if (hw->mac.type == ixgbe_mac_82598EB) {
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
 		/*
 		 * enable cache line friendly hardware writes:
 		 * PTHRESH=32 descriptors (half the internal cache),
@@ -4107,25 +4293,37 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
 		 */
 		rxdctl &= ~0x3FFFFF;
 		rxdctl |=  0x080420;
+		break;
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 #if (PAGE_SIZE < 8192)
-	/* RXDCTL.RLPML does not work on 82599 */
-	} else if (hw->mac.type != ixgbe_mac_82599EB) {
 		rxdctl &= ~(IXGBE_RXDCTL_RLPMLMASK |
 			    IXGBE_RXDCTL_RLPML_EN);
 
-		/* Limit the maximum frame size so we don't overrun the skb.
-		 * This can happen in SRIOV mode when the MTU of the VF is
-		 * higher than the MTU of the PF.
-		 */
+		/* Limit the maximum frame size so we don't overrun the skb */
 		if (ring_uses_build_skb(ring) &&
 		    !test_bit(__IXGBE_RX_3K_BUFFER, &ring->state))
 			rxdctl |= IXGBE_MAX_2K_FRAME_BUILD_SKB |
 				  IXGBE_RXDCTL_RLPML_EN;
 #endif
+#else /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+		/* If operating in IOV mode set RLPML */
+		if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+			break;
+		rxdctl |= ring->rx_buf_len | IXGBE_RXDCTL_RLPML_EN;
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+		break;
+	default:
+		break;
 	}
 
-	if (ring->xsk_pool && hw->mac.type != ixgbe_mac_82599EB) {
-		u32 xsk_buf_len = xsk_pool_get_rx_frame_size(ring->xsk_pool);
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (ring->xsk_umem && hw->mac.type != ixgbe_mac_82599EB) {
+		u32 xsk_buf_len = ring->xsk_umem->chunk_size_nohr -
+				  XDP_PACKET_HEADROOM;
 
 		rxdctl &= ~(IXGBE_RXDCTL_RLPMLMASK |
 			    IXGBE_RXDCTL_RLPML_EN);
@@ -4134,6 +4332,7 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
 		ring->rx_buf_len = xsk_buf_len;
 	}
 
+#endif
 	/* initialize rx_buffer_info */
 	memset(ring->rx_buffer_info, 0,
 	       sizeof(struct ixgbe_rx_buffer) * ring->count);
@@ -4147,17 +4346,21 @@ void ixgbe_configure_rx_ring(struct ixgbe_adapter *adapter,
 	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
 
 	ixgbe_rx_desc_queue_enable(adapter, ring);
-	if (ring->xsk_pool)
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (ring->xsk_umem)
 		ixgbe_alloc_rx_buffers_zc(ring, ixgbe_desc_unused(ring));
 	else
 		ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
+#else
+	ixgbe_alloc_rx_buffers(ring, ixgbe_desc_unused(ring));
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
 }
 
 static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	int rss_i = adapter->ring_feature[RING_F_RSS].indices;
-	u16 pool = adapter->num_rx_pools;
+	int p;
 
 	/* PSRTYPE must be initialized in non 82598 adapters */
 	u32 psrtype = IXGBE_PSRTYPE_TCPHDR |
@@ -4174,51 +4377,129 @@ static void ixgbe_setup_psrtype(struct ixgbe_adapter *adapter)
 	else if (rss_i > 1)
 		psrtype |= 1u << 29;
 
-	while (pool--)
-		IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(VMDQ_P(pool)), psrtype);
+	for (p = 0; p < adapter->num_rx_pools; p++)
+		IXGBE_WRITE_REG(hw, IXGBE_PSRTYPE(VMDQ_P(p)), psrtype);
+}
+
+/**
+ * ixgbe_configure_bridge_mode - common settings for configuring bridge mode
+ * @adapter: the private structure
+ *
+ * This function's purpose is to remove code duplication and configure some
+ * settings require to switch bridge modes.
+ **/
+static void ixgbe_configure_bridge_mode(struct ixgbe_adapter *adapter)
+{
+	struct ixgbe_hw * hw = &adapter->hw;
+	unsigned int p;
+	u32 vmdctl;
+
+	if (adapter->flags & IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE) {
+		/* disable Tx loopback, rely on switch hairpin mode */
+		IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, 0);
+
+		/* must enable Rx switching replication to allow multicast
+		 * packet reception on all VFs, and to enable source address
+		 * pruning.
+		 */
+		vmdctl = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
+		vmdctl |= IXGBE_VT_CTL_REPLEN;
+		IXGBE_WRITE_REG(hw, IXGBE_VMD_CTL, vmdctl);
+
+		/* enable Rx source address pruning. Note, this requires
+		 * replication to be enabled or else it does nothing.
+		 */
+		for (p = 0; p < (adapter->num_vfs + adapter->num_rx_pools); p++) {
+			if (hw->mac.ops.set_source_address_pruning)
+				hw->mac.ops.set_source_address_pruning(hw,
+								       true,
+								       p);
+		}
+	} else {
+		/* enable Tx loopback for internal VF/PF communication */
+		IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
+
+		/* disable Rx switching replication unless we have SR-IOV
+		 * virtual functions
+		 */
+		vmdctl = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
+		if (!adapter->num_vfs)
+			vmdctl &= ~IXGBE_VT_CTL_REPLEN;
+		IXGBE_WRITE_REG(hw, IXGBE_VMD_CTL, vmdctl);
+
+		/* disable Rx source address pruning, since we don't expect to
+		 * be receiving external loopback of our transmitted frames.
+		 */
+		for (p = 0; p < (adapter->num_vfs + adapter->num_rx_pools); p++) {
+			if (hw->mac.ops.set_source_address_pruning)
+				hw->mac.ops.set_source_address_pruning(hw,
+								       false,
+								       p);
+		}
+	}
+
 }
 
 static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u16 pool = adapter->num_rx_pools;
 	u32 reg_offset, vf_shift, vmolr;
 	u32 gcr_ext, vmdctl;
 	int i;
 
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+	if (!(adapter->flags & IXGBE_FLAG_VMDQ_ENABLED))
 		return;
 
-	vmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
-	vmdctl |= IXGBE_VMD_CTL_VMDQ_EN;
-	vmdctl &= ~IXGBE_VT_CTL_POOL_MASK;
-	vmdctl |= VMDQ_P(0) << IXGBE_VT_CTL_POOL_SHIFT;
-	vmdctl |= IXGBE_VT_CTL_REPLEN;
-	IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		vmdctl = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
+		vmdctl |= IXGBE_VMD_CTL_VMDQ_EN;
+		IXGBE_WRITE_REG(hw, IXGBE_VMD_CTL, vmdctl);
+		break;
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		vmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
+		vmdctl |= IXGBE_VT_CTL_VT_ENABLE;
+		vmdctl &= ~IXGBE_VT_CTL_POOL_MASK;
+		vmdctl |= VMDQ_P(0) << IXGBE_VT_CTL_POOL_SHIFT;
+		if (adapter->num_vfs)
+			vmdctl |= IXGBE_VT_CTL_REPLEN;
+		IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
+
+		for (i = 1; i < adapter->num_rx_pools; i++) {
+			int pool = VMDQ_P(i);
 
-	/* accept untagged packets until a vlan tag is
-	 * specifically set for the VMDQ queue/pool
-	 */
-	vmolr = IXGBE_VMOLR_AUPE;
-	while (pool--)
-		IXGBE_WRITE_REG(hw, IXGBE_VMOLR(VMDQ_P(pool)), vmolr);
-
-	vf_shift = VMDQ_P(0) % 32;
-	reg_offset = (VMDQ_P(0) >= 32) ? 1 : 0;
-
-	/* Enable only the PF's pool for Tx/Rx */
-	IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), GENMASK(31, vf_shift));
-	IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset ^ 1), reg_offset - 1);
-	IXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset), GENMASK(31, vf_shift));
-	IXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset ^ 1), reg_offset - 1);
-	if (adapter->bridge_mode == BRIDGE_MODE_VEB)
-		IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
+			/* accept untagged packets until a vlan tag is
+			 * specifically set for the VMDQ queue/pool
+			 */
+			vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(pool));
+			vmolr |= IXGBE_VMOLR_AUPE;
+			IXGBE_WRITE_REG(hw, IXGBE_VMOLR(pool), vmolr);
+		}
 
-	/* Map PF MAC address in RAR Entry 0 to first pool following VFs */
-	hw->mac.ops.set_vmdq(hw, 0, VMDQ_P(0));
+		vf_shift = VMDQ_P(0) % 32;
+		reg_offset = (VMDQ_P(0) >= 32) ? 1 : 0;
 
-	/* clear VLAN promisc flag so VFTA will be updated if necessary */
-	adapter->flags2 &= ~IXGBE_FLAG2_VLAN_PROMISC;
+		/* Enable only the PF pools for Tx/Rx */
+		IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), (~0) << vf_shift);
+		IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset ^ 1), reg_offset - 1);
+		IXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset), (~0) << vf_shift);
+		IXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset ^ 1), reg_offset - 1);
+
+		/* clear VLAN promisc flag so VFTA
+		 * will be updated if necessary
+		 */
+		adapter->flags2 &= ~IXGBE_FLAG2_VLAN_PROMISC;
+		break;
+	default:
+		break;
+	}
+
+	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+		return;
 
 	/*
 	 * Set up VF register offsets for selected VT Mode,
@@ -4238,15 +4519,21 @@ static void ixgbe_configure_virtualization(struct ixgbe_adapter *adapter)
 
 	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, gcr_ext);
 
+	/* configure default bridge settings */
+	ixgbe_configure_bridge_mode(adapter);
+#if IS_ENABLED(CONFIG_PCI_IOV)
 	for (i = 0; i < adapter->num_vfs; i++) {
 		/* configure spoof checking */
 		ixgbe_ndo_set_vf_spoofchk(adapter->netdev, i,
 					  adapter->vfinfo[i].spoofchk_enabled);
 
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 		/* Enable/Disable RSS query feature  */
 		ixgbe_ndo_set_vf_rss_query_en(adapter->netdev, i,
-					  adapter->vfinfo[i].rss_query_enabled);
+					adapter->vfinfo[i].rss_query_enabled);
+#endif /* HAVE_NDO_SET_VF_RSS_QUERY_EN */
 	}
+#endif /* CONFIG_PCI_IOV */
 }
 
 static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
@@ -4257,14 +4544,25 @@ static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
 	struct ixgbe_ring *rx_ring;
 	int i;
 	u32 mhadd, hlreg0;
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	int rx_buf_len;
+#endif
+
+	switch (hw->mac.type) {
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		max_frame += IXGBE_TS_HDR_LEN;
+	default:
+		break;
+	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* adjust max frame to be able to do baby jumbo for FCoE */
 	if ((adapter->flags & IXGBE_FLAG_FCOE_ENABLED) &&
 	    (max_frame < IXGBE_FCOE_JUMBO_FRAME_SIZE))
 		max_frame = IXGBE_FCOE_JUMBO_FRAME_SIZE;
-
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
 
 	/* adjust max frame to be at least the size of a standard frame */
 	if (max_frame < (ETH_FRAME_LEN + ETH_FCS_LEN))
@@ -4278,8 +4576,32 @@ static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
 		IXGBE_WRITE_REG(hw, IXGBE_MHADD, mhadd);
 	}
 
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+		/* MHADD will allow an extra 4 bytes past for vlan tagged frames */
+		max_frame += VLAN_HLEN;
+
+	if (!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) &&
+	    (max_frame <= MAXIMUM_ETHERNET_VLAN_SIZE)) {
+		rx_buf_len = MAXIMUM_ETHERNET_VLAN_SIZE;
+	/*
+	 * Make best use of allocation by using all but 1K of a
+	 * power of 2 allocation that will be used for skb->head.
+	 */
+	} else if (max_frame <= IXGBE_RXBUFFER_3K) {
+		rx_buf_len = IXGBE_RXBUFFER_3K;
+	} else if (max_frame <= IXGBE_RXBUFFER_7K) {
+		rx_buf_len = IXGBE_RXBUFFER_7K;
+	} else if (max_frame <= IXGBE_RXBUFFER_15K) {
+		rx_buf_len = IXGBE_RXBUFFER_15K;
+	} else {
+		rx_buf_len = IXGBE_MAX_RXBUFFER;
+	}
+
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 	hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
-	/* set jumbo enable since MHADD.MFS is keeping size locked at max_frame */
+	/* set jumbo enable since MHADD.MFS is keeping size locked at
+	 * max_frame
+	 */
 	hlreg0 |= IXGBE_HLREG0_JUMBOEN;
 	IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
 
@@ -4291,14 +4613,18 @@ static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
 		rx_ring = adapter->rx_ring[i];
 
 		clear_ring_rsc_enabled(rx_ring);
-		clear_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state);
-		clear_bit(__IXGBE_RX_BUILD_SKB_ENABLED, &rx_ring->state);
-
 		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)
 			set_ring_rsc_enabled(rx_ring);
 
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+		clear_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state);
+		clear_bit(__IXGBE_RX_BUILD_SKB_ENABLED, &rx_ring->state);
+#if IS_ENABLED(CONFIG_FCOE)
+
 		if (test_bit(__IXGBE_RX_FCOE, &rx_ring->state))
 			set_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state);
+#endif
+#ifdef HAVE_SWIOTLB_SKIP_CPU_SYNC
 
 		if (adapter->flags2 & IXGBE_FLAG2_RX_LEGACY)
 			continue;
@@ -4313,6 +4639,20 @@ static void ixgbe_set_rx_buffer_len(struct ixgbe_adapter *adapter)
 		    (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)))
 			set_bit(__IXGBE_RX_3K_BUFFER, &rx_ring->state);
 #endif
+#else /* !HAVE_SWIOTLB_SKIP_CPU_SYNC */
+
+		adapter->flags2 |= IXGBE_FLAG2_RX_LEGACY;
+#endif /* !HAVE_SWIOTLB_SKIP_CPU_SYNC */
+#else /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+
+		rx_ring->rx_buf_len = rx_buf_len;
+#if IS_ENABLED(CONFIG_FCOE)
+
+		if (test_bit(__IXGBE_RX_FCOE, &rx_ring->state) &&
+		    (rx_buf_len < IXGBE_FCOE_JUMBO_FRAME_SIZE))
+			rx_ring->rx_buf_len = IXGBE_FCOE_JUMBO_FRAME_SIZE;
+#endif /* CONFIG_FCOE */
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 	}
 }
 
@@ -4322,25 +4662,12 @@ static void ixgbe_setup_rdrxctl(struct ixgbe_adapter *adapter)
 	u32 rdrxctl = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
 
 	switch (hw->mac.type) {
-	case ixgbe_mac_82598EB:
-		/*
-		 * For VMDq support of different descriptor types or
-		 * buffer sizes through the use of multiple SRRCTL
-		 * registers, RDRXCTL.MVMEN must be set to 1
-		 *
-		 * also, the manual doesn't mention it clearly but DCA hints
-		 * will only use queue 0's tags unless this bit is set.  Side
-		 * effects of setting this bit are only that SRRCTL must be
-		 * fully programmed [0..15]
-		 */
-		rdrxctl |= IXGBE_RDRXCTL_MVMEN;
-		break;
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		if (adapter->num_vfs)
 			rdrxctl |= IXGBE_RDRXCTL_PSP;
-		fallthrough;
+		/* fall through */
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
 		/* Disable RSC for ACK packets */
@@ -4351,6 +4678,19 @@ static void ixgbe_setup_rdrxctl(struct ixgbe_adapter *adapter)
 		rdrxctl |= (IXGBE_RDRXCTL_RSCACKC | IXGBE_RDRXCTL_FCOE_WRFIX);
 		rdrxctl |= IXGBE_RDRXCTL_CRCSTRIP;
 		break;
+	case ixgbe_mac_82598EB:
+		/*
+		 * For VMDq support of different descriptor types or
+		 * buffer sizes through the use of multiple SRRCTL
+		 * registers, RDRXCTL.MVMEN must be set to 1
+		 *
+		 * also, the manual doesn't mention it clearly but DCA hints
+		 * will only use queue 0's tags unless this bit is set.  Side
+		 * effects of setting this bit are only that SRRCTL must be
+		 * fully programmed [0..15]
+		 */
+		rdrxctl |= IXGBE_RDRXCTL_MVMEN;
+		break;
 	default:
 		/* We should do nothing since we don't know this hardware */
 		return;
@@ -4372,7 +4712,7 @@ static void ixgbe_configure_rx(struct ixgbe_adapter *adapter)
 	u32 rxctrl, rfctl;
 
 	/* disable receives while setting up the descriptors */
-	hw->mac.ops.disable_rx(hw);
+	ixgbe_disable_rx(hw);
 
 	ixgbe_setup_psrtype(adapter);
 	ixgbe_setup_rdrxctl(adapter);
@@ -4410,22 +4750,73 @@ static void ixgbe_configure_rx(struct ixgbe_adapter *adapter)
 	hw->mac.ops.enable_rx_dma(hw, rxctrl);
 }
 
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+#ifdef HAVE_INT_NDO_VLAN_RX_ADD_VID
+#ifdef NETIF_F_HW_VLAN_CTAG_TX
 static int ixgbe_vlan_rx_add_vid(struct net_device *netdev,
-				 __be16 proto, u16 vid)
+				 __always_unused __be16 proto, u16 vid)
+#else /* !NETIF_F_HW_VLAN_CTAG_TX */
+static int ixgbe_vlan_rx_add_vid(struct net_device *netdev, u16 vid)
+#endif /* NETIF_F_HW_VLAN_CTAG_TX */
+#else /* !HAVE_INT_NDO_VLAN_RX_ADD_VID */
+static void ixgbe_vlan_rx_add_vid(struct net_device *netdev, u16 vid)
+#endif /* HAVE_INT_NDO_VLAN_RX_ADD_VID */
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
+	int pool_ndx = VMDQ_P(0);
 
 	/* add VID to filter table */
-	if (!vid || !(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
-		hw->mac.ops.set_vfta(&adapter->hw, vid, VMDQ_P(0), true, !!vid);
+	if (hw->mac.ops.set_vfta) {
+#ifndef HAVE_VLAN_RX_REGISTER
+		if (vid < VLAN_N_VID)
+			set_bit(vid, adapter->active_vlans);
+#endif
+
+		if (!vid || !(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
+			hw->mac.ops.set_vfta(hw, vid, pool_ndx, true, !!vid);
+
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED &&
+		    adapter->hw.mac.type != ixgbe_mac_82598EB) {
+			int i;
 
-	set_bit(vid, adapter->active_vlans);
+			/* enable vlan id for all pools */
+			for (i = 1; i < adapter->num_rx_pools; i++)
+				hw->mac.ops.set_vfta(hw, vid, VMDQ_P(i), true,
+#ifdef HAVE_VLAN_RX_REGISTER
+						     false);
+#else
+						     true);
+#endif
+		}
+	}
+#ifndef HAVE_NETDEV_VLAN_FEATURES
 
+	/*
+	 * Copy feature flags from netdev to the vlan netdev for this vid.
+	 * This allows things like TSO to bubble down to our vlan device.
+	 * Some vlans, such as VLAN 0 for DCB will not have a v_netdev so
+	 * we will not have a netdev that needs updating.
+	 */
+	if (adapter->vlgrp) {
+		struct vlan_group *vlgrp = adapter->vlgrp;
+		struct net_device *v_netdev = vlan_group_get_device(vlgrp, vid);
+		if (v_netdev) {
+			v_netdev->features |= netdev->features;
+			vlan_group_set_device(vlgrp, vid, v_netdev);
+		}
+	}
+#endif /* HAVE_NETDEV_VLAN_FEATURES */
+#ifdef HAVE_INT_NDO_VLAN_RX_ADD_VID
 	return 0;
+#endif
 }
 
+#if defined(HAVE_VLAN_RX_REGISTER) && defined(CONFIG_PCI_IOV)
+int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw, u32 vlan)
+#else
 static int ixgbe_find_vlvf_entry(struct ixgbe_hw *hw, u32 vlan)
+#endif
 {
 	u32 vlvf;
 	int idx;
@@ -4458,7 +4849,7 @@ void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid)
 	 * entry other than the PF.
 	 */
 	word = idx * 2 + (VMDQ_P(0) / 32);
-	bits = ~BIT(VMDQ_P(0) % 32);
+	bits = ~(1 << (VMDQ_P(0)) % 32);
 	bits &= IXGBE_READ_REG(hw, IXGBE_VLVFB(word));
 
 	/* Disable the filter so this falls into the default pool. */
@@ -4469,31 +4860,78 @@ void ixgbe_update_pf_promisc_vlvf(struct ixgbe_adapter *adapter, u32 vid)
 	}
 }
 
+#ifdef HAVE_INT_NDO_VLAN_RX_ADD_VID
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
 static int ixgbe_vlan_rx_kill_vid(struct net_device *netdev,
-				  __be16 proto, u16 vid)
+				  __always_unused __be16 proto, u16 vid)
+#else /* !NETIF_F_HW_VLAN_CTAG_RX */
+static int ixgbe_vlan_rx_kill_vid(struct net_device *netdev, u16 vid)
+#endif /* NETIF_F_HW_VLAN_CTAG_RX */
+#else
+static void ixgbe_vlan_rx_kill_vid(struct net_device *netdev, u16 vid)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
+	int pool_ndx = VMDQ_P(0);
+
+	/* User is not allowed to remove vlan ID 0 */
+	if (!vid)
+#ifdef HAVE_INT_NDO_VLAN_RX_ADD_VID
+		return 0;
+#else
+		return;
+#endif
+
+#ifdef HAVE_VLAN_RX_REGISTER
+	if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		ixgbe_irq_disable(adapter);
 
+	vlan_group_set_device(adapter->vlgrp, vid, NULL);
+
+	if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		ixgbe_irq_enable(adapter, true, true);
+
+#endif /* HAVE_VLAN_RX_REGISTER */
 	/* remove VID from filter table */
-	if (vid && !(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
-		hw->mac.ops.set_vfta(hw, vid, VMDQ_P(0), false, true);
+	if (hw->mac.ops.set_vfta) {
+		if (vid && !(adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
+			hw->mac.ops.set_vfta(hw, vid, pool_ndx, false, true);
 
-	clear_bit(vid, adapter->active_vlans);
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED &&
+		    adapter->hw.mac.type != ixgbe_mac_82598EB) {
+			int i;
+
+			/* remove vlan id from all pools */
+			for (i = 1; i < adapter->num_rx_pools; i++)
+				hw->mac.ops.set_vfta(hw, vid, VMDQ_P(i), false,
+						     true);
+		}
+	}
+#ifndef HAVE_VLAN_RX_REGISTER
 
+	clear_bit(vid, adapter->active_vlans);
+#endif
+#ifdef HAVE_INT_NDO_VLAN_RX_ADD_VID
 	return 0;
+#endif
 }
 
+#ifdef HAVE_8021P_SUPPORT
 /**
- * ixgbe_vlan_strip_disable - helper to disable hw vlan stripping
+ * ixgbe_vlan_strip_disable - helper to disable vlan tag stripping
  * @adapter: driver data
  */
-static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter)
+void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 vlnctrl;
 	int i, j;
 
+	/* leave vlan tag stripping enabled for DCB */
+	if (adapter->flags & IXGBE_FLAG_DCB_ENABLED)
+		return;
+
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
 		vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
@@ -4504,13 +4942,10 @@ static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		for (i = 0; i < adapter->num_rx_queues; i++) {
 			struct ixgbe_ring *ring = adapter->rx_ring[i];
 
-			if (!netif_is_ixgbe(ring->netdev))
-				continue;
-
 			j = ring->reg_idx;
 			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
 			vlnctrl &= ~IXGBE_RXDCTL_VME;
@@ -4522,11 +4957,12 @@ static void ixgbe_vlan_strip_disable(struct ixgbe_adapter *adapter)
 	}
 }
 
+#endif /* HAVE_8021P_SUPPORT */
 /**
- * ixgbe_vlan_strip_enable - helper to enable hw vlan stripping
+ * ixgbe_vlan_strip_enable - helper to enable vlan tag stripping
  * @adapter: driver data
  */
-static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter)
+void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 vlnctrl;
@@ -4542,13 +4978,10 @@ static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		for (i = 0; i < adapter->num_rx_queues; i++) {
 			struct ixgbe_ring *ring = adapter->rx_ring[i];
 
-			if (!netif_is_ixgbe(ring->netdev))
-				continue;
-
 			j = ring->reg_idx;
 			vlnctrl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(j));
 			vlnctrl |= IXGBE_RXDCTL_VME;
@@ -4560,6 +4993,7 @@ static void ixgbe_vlan_strip_enable(struct ixgbe_adapter *adapter)
 	}
 }
 
+#ifndef HAVE_VLAN_RX_REGISTER
 static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -4568,7 +5002,7 @@ static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)
 	vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
 
 	if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED) {
-	/* For VMDq and SR-IOV we must leave VLAN filtering enabled */
+	/* we need to keep the VLAN filter on in SRIOV */
 		vlnctrl |= IXGBE_VLNCTRL_VFE;
 		IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
 	} else {
@@ -4593,7 +5027,7 @@ static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)
 		u32 reg_offset = IXGBE_VLVFB(i * 2 + VMDQ_P(0) / 32);
 		u32 vlvfb = IXGBE_READ_REG(hw, reg_offset);
 
-		vlvfb |= BIT(VMDQ_P(0) % 32);
+		vlvfb |= 1 << (VMDQ_P(0) % 32);
 		IXGBE_WRITE_REG(hw, reg_offset, vlvfb);
 	}
 
@@ -4623,7 +5057,7 @@ static void ixgbe_scrub_vfta(struct ixgbe_adapter *adapter, u32 vfta_offset)
 
 		if (vlvf) {
 			/* record VLAN ID in VFTA */
-			vfta[(vid - vid_start) / 32] |= BIT(vid % 32);
+			vfta[(vid - vid_start) / 32] |= 1 << (vid % 32);
 
 			/* if PF is part of this then continue */
 			if (test_bit(vid, adapter->active_vlans))
@@ -4632,7 +5066,7 @@ static void ixgbe_scrub_vfta(struct ixgbe_adapter *adapter, u32 vfta_offset)
 
 		/* remove PF from the pool */
 		word = i * 2 + VMDQ_P(0) / 32;
-		bits = ~BIT(VMDQ_P(0) % 32);
+		bits = ~(1 << (VMDQ_P(0) % 32));
 		bits &= IXGBE_READ_REG(hw, IXGBE_VLVFB(word));
 		IXGBE_WRITE_REG(hw, IXGBE_VLVFB(word), bits);
 	}
@@ -4654,7 +5088,7 @@ static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 vlnctrl, i;
 
-	/* Set VLAN filtering to enabled */
+	/* configure vlan filtering */
 	vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
 	vlnctrl |= IXGBE_VLNCTRL_VFE;
 	IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
@@ -4673,15 +5107,135 @@ static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)
 	for (i = 0; i < hw->mac.vft_size; i += VFTA_BLOCK_SIZE)
 		ixgbe_scrub_vfta(adapter, i);
 }
+#endif /* HAVE_VLAN_RX_REGISTER */
+
+#ifdef HAVE_VLAN_RX_REGISTER
+static void ixgbe_vlan_mode(struct net_device *netdev, struct vlan_group *grp)
+#else
+void ixgbe_vlan_mode(struct net_device *netdev, u32 features)
+#endif
+{
+#if defined(HAVE_VLAN_RX_REGISTER) || defined(HAVE_8021P_SUPPORT)
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#endif
+#ifdef HAVE_8021P_SUPPORT
+	bool enable;
+#endif
+
+#ifdef HAVE_VLAN_RX_REGISTER
+	if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		ixgbe_irq_disable(adapter);
+
+	adapter->vlgrp = grp;
+
+	if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		ixgbe_irq_enable(adapter, true, true);
+#endif
+#ifdef HAVE_8021P_SUPPORT
+#ifdef HAVE_VLAN_RX_REGISTER
+	enable = (grp || (adapter->flags & IXGBE_FLAG_DCB_ENABLED));
+#else
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
+	enable = !!(features & NETIF_F_HW_VLAN_CTAG_RX);
+#else
+	enable = !!(features & NETIF_F_HW_VLAN_RX);
+#endif /* NETIF_F_HW_VLAN_CTAG_RX */
+#endif /* HAVE_VLAN_RX_REGISTER */
+	if (enable)
+		/* enable VLAN tag insert/strip */
+		ixgbe_vlan_strip_enable(adapter);
+	else
+		/* disable VLAN tag insert/strip */
+		ixgbe_vlan_strip_disable(adapter);
+
+#endif /* HAVE_8021P_SUPPORT */
+}
 
 static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter)
 {
 	u16 vid = 1;
+#ifdef HAVE_VLAN_RX_REGISTER
+
+	ixgbe_vlan_mode(adapter->netdev, adapter->vlgrp);
+
+	/*
+	 * add vlan ID 0 and enable vlan tag stripping so we
+	 * always accept priority-tagged traffic
+	 */
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
+	ixgbe_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);
+#else
+	ixgbe_vlan_rx_add_vid(adapter->netdev, 0);
+#endif
+#ifndef HAVE_8021P_SUPPORT
+	ixgbe_vlan_strip_enable(adapter);
+#endif
+
+	if (adapter->vlgrp) {
+		for (; vid < VLAN_N_VID; vid++) {
+			if (!vlan_group_get_device(adapter->vlgrp, vid))
+				continue;
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
+			ixgbe_vlan_rx_add_vid(adapter->netdev,
+					      htons(ETH_P_8021Q), vid);
+#else
+			ixgbe_vlan_rx_add_vid(adapter->netdev, vid);
+#endif
+		}
+	}
+#else /* !HAVE_VLAN_RX_REGISTER */
 
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
 	ixgbe_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), 0);
+#else
+	ixgbe_vlan_rx_add_vid(adapter->netdev, 0);
+#endif
 
 	for_each_set_bit_from(vid, adapter->active_vlans, VLAN_N_VID)
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
 		ixgbe_vlan_rx_add_vid(adapter->netdev, htons(ETH_P_8021Q), vid);
+#else
+		ixgbe_vlan_rx_add_vid(adapter->netdev, vid);
+#endif
+#endif /* HAVE_VLAN_RX_REGISTER */
+}
+
+#endif
+static u8 *ixgbe_addr_list_itr(struct ixgbe_hw __maybe_unused *hw, u8 **mc_addr_ptr, u32 *vmdq)
+{
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+	struct netdev_hw_addr *mc_ptr;
+#else
+	struct dev_mc_list *mc_ptr;
+#endif
+#ifdef CONFIG_PCI_IOV
+	struct ixgbe_adapter *adapter = hw->back;
+#endif /* CONFIG_PCI_IOV */
+	u8 *addr = *mc_addr_ptr;
+
+	/* VMDQ_P implicitely uses the adapter struct when CONFIG_PCI_IOV is
+	 * defined, so we have to wrap the pointer above correctly to prevent
+	 * a warning.
+	 */
+	*vmdq = VMDQ_P(0);
+
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+	mc_ptr = container_of(addr, struct netdev_hw_addr, addr[0]);
+	if (mc_ptr->list.next) {
+		struct netdev_hw_addr *ha;
+
+		ha = list_entry(mc_ptr->list.next, struct netdev_hw_addr, list);
+		*mc_addr_ptr = ha->addr;
+	}
+#else
+	mc_ptr = container_of(addr, struct dev_mc_list, dmi_addr[0]);
+	if (mc_ptr->next)
+		*mc_addr_ptr = mc_ptr->next->dmi_addr;
+#endif
+	else
+		*mc_addr_ptr = NULL;
+
+	return addr;
 }
 
 /**
@@ -4693,24 +5247,44 @@ static void ixgbe_restore_vlan(struct ixgbe_adapter *adapter)
  *                0 on no addresses written
  *                X on writing X addresses to MTA
  **/
-static int ixgbe_write_mc_addr_list(struct net_device *netdev)
+int ixgbe_write_mc_addr_list(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+	struct netdev_hw_addr *ha;
+#endif
+	u8  *addr_list = NULL;
+	int addr_count = 0;
+
+	if (!hw->mac.ops.update_mc_addr_list)
+		return -ENOMEM;
 
 	if (!netif_running(netdev))
 		return 0;
 
-	if (hw->mac.ops.update_mc_addr_list)
-		hw->mac.ops.update_mc_addr_list(hw, netdev);
-	else
-		return -ENOMEM;
-
 #ifdef CONFIG_PCI_IOV
 	ixgbe_restore_vf_multicasts(adapter);
 #endif
 
-	return netdev_mc_count(netdev);
+	if (netdev_mc_empty(netdev)) {
+		hw->mac.ops.update_mc_addr_list(hw, NULL, 0,
+						ixgbe_addr_list_itr, false);
+	} else {
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+		ha = list_first_entry(&netdev->mc.list,
+				      struct netdev_hw_addr, list);
+		addr_list = ha->addr;
+#else
+		addr_list = netdev->mc_list->dmi_addr;
+#endif
+		addr_count = netdev_mc_count(netdev);
+
+		hw->mac.ops.update_mc_addr_list(hw, addr_list, addr_count,
+						ixgbe_addr_list_itr, false);
+	}
+
+	return addr_count;
 }
 
 #ifdef CONFIG_PCI_IOV
@@ -4732,8 +5306,8 @@ void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter)
 			hw->mac.ops.clear_rar(hw, i);
 	}
 }
-
 #endif
+
 static void ixgbe_sync_mac_table(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_mac_addr *mac_table = &adapter->mac_table[0];
@@ -4756,25 +5330,11 @@ static void ixgbe_sync_mac_table(struct ixgbe_adapter *adapter)
 	}
 }
 
-static void ixgbe_flush_sw_mac_table(struct ixgbe_adapter *adapter)
+int ixgbe_available_rars(struct ixgbe_adapter *adapter, u16 pool)
 {
 	struct ixgbe_mac_addr *mac_table = &adapter->mac_table[0];
 	struct ixgbe_hw *hw = &adapter->hw;
-	int i;
-
-	for (i = 0; i < hw->mac.num_rar_entries; i++, mac_table++) {
-		mac_table->state |= IXGBE_MAC_STATE_MODIFIED;
-		mac_table->state &= ~IXGBE_MAC_STATE_IN_USE;
-	}
-
-	ixgbe_sync_mac_table(adapter);
-}
-
-static int ixgbe_available_rars(struct ixgbe_adapter *adapter, u16 pool)
-{
-	struct ixgbe_mac_addr *mac_table = &adapter->mac_table[0];
-	struct ixgbe_hw *hw = &adapter->hw;
-	int i, count = 0;
+	int i, count = 0;
 
 	for (i = 0; i < hw->mac.num_rar_entries; i++, mac_table++) {
 		/* do not count default RAR as available */
@@ -4799,7 +5359,7 @@ static void ixgbe_mac_set_default_filter(struct ixgbe_adapter *adapter)
 	struct ixgbe_mac_addr *mac_table = &adapter->mac_table[0];
 	struct ixgbe_hw *hw = &adapter->hw;
 
-	memcpy(&mac_table->addr, hw->mac.addr, ETH_ALEN);
+	ether_addr_copy(mac_table->addr, hw->mac.addr);
 	mac_table->pool = VMDQ_P(0);
 
 	mac_table->state = IXGBE_MAC_STATE_DEFAULT | IXGBE_MAC_STATE_IN_USE;
@@ -4819,8 +5379,9 @@ int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter,
 		return -EINVAL;
 
 	for (i = 0; i < hw->mac.num_rar_entries; i++, mac_table++) {
-		if (mac_table->state & IXGBE_MAC_STATE_IN_USE)
+		if (mac_table->state & IXGBE_MAC_STATE_IN_USE) {
 			continue;
+		}
 
 		ether_addr_copy(mac_table->addr, addr);
 		mac_table->pool = pool;
@@ -4836,6 +5397,20 @@ int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter,
 	return -ENOMEM;
 }
 
+static void ixgbe_flush_sw_mac_table(struct ixgbe_adapter *adapter)
+{
+	struct ixgbe_mac_addr *mac_table = &adapter->mac_table[0];
+	struct ixgbe_hw *hw = &adapter->hw;
+	int i;
+
+	for (i = 0; i < hw->mac.num_rar_entries; i++, mac_table++) {
+		mac_table->state |= IXGBE_MAC_STATE_MODIFIED;
+		mac_table->state &= ~IXGBE_MAC_STATE_IN_USE;
+	}
+
+	ixgbe_sync_mac_table(adapter);
+}
+
 int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
 			 const u8 *addr, u16 pool)
 {
@@ -4846,7 +5421,7 @@ int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
 	if (is_zero_ether_addr(addr))
 		return -EINVAL;
 
-	/* search table for addr, if found clear IN_USE flag and sync */
+	/* search table for addr, if found clear IN USE flag and sync */
 	for (i = 0; i < hw->mac.num_rar_entries; i++, mac_table++) {
 		/* we can only delete an entry if it is in use */
 		if (!(mac_table->state & IXGBE_MAC_STATE_IN_USE))
@@ -4869,6 +5444,7 @@ int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
 	return -ENOMEM;
 }
 
+#ifdef HAVE_SET_RX_MODE
 static int ixgbe_uc_sync(struct net_device *netdev, const unsigned char *addr)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
@@ -4888,6 +5464,7 @@ static int ixgbe_uc_unsync(struct net_device *netdev, const unsigned char *addr)
 	return 0;
 }
 
+#endif
 /**
  * ixgbe_set_rx_mode - Unicast, Multicast and Promiscuous mode set
  * @netdev: network interface device structure
@@ -4902,33 +5479,62 @@ void ixgbe_set_rx_mode(struct net_device *netdev)
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 fctrl, vmolr = IXGBE_VMOLR_BAM | IXGBE_VMOLR_AUPE;
+#if defined(HAVE_VLAN_RX_REGISTER) || defined(ESX55)
+	u32 vlnctrl;
+#endif
+#if defined(NETIF_F_HW_VLAN_CTAG_FILTER) || defined(NETIF_F_HW_VLAN_FILTER)
 	netdev_features_t features = netdev->features;
+#endif
 	int count;
 
 	/* Check for Promiscuous and All Multicast modes */
 	fctrl = IXGBE_READ_REG(hw, IXGBE_FCTRL);
+#if defined(HAVE_VLAN_RX_REGISTER) || defined(ESX55)
+	vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);
+#endif
 
 	/* set all bits that we expect to always be set */
-	fctrl &= ~IXGBE_FCTRL_SBP; /* disable store-bad-packets */
 	fctrl |= IXGBE_FCTRL_BAM;
 	fctrl |= IXGBE_FCTRL_DPF; /* discard pause frames when FC enabled */
 	fctrl |= IXGBE_FCTRL_PMCF;
 
 	/* clear the bits we are changing the status of */
 	fctrl &= ~(IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
+#if defined(HAVE_VLAN_RX_REGISTER) || defined(ESX55)
+	vlnctrl  &= ~(IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);
+#endif
 	if (netdev->flags & IFF_PROMISC) {
 		hw->addr_ctrl.user_set_promisc = true;
 		fctrl |= (IXGBE_FCTRL_UPE | IXGBE_FCTRL_MPE);
 		vmolr |= IXGBE_VMOLR_MPE;
+#ifdef HAVE_VLAN_RX_REGISTER
+		/* Only disable hardware filter vlans in promiscuous mode
+		 * if SR-IOV and VMDQ are disabled - otherwise ensure
+		 * that hardware VLAN filters remain enabled.
+		 */
+		if ((adapter->flags & (IXGBE_FLAG_VMDQ_ENABLED |
+				       IXGBE_FLAG_SRIOV_ENABLED)))
+			vlnctrl |= (IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);
+#endif
+#ifdef NETIF_F_HW_VLAN_CTAG_FILTER
 		features &= ~NETIF_F_HW_VLAN_CTAG_FILTER;
+#endif
+#ifdef NETIF_F_HW_VLAN_FILTER
+		features &= ~NETIF_F_HW_VLAN_FILTER;
+#endif
 	} else {
 		if (netdev->flags & IFF_ALLMULTI) {
 			fctrl |= IXGBE_FCTRL_MPE;
 			vmolr |= IXGBE_VMOLR_MPE;
 		}
 		hw->addr_ctrl.user_set_promisc = false;
+#if defined(HAVE_VLAN_RX_REGISTER) || defined(ESX55)
+		/* enable hardware vlan filtering */
+		vlnctrl |= IXGBE_VLNCTRL_VFE;
+#endif
 	}
 
+#ifdef HAVE_SET_RX_MODE
 	/*
 	 * Write addresses to available RAR registers, if there is not
 	 * sufficient space to store all the addresses then enable
@@ -4939,7 +5545,9 @@ void ixgbe_set_rx_mode(struct net_device *netdev)
 		vmolr |= IXGBE_VMOLR_ROPE;
 	}
 
-	/* Write addresses to the MTA, if the attempt fails
+#endif
+	/*
+	 * Write addresses to the MTA, if the attempt fails
 	 * then we should just turn on promiscuous mode so
 	 * that we can at least receive multicast traffic
 	 */
@@ -4958,125 +5566,236 @@ void ixgbe_set_rx_mode(struct net_device *netdev)
 		IXGBE_WRITE_REG(hw, IXGBE_VMOLR(VMDQ_P(0)), vmolr);
 	}
 
-	/* This is useful for sniffing bad packets. */
-	if (features & NETIF_F_RXALL) {
-		/* UPE and MPE will be handled by normal PROMISC logic
-		 * in e1000e_set_rx_mode */
-		fctrl |= (IXGBE_FCTRL_SBP | /* Receive bad packets */
-			  IXGBE_FCTRL_BAM | /* RX All Bcast Pkts */
-			  IXGBE_FCTRL_PMCF); /* RX All MAC Ctrl Pkts */
-
-		fctrl &= ~(IXGBE_FCTRL_DPF);
-		/* NOTE:  VLAN filtering is disabled by setting PROMISC */
-	}
-
 	IXGBE_WRITE_REG(hw, IXGBE_FCTRL, fctrl);
 
+#ifdef HAVE_8021P_SUPPORT
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
 	if (features & NETIF_F_HW_VLAN_CTAG_RX)
+#else
+	if (features & NETIF_F_HW_VLAN_RX)
+#endif
 		ixgbe_vlan_strip_enable(adapter);
 	else
 		ixgbe_vlan_strip_disable(adapter);
+#endif /* HAVE_8021P_SUPPORT */
 
+#if defined(NETIF_F_HW_VLAN_CTAG_FILTER)
 	if (features & NETIF_F_HW_VLAN_CTAG_FILTER)
 		ixgbe_vlan_promisc_disable(adapter);
 	else
 		ixgbe_vlan_promisc_enable(adapter);
+#elif defined(NETIF_F_HW_VLAN_FILTER) && !defined(HAVE_VLAN_RX_REGISTER)
+	if (features & NETIF_F_HW_VLAN_FILTER)
+		ixgbe_vlan_promisc_disable(adapter);
+	else
+		ixgbe_vlan_promisc_enable(adapter);
+#elif defined(HAVE_VLAN_RX_REGISTER) || defined(ESX55)
+	IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
+#endif /* NETIF_F_HW_VLAN_CTAG_FILTER */
 }
 
 static void ixgbe_napi_enable_all(struct ixgbe_adapter *adapter)
 {
+	struct ixgbe_q_vector *q_vector;
 	int q_idx;
 
-	for (q_idx = 0; q_idx < adapter->num_q_vectors; q_idx++)
-		napi_enable(&adapter->q_vector[q_idx]->napi);
+	for (q_idx = 0; q_idx < adapter->num_q_vectors; q_idx++) {
+		q_vector = adapter->q_vector[q_idx];
+#ifdef HAVE_NDO_BUSY_POLL
+		ixgbe_qv_init_lock(adapter->q_vector[q_idx]);
+#endif
+		napi_enable(&q_vector->napi);
+	}
 }
 
 static void ixgbe_napi_disable_all(struct ixgbe_adapter *adapter)
 {
+	struct ixgbe_q_vector *q_vector;
 	int q_idx;
 
-	for (q_idx = 0; q_idx < adapter->num_q_vectors; q_idx++)
-		napi_disable(&adapter->q_vector[q_idx]->napi);
+	for (q_idx = 0; q_idx < adapter->num_q_vectors; q_idx++) {
+		q_vector = adapter->q_vector[q_idx];
+		napi_disable(&q_vector->napi);
+#ifdef HAVE_NDO_BUSY_POLL
+		while(!ixgbe_qv_disable(adapter->q_vector[q_idx])) {
+			pr_info("QV %d locked\n", q_idx);
+			usleep_range(1000, 20000);
+		}
+#endif
+	}
 }
 
-static int ixgbe_udp_tunnel_sync(struct net_device *dev, unsigned int table)
+#ifdef HAVE_DCBNL_IEEE
+s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame)
+{
+	__u16 refill[IEEE_8021QAZ_MAX_TCS], max[IEEE_8021QAZ_MAX_TCS];
+	__u8 prio_type[IEEE_8021QAZ_MAX_TCS];
+	int i;
+
+	/* naively give each TC a bwg to map onto CEE hardware */
+	__u8 bwg_id[IEEE_8021QAZ_MAX_TCS] = {0, 1, 2, 3, 4, 5, 6, 7};
+
+	/* Map TSA onto CEE prio type */
+	for (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {
+		switch (ets->tc_tsa[i]) {
+		case IEEE_8021QAZ_TSA_STRICT:
+			prio_type[i] = 2;
+			break;
+		case IEEE_8021QAZ_TSA_ETS:
+			prio_type[i] = 0;
+			break;
+		default:
+			/* Hardware only supports priority strict or
+			 * ETS transmission selection algorithms if
+			 * we receive some other value from dcbnl
+			 * throw an error
+			 */
+			return -EINVAL;
+		}
+	}
+
+	ixgbe_dcb_calculate_tc_credits(ets->tc_tx_bw, refill, max, max_frame);
+	return ixgbe_dcb_hw_config(hw, refill, max,
+				   bwg_id, prio_type, ets->prio_tc);
+}
+#endif /* HAVE_DCBNL_IEEE */
+
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+void ixgbe_clear_udp_tunnel_port(struct ixgbe_adapter *adapter, u32 mask)
 {
-	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_hw *hw = &adapter->hw;
-	struct udp_tunnel_info ti;
+	u32 vxlanctrl;
 
-	udp_tunnel_nic_get_port(dev, table, 0, &ti);
-	if (ti.type == UDP_TUNNEL_TYPE_VXLAN)
-		adapter->vxlan_port = ti.port;
-	else
-		adapter->geneve_port = ti.port;
+	if (!(adapter->flags & (IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE |
+				IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE)))
+		return;
 
-	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL,
-			ntohs(adapter->vxlan_port) |
-			ntohs(adapter->geneve_port) <<
-				IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT);
-	return 0;
+	vxlanctrl = IXGBE_READ_REG(hw, IXGBE_VXLANCTRL) & ~mask;
+	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL, vxlanctrl);
+
+	if (mask & IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK)
+		adapter->vxlan_port = 0;
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+	if (mask & IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK)
+		adapter->geneve_port = 0;
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
 }
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
 
-static const struct udp_tunnel_nic_info ixgbe_udp_tunnels_x550 = {
-	.sync_table	= ixgbe_udp_tunnel_sync,
-	.flags		= UDP_TUNNEL_NIC_INFO_IPV4_ONLY,
-	.tables		= {
-		{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },
-	},
-};
+#ifdef NETIF_F_GSO_PARTIAL
+/* NETIF_F_GSO_IPXIP4/6 may not be defined in all distributions */
+#ifndef NETIF_F_GSO_IPXIP4
+#define NETIF_F_GSO_IPXIP4 0
+#endif
+#ifndef NETIF_F_GSO_IPXIP6
+#define NETIF_F_GSO_IPXIP6 0
+#endif
+#define IXGBE_GSO_PARTIAL_FEATURES (NETIF_F_GSO_GRE | \
+				    NETIF_F_GSO_GRE_CSUM | \
+				    NETIF_F_GSO_IPXIP4 | \
+				    NETIF_F_GSO_IPXIP6 | \
+				    NETIF_F_GSO_UDP_TUNNEL | \
+				    NETIF_F_GSO_UDP_TUNNEL_CSUM)
+#endif /* NETIF_F_GSO_PARTIAL */
 
-static const struct udp_tunnel_nic_info ixgbe_udp_tunnels_x550em_a = {
-	.sync_table	= ixgbe_udp_tunnel_sync,
-	.flags		= UDP_TUNNEL_NIC_INFO_IPV4_ONLY,
-	.tables		= {
-		{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_VXLAN,  },
-		{ .n_entries = 1, .tunnel_types = UDP_TUNNEL_TYPE_GENEVE, },
-	},
-};
+static inline unsigned long ixgbe_tso_features(void)
+{
+	unsigned long features = 0;
 
-#ifdef CONFIG_IXGBE_DCB
-/**
- * ixgbe_configure_dcb - Configure DCB hardware
+#ifdef NETIF_F_TSO
+	features |= NETIF_F_TSO;
+#endif /* NETIF_F_TSO */
+#ifdef NETIF_F_TSO6
+	features |= NETIF_F_TSO6;
+#endif /* NETIF_F_TSO6 */
+#ifdef NETIF_F_GSO_PARTIAL
+	features |= NETIF_F_GSO_PARTIAL | IXGBE_GSO_PARTIAL_FEATURES;
+#endif
+
+	return features;
+}
+
+/*
+ * ixgbe_configure_dcb - Configure DCB hardware support
  * @adapter: ixgbe adapter struct
  *
- * This is called by the driver on open to configure the DCB hardware.
- * This is also called by the gennetlink interface when reconfiguring
- * the DCB state.
+ * Called when the driver opens or needs to reconfigure DCB related bits.
  */
 static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	int max_frame = adapter->netdev->mtu + ETH_HLEN + ETH_FCS_LEN;
+	struct net_device *netdev = adapter->netdev;
 
+	int max_frame = netdev->mtu + ETH_HLEN + ETH_FCS_LEN;
+
+	/* The following workaround for 82598EB was originaly hidden inside a
+	 * kcompat definition of netif_set_gso_max_size. This workaround is
+	 * necessary as the 82598EB hardware does not support TSO and DCB
+	 * unless the stack TSO maximum segment size can be reduced. Older
+	 * kernels do not support the requisite interface, and thus need TSO
+	 * disabled if we want to support DCB.
+	 */
 	if (!(adapter->flags & IXGBE_FLAG_DCB_ENABLED)) {
-		if (hw->mac.type == ixgbe_mac_82598EB)
-			netif_set_gso_max_size(adapter->netdev, 65536);
+		if (hw->mac.type == ixgbe_mac_82598EB) {
+#ifdef NETDEV_CAN_SET_GSO_MAX_SIZE
+			netif_set_gso_max_size(netdev, 65536);
+#else
+			/* We previously disabled TSO, so we should enable it
+			 * now. */
+			netdev->features |= ixgbe_tso_features();
+#ifdef NETIF_F_GSO_PARTIAL
+			netdev->gso_partial_features =
+						     IXGBE_GSO_PARTIAL_FEATURES;
+#endif
+#endif /* NETDEV_CAN_SET_GSO_MAX_SIZE */
+		}
 		return;
 	}
 
-	if (hw->mac.type == ixgbe_mac_82598EB)
-		netif_set_gso_max_size(adapter->netdev, 32768);
-
-#ifdef IXGBE_FCOE
-	if (adapter->netdev->features & NETIF_F_FCOE_MTU)
-		max_frame = max(max_frame, IXGBE_FCOE_JUMBO_FRAME_SIZE);
+	if (hw->mac.type == ixgbe_mac_82598EB) {
+#ifdef NETDEV_CAN_SET_GSO_MAX_SIZE
+		netif_set_gso_max_size(netdev, 32768);
+#else
+		/* Simply disable TSO since we cannot change the maximum
+		 * segment size. */
+		netdev->features &= ~ixgbe_tso_features();
+#ifdef NETIF_F_GSO_PARTIAL
+		netdev->gso_partial_features = 0;
 #endif
+#endif /* NETDEV_CAN_SET_GSO_MAX_SIZE */
+	}
+
+#if IS_ENABLED(CONFIG_FCOE)
+	if (netdev->features & NETIF_F_FCOE_MTU)
+		max_frame = max_t(int, max_frame,
+				  IXGBE_FCOE_JUMBO_FRAME_SIZE);
+#endif /* CONFIG_FCOE */
 
-	/* reconfigure the hardware */
-	if (adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE) {
-		ixgbe_dcb_calculate_tc_credits(hw, &adapter->dcb_cfg, max_frame,
-						DCB_TX_CONFIG);
-		ixgbe_dcb_calculate_tc_credits(hw, &adapter->dcb_cfg, max_frame,
-						DCB_RX_CONFIG);
-		ixgbe_dcb_hw_config(hw, &adapter->dcb_cfg);
-	} else if (adapter->ixgbe_ieee_ets && adapter->ixgbe_ieee_pfc) {
-		ixgbe_dcb_hw_ets(&adapter->hw,
-				 adapter->ixgbe_ieee_ets,
-				 max_frame);
-		ixgbe_dcb_hw_pfc_config(&adapter->hw,
-					adapter->ixgbe_ieee_pfc->pfc_en,
-					adapter->ixgbe_ieee_ets->prio_tc);
+#ifdef HAVE_DCBNL_IEEE
+	if (adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE) {
+		if (adapter->ixgbe_ieee_ets)
+			ixgbe_dcb_hw_ets(&adapter->hw,
+					 adapter->ixgbe_ieee_ets,
+					 max_frame);
+
+		if (adapter->ixgbe_ieee_pfc && adapter->ixgbe_ieee_ets) {
+			struct ieee_pfc *pfc = adapter->ixgbe_ieee_pfc;
+			u8 *tc = adapter->ixgbe_ieee_ets->prio_tc;
+
+			ixgbe_dcb_config_pfc(&adapter->hw, pfc->pfc_en, tc);
+		}
+	} else
+#endif /* HAVE_DCBNL_IEEE */
+	{
+		ixgbe_dcb_calculate_tc_credits_cee(hw,
+						   &adapter->dcb_cfg,
+						   max_frame,
+						   IXGBE_DCB_TX_CONFIG);
+		ixgbe_dcb_calculate_tc_credits_cee(hw,
+						   &adapter->dcb_cfg,
+						   max_frame,
+						   IXGBE_DCB_RX_CONFIG);
+		ixgbe_dcb_hw_config_cee(hw, &adapter->dcb_cfg);
 	}
 
 	/* Enable RSS Hash per TC */
@@ -5093,16 +5812,149 @@ static void ixgbe_configure_dcb(struct ixgbe_adapter *adapter)
 		IXGBE_WRITE_REG(hw, IXGBE_RQTC, msb * 0x11111111);
 	}
 }
-#endif
 
+#ifndef IXGBE_NO_LLI
+static void ixgbe_configure_lli_82599(struct ixgbe_adapter *adapter)
+{
+	u16 port;
+
+	if (adapter->lli_etype) {
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_L34T_IMIR(0),
+				(IXGBE_IMIR_LLI_EN_82599 |
+				 IXGBE_IMIR_SIZE_BP_82599 |
+				 IXGBE_IMIR_CTRL_BP_82599));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_ETQS(0), IXGBE_ETQS_LLI);
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_ETQF(0),
+				(adapter->lli_etype | IXGBE_ETQF_FILTER_EN));
+	}
+
+	if (adapter->lli_port) {
+		port = swab16(adapter->lli_port);
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_L34T_IMIR(0),
+				(IXGBE_IMIR_LLI_EN_82599 |
+				 IXGBE_IMIR_SIZE_BP_82599 |
+				 IXGBE_IMIR_CTRL_BP_82599));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FTQF(0),
+				(IXGBE_FTQF_POOL_MASK_EN |
+				 (IXGBE_FTQF_PRIORITY_MASK <<
+				  IXGBE_FTQF_PRIORITY_SHIFT) |
+				 (IXGBE_FTQF_DEST_PORT_MASK <<
+				  IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_SDPQF(0), (port << 16));
+	}
+
+	if (adapter->flags & IXGBE_FLAG_LLI_PUSH) {
+		switch (adapter->hw.mac.type) {
+		case ixgbe_mac_82599EB:
+			IXGBE_WRITE_REG(&adapter->hw, IXGBE_L34T_IMIR(0),
+					(IXGBE_IMIR_LLI_EN_82599 |
+					 IXGBE_IMIR_SIZE_BP_82599 |
+					 IXGBE_IMIR_CTRL_PSH_82599 |
+					 IXGBE_IMIR_CTRL_SYN_82599 |
+					 IXGBE_IMIR_CTRL_URG_82599 |
+					 IXGBE_IMIR_CTRL_ACK_82599 |
+					 IXGBE_IMIR_CTRL_RST_82599 |
+					 IXGBE_IMIR_CTRL_FIN_82599));
+			IXGBE_WRITE_REG(&adapter->hw, IXGBE_LLITHRESH,
+					0xfc000000);
+			break;
+		case ixgbe_mac_X540:
+			IXGBE_WRITE_REG(&adapter->hw, IXGBE_L34T_IMIR(0),
+					(IXGBE_IMIR_LLI_EN_82599 |
+					 IXGBE_IMIR_SIZE_BP_82599 |
+					 IXGBE_IMIR_CTRL_PSH_82599));
+			break;
+		default:
+			break;
+		}
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FTQF(0),
+				(IXGBE_FTQF_POOL_MASK_EN |
+				 (IXGBE_FTQF_PRIORITY_MASK <<
+				  IXGBE_FTQF_PRIORITY_SHIFT) |
+				 (IXGBE_FTQF_5TUPLE_MASK_MASK <<
+				  IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
+
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_SYNQF, 0x80000100);
+	}
+
+	if (adapter->lli_size) {
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_L34T_IMIR(0),
+				(IXGBE_IMIR_LLI_EN_82599 |
+				 IXGBE_IMIR_CTRL_BP_82599));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_LLITHRESH,
+				adapter->lli_size);
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FTQF(0),
+				(IXGBE_FTQF_POOL_MASK_EN |
+				 (IXGBE_FTQF_PRIORITY_MASK <<
+				  IXGBE_FTQF_PRIORITY_SHIFT) |
+				 (IXGBE_FTQF_5TUPLE_MASK_MASK <<
+				  IXGBE_FTQF_5TUPLE_MASK_SHIFT)));
+	}
+
+	if (adapter->lli_vlan_pri) {
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIRVP,
+				(IXGBE_IMIRVP_PRIORITY_EN |
+				 adapter->lli_vlan_pri));
+	}
+}
+
+static void ixgbe_configure_lli(struct ixgbe_adapter *adapter)
+{
+	u16 port;
+
+	/* lli should only be enabled with MSI-X and MSI */
+	if (!(adapter->flags & IXGBE_FLAG_MSI_ENABLED) &&
+	    !(adapter->flags & IXGBE_FLAG_MSIX_ENABLED))
+		return;
+	/* LLI not supported on X550 and X550EM_x*/
+	if ((adapter->hw.mac.type == ixgbe_mac_X550) ||
+	    (adapter->hw.mac.type == ixgbe_mac_X550EM_x))
+		return;
+	/* LLI not supported on X550EM_a */
+	if (adapter->hw.mac.type == ixgbe_mac_X550EM_a)
+		return;
+	if (adapter->hw.mac.type != ixgbe_mac_82598EB) {
+		ixgbe_configure_lli_82599(adapter);
+		return;
+	}
+
+	if (adapter->lli_port) {
+		/* use filter 0 for port */
+		port = swab16(adapter->lli_port);
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIR(0),
+				(port | IXGBE_IMIR_PORT_IM_EN));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIREXT(0),
+				(IXGBE_IMIREXT_SIZE_BP |
+				 IXGBE_IMIREXT_CTRL_BP));
+	}
+
+	if (adapter->flags & IXGBE_FLAG_LLI_PUSH) {
+		/* use filter 1 for push flag */
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIR(1),
+				(IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIREXT(1),
+				(IXGBE_IMIREXT_SIZE_BP |
+				 IXGBE_IMIREXT_CTRL_PSH));
+	}
+
+	if (adapter->lli_size) {
+		/* use filter 2 for size */
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIR(2),
+				(IXGBE_IMIR_PORT_BP | IXGBE_IMIR_PORT_IM_EN));
+		IXGBE_WRITE_REG(&adapter->hw, IXGBE_IMIREXT(2),
+				(adapter->lli_size | IXGBE_IMIREXT_CTRL_BP));
+	}
+}
+
+#endif /* IXGBE_NO_LLI */
 /* Additional bittime to account for IXGBE framing */
 #define IXGBE_ETH_FRAMING 20
 
-/**
+/*
  * ixgbe_hpbthresh - calculate high water mark for flow control
  *
  * @adapter: board private structure to calculate for
- * @pb: packet buffer to calculate
+ * @pb - packet buffer to calculate
  */
 static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
 {
@@ -5114,20 +5966,20 @@ static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
 	/* Calculate max LAN frame size */
 	tc = link = dev->mtu + ETH_HLEN + ETH_FCS_LEN + IXGBE_ETH_FRAMING;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* FCoE traffic class uses FCOE jumbo frames */
 	if ((dev->features & NETIF_F_FCOE_MTU) &&
 	    (tc < IXGBE_FCOE_JUMBO_FRAME_SIZE) &&
-	    (pb == ixgbe_fcoe_get_tc(adapter)))
+	    (pb == netdev_get_prio_tc_map(dev, adapter->fcoe.up)))
 		tc = IXGBE_FCOE_JUMBO_FRAME_SIZE;
-#endif
+#endif /* CONFIG_FCOE */
 
 	/* Calculate delay value for device */
 	switch (hw->mac.type) {
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		dv_id = IXGBE_DV_X540(link, tc);
 		break;
 	default:
@@ -5151,7 +6003,7 @@ static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
 	 */
 	if (marker < 0) {
 		e_warn(drv, "Packet Buffer(%i) can not provide enough"
-			    "headroom to support flow control."
+			    "headroom to suppport flow control."
 			    "Decrease MTU or number of traffic classes\n", pb);
 		marker = tc + 1;
 	}
@@ -5159,13 +6011,13 @@ static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
 	return marker;
 }
 
-/**
+/*
  * ixgbe_lpbthresh - calculate low water mark for for flow control
  *
  * @adapter: board private structure to calculate for
- * @pb: packet buffer to calculate
+ * @pb - packet buffer to calculate
  */
-static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int pb)
+static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int __maybe_unused pb)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct net_device *dev = adapter->netdev;
@@ -5175,20 +6027,20 @@ static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int pb)
 	/* Calculate max LAN frame size */
 	tc = dev->mtu + ETH_HLEN + ETH_FCS_LEN;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* FCoE traffic class uses FCOE jumbo frames */
 	if ((dev->features & NETIF_F_FCOE_MTU) &&
 	    (tc < IXGBE_FCOE_JUMBO_FRAME_SIZE) &&
 	    (pb == netdev_get_prio_tc_map(dev, adapter->fcoe.up)))
 		tc = IXGBE_FCOE_JUMBO_FRAME_SIZE;
-#endif
+#endif /* CONFIG_FCOE */
 
 	/* Calculate delay value for device */
 	switch (hw->mac.type) {
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		dv_id = IXGBE_LOW_DV_X540(tc);
 		break;
 	default:
@@ -5206,12 +6058,13 @@ static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int pb)
 static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	int num_tc = adapter->hw_tcs;
+	int num_tc = netdev_get_num_tc(adapter->netdev);
 	int i;
 
 	if (!num_tc)
 		num_tc = 1;
 
+
 	for (i = 0; i < num_tc; i++) {
 		hw->fc.high_water[i] = ixgbe_hpbthresh(adapter, i);
 		hw->fc.low_water[i] = ixgbe_lpbthresh(adapter, i);
@@ -5221,7 +6074,7 @@ static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter)
 			hw->fc.low_water[i] = 0;
 	}
 
-	for (; i < MAX_TRAFFIC_CLASS; i++)
+	for (; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++)
 		hw->fc.high_water[i] = 0;
 }
 
@@ -5229,7 +6082,7 @@ static void ixgbe_configure_pb(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	int hdrm;
-	u8 tc = adapter->hw_tcs;
+	u8 tc = netdev_get_num_tc(adapter->netdev);
 
 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE ||
 	    adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
@@ -5237,7 +6090,7 @@ static void ixgbe_configure_pb(struct ixgbe_adapter *adapter)
 	else
 		hdrm = 0;
 
-	hw->mac.ops.set_rxpba(hw, tc, hdrm, PBA_STRATEGY_EQUAL);
+	hw->mac.ops.setup_rxpba(hw, tc, hdrm, PBA_STRATEGY_EQUAL);
 	ixgbe_pbthresh_setup(adapter);
 }
 
@@ -5246,12 +6099,13 @@ static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct hlist_node *node2;
 	struct ixgbe_fdir_filter *filter;
-	u8 queue;
+	u8 queue = 0;
 
 	spin_lock(&adapter->fdir_perfect_lock);
 
 	if (!hlist_empty(&adapter->fdir_filter_list))
-		ixgbe_fdir_set_input_mask_82599(hw, &adapter->fdir_mask);
+		ixgbe_fdir_set_input_mask_82599(hw, &adapter->fdir_mask,
+						adapter->cloud_mode);
 
 	hlist_for_each_entry_safe(filter, node2,
 				  &adapter->fdir_filter_list, fdir_node) {
@@ -5261,14 +6115,16 @@ static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter)
 			u32 ring = ethtool_get_flow_spec_ring(filter->action);
 			u8 vf = ethtool_get_flow_spec_ring_vf(filter->action);
 
-			if (!vf && (ring >= adapter->num_rx_queues)) {
-				e_err(drv, "FDIR restore failed without VF, ring: %u\n",
+			if (!vf && ring >= adapter->num_rx_queues) {
+				e_err(drv,
+				      "FDIR restore failed w/o vf, ring:%u\n",
 				      ring);
 				continue;
 			} else if (vf &&
 				   ((vf > adapter->num_vfs) ||
-				     ring >= adapter->num_rx_queues_per_pool)) {
-				e_err(drv, "FDIR restore failed with VF, vf: %hhu, ring: %u\n",
+				   ring >= adapter->num_rx_queues_per_pool)) {
+				e_err(drv,
+				      "FDIR restore failed vf:%hhu, ring:%u\n",
 				      vf, ring);
 				continue;
 			}
@@ -5282,7 +6138,10 @@ static void ixgbe_fdir_filter_restore(struct ixgbe_adapter *adapter)
 		}
 
 		ixgbe_fdir_write_perfect_filter_82599(hw,
-				&filter->filter, filter->sw_idx, queue);
+						      &filter->filter,
+						      filter->sw_idx,
+						      queue,
+						      adapter->cloud_mode);
 	}
 
 	spin_unlock(&adapter->fdir_perfect_lock);
@@ -5296,25 +6155,54 @@ static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring)
 {
 	u16 i = rx_ring->next_to_clean;
 	struct ixgbe_rx_buffer *rx_buffer = &rx_ring->rx_buffer_info[i];
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+	DEFINE_DMA_ATTRS(attrs);
+
+	dma_set_attr(DMA_ATTR_SKIP_CPU_SYNC, &attrs);
+	dma_set_attr(DMA_ATTR_WEAK_ORDERING, &attrs);
+#endif
 
-	if (rx_ring->xsk_pool) {
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (rx_ring->xsk_umem) {
 		ixgbe_xsk_clean_rx_ring(rx_ring);
 		goto skip_free;
 	}
 
+#endif
 	/* Free all the Rx ring sk_buffs */
+#ifdef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+	while (i != rx_ring->next_to_use) {
+#else
 	while (i != rx_ring->next_to_alloc) {
+#endif
 		if (rx_buffer->skb) {
 			struct sk_buff *skb = rx_buffer->skb;
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 			if (IXGBE_CB(skb)->page_released)
 				dma_unmap_page_attrs(rx_ring->dev,
 						     IXGBE_CB(skb)->dma,
 						     ixgbe_rx_pg_size(rx_ring),
 						     DMA_FROM_DEVICE,
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+						     &attrs);
+#else
 						     IXGBE_RX_DMA_ATTR);
+#endif
+#else
+			/* We need to clean up RSC frag lists */
+			skb = ixgbe_merge_active_tail(skb);
+			if (ixgbe_close_active_frag_list(skb))
+				dma_unmap_single(rx_ring->dev,
+						 IXGBE_CB(skb)->dma,
+						 rx_ring->rx_buf_len,
+						 DMA_FROM_DEVICE);
+			IXGBE_CB(skb)->dma = 0;
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 			dev_kfree_skb(skb);
+			rx_buffer->skb = NULL;
 		}
 
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 		/* Invalidate cache lines that may have been written to by
 		 * device so that we avoid corrupting memory.
 		 */
@@ -5328,10 +6216,23 @@ static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring)
 		dma_unmap_page_attrs(rx_ring->dev, rx_buffer->dma,
 				     ixgbe_rx_pg_size(rx_ring),
 				     DMA_FROM_DEVICE,
+#if defined(HAVE_STRUCT_DMA_ATTRS) && defined(HAVE_SWIOTLB_SKIP_CPU_SYNC)
+				     &attrs);
+#else
 				     IXGBE_RX_DMA_ATTR);
+#endif
+
 		__page_frag_cache_drain(rx_buffer->page,
 					rx_buffer->pagecnt_bias);
-
+#else /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
+		if (rx_buffer->dma) {
+			dma_unmap_single(rx_ring->dev,
+					 rx_buffer->dma,
+					 rx_ring->rx_buf_len,
+					 DMA_FROM_DEVICE);
+			rx_buffer->dma = 0;
+		}
+#endif /* CONFIG_IXGBE_DISABLE_PACKET_SPLIT */
 		i++;
 		rx_buffer++;
 		if (i == rx_ring->count) {
@@ -5340,93 +6241,14 @@ static void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring)
 		}
 	}
 
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 skip_free:
+#endif
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
 	rx_ring->next_to_alloc = 0;
 	rx_ring->next_to_clean = 0;
 	rx_ring->next_to_use = 0;
-}
-
-static int ixgbe_fwd_ring_up(struct ixgbe_adapter *adapter,
-			     struct ixgbe_fwd_adapter *accel)
-{
-	u16 rss_i = adapter->ring_feature[RING_F_RSS].indices;
-	int num_tc = netdev_get_num_tc(adapter->netdev);
-	struct net_device *vdev = accel->netdev;
-	int i, baseq, err;
-
-	baseq = accel->pool * adapter->num_rx_queues_per_pool;
-	netdev_dbg(vdev, "pool %i:%i queues %i:%i\n",
-		   accel->pool, adapter->num_rx_pools,
-		   baseq, baseq + adapter->num_rx_queues_per_pool);
-
-	accel->rx_base_queue = baseq;
-	accel->tx_base_queue = baseq;
-
-	/* record configuration for macvlan interface in vdev */
-	for (i = 0; i < num_tc; i++)
-		netdev_bind_sb_channel_queue(adapter->netdev, vdev,
-					     i, rss_i, baseq + (rss_i * i));
-
-	for (i = 0; i < adapter->num_rx_queues_per_pool; i++)
-		adapter->rx_ring[baseq + i]->netdev = vdev;
-
-	/* Guarantee all rings are updated before we update the
-	 * MAC address filter.
-	 */
-	wmb();
-
-	/* ixgbe_add_mac_filter will return an index if it succeeds, so we
-	 * need to only treat it as an error value if it is negative.
-	 */
-	err = ixgbe_add_mac_filter(adapter, vdev->dev_addr,
-				   VMDQ_P(accel->pool));
-	if (err >= 0)
-		return 0;
-
-	/* if we cannot add the MAC rule then disable the offload */
-	macvlan_release_l2fw_offload(vdev);
-
-	for (i = 0; i < adapter->num_rx_queues_per_pool; i++)
-		adapter->rx_ring[baseq + i]->netdev = NULL;
-
-	netdev_err(vdev, "L2FW offload disabled due to L2 filter error\n");
-
-	/* unbind the queues and drop the subordinate channel config */
-	netdev_unbind_sb_channel(adapter->netdev, vdev);
-	netdev_set_sb_channel(vdev, 0);
-
-	clear_bit(accel->pool, adapter->fwd_bitmask);
-	kfree(accel);
-
-	return err;
-}
-
-static int ixgbe_macvlan_up(struct net_device *vdev,
-			    struct netdev_nested_priv *priv)
-{
-	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)priv->data;
-	struct ixgbe_fwd_adapter *accel;
-
-	if (!netif_is_macvlan(vdev))
-		return 0;
-
-	accel = macvlan_accel_priv(vdev);
-	if (!accel)
-		return 0;
-
-	ixgbe_fwd_ring_up(adapter, accel);
-
-	return 0;
-}
-
-static void ixgbe_configure_dfwd(struct ixgbe_adapter *adapter)
-{
-	struct netdev_nested_priv priv = {
-		.data = (void *)adapter,
-	};
-
-	netdev_walk_all_upper_dev_rcu(adapter->netdev,
-				      ixgbe_macvlan_up, &priv);
+#endif
 }
 
 static void ixgbe_configure(struct ixgbe_adapter *adapter)
@@ -5434,9 +6256,8 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
 	struct ixgbe_hw *hw = &adapter->hw;
 
 	ixgbe_configure_pb(adapter);
-#ifdef CONFIG_IXGBE_DCB
 	ixgbe_configure_dcb(adapter);
-#endif
+
 	/*
 	 * We must restore virtualization before VLANs or else
 	 * the VLVF registers will not be populated
@@ -5444,50 +6265,73 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
 	ixgbe_configure_virtualization(adapter);
 
 	ixgbe_set_rx_mode(adapter->netdev);
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
 	ixgbe_restore_vlan(adapter);
-	ixgbe_ipsec_restore(adapter);
+#endif
 
-	switch (hw->mac.type) {
-	case ixgbe_mac_82599EB:
-	case ixgbe_mac_X540:
-		hw->mac.ops.disable_rx_buff(hw);
-		break;
-	default:
-		break;
-	}
+	if (adapter->hw.mac.type == ixgbe_mac_82599EB ||
+	    adapter->hw.mac.type == ixgbe_mac_X540)
+		hw->mac.ops.disable_sec_rx_path(hw);
 
 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE) {
 		ixgbe_init_fdir_signature_82599(&adapter->hw,
 						adapter->fdir_pballoc);
 	} else if (adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE) {
 		ixgbe_init_fdir_perfect_82599(&adapter->hw,
-					      adapter->fdir_pballoc);
+					      adapter->fdir_pballoc, adapter->cloud_mode);
 		ixgbe_fdir_filter_restore(adapter);
 	}
 
-	switch (hw->mac.type) {
-	case ixgbe_mac_82599EB:
-	case ixgbe_mac_X540:
-		hw->mac.ops.enable_rx_buff(hw);
-		break;
-	default:
-		break;
+	if (adapter->hw.mac.type == ixgbe_mac_82599EB ||
+	    adapter->hw.mac.type == ixgbe_mac_X540)
+		hw->mac.ops.enable_sec_rx_path(hw);
+
+	/* Enable EEE only when supported and enabled */
+	if (hw->mac.ops.setup_eee &&
+	    (adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE)) {
+		bool eee_enable = !!(adapter->flags2 & IXGBE_FLAG2_EEE_ENABLED);
+
+		hw->mac.ops.setup_eee(hw, eee_enable);
 	}
 
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 	/* configure DCA */
 	if (adapter->flags & IXGBE_FLAG_DCA_CAPABLE)
 		ixgbe_setup_dca(adapter);
-#endif /* CONFIG_IXGBE_DCA */
+#endif
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* configure FCoE L2 filters, redirection table, and Rx control */
 	ixgbe_configure_fcoe(adapter);
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
 	ixgbe_configure_tx(adapter);
 	ixgbe_configure_rx(adapter);
-	ixgbe_configure_dfwd(adapter);
+}
+
+static bool ixgbe_is_sfp(struct ixgbe_hw *hw)
+{
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+		if (hw->phy.type == ixgbe_phy_nl)
+			return true;
+		return false;
+	case ixgbe_mac_82599EB:
+		switch (hw->mac.ops.get_media_type(hw)) {
+		case ixgbe_media_type_fiber:
+		case ixgbe_media_type_fiber_qsfp:
+			return true;
+		default:
+			return false;
+		}
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber)
+			return true;
+		return false;
+	default:
+		return false;
+	}
 }
 
 /**
@@ -5497,7 +6341,7 @@ static void ixgbe_configure(struct ixgbe_adapter *adapter)
 static void ixgbe_sfp_link_config(struct ixgbe_adapter *adapter)
 {
 	/*
-	 * We are assuming the worst case scenario here, and that
+	 * We are assuming the worst case scenerio here, and that
 	 * is that an SFP was inserted/removed after the reset
 	 * but before SFP detection was enabled.  As such the best
 	 * solution is to just start searching as soon as we start
@@ -5519,13 +6363,13 @@ static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw)
 {
 	u32 speed;
 	bool autoneg, link_up = false;
-	int ret = IXGBE_ERR_LINK_SETUP;
+	u32 ret = IXGBE_ERR_LINK_SETUP;
 
 	if (hw->mac.ops.check_link)
 		ret = hw->mac.ops.check_link(hw, &speed, &link_up, false);
 
 	if (ret)
-		return ret;
+		goto link_cfg_out;
 
 	speed = hw->phy.autoneg_advertised;
 	if (!speed && hw->mac.ops.get_link_capabilities) {
@@ -5536,15 +6380,56 @@ static int ixgbe_non_sfp_link_config(struct ixgbe_hw *hw)
 	}
 
 	if (ret)
-		return ret;
+		goto link_cfg_out;
 
 	if (hw->mac.ops.setup_link)
 		ret = hw->mac.ops.setup_link(hw, speed, link_up);
-
+link_cfg_out:
 	return ret;
 }
 
-static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
+/**
+ * ixgbe_clear_vf_stats_counters - Clear out VF stats after reset
+ * @adapter: board private structure
+ *
+ * On a reset we need to clear out the VF stats or accounting gets
+ * messed up because they're not clear on read.
+ **/
+static void ixgbe_clear_vf_stats_counters(struct ixgbe_adapter *adapter)
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+	int i;
+
+	for (i = 0; i < adapter->num_vfs; i++) {
+		adapter->vfinfo[i].last_vfstats.gprc =
+			IXGBE_READ_REG(hw, IXGBE_PVFGPRC(i));
+		adapter->vfinfo[i].saved_rst_vfstats.gprc +=
+			adapter->vfinfo[i].vfstats.gprc;
+		adapter->vfinfo[i].vfstats.gprc = 0;
+		adapter->vfinfo[i].last_vfstats.gptc =
+			IXGBE_READ_REG(hw, IXGBE_PVFGPTC(i));
+		adapter->vfinfo[i].saved_rst_vfstats.gptc +=
+			adapter->vfinfo[i].vfstats.gptc;
+		adapter->vfinfo[i].vfstats.gptc = 0;
+		adapter->vfinfo[i].last_vfstats.gorc =
+			IXGBE_READ_REG(hw, IXGBE_PVFGORC_LSB(i));
+		adapter->vfinfo[i].saved_rst_vfstats.gorc +=
+			adapter->vfinfo[i].vfstats.gorc;
+		adapter->vfinfo[i].vfstats.gorc = 0;
+		adapter->vfinfo[i].last_vfstats.gotc =
+			IXGBE_READ_REG(hw, IXGBE_PVFGOTC_LSB(i));
+		adapter->vfinfo[i].saved_rst_vfstats.gotc +=
+			adapter->vfinfo[i].vfstats.gotc;
+		adapter->vfinfo[i].vfstats.gotc = 0;
+		adapter->vfinfo[i].last_vfstats.mprc =
+			IXGBE_READ_REG(hw, IXGBE_PVFMPRC(i));
+		adapter->vfinfo[i].saved_rst_vfstats.mprc +=
+			adapter->vfinfo[i].vfstats.mprc;
+		adapter->vfinfo[i].vfstats.mprc = 0;
+	}
+}
+
+static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 gpie = 0;
@@ -5565,7 +6450,7 @@ static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
 		case ixgbe_mac_X540:
 		case ixgbe_mac_X550:
 		case ixgbe_mac_X550EM_x:
-		case ixgbe_mac_x550em_a:
+		case ixgbe_mac_X550EM_a:
 		default:
 			IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(0), 0xFFFFFFFF);
 			IXGBE_WRITE_REG(hw, IXGBE_EIAM_EX(1), 0xFFFFFFFF);
@@ -5577,9 +6462,6 @@ static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
 		IXGBE_WRITE_REG(hw, IXGBE_EIAM, IXGBE_EICS_RTX_QUEUE);
 	}
 
-	/* XXX: to interrupt immediately for EICS writes, enable this */
-	/* gpie |= IXGBE_GPIE_EIMEN; */
-
 	if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
 		gpie &= ~IXGBE_GPIE_VTMODE_MASK;
 
@@ -5597,26 +6479,25 @@ static void ixgbe_setup_gpie(struct ixgbe_adapter *adapter)
 	}
 
 	/* Enable Thermal over heat sensor interrupt */
-	if (adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE) {
+	if (adapter->flags2 & IXGBE_FLAG2_TEMP_SENSOR_CAPABLE)
 		switch (adapter->hw.mac.type) {
 		case ixgbe_mac_82599EB:
-			gpie |= IXGBE_SDP0_GPIEN_8259X;
+			gpie |= IXGBE_SDP0_GPIEN;
 			break;
 		default:
 			break;
 		}
-	}
 
 	/* Enable fan failure interrupt */
 	if (adapter->flags & IXGBE_FLAG_FAN_FAIL_CAPABLE)
-		gpie |= IXGBE_SDP1_GPIEN(hw);
+		gpie |= IXGBE_SDP1_GPIEN;
 
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
-		gpie |= IXGBE_SDP1_GPIEN_8259X | IXGBE_SDP2_GPIEN_8259X;
+		gpie |= IXGBE_SDP1_GPIEN | IXGBE_SDP2_GPIEN;
 		break;
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		gpie |= IXGBE_SDP0_GPIEN_X540;
 		break;
 	default:
@@ -5643,17 +6524,18 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
 	/* enable the optics for 82599 SFP+ fiber */
 	if (hw->mac.ops.enable_tx_laser)
 		hw->mac.ops.enable_tx_laser(hw);
-
-	if (hw->phy.ops.set_phy_power)
-		hw->phy.ops.set_phy_power(hw, true);
+	ixgbe_set_phy_power(hw, true);
 
 	smp_mb__before_atomic();
 	clear_bit(__IXGBE_DOWN, &adapter->state);
 	ixgbe_napi_enable_all(adapter);
+#ifndef IXGBE_NO_LLI
+	ixgbe_configure_lli(adapter);
+#endif
 
 	if (ixgbe_is_sfp(hw)) {
 		ixgbe_sfp_link_config(adapter);
-	} else {
+	} else if (!hw->phy.reset_disable) {
 		err = ixgbe_non_sfp_link_config(hw);
 		if (err)
 			e_err(probe, "link_config FAILED %d\n", err);
@@ -5673,12 +6555,16 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
 			e_crit(drv, "Fan has stopped, replace the adapter\n");
 	}
 
+	/* enable transmits */
+	netif_tx_start_all_queues(adapter->netdev);
+
 	/* bring the link up in the watchdog, this could race with our first
 	 * link up interrupt but shouldn't be a problem */
 	adapter->flags |= IXGBE_FLAG_NEED_LINK_UPDATE;
 	adapter->link_check_timeout = jiffies;
 	mod_timer(&adapter->service_timer, jiffies);
 
+	ixgbe_clear_vf_stats_counters(adapter);
 	/* Set PF Reset Done bit so PF/VF Mail Ops can work */
 	ctrl_ext = IXGBE_READ_REG(hw, IXGBE_CTRL_EXT);
 	ctrl_ext |= IXGBE_CTRL_EXT_PFRSTD;
@@ -5687,8 +6573,13 @@ static void ixgbe_up_complete(struct ixgbe_adapter *adapter)
 
 void ixgbe_reinit_locked(struct ixgbe_adapter *adapter)
 {
+	WARN_ON(in_interrupt());
 	/* put off any impending NetWatchDogTimeout */
+#ifdef HAVE_NETIF_TRANS_UPDATE
 	netif_trans_update(adapter->netdev);
+#else
+	adapter->netdev->trans_start = jiffies;
+#endif
 
 	while (test_and_set_bit(__IXGBE_RESETTING, &adapter->state))
 		usleep_range(1000, 2000);
@@ -5752,7 +6643,7 @@ static unsigned long ixgbe_get_completion_timeout(struct ixgbe_adapter *adapter)
 	return 32000ul;
 }
 
-void ixgbe_disable_rx(struct ixgbe_adapter *adapter)
+void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter)
 {
 	unsigned long wait_delay, delay_interval;
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -5762,7 +6653,7 @@ void ixgbe_disable_rx(struct ixgbe_adapter *adapter)
 	/* disable receives */
 	hw->mac.ops.disable_rx(hw);
 
-	if (ixgbe_removed(hw->hw_addr))
+	if (IXGBE_REMOVED(hw->hw_addr))
 		return;
 
 	/* disable all enabled Rx queues */
@@ -5824,14 +6715,14 @@ void ixgbe_disable_rx(struct ixgbe_adapter *adapter)
 	      "RXDCTL.ENABLE for one or more queues not cleared within the polling period\n");
 }
 
-void ixgbe_disable_tx(struct ixgbe_adapter *adapter)
+void ixgbe_disable_tx_queue(struct ixgbe_adapter *adapter)
 {
 	unsigned long wait_delay, delay_interval;
 	struct ixgbe_hw *hw = &adapter->hw;
 	int i, wait_loop;
 	u32 txdctl;
 
-	if (ixgbe_removed(hw->hw_addr))
+	if (IXGBE_REMOVED(hw->hw_addr))
 		return;
 
 	/* disable all enabled Tx queues */
@@ -5911,11 +6802,11 @@ void ixgbe_disable_tx(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL,
 				(IXGBE_READ_REG(hw, IXGBE_DMATXCTL) &
 				 ~IXGBE_DMATXCTL_TE));
-		fallthrough;
+		/* fall through */
 	default:
 		break;
 	}
@@ -5924,10 +6815,12 @@ void ixgbe_disable_tx(struct ixgbe_adapter *adapter)
 void ixgbe_reset(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
+#ifdef HAVE_SET_RX_MODE
 	struct net_device *netdev = adapter->netdev;
+#endif
 	int err;
 
-	if (ixgbe_removed(hw->hw_addr))
+	if (IXGBE_REMOVED(hw->hw_addr))
 		return;
 	/* lock SFP init bit to prevent race conditions with the watchdog */
 	while (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))
@@ -5940,7 +6833,7 @@ void ixgbe_reset(struct ixgbe_adapter *adapter)
 
 	err = hw->mac.ops.init_hw(hw);
 	switch (err) {
-	case 0:
+	case IXGBE_SUCCESS:
 	case IXGBE_ERR_SFP_NOT_PRESENT:
 	case IXGBE_ERR_SFP_NOT_SUPPORTED:
 		break;
@@ -5950,12 +6843,15 @@ void ixgbe_reset(struct ixgbe_adapter *adapter)
 	case IXGBE_ERR_EEPROM_VERSION:
 		/* We are running on a pre-production device, log a warning */
 		e_dev_warn("This device is a pre-production adapter/LOM. "
-			   "Please be aware there may be issues associated with "
-			   "your hardware.  If you are experiencing problems "
-			   "please contact your Intel or hardware "
+			   "Please be aware there may be issues associated "
+			   "with your hardware.  If you are experiencing "
+			   "problems please contact your Intel or hardware "
 			   "representative who provided you with this "
 			   "hardware.\n");
 		break;
+	case IXGBE_ERR_OVERTEMP:
+		e_crit(drv, "%s\n", ixgbe_overheat_msg);
+		break;
 	default:
 		e_dev_err("Hardware Error: %d\n", err);
 	}
@@ -5964,7 +6860,9 @@ void ixgbe_reset(struct ixgbe_adapter *adapter)
 
 	/* flush entries out of MAC table */
 	ixgbe_flush_sw_mac_table(adapter);
+#ifdef HAVE_SET_RX_MODE
 	__dev_uc_unsync(netdev, NULL);
+#endif
 
 	/* do not flush user set addresses */
 	ixgbe_mac_set_default_filter(adapter);
@@ -5973,15 +6871,21 @@ void ixgbe_reset(struct ixgbe_adapter *adapter)
 	if (hw->mac.san_mac_rar_index)
 		hw->mac.ops.set_vmdq_san_mac(hw, VMDQ_P(0));
 
+	/* Clear saved DMA coalescing values except for watchdog_timer */
+	hw->mac.dmac_config.fcoe_en = false;
+	hw->mac.dmac_config.link_speed = 0;
+	hw->mac.dmac_config.fcoe_tc = 0;
+	hw->mac.dmac_config.num_tcs = 0;
+
+#ifdef HAVE_PTP_1588_CLOCK
 	if (test_bit(__IXGBE_PTP_RUNNING, &adapter->state))
 		ixgbe_ptp_reset(adapter);
+#endif
 
-	if (hw->phy.ops.set_phy_power) {
-		if (!netif_running(adapter->netdev) && !adapter->wol)
-			hw->phy.ops.set_phy_power(hw, false);
-		else
-			hw->phy.ops.set_phy_power(hw, true);
-	}
+	if (!netif_running(adapter->netdev) && !adapter->wol)
+		ixgbe_set_phy_power(hw, false);
+	else
+		ixgbe_set_phy_power(hw, true);
 }
 
 /**
@@ -5993,19 +6897,29 @@ static void ixgbe_clean_tx_ring(struct ixgbe_ring *tx_ring)
 	u16 i = tx_ring->next_to_clean;
 	struct ixgbe_tx_buffer *tx_buffer = &tx_ring->tx_buffer_info[i];
 
-	if (tx_ring->xsk_pool) {
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (tx_ring->xsk_umem) {
 		ixgbe_xsk_clean_tx_ring(tx_ring);
 		goto out;
 	}
 
+#endif
 	while (i != tx_ring->next_to_use) {
 		union ixgbe_adv_tx_desc *eop_desc, *tx_desc;
 
 		/* Free all the Tx ring sk_buffs */
+#ifdef HAVE_XDP_SUPPORT
 		if (ring_is_xdp(tx_ring))
+#ifdef HAVE_XDP_FRAME_STRUCT
 			xdp_return_frame(tx_buffer->xdpf);
+#else
+			page_frag_free(tx_buffer->data);
+#endif
 		else
 			dev_kfree_skb_any(tx_buffer->skb);
+#else
+		dev_kfree_skb_any(tx_buffer->skb);
+#endif
 
 		/* unmap skb header data */
 		dma_unmap_single(tx_ring->dev,
@@ -6049,7 +6963,10 @@ static void ixgbe_clean_tx_ring(struct ixgbe_ring *tx_ring)
 	if (!ring_is_xdp(tx_ring))
 		netdev_tx_reset_queue(txring_txq(tx_ring));
 
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 out:
+#endif
+
 	/* reset next_to_use and next_to_clean */
 	tx_ring->next_to_use = 0;
 	tx_ring->next_to_clean = 0;
@@ -6116,7 +7033,7 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 	netif_tx_disable(netdev);
 
 	/* Disable Rx */
-	ixgbe_disable_rx(adapter);
+	ixgbe_disable_rx_queue(adapter);
 
 	/* synchronize_rcu() needed for pending XDP buffers to drain */
 	if (adapter->xdp_ring[0])
@@ -6126,8 +7043,8 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 
 	ixgbe_napi_disable_all(adapter);
 
+	adapter->flags2 &= ~(IXGBE_FLAG2_FDIR_REQUIRES_REINIT);
 	clear_bit(__IXGBE_RESET_REQUESTED, &adapter->state);
-	adapter->flags2 &= ~IXGBE_FLAG2_FDIR_REQUIRES_REINIT;
 	adapter->flags &= ~IXGBE_FLAG_NEED_LINK_UPDATE;
 
 	del_timer_sync(&adapter->service_timer);
@@ -6138,7 +7055,7 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 
 		/* Mark all the VFs as inactive */
 		for (i = 0 ; i < adapter->num_vfs; i++)
-			adapter->vfinfo[i].clear_to_send = false;
+			adapter->vfinfo[i].clear_to_send = 0;
 
 		/* ping all the active vfs to let them know we are going down */
 		ixgbe_ping_all_vfs(adapter);
@@ -6148,9 +7065,11 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 	}
 
 	/* disable transmits in the hardware now that interrupts are off */
-	ixgbe_disable_tx(adapter);
+	ixgbe_disable_tx_queue(adapter);
 
+#ifdef HAVE_PCI_ERS
 	if (!pci_channel_offline(adapter->pdev))
+#endif
 		ixgbe_reset(adapter);
 
 	/* power down the optics for 82599 SFP+ fiber */
@@ -6163,9 +7082,9 @@ void ixgbe_down(struct ixgbe_adapter *adapter)
 
 /**
  * ixgbe_eee_capable - helper function to determine EEE support on X550
- * @adapter: board private structure
- */
-static void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
+ * @adapter: board private structure to initialize
+ **/
+static inline void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 
@@ -6186,126 +7105,91 @@ static void ixgbe_set_eee_capable(struct ixgbe_adapter *adapter)
 	}
 }
 
-/**
- * ixgbe_tx_timeout - Respond to a Tx Hang
- * @netdev: network interface device structure
- * @txqueue: queue number that timed out
- **/
-static void ixgbe_tx_timeout(struct net_device *netdev, unsigned int __always_unused txqueue)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-
-	/* Do the reset outside of interrupt context */
-	ixgbe_tx_timeout_reset(adapter);
-}
-
-#ifdef CONFIG_IXGBE_DCB
+#if IS_ENABLED(CONFIG_DCB)
 static void ixgbe_init_dcb(struct ixgbe_adapter *adapter)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
-	struct tc_configuration *tc;
-	int j;
-
-	switch (hw->mac.type) {
-	case ixgbe_mac_82598EB:
-	case ixgbe_mac_82599EB:
-		adapter->dcb_cfg.num_tcs.pg_tcs = MAX_TRAFFIC_CLASS;
-		adapter->dcb_cfg.num_tcs.pfc_tcs = MAX_TRAFFIC_CLASS;
-		break;
-	case ixgbe_mac_X540:
-	case ixgbe_mac_X550:
-		adapter->dcb_cfg.num_tcs.pg_tcs = X540_TRAFFIC_CLASS;
-		adapter->dcb_cfg.num_tcs.pfc_tcs = X540_TRAFFIC_CLASS;
-		break;
-	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-	default:
-		adapter->dcb_cfg.num_tcs.pg_tcs = DEF_TRAFFIC_CLASS;
-		adapter->dcb_cfg.num_tcs.pfc_tcs = DEF_TRAFFIC_CLASS;
-		break;
-	}
+	struct ixgbe_dcb_tc_config *tc;
+	int j, bwg_pct;
 
 	/* Configure DCB traffic classes */
-	for (j = 0; j < MAX_TRAFFIC_CLASS; j++) {
+	bwg_pct = 100 / adapter->dcb_cfg.num_tcs.pg_tcs;
+	for (j = 0; j < adapter->dcb_cfg.num_tcs.pg_tcs; j++) {
 		tc = &adapter->dcb_cfg.tc_config[j];
-		tc->path[DCB_TX_CONFIG].bwg_id = 0;
-		tc->path[DCB_TX_CONFIG].bwg_percent = 12 + (j & 1);
-		tc->path[DCB_RX_CONFIG].bwg_id = 0;
-		tc->path[DCB_RX_CONFIG].bwg_percent = 12 + (j & 1);
-		tc->dcb_pfc = pfc_disabled;
+		tc->path[IXGBE_DCB_TX_CONFIG].bwg_id = 0;
+		tc->path[IXGBE_DCB_TX_CONFIG].bwg_percent = bwg_pct;
+		tc->path[IXGBE_DCB_RX_CONFIG].bwg_id = 0;
+		tc->path[IXGBE_DCB_RX_CONFIG].bwg_percent = bwg_pct;
+		tc->pfc = ixgbe_dcb_pfc_disabled;
 	}
 
-	/* Initialize default user to priority mapping, UPx->TC0 */
+	/* reset back to TC 0 */
 	tc = &adapter->dcb_cfg.tc_config[0];
-	tc->path[DCB_TX_CONFIG].up_to_tc_bitmap = 0xFF;
-	tc->path[DCB_RX_CONFIG].up_to_tc_bitmap = 0xFF;
 
-	adapter->dcb_cfg.bw_percentage[DCB_TX_CONFIG][0] = 100;
-	adapter->dcb_cfg.bw_percentage[DCB_RX_CONFIG][0] = 100;
+	/* total of all TCs bandwidth needs to be 100 */
+	bwg_pct += 100 % adapter->dcb_cfg.num_tcs.pg_tcs;
+	tc->path[IXGBE_DCB_TX_CONFIG].bwg_percent = bwg_pct;
+	tc->path[IXGBE_DCB_RX_CONFIG].bwg_percent = bwg_pct;
+
+	/* Initialize default user to priority mapping, UPx->TC0 */
+	tc->path[IXGBE_DCB_TX_CONFIG].up_to_tc_bitmap = 0xFF;
+	tc->path[IXGBE_DCB_RX_CONFIG].up_to_tc_bitmap = 0xFF;
+
+	adapter->dcb_cfg.bw_percentage[IXGBE_DCB_TX_CONFIG][0] = 100;
+	adapter->dcb_cfg.bw_percentage[IXGBE_DCB_RX_CONFIG][0] = 100;
+	adapter->dcb_cfg.rx_pba_cfg = ixgbe_dcb_pba_equal;
 	adapter->dcb_cfg.pfc_mode_enable = false;
+	adapter->dcb_cfg.round_robin_enable = false;
 	adapter->dcb_set_bitmap = 0x00;
 	if (adapter->flags & IXGBE_FLAG_DCB_CAPABLE)
 		adapter->dcbx_cap = DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_CEE;
 	memcpy(&adapter->temp_dcb_cfg, &adapter->dcb_cfg,
 	       sizeof(adapter->temp_dcb_cfg));
 }
-#endif
+#endif /*CONFIG_DCB*/
 
 /**
  * ixgbe_sw_init - Initialize general software structures (struct ixgbe_adapter)
  * @adapter: board private structure to initialize
- * @ii: pointer to ixgbe_info for device
  *
  * ixgbe_sw_init initializes the Adapter private data structure.
  * Fields are initialized based on PCI device information and
  * OS network device settings (MTU size).
  **/
-static int ixgbe_sw_init(struct ixgbe_adapter *adapter,
-			 const struct ixgbe_info *ii)
+#ifdef HAVE_CONFIG_HOTPLUG
+static int __devinit ixgbe_sw_init(struct ixgbe_adapter *adapter)
+#else
+static int ixgbe_sw_init(struct ixgbe_adapter *adapter)
+#endif
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct pci_dev *pdev = adapter->pdev;
-	unsigned int rss, fdir;
+	int err;
+	unsigned int fdir;
 	u32 fwsm;
+#ifdef HAVE_TC_SETUP_CLSU32
 	int i;
+#endif
 
 	/* PCI config space info */
 
 	hw->vendor_id = pdev->vendor;
 	hw->device_id = pdev->device;
-	hw->revision_id = pdev->revision;
+	pci_read_config_byte(pdev, PCI_REVISION_ID, &hw->revision_id);
+	if (hw->revision_id == IXGBE_FAILED_READ_CFG_BYTE &&
+	    ixgbe_check_cfg_remove(hw, pdev)) {
+		e_err(probe, "read of revision id failed\n");
+		err = -ENODEV;
+		goto out;
+	}
 	hw->subsystem_vendor_id = pdev->subsystem_vendor;
 	hw->subsystem_device_id = pdev->subsystem_device;
 
-	/* get_invariants needs the device IDs */
-	ii->get_invariants(hw);
-
-	/* Set common capability flags and settings */
-	rss = min_t(int, ixgbe_max_rss_indices(adapter), num_online_cpus());
-	adapter->ring_feature[RING_F_RSS].limit = rss;
-	adapter->flags2 |= IXGBE_FLAG2_RSC_CAPABLE;
-	adapter->max_q_vectors = MAX_Q_VECTORS_82599;
-	adapter->atr_sample_rate = 20;
-	fdir = min_t(int, IXGBE_MAX_FDIR_INDICES, num_online_cpus());
-	adapter->ring_feature[RING_F_FDIR].limit = fdir;
-	adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_64K;
-	adapter->ring_feature[RING_F_VMDQ].limit = 1;
-#ifdef CONFIG_IXGBE_DCA
-	adapter->flags |= IXGBE_FLAG_DCA_CAPABLE;
-#endif
-#ifdef CONFIG_IXGBE_DCB
-	adapter->flags |= IXGBE_FLAG_DCB_CAPABLE;
-	adapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;
-#endif
-#ifdef IXGBE_FCOE
-	adapter->flags |= IXGBE_FLAG_FCOE_CAPABLE;
-	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
-#ifdef CONFIG_IXGBE_DCB
-	/* Default traffic class to use for FCoE */
-	adapter->fcoe.up = IXGBE_FCOE_DEFTC;
-#endif /* CONFIG_IXGBE_DCB */
-#endif /* IXGBE_FCOE */
-
+	err = ixgbe_init_shared_code(hw);
+	if (err) {
+		e_err(probe, "init_shared_code failed: %d\n", err);
+		goto out;
+	}
+#ifdef HAVE_TC_SETUP_CLSU32
 	/* initialize static ixgbe jump table entries */
 	adapter->jump_tables[0] = kzalloc(sizeof(*adapter->jump_tables[0]),
 					  GFP_KERNEL);
@@ -6315,50 +7199,81 @@ static int ixgbe_sw_init(struct ixgbe_adapter *adapter,
 
 	for (i = 1; i < IXGBE_MAX_LINK_HANDLE; i++)
 		adapter->jump_tables[i] = NULL;
-
-	adapter->mac_table = kcalloc(hw->mac.num_rar_entries,
-				     sizeof(struct ixgbe_mac_addr),
+#endif /* HAVE_TC_SETUP_CLSU32 */
+	adapter->mac_table = kzalloc(sizeof(struct ixgbe_mac_addr) *
+				     hw->mac.num_rar_entries,
 				     GFP_KERNEL);
-	if (!adapter->mac_table)
-		return -ENOMEM;
+	if (!adapter->mac_table) {
+		err = IXGBE_ERR_OUT_OF_MEM;
+		e_err(probe, "mac_table allocation failed: %d\n", err);
+		goto out;
+	}
 
-	if (ixgbe_init_rss_key(adapter))
-		return -ENOMEM;
+	if (ixgbe_init_rss_key(adapter)) {
+		err = IXGBE_ERR_OUT_OF_MEM;
+		e_err(probe, "rss_key allocation failed: %d\n", err);
+		goto out;
+	}
 
-	adapter->af_xdp_zc_qps = bitmap_zalloc(MAX_XDP_QUEUES, GFP_KERNEL);
-	if (!adapter->af_xdp_zc_qps)
-		return -ENOMEM;
+	/* Set common capability flags and settings */
+#if IS_ENABLED(CONFIG_DCA)
+	adapter->flags |= IXGBE_FLAG_DCA_CAPABLE;
+#endif
+#if IS_ENABLED(CONFIG_DCB)
+	adapter->flags |= IXGBE_FLAG_DCB_CAPABLE;
+	adapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;
+#endif
+#if IS_ENABLED(CONFIG_FCOE)
+	adapter->flags |= IXGBE_FLAG_FCOE_CAPABLE;
+	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
+#if IS_ENABLED(CONFIG_DCB)
+	/* Default traffic class to use for FCoE */
+	adapter->fcoe.up = IXGBE_FCOE_DEFUP;
+	adapter->fcoe.up_set = IXGBE_FCOE_DEFUP;
+#endif /* CONFIG_DCB */
+#endif /* CONFIG_FCOE */
+	adapter->flags2 |= IXGBE_FLAG2_RSC_CAPABLE;
+	fdir = min_t(int, IXGBE_MAX_FDIR_INDICES, num_online_cpus());
+	adapter->ring_feature[RING_F_FDIR].limit = fdir;
+	adapter->max_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82599;
 
 	/* Set MAC specific capability flags and exceptions */
 	switch (hw->mac.type) {
 	case ixgbe_mac_82598EB:
+		adapter->flags |= IXGBE_FLAGS_82598_INIT;
 		adapter->flags2 &= ~IXGBE_FLAG2_RSC_CAPABLE;
 
 		if (hw->device_id == IXGBE_DEV_ID_82598AT)
 			adapter->flags |= IXGBE_FLAG_FAN_FAIL_CAPABLE;
 
-		adapter->max_q_vectors = MAX_Q_VECTORS_82598;
+		adapter->max_q_vectors = IXGBE_MAX_MSIX_Q_VECTORS_82598;
 		adapter->ring_feature[RING_F_FDIR].limit = 0;
-		adapter->atr_sample_rate = 0;
-		adapter->fdir_pballoc = 0;
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		adapter->flags &= ~IXGBE_FLAG_FCOE_CAPABLE;
-		adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
-#ifdef CONFIG_IXGBE_DCB
+#if IS_ENABLED(CONFIG_DCB)
 		adapter->fcoe.up = 0;
+		adapter->fcoe.up_set = 0;
 #endif /* IXGBE_DCB */
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
 		break;
 	case ixgbe_mac_82599EB:
+		adapter->flags |= IXGBE_FLAGS_82599_INIT;
 		if (hw->device_id == IXGBE_DEV_ID_82599_T3_LOM)
 			adapter->flags2 |= IXGBE_FLAG2_TEMP_SENSOR_CAPABLE;
+#ifndef IXGBE_NO_SMART_SPEED
+		hw->phy.smart_speed = ixgbe_smart_speed_on;
+#else
+		hw->phy.smart_speed = ixgbe_smart_speed_off;
+#endif
 		break;
 	case ixgbe_mac_X540:
-		fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));
+		adapter->flags |= IXGBE_FLAGS_X540_INIT;
+		fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM);
 		if (fwsm & IXGBE_FWSM_TS_ENABLED)
 			adapter->flags2 |= IXGBE_FLAG2_TEMP_SENSOR_CAPABLE;
 		break;
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
+		adapter->flags |= IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE;
 		switch (hw->device_id) {
 		case IXGBE_DEV_ID_X550EM_A_1G_T:
 		case IXGBE_DEV_ID_X550EM_A_1G_T_L:
@@ -6367,66 +7282,78 @@ static int ixgbe_sw_init(struct ixgbe_adapter *adapter,
 		default:
 			break;
 		}
-		fallthrough;
+		/* fall through */
 	case ixgbe_mac_X550EM_x:
-#ifdef CONFIG_IXGBE_DCB
+#if IS_ENABLED(CONFIG_DCB)
 		adapter->flags &= ~IXGBE_FLAG_DCB_CAPABLE;
 #endif
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		adapter->flags &= ~IXGBE_FLAG_FCOE_CAPABLE;
-#ifdef CONFIG_IXGBE_DCB
+#if IS_ENABLED(CONFIG_DCB)
 		adapter->fcoe.up = 0;
-#endif /* IXGBE_DCB */
-#endif /* IXGBE_FCOE */
-		fallthrough;
+		adapter->fcoe.up_set = 0;
+#endif /* CONFIG_DCB */
+#endif /* CONFIG_FCOE */
+	/* fall through */
 	case ixgbe_mac_X550:
 		if (hw->mac.type == ixgbe_mac_X550)
 			adapter->flags2 |= IXGBE_FLAG2_TEMP_SENSOR_CAPABLE;
-#ifdef CONFIG_IXGBE_DCA
+		ixgbe_set_eee_capable(adapter);
+		adapter->flags |= IXGBE_FLAGS_X550_INIT;
+#if IS_ENABLED(CONFIG_DCA)
 		adapter->flags &= ~IXGBE_FLAG_DCA_CAPABLE;
-#endif
-		break;
+#endif /* CONFIG_DCA */
 	default:
 		break;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* FCoE support exists, always init the FCoE lock */
 	spin_lock_init(&adapter->fcoe.lock);
+#endif /* CONFIG_FCOE */
 
-#endif
 	/* n-tuple support exists, always init our spinlock */
 	spin_lock_init(&adapter->fdir_perfect_lock);
 
-#ifdef CONFIG_IXGBE_DCB
+#if IS_ENABLED(CONFIG_DCB)
+	switch (hw->mac.type) {
+	case ixgbe_mac_82598EB:
+	case ixgbe_mac_82599EB:
+		adapter->dcb_cfg.num_tcs.pg_tcs = 8;
+		adapter->dcb_cfg.num_tcs.pfc_tcs = 8;
+		break;
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+		adapter->dcb_cfg.num_tcs.pg_tcs = 4;
+		adapter->dcb_cfg.num_tcs.pfc_tcs = 4;
+		break;
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+	default:
+		adapter->dcb_cfg.num_tcs.pg_tcs = 1;
+		adapter->dcb_cfg.num_tcs.pfc_tcs = 1;
+		break;
+	}
 	ixgbe_init_dcb(adapter);
-#endif
-	ixgbe_init_ipsec_offload(adapter);
+
+#endif /* CONFIG_DCB */
+
+	if (hw->mac.type == ixgbe_mac_82599EB ||
+	    hw->mac.type == ixgbe_mac_X550 ||
+	    hw->mac.type == ixgbe_mac_X550EM_x ||
+	    hw->mac.type == ixgbe_mac_X550EM_a ||
+	    hw->mac.type == ixgbe_mac_X540)
+		ixgbe_init_mbx_params_pf(hw);
 
 	/* default flow control settings */
 	hw->fc.requested_mode = ixgbe_fc_full;
 	hw->fc.current_mode = ixgbe_fc_full;	/* init for ethtool output */
+
+	adapter->last_lfc_mode = hw->fc.current_mode;
 	ixgbe_pbthresh_setup(adapter);
 	hw->fc.pause_time = IXGBE_DEFAULT_FCPAUSE;
 	hw->fc.send_xon = true;
-	hw->fc.disable_fc_autoneg = ixgbe_device_supports_autoneg_fc(hw);
-
-#ifdef CONFIG_PCI_IOV
-	if (max_vfs > 0)
-		e_dev_warn("Enabling SR-IOV VFs using the max_vfs module parameter is deprecated - please use the pci sysfs interface instead.\n");
-
-	/* assign number of SR-IOV VFs */
-	if (hw->mac.type != ixgbe_mac_82598EB) {
-		if (max_vfs > IXGBE_MAX_VFS_DRV_LIMIT) {
-			max_vfs = 0;
-			e_dev_warn("max_vfs parameter out of range. Not assigning any SR-IOV VFs\n");
-		}
-	}
-#endif /* CONFIG_PCI_IOV */
-
-	/* enable itr by default in dynamic mode */
-	adapter->rx_itr_setting = 1;
-	adapter->tx_itr_setting = 1;
+	hw->fc.disable_fc_autoneg = false;
 
 	/* set default ring sizes */
 	adapter->tx_ring_count = IXGBE_DEFAULT_TXD;
@@ -6435,17 +7362,9 @@ static int ixgbe_sw_init(struct ixgbe_adapter *adapter,
 	/* set default work limits */
 	adapter->tx_work_limit = IXGBE_DEFAULT_TX_WORK;
 
-	/* initialize eeprom parameters */
-	if (ixgbe_init_eeprom_params_generic(hw)) {
-		e_dev_err("EEPROM initialization failed\n");
-		return -EIO;
-	}
-
-	/* PF holds first pool slot */
-	set_bit(0, adapter->fwd_bitmask);
 	set_bit(__IXGBE_DOWN, &adapter->state);
-
-	return 0;
+out:
+	return err;
 }
 
 /**
@@ -6458,15 +7377,15 @@ int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring)
 {
 	struct device *dev = tx_ring->dev;
 	int orig_node = dev_to_node(dev);
-	int ring_node = NUMA_NO_NODE;
+	int node = -1;
 	int size;
 
 	size = sizeof(struct ixgbe_tx_buffer) * tx_ring->count;
 
 	if (tx_ring->q_vector)
-		ring_node = tx_ring->q_vector->numa_node;
+		node = tx_ring->q_vector->node;
 
-	tx_ring->tx_buffer_info = vmalloc_node(size, ring_node);
+	tx_ring->tx_buffer_info = vmalloc_node(size, node);
 	if (!tx_ring->tx_buffer_info)
 		tx_ring->tx_buffer_info = vmalloc(size);
 	if (!tx_ring->tx_buffer_info)
@@ -6476,7 +7395,7 @@ int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring)
 	tx_ring->size = tx_ring->count * sizeof(union ixgbe_adv_tx_desc);
 	tx_ring->size = ALIGN(tx_ring->size, 4096);
 
-	set_dev_node(dev, ring_node);
+	set_dev_node(dev, node);
 	tx_ring->desc = dma_alloc_coherent(dev,
 					   tx_ring->size,
 					   &tx_ring->dma,
@@ -6488,8 +7407,6 @@ int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring)
 	if (!tx_ring->desc)
 		goto err;
 
-	tx_ring->next_to_use = 0;
-	tx_ring->next_to_clean = 0;
 	return 0;
 
 err:
@@ -6514,6 +7431,7 @@ static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter)
 	int i, j = 0, err = 0;
 
 	for (i = 0; i < adapter->num_tx_queues; i++) {
+
 		err = ixgbe_setup_tx_resources(adapter->tx_ring[i]);
 		if (!err)
 			continue;
@@ -6542,8 +7460,8 @@ static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter)
 
 /**
  * ixgbe_setup_rx_resources - allocate Rx resources (Descriptors)
- * @adapter: pointer to ixgbe_adapter
- * @rx_ring:    rx descriptor ring (for a specific queue) to setup
+ * @adapter: board private structure
+ * @rx_ring: rx descriptor ring (for a specific queue) to setup
  *
  * Returns 0 on success, negative on failure
  **/
@@ -6552,15 +7470,22 @@ int ixgbe_setup_rx_resources(struct ixgbe_adapter *adapter,
 {
 	struct device *dev = rx_ring->dev;
 	int orig_node = dev_to_node(dev);
-	int ring_node = NUMA_NO_NODE;
+	int node = -1;
 	int size;
+#ifdef HAVE_XDP_BUFF_RXQ
+#ifdef HAVE_XDP_FRAME_STRUCT
+#ifndef HAVE_AF_XDP_ZC_SUPPORT
+	int err;
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
+#endif /* HAVE_XDP_FRAME_STRUCT */
+#endif /* HAVE_XDP_BUFF_RXQ */
 
 	size = sizeof(struct ixgbe_rx_buffer) * rx_ring->count;
 
 	if (rx_ring->q_vector)
-		ring_node = rx_ring->q_vector->numa_node;
+		node = rx_ring->q_vector->node;
 
-	rx_ring->rx_buffer_info = vmalloc_node(size, ring_node);
+	rx_ring->rx_buffer_info = vmalloc_node(size, node);
 	if (!rx_ring->rx_buffer_info)
 		rx_ring->rx_buffer_info = vmalloc(size);
 	if (!rx_ring->rx_buffer_info)
@@ -6570,7 +7495,7 @@ int ixgbe_setup_rx_resources(struct ixgbe_adapter *adapter,
 	rx_ring->size = rx_ring->count * sizeof(union ixgbe_adv_rx_desc);
 	rx_ring->size = ALIGN(rx_ring->size, 4096);
 
-	set_dev_node(dev, ring_node);
+	set_dev_node(dev, node);
 	rx_ring->desc = dma_alloc_coherent(dev,
 					   rx_ring->size,
 					   &rx_ring->dma,
@@ -6582,14 +7507,24 @@ int ixgbe_setup_rx_resources(struct ixgbe_adapter *adapter,
 	if (!rx_ring->desc)
 		goto err;
 
-	rx_ring->next_to_clean = 0;
-	rx_ring->next_to_use = 0;
-
+#ifdef HAVE_XDP_BUFF_RXQ
 	/* XDP RX-queue info */
 	if (xdp_rxq_info_reg(&rx_ring->xdp_rxq, adapter->netdev,
 			     rx_ring->queue_index) < 0)
 		goto err;
 
+#ifndef HAVE_AF_XDP_ZC_SUPPORT
+#ifdef HAVE_XDP_FRAME_STRUCT
+	err = xdp_rxq_info_reg_mem_model(&rx_ring->xdp_rxq,
+					 MEM_TYPE_PAGE_SHARED, NULL);
+	if (err) {
+		xdp_rxq_info_unreg(&rx_ring->xdp_rxq);
+		goto err;
+	}
+#endif /* HAVE_XDP_FRAME_STRUCT */
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
+#endif /* HAVE_XDP_BUFF_RXQ */
+
 	rx_ring->xdp_prog = adapter->xdp_prog;
 
 	return 0;
@@ -6623,7 +7558,7 @@ static int ixgbe_setup_all_rx_resources(struct ixgbe_adapter *adapter)
 		goto err_setup_rx;
 	}
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	err = ixgbe_setup_fcoe_ddp_resources(adapter);
 	if (!err)
 #endif
@@ -6654,7 +7589,6 @@ void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring)
 
 	dma_free_coherent(tx_ring->dev, tx_ring->size,
 			  tx_ring->desc, tx_ring->dma);
-
 	tx_ring->desc = NULL;
 }
 
@@ -6669,8 +7603,7 @@ static void ixgbe_free_all_tx_resources(struct ixgbe_adapter *adapter)
 	int i;
 
 	for (i = 0; i < adapter->num_tx_queues; i++)
-		if (adapter->tx_ring[i]->desc)
-			ixgbe_free_tx_resources(adapter->tx_ring[i]);
+		ixgbe_free_tx_resources(adapter->tx_ring[i]);
 	for (i = 0; i < adapter->num_xdp_queues; i++)
 		if (adapter->xdp_ring[i]->desc)
 			ixgbe_free_tx_resources(adapter->xdp_ring[i]);
@@ -6687,7 +7620,9 @@ void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring)
 	ixgbe_clean_rx_ring(rx_ring);
 
 	rx_ring->xdp_prog = NULL;
+#ifdef HAVE_XDP_BUFF_RXQ
 	xdp_rxq_info_unreg(&rx_ring->xdp_rxq);
+#endif
 	vfree(rx_ring->rx_buffer_info);
 	rx_ring->rx_buffer_info = NULL;
 
@@ -6711,13 +7646,12 @@ static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter)
 {
 	int i;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	ixgbe_free_fcoe_ddp_resources(adapter);
-
 #endif
+
 	for (i = 0; i < adapter->num_rx_queues; i++)
-		if (adapter->rx_ring[i]->desc)
-			ixgbe_free_rx_resources(adapter->rx_ring[i]);
+		ixgbe_free_rx_resources(adapter->rx_ring[i]);
 }
 
 /**
@@ -6730,6 +7664,9 @@ static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter)
 static int ixgbe_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+#ifndef HAVE_NETDEVICE_MIN_MAX_MTU
+	int max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;
+#endif
 
 	if (adapter->xdp_prog) {
 		int new_frame_size = new_mtu + ETH_HLEN + ETH_FCS_LEN +
@@ -6746,6 +7683,12 @@ static int ixgbe_change_mtu(struct net_device *netdev, int new_mtu)
 		}
 	}
 
+#ifndef HAVE_NETDEVICE_MIN_MAX_MTU
+	/* MTU < 68 is an error and causes problems on some kernels */
+	if ((new_mtu < 68) || (max_frame > IXGBE_MAX_JUMBO_FRAME_SIZE))
+		return -EINVAL;
+
+#endif
 	/*
 	 * For 82599EB we cannot allow legacy VFs to enable their receive
 	 * paths when MTU greater than 1500 is configured.  So display a
@@ -6753,11 +7696,14 @@ static int ixgbe_change_mtu(struct net_device *netdev, int new_mtu)
 	 */
 	if ((adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) &&
 	    (adapter->hw.mac.type == ixgbe_mac_82599EB) &&
+#ifndef HAVE_NETDEVICE_MIN_MAX_MTU
+	    (max_frame > (ETH_FRAME_LEN + ETH_FCS_LEN)))
+#else
 	    (new_mtu > ETH_DATA_LEN))
+#endif
 		e_warn(probe, "Setting MTU > 1500 will disable legacy VFs\n");
 
-	netdev_dbg(netdev, "changing MTU from %d to %d\n",
-		   netdev->mtu, new_mtu);
+	e_info(probe, "changing MTU from %d to %d\n", netdev->mtu, new_mtu);
 
 	/* must set new MTU before calling down or up */
 	netdev->mtu = new_mtu;
@@ -6783,8 +7729,7 @@ static int ixgbe_change_mtu(struct net_device *netdev, int new_mtu)
 int ixgbe_open(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw *hw = &adapter->hw;
-	int err, queues;
+	int err;
 
 	/* disallow open during test */
 	if (test_bit(__IXGBE_TESTING, &adapter->state))
@@ -6809,30 +7754,40 @@ int ixgbe_open(struct net_device *netdev)
 		goto err_req_irq;
 
 	/* Notify the stack of the actual queue counts. */
-	queues = adapter->num_tx_queues;
-	err = netif_set_real_num_tx_queues(netdev, queues);
+	err = netif_set_real_num_tx_queues(netdev,
+					   adapter->num_rx_pools > 1 ? 1 :
+					   adapter->num_tx_queues);
 	if (err)
 		goto err_set_queues;
 
-	queues = adapter->num_rx_queues;
-	err = netif_set_real_num_rx_queues(netdev, queues);
+	err = netif_set_real_num_rx_queues(netdev,
+					   adapter->num_rx_pools > 1 ? 1 :
+					   adapter->num_rx_queues);
 	if (err)
 		goto err_set_queues;
 
+#ifdef HAVE_PTP_1588_CLOCK
 	ixgbe_ptp_init(adapter);
+#endif /* HAVE_PTP_1588_CLOCK*/
 
 	ixgbe_up_complete(adapter);
 
-	udp_tunnel_nic_reset_ntf(netdev);
-
-	return 0;
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+	ixgbe_clear_udp_tunnel_port(adapter, IXGBE_VXLANCTRL_ALL_UDPPORT_MASK);
+#endif
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+	udp_tunnel_get_rx_info(netdev);
+#elif defined(HAVE_VXLAN_RX_OFFLOAD)
+	vxlan_get_rx_port(netdev);
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
+	return IXGBE_SUCCESS;
 
 err_set_queues:
 	ixgbe_free_irq(adapter);
 err_req_irq:
 	ixgbe_free_all_rx_resources(adapter);
-	if (hw->phy.ops.set_phy_power && !adapter->wol)
-		hw->phy.ops.set_phy_power(&adapter->hw, false);
+	if (!adapter->wol)
+		ixgbe_set_phy_power(&adapter->hw, false);
 err_setup_rx:
 	ixgbe_free_all_tx_resources(adapter);
 err_setup_tx:
@@ -6841,23 +7796,31 @@ int ixgbe_open(struct net_device *netdev)
 	return err;
 }
 
+/**
+ * ixgbe_close_suspend - actions necessary to both suspend and close flows
+ * @adapter: the private adapter struct
+ *
+ * This function should contain the necessary work common to both suspending
+ * and closing of the device.
+ */
 static void ixgbe_close_suspend(struct ixgbe_adapter *adapter)
 {
+#ifdef HAVE_PTP_1588_CLOCK
 	ixgbe_ptp_suspend(adapter);
+#endif
 
 	if (adapter->hw.phy.ops.enter_lplu) {
 		adapter->hw.phy.reset_disable = true;
 		ixgbe_down(adapter);
-		adapter->hw.phy.ops.enter_lplu(&adapter->hw);
+		ixgbe_enter_lplu(&adapter->hw);
 		adapter->hw.phy.reset_disable = false;
 	} else {
 		ixgbe_down(adapter);
 	}
-
 	ixgbe_free_irq(adapter);
 
-	ixgbe_free_all_tx_resources(adapter);
 	ixgbe_free_all_rx_resources(adapter);
+	ixgbe_free_all_tx_resources(adapter);
 }
 
 /**
@@ -6875,7 +7838,9 @@ int ixgbe_close(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+#ifdef HAVE_PTP_1588_CLOCK
 	ixgbe_ptp_stop(adapter);
+#endif
 
 	if (netif_device_present(netdev))
 		ixgbe_close_suspend(adapter);
@@ -6887,26 +7852,48 @@ int ixgbe_close(struct net_device *netdev)
 	return 0;
 }
 
-static int __maybe_unused ixgbe_resume(struct device *dev_d)
+#ifdef CONFIG_PM
+#ifndef USE_LEGACY_PM_SUPPORT
+static int ixgbe_resume(struct device *dev)
+#else
+static int ixgbe_resume(struct pci_dev *pdev)
+#endif /* USE_LEGACY_PM_SUPPORT */
 {
-	struct pci_dev *pdev = to_pci_dev(dev_d);
-	struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
-	struct net_device *netdev = adapter->netdev;
+	struct ixgbe_adapter *adapter;
+	struct net_device *netdev;
 	u32 err;
+#ifndef USE_LEGACY_PM_SUPPORT
+	struct pci_dev *pdev = to_pci_dev(dev);
+#endif
 
+	adapter = pci_get_drvdata(pdev);
+	netdev = adapter->netdev;
 	adapter->hw.hw_addr = adapter->io_addr;
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	/*
+	 * pci_restore_state clears dev->state_saved so call
+	 * pci_save_state to restore it.
+	 */
+	pci_save_state(pdev);
 
+	err = pci_enable_device_mem(pdev);
+	if (err) {
+		e_dev_err("Cannot enable PCI device from suspend\n");
+		return err;
+	}
 	smp_mb__before_atomic();
 	clear_bit(__IXGBE_DISABLED, &adapter->state);
 	pci_set_master(pdev);
 
-	device_wakeup_disable(dev_d);
+	pci_wake_from_d3(pdev, false);
 
 	ixgbe_reset(adapter);
 
 	IXGBE_WRITE_REG(&adapter->hw, IXGBE_WUS, ~0);
 
 	rtnl_lock();
+
 	err = ixgbe_init_interrupt_scheme(adapter);
 	if (!err && netif_running(netdev))
 		err = ixgbe_open(netdev);
@@ -6914,11 +7901,82 @@ static int __maybe_unused ixgbe_resume(struct device *dev_d)
 
 	if (!err)
 		netif_device_attach(netdev);
+
 	rtnl_unlock();
 
 	return err;
 }
 
+#ifndef USE_LEGACY_PM_SUPPORT
+/**
+ * ixgbe_freeze - quiesce the device (no IRQ's or DMA)
+ * @dev: The port's netdev
+ */
+static int ixgbe_freeze(struct device *dev)
+{
+	struct ixgbe_adapter *adapter = pci_get_drvdata(to_pci_dev(dev));
+	struct net_device *netdev = adapter->netdev;
+	bool lplu_enabled = !!adapter->hw.phy.ops.enter_lplu;
+
+	rtnl_lock();
+	netif_device_detach(netdev);
+
+	if (netif_running(netdev)) {
+		if (lplu_enabled) {
+			adapter->hw.phy.reset_disable = true;
+			ixgbe_down(adapter);
+			adapter->hw.phy.reset_disable = false;
+		} else {
+			ixgbe_down(adapter);
+		}
+		ixgbe_free_irq(adapter);
+	}
+
+	ixgbe_reset_interrupt_capability(adapter);
+	rtnl_unlock();
+
+	return 0;
+}
+
+/**
+ * ixgbe_thaw - un-quiesce the device
+ * @dev: The port's netdev
+ */
+static int ixgbe_thaw(struct device *dev)
+{
+	struct ixgbe_adapter *adapter = pci_get_drvdata(to_pci_dev(dev));
+	struct net_device *netdev = adapter->netdev;
+	bool lplu_enabled = !!adapter->hw.phy.ops.enter_lplu;
+
+	ixgbe_set_interrupt_capability(adapter);
+
+	if (netif_running(netdev)) {
+		u32 err = ixgbe_request_irq(adapter);
+		if (err)
+			return err;
+
+		if (lplu_enabled) {
+			adapter->hw.phy.reset_disable = true;
+			ixgbe_up(adapter);
+			adapter->hw.phy.reset_disable = false;
+		} else {
+			ixgbe_up(adapter);
+		}
+	}
+
+	netif_device_attach(netdev);
+
+	return 0;
+}
+#endif /* USE_LEGACY_PM_SUPPORT */
+#endif /* CONFIG_PM */
+
+/*
+ * __ixgbe_shutdown is not used when power management
+ * is disabled on older kernels (<2.6.12). causes a compile
+ * warning/error, because it is defined and not used.
+ */
+#if defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER)
 static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 {
 	struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
@@ -6926,6 +7984,9 @@ static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 ctrl;
 	u32 wufc = adapter->wol;
+#ifdef CONFIG_PM
+	int retval = 0;
+#endif
 
 	rtnl_lock();
 	netif_device_detach(netdev);
@@ -6936,8 +7997,16 @@ static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 	ixgbe_clear_interrupt_scheme(adapter);
 	rtnl_unlock();
 
-	if (hw->mac.ops.stop_link_on_d3)
-		hw->mac.ops.stop_link_on_d3(hw);
+#ifdef CONFIG_PM
+	retval = pci_save_state(pdev);
+	if (retval)
+		return retval;
+
+#endif
+
+	/* this won't stop link of managebility or WoL is enabled */
+	if (hw->mac.type == ixgbe_mac_82599EB)
+		ixgbe_stop_mac_link_on_d3_82599(hw);
 
 	if (wufc) {
 		u32 fctrl;
@@ -6971,7 +8040,7 @@ static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		pci_wake_from_d3(pdev, !!wufc);
 		break;
 	default:
@@ -6979,8 +8048,8 @@ static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 	}
 
 	*enable_wake = !!wufc;
-	if (hw->phy.ops.set_phy_power && !*enable_wake)
-		hw->phy.ops.set_phy_power(hw, false);
+	if (!*enable_wake)
+		ixgbe_set_phy_power(hw, false);
 
 	ixgbe_release_hw_control(adapter);
 
@@ -6989,20 +8058,38 @@ static int __ixgbe_shutdown(struct pci_dev *pdev, bool *enable_wake)
 
 	return 0;
 }
+#endif /* defined(CONFIG_PM) || !defined(USE_REBOOT_NOTIFIER) */
 
-static int __maybe_unused ixgbe_suspend(struct device *dev_d)
+#ifdef CONFIG_PM
+#ifndef USE_LEGACY_PM_SUPPORT
+static int ixgbe_suspend(struct device *dev)
+#else
+static int ixgbe_suspend(struct pci_dev *pdev,
+			 pm_message_t __always_unused state)
+#endif /* USE_LEGACY_PM_SUPPORT */
 {
-	struct pci_dev *pdev = to_pci_dev(dev_d);
 	int retval;
 	bool wake;
+#ifndef USE_LEGACY_PM_SUPPORT
+	struct pci_dev *pdev = to_pci_dev(dev);
+#endif
 
 	retval = __ixgbe_shutdown(pdev, &wake);
+	if (retval)
+		return retval;
 
-	device_set_wakeup_enable(dev_d, wake);
+	if (wake) {
+		pci_prepare_to_sleep(pdev);
+	} else {
+		pci_wake_from_d3(pdev, false);
+		pci_set_power_state(pdev, PCI_D3hot);
+	}
 
-	return retval;
+	return 0;
 }
+#endif /* CONFIG_PM */
 
+#ifndef USE_REBOOT_NOTIFIER
 static void ixgbe_shutdown(struct pci_dev *pdev)
 {
 	bool wake;
@@ -7015,13 +8102,120 @@ static void ixgbe_shutdown(struct pci_dev *pdev)
 	}
 }
 
+#endif
+#ifdef HAVE_NDO_GET_STATS64
+static void ixgbe_get_ring_stats64(struct rtnl_link_stats64 *stats,
+				   struct ixgbe_ring *ring)
+{
+	u64 bytes, packets;
+	unsigned int start;
+
+	if (ring) {
+		do {
+			start = u64_stats_fetch_begin_irq(&ring->syncp);
+			packets = ring->stats.packets;
+			bytes   = ring->stats.bytes;
+		} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
+		stats->tx_packets += packets;
+		stats->tx_bytes   += bytes;
+	}
+}
+
+/**
+ * ixgbe_get_stats64 - Get System Network Statistics
+ * @netdev: network interface device structure
+ * @stats: storage space for 64bit statistics
+ *
+ * Returns 64bit statistics, for use in the ndo_get_stats64 callback. This
+ * function replaces ixgbe_get_stats for kernels which support it.
+ */
+#ifdef HAVE_VOID_NDO_GET_STATS64
+static void ixgbe_get_stats64(struct net_device *netdev,
+			      struct rtnl_link_stats64 *stats)
+#else
+static struct rtnl_link_stats64 *
+ixgbe_get_stats64(struct net_device *netdev, struct rtnl_link_stats64 *stats)
+#endif
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	int i;
+
+	rcu_read_lock();
+	for (i = 0; i < adapter->num_rx_queues; i++) {
+		struct ixgbe_ring *ring = READ_ONCE(adapter->rx_ring[i]);
+		u64 bytes, packets;
+		unsigned int start;
+
+		if (ring) {
+			do {
+				start = u64_stats_fetch_begin_irq(&ring->syncp);
+				packets = ring->stats.packets;
+				bytes   = ring->stats.bytes;
+			} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
+			stats->rx_packets += packets;
+			stats->rx_bytes   += bytes;
+		}
+	}
+
+	for (i = 0; i < adapter->num_tx_queues; i++) {
+		struct ixgbe_ring *ring = READ_ONCE(adapter->tx_ring[i]);
+
+		ixgbe_get_ring_stats64(stats, ring);
+	}
+
+	for (i = 0; i < adapter->num_xdp_queues; i++) {
+		struct ixgbe_ring *ring = READ_ONCE(adapter->xdp_ring[i]);
+
+		ixgbe_get_ring_stats64(stats, ring);
+	}
+	rcu_read_unlock();
+
+	/* following stats updated by ixgbe_watchdog_task() */
+	stats->multicast	= netdev->stats.multicast;
+	stats->rx_errors	= netdev->stats.rx_errors;
+	stats->rx_length_errors	= netdev->stats.rx_length_errors;
+	stats->rx_crc_errors	= netdev->stats.rx_crc_errors;
+	stats->rx_missed_errors	= netdev->stats.rx_missed_errors;
+#ifndef HAVE_VOID_NDO_GET_STATS64
+
+	return stats;
+#endif
+}
+#else
+/**
+ * ixgbe_get_stats - Get System Network Statistics
+ * @netdev: network interface device structure
+ *
+ * Returns the address of the device statistics structure.
+ * The statistics are actually updated from the timer callback.
+ **/
+static struct net_device_stats *ixgbe_get_stats(struct net_device *netdev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	/* update the stats data */
+	ixgbe_update_stats(adapter);
+
+#ifdef HAVE_NETDEV_STATS_IN_NETDEV
+	/* only return the current stats */
+	return &netdev->stats;
+#else
+	/* only return the current stats */
+	return &adapter->net_stats;
+#endif /* HAVE_NETDEV_STATS_IN_NETDEV */
+}
+#endif
 /**
  * ixgbe_update_stats - Update the board statistics counters.
  * @adapter: board private structure
  **/
 void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 {
-	struct net_device *netdev = adapter->netdev;
+#ifdef HAVE_NETDEV_STATS_IN_NETDEV
+	struct net_device_stats *net_stats = &adapter->netdev->stats;
+#else
+	struct net_device_stats *net_stats = &adapter->net_stats;
+#endif /* HAVE_NETDEV_STATS_IN_NETDEV */
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct ixgbe_hw_stats *hwstats = &adapter->stats;
 	u64 total_mpc = 0;
@@ -7047,10 +8241,7 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 	}
 
 	for (i = 0; i < adapter->num_rx_queues; i++) {
-		struct ixgbe_ring *rx_ring = READ_ONCE(adapter->rx_ring[i]);
-
-		if (!rx_ring)
-			continue;
+		struct ixgbe_ring *rx_ring = adapter->rx_ring[i];
 		non_eop_descs += rx_ring->rx_stats.non_eop_descs;
 		alloc_rx_page += rx_ring->rx_stats.alloc_rx_page;
 		alloc_rx_page_failed += rx_ring->rx_stats.alloc_rx_page_failed;
@@ -7058,33 +8249,29 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 		hw_csum_rx_error += rx_ring->rx_stats.csum_err;
 		bytes += rx_ring->stats.bytes;
 		packets += rx_ring->stats.packets;
+
 	}
 	adapter->non_eop_descs = non_eop_descs;
 	adapter->alloc_rx_page = alloc_rx_page;
 	adapter->alloc_rx_page_failed = alloc_rx_page_failed;
 	adapter->alloc_rx_buff_failed = alloc_rx_buff_failed;
 	adapter->hw_csum_rx_error = hw_csum_rx_error;
-	netdev->stats.rx_bytes = bytes;
-	netdev->stats.rx_packets = packets;
+	net_stats->rx_bytes = bytes;
+	net_stats->rx_packets = packets;
 
 	bytes = 0;
 	packets = 0;
 	/* gather some stats to the adapter struct that are per queue */
 	for (i = 0; i < adapter->num_tx_queues; i++) {
-		struct ixgbe_ring *tx_ring = READ_ONCE(adapter->tx_ring[i]);
-
-		if (!tx_ring)
-			continue;
+		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
 		restart_queue += tx_ring->tx_stats.restart_queue;
 		tx_busy += tx_ring->tx_stats.tx_busy;
 		bytes += tx_ring->stats.bytes;
 		packets += tx_ring->stats.packets;
 	}
 	for (i = 0; i < adapter->num_xdp_queues; i++) {
-		struct ixgbe_ring *xdp_ring = READ_ONCE(adapter->xdp_ring[i]);
+		struct ixgbe_ring *xdp_ring = adapter->xdp_ring[i];
 
-		if (!xdp_ring)
-			continue;
 		restart_queue += xdp_ring->tx_stats.restart_queue;
 		tx_busy += xdp_ring->tx_stats.tx_busy;
 		bytes += xdp_ring->stats.bytes;
@@ -7092,8 +8279,8 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 	}
 	adapter->restart_queue = restart_queue;
 	adapter->tx_busy = tx_busy;
-	netdev->stats.tx_bytes = bytes;
-	netdev->stats.tx_packets = packets;
+	net_stats->tx_bytes = bytes;
+	net_stats->tx_packets = packets;
 
 	hwstats->crcerrs += IXGBE_READ_REG(hw, IXGBE_CRCERRS);
 
@@ -7118,7 +8305,7 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 		case ixgbe_mac_X540:
 		case ixgbe_mac_X550:
 		case ixgbe_mac_X550EM_x:
-		case ixgbe_mac_x550em_a:
+		case ixgbe_mac_X550EM_a:
 			hwstats->pxonrxc[i] +=
 				IXGBE_READ_REG(hw, IXGBE_PXONRXCNT(i));
 			break;
@@ -7132,10 +8319,10 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 		hwstats->qptc[i] += IXGBE_READ_REG(hw, IXGBE_QPTC(i));
 		hwstats->qprc[i] += IXGBE_READ_REG(hw, IXGBE_QPRC(i));
 		if ((hw->mac.type == ixgbe_mac_82599EB) ||
-		    (hw->mac.type == ixgbe_mac_X540) ||
 		    (hw->mac.type == ixgbe_mac_X550) ||
 		    (hw->mac.type == ixgbe_mac_X550EM_x) ||
-		    (hw->mac.type == ixgbe_mac_x550em_a)) {
+		    (hw->mac.type == ixgbe_mac_X550EM_a) ||
+		    (hw->mac.type == ixgbe_mac_X540)) {
 			hwstats->qbtc[i] += IXGBE_READ_REG(hw, IXGBE_QBTC_L(i));
 			IXGBE_READ_REG(hw, IXGBE_QBTC_H(i)); /* to clear */
 			hwstats->qbrc[i] += IXGBE_READ_REG(hw, IXGBE_QBRC_L(i));
@@ -7160,13 +8347,13 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		/* OS2BMC stats are X540 and later */
+	case ixgbe_mac_X550EM_a:
+		/* OS2BMC stats are X540 only*/
 		hwstats->o2bgptc += IXGBE_READ_REG(hw, IXGBE_O2BGPTC);
 		hwstats->o2bspc += IXGBE_READ_REG(hw, IXGBE_O2BSPC);
 		hwstats->b2ospc += IXGBE_READ_REG(hw, IXGBE_B2OSPC);
 		hwstats->b2ogprc += IXGBE_READ_REG(hw, IXGBE_B2OGPRC);
-		fallthrough;
+		/* fall through */
 	case ixgbe_mac_82599EB:
 		for (i = 0; i < 16; i++)
 			adapter->hw_rx_no_dma_resources +=
@@ -7178,16 +8365,19 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 		hwstats->tor += IXGBE_READ_REG(hw, IXGBE_TORL);
 		IXGBE_READ_REG(hw, IXGBE_TORH); /* to clear */
 		hwstats->lxonrxc += IXGBE_READ_REG(hw, IXGBE_LXONRXCNT);
+#ifdef HAVE_TX_MQ
 		hwstats->fdirmatch += IXGBE_READ_REG(hw, IXGBE_FDIRMATCH);
 		hwstats->fdirmiss += IXGBE_READ_REG(hw, IXGBE_FDIRMISS);
-#ifdef IXGBE_FCOE
+#endif /* HAVE_TX_MQ */
+#if IS_ENABLED(CONFIG_FCOE)
 		hwstats->fccrc += IXGBE_READ_REG(hw, IXGBE_FCCRC);
+		hwstats->fclast += IXGBE_READ_REG(hw, IXGBE_FCLAST);
 		hwstats->fcoerpdc += IXGBE_READ_REG(hw, IXGBE_FCOERPDC);
 		hwstats->fcoeprc += IXGBE_READ_REG(hw, IXGBE_FCOEPRC);
 		hwstats->fcoeptc += IXGBE_READ_REG(hw, IXGBE_FCOEPTC);
 		hwstats->fcoedwrc += IXGBE_READ_REG(hw, IXGBE_FCOEDWRC);
 		hwstats->fcoedwtc += IXGBE_READ_REG(hw, IXGBE_FCOEDWTC);
-		/* Add up per cpu counters for total ddp aloc fail */
+		/* Add up per cpu counters for total ddp alloc fail */
 		if (adapter->fcoe.ddp_pool) {
 			struct ixgbe_fcoe *fcoe = &adapter->fcoe;
 			struct ixgbe_fcoe_ddp_pool *ddp_pool;
@@ -7201,7 +8391,8 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 			hwstats->fcoe_noddp = noddp;
 			hwstats->fcoe_noddp_ext_buff = noddp_ext_buff;
 		}
-#endif /* IXGBE_FCOE */
+
+#endif /* CONFIG_FCOE */
 		break;
 	default:
 		break;
@@ -7244,18 +8435,46 @@ void ixgbe_update_stats(struct ixgbe_adapter *adapter)
 	hwstats->ptc1023 += IXGBE_READ_REG(hw, IXGBE_PTC1023);
 	hwstats->ptc1522 += IXGBE_READ_REG(hw, IXGBE_PTC1522);
 	hwstats->bptc += IXGBE_READ_REG(hw, IXGBE_BPTC);
-
 	/* Fill out the OS statistics structure */
-	netdev->stats.multicast = hwstats->mprc;
+	net_stats->multicast = hwstats->mprc;
 
 	/* Rx Errors */
-	netdev->stats.rx_errors = hwstats->crcerrs + hwstats->rlec;
-	netdev->stats.rx_dropped = 0;
-	netdev->stats.rx_length_errors = hwstats->rlec;
-	netdev->stats.rx_crc_errors = hwstats->crcerrs;
-	netdev->stats.rx_missed_errors = total_mpc;
+	net_stats->rx_errors = hwstats->crcerrs +
+				       hwstats->rlec;
+	net_stats->rx_dropped = 0;
+	net_stats->rx_length_errors = hwstats->rlec;
+	net_stats->rx_crc_errors = hwstats->crcerrs;
+	net_stats->rx_missed_errors = total_mpc;
+
+	/*
+	 * VF Stats Collection - skip while resetting because these
+	 * are not clear on read and otherwise you'll sometimes get
+	 * crazy values.
+	 */
+	if (!test_bit(__IXGBE_RESETTING, &adapter->state)) {
+		for (i = 0; i < adapter->num_vfs; i++) {
+			UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPRC(i),	      \
+					adapter->vfinfo[i].last_vfstats.gprc, \
+					adapter->vfinfo[i].vfstats.gprc);
+			UPDATE_VF_COUNTER_32bit(IXGBE_PVFGPTC(i),	      \
+					adapter->vfinfo[i].last_vfstats.gptc, \
+					adapter->vfinfo[i].vfstats.gptc);
+			UPDATE_VF_COUNTER_36bit(IXGBE_PVFGORC_LSB(i),	      \
+					IXGBE_PVFGORC_MSB(i),		      \
+					adapter->vfinfo[i].last_vfstats.gorc, \
+					adapter->vfinfo[i].vfstats.gorc);
+			UPDATE_VF_COUNTER_36bit(IXGBE_PVFGOTC_LSB(i),	      \
+					IXGBE_PVFGOTC_MSB(i),		      \
+					adapter->vfinfo[i].last_vfstats.gotc, \
+					adapter->vfinfo[i].vfstats.gotc);
+			UPDATE_VF_COUNTER_32bit(IXGBE_PVFMPRC(i),	      \
+					adapter->vfinfo[i].last_vfstats.mprc, \
+					adapter->vfinfo[i].vfstats.mprc);
+		}
+	}
 }
 
+#ifdef HAVE_TX_MQ
 /**
  * ixgbe_fdir_reinit_subtask - worker thread to reinit FDIR filter table
  * @adapter: pointer to the device adapter structure
@@ -7280,7 +8499,7 @@ static void ixgbe_fdir_reinit_subtask(struct ixgbe_adapter *adapter)
 
 	adapter->fdir_overflow++;
 
-	if (ixgbe_reinit_fdir_tables_82599(hw) == 0) {
+	if (ixgbe_reinit_fdir_tables_82599(hw) == IXGBE_SUCCESS) {
 		for (i = 0; i < adapter->num_tx_queues; i++)
 			set_bit(__IXGBE_TX_FDIR_INIT_DONE,
 				&(adapter->tx_ring[i]->state));
@@ -7295,6 +8514,7 @@ static void ixgbe_fdir_reinit_subtask(struct ixgbe_adapter *adapter)
 	}
 }
 
+#endif /* HAVE_TX_MQ */
 /**
  * ixgbe_check_hang_subtask - check for hung queues and dropped interrupts
  * @adapter: pointer to the device adapter structure
@@ -7337,7 +8557,7 @@ static void ixgbe_check_hang_subtask(struct ixgbe_adapter *adapter)
 		for (i = 0; i < adapter->num_q_vectors; i++) {
 			struct ixgbe_q_vector *qv = adapter->q_vector[i];
 			if (qv->rx.ring || qv->tx.ring)
-				eics |= BIT_ULL(i);
+				eics |= ((u64)1 << i);
 		}
 	}
 
@@ -7367,9 +8587,11 @@ static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter)
 		link_up = true;
 	}
 
+#ifdef HAVE_DCBNL_IEEE
 	if (adapter->ixgbe_ieee_pfc)
 		pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
 
+#endif
 	if (link_up && !((adapter->flags & IXGBE_FLAG_DCB_ENABLED) && pfc_en)) {
 		hw->mac.ops.fc_enable(hw);
 		ixgbe_set_rx_drop_en(adapter);
@@ -7385,22 +8607,47 @@ static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter)
 
 	adapter->link_up = link_up;
 	adapter->link_speed = link_speed;
+
+	if (hw->mac.ops.dmac_config && hw->mac.dmac_config.watchdog_timer) {
+		u8 num_tcs = netdev_get_num_tc(adapter->netdev);
+#if IS_ENABLED(CONFIG_FCOE)
+		u8 fcoe_tc = ixgbe_fcoe_get_tc(adapter);
+		bool fcoe_en = !!(adapter->flags & IXGBE_FLAG_FCOE_ENABLED);
+#endif /* CONFIG_FCOE */
+
+		if (hw->mac.dmac_config.link_speed != link_speed ||
+#if IS_ENABLED(CONFIG_FCOE)
+		    hw->mac.dmac_config.fcoe_tc != fcoe_tc ||
+		    hw->mac.dmac_config.fcoe_en != fcoe_en ||
+#endif /* CONFIG_FCOE */
+		    hw->mac.dmac_config.num_tcs != num_tcs) {
+			hw->mac.dmac_config.link_speed = link_speed;
+			hw->mac.dmac_config.num_tcs = num_tcs;
+#if IS_ENABLED(CONFIG_FCOE)
+			hw->mac.dmac_config.fcoe_en = fcoe_en;
+			hw->mac.dmac_config.fcoe_tc = fcoe_tc;
+#endif /* CONFIG_FCOE */
+			hw->mac.ops.dmac_config(hw);
+		}
+	}
 }
 
 static void ixgbe_update_default_up(struct ixgbe_adapter *adapter)
 {
-#ifdef CONFIG_IXGBE_DCB
+	u8 up = 0;
+#ifdef HAVE_DCBNL_IEEE
 	struct net_device *netdev = adapter->netdev;
 	struct dcb_app app = {
-			      .selector = IEEE_8021QAZ_APP_SEL_ETHERTYPE,
+			      .selector = DCB_APP_IDTYPE_ETHTYPE,
 			      .protocol = 0,
 			     };
-	u8 up = 0;
-
-	if (adapter->dcbx_cap & DCB_CAP_DCBX_VER_IEEE)
-		up = dcb_ieee_getapp_mask(netdev, &app);
+	up = dcb_getapp(netdev, &app);
+#endif
 
+#if IS_ENABLED(CONFIG_FCOE)
 	adapter->default_up = (up > 1) ? (ffs(up) - 1) : 0;
+#else
+	adapter->default_up = up;
 #endif
 }
 
@@ -7431,11 +8678,11 @@ static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter)
 		flow_tx = !!(rmcs & IXGBE_RMCS_TFCE_802_3X);
 	}
 		break;
-	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-	case ixgbe_mac_82599EB: {
+	case ixgbe_mac_X550EM_a:
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540: {
 		u32 mflcn = IXGBE_READ_REG(hw, IXGBE_MFLCN);
 		u32 fccfg = IXGBE_READ_REG(hw, IXGBE_FCCFG);
 		flow_rx = !!(mflcn & IXGBE_MFLCN_RFCE);
@@ -7448,11 +8695,13 @@ static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter)
 		break;
 	}
 
+#ifdef HAVE_PTP_1588_CLOCK
 	adapter->last_rx_ptp_check = jiffies;
 
 	if (test_bit(__IXGBE_PTP_RUNNING, &adapter->state))
 		ixgbe_ptp_start_cyclecounter(adapter);
 
+#endif
 	switch (link_speed) {
 	case IXGBE_LINK_SPEED_10GB_FULL:
 		speed_str = "10 Gbps";
@@ -7482,16 +8731,17 @@ static void ixgbe_watchdog_link_is_up(struct ixgbe_adapter *adapter)
 	       (flow_tx ? "TX" : "None"))));
 
 	netif_carrier_on(netdev);
+#ifdef IFLA_VF_MAX
 	ixgbe_check_vf_rate_limit(adapter);
+#endif /* IFLA_VF_MAX */
+	/* Turn on malicious driver detection */
+	if ((adapter->num_vfs) && (hw->mac.ops.enable_mdd) &&
+		(adapter->flags & IXGBE_FLAG_MDD_ENABLED))
+		hw->mac.ops.enable_mdd(hw);
 
-	/* enable transmits */
-	netif_tx_wake_all_queues(adapter->netdev);
-
+	netif_tx_wake_all_queues(netdev);
 	/* update the default user priority for VFs */
 	ixgbe_update_default_up(adapter);
-
-	/* ping all the active vfs to let them know link has changed */
-	ixgbe_ping_all_vfs(adapter);
 }
 
 /**
@@ -7515,11 +8765,14 @@ static void ixgbe_watchdog_link_is_down(struct ixgbe_adapter *adapter)
 	if (ixgbe_is_sfp(hw) && hw->mac.type == ixgbe_mac_82598EB)
 		adapter->flags2 |= IXGBE_FLAG2_SEARCH_FOR_SFP;
 
+#ifdef HAVE_PTP_1588_CLOCK
 	if (test_bit(__IXGBE_PTP_RUNNING, &adapter->state))
 		ixgbe_ptp_start_cyclecounter(adapter);
 
+#endif
 	e_info(drv, "NIC Link is Down\n");
 	netif_carrier_off(netdev);
+	netif_tx_stop_all_queues(netdev);
 
 	/* ping all the active vfs to let them know link has changed */
 	ixgbe_ping_all_vfs(adapter);
@@ -7557,16 +8810,15 @@ static bool ixgbe_vf_tx_pending(struct ixgbe_adapter *adapter)
 	if (!adapter->num_vfs)
 		return false;
 
-	/* resetting the PF is only needed for MAC before X550 */
+	/* resetting the PF is only needed for MACs < X550 */
 	if (hw->mac.type >= ixgbe_mac_X550)
 		return false;
-
 	for (i = 0; i < adapter->num_vfs; i++) {
 		for (j = 0; j < q_per_pool; j++) {
 			u32 h, t;
 
-			h = IXGBE_READ_REG(hw, IXGBE_PVFTDHN(q_per_pool, i, j));
-			t = IXGBE_READ_REG(hw, IXGBE_PVFTDTN(q_per_pool, i, j));
+			h = IXGBE_READ_REG(hw, IXGBE_PVFTDHn(q_per_pool, i, j));
+			t = IXGBE_READ_REG(hw, IXGBE_PVFTDTn(q_per_pool, i, j));
 
 			if (h != t)
 				return true;
@@ -7590,13 +8842,42 @@ static void ixgbe_watchdog_flush_tx(struct ixgbe_adapter *adapter)
 			 * to get done, so reset controller to flush Tx.
 			 * (Do the reset outside of interrupt context).
 			 */
-			e_warn(drv, "initiating reset to clear Tx work after link loss\n");
+			e_warn(drv, "initiating reset due to lost link with pending Tx work\n");
 			set_bit(__IXGBE_RESET_REQUESTED, &adapter->state);
 		}
 	}
 }
 
 #ifdef CONFIG_PCI_IOV
+static inline void ixgbe_issue_vf_flr(struct ixgbe_adapter *adapter,
+				      struct pci_dev *vfdev)
+{
+	int pos, i;
+	u16 status;
+
+	/* wait for pending transactions on the bus */
+	for (i = 0; i < 4; i++) {
+		if (i)
+			msleep((1 << (i - 1)) * 100);
+
+		pcie_capability_read_word(vfdev, PCI_EXP_DEVSTA, &status);
+		if (!(status & PCI_EXP_DEVSTA_TRPND))
+			goto clear;
+	}
+
+	e_dev_warn("Issuing VFLR with pending transactions\n");
+
+clear:
+	pos = pci_find_capability(vfdev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return;
+
+	e_dev_err("Issuing VFLR for VF %s\n", pci_name(vfdev));
+	pci_write_config_word(vfdev, pos + PCI_EXP_DEVCTL,
+			      PCI_EXP_DEVCTL_BCR_FLR);
+	msleep(100);
+}
+
 static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -7610,7 +8891,8 @@ static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
 	gpc = IXGBE_READ_REG(hw, IXGBE_TXDGPC);
 	if (gpc) /* If incrementing then no need for the check below */
 		return;
-	/* Check to see if a bad DMA write target from an errant or
+	/*
+	 * Check to see if a bad DMA write target from an errant or
 	 * malicious VF has caused a PCIe error.  If so then we can
 	 * issue a VFLR to the offending VF(s) and then resume without
 	 * requesting a full slot reset.
@@ -7629,7 +8911,7 @@ static void ixgbe_check_for_bad_vf(struct ixgbe_adapter *adapter)
 		pci_read_config_word(vfdev, PCI_STATUS, &status_reg);
 		if (status_reg != IXGBE_FAILED_READ_CFG_WORD &&
 		    status_reg & PCI_STATUS_REC_MASTER_ABORT)
-			pcie_flr(vfdev);
+			ixgbe_issue_vf_flr(adapter, vfdev);
 	}
 }
 
@@ -7651,20 +8933,11 @@ static void ixgbe_spoof_check(struct ixgbe_adapter *adapter)
 	if (!ssvpc)
 		return;
 
-	e_warn(drv, "%u Spoofed packets detected\n", ssvpc);
-}
-#else
-static void ixgbe_spoof_check(struct ixgbe_adapter __always_unused *adapter)
-{
+	e_warn(drv, "%d Spoofed packets detected\n", ssvpc);
 }
 
-static void
-ixgbe_check_for_bad_vf(struct ixgbe_adapter __always_unused *adapter)
-{
-}
 #endif /* CONFIG_PCI_IOV */
 
-
 /**
  * ixgbe_watchdog_subtask - check and bring link up
  * @adapter: pointer to the device adapter structure
@@ -7683,9 +8956,10 @@ static void ixgbe_watchdog_subtask(struct ixgbe_adapter *adapter)
 		ixgbe_watchdog_link_is_up(adapter);
 	else
 		ixgbe_watchdog_link_is_down(adapter);
-
-	ixgbe_check_for_bad_vf(adapter);
+#ifdef CONFIG_PCI_IOV
 	ixgbe_spoof_check(adapter);
+	ixgbe_check_for_bad_vf(adapter);
+#endif /* CONFIG_PCI_IOV */
 	ixgbe_update_stats(adapter);
 
 	ixgbe_watchdog_flush_tx(adapter);
@@ -7707,7 +8981,7 @@ static void ixgbe_sfp_detection_subtask(struct ixgbe_adapter *adapter)
 
 	if (adapter->sfp_poll_time &&
 	    time_after(adapter->sfp_poll_time, jiffies))
-		return; /* If not yet time to poll for SFP */
+		return;	/* If not yet time to poll for SFP */
 
 	/* someone else is in init, wait until next service event */
 	if (test_and_set_bit(__IXGBE_IN_SFP_INIT, &adapter->state))
@@ -7755,12 +9029,13 @@ static void ixgbe_sfp_detection_subtask(struct ixgbe_adapter *adapter)
 	clear_bit(__IXGBE_IN_SFP_INIT, &adapter->state);
 
 	if ((err == IXGBE_ERR_SFP_NOT_SUPPORTED) &&
-	    (adapter->netdev->reg_state == NETREG_REGISTERED)) {
+	    adapter->netdev_registered) {
 		e_dev_err("failed to initialize because an unsupported "
 			  "SFP+ module type was detected.\n");
 		e_dev_err("Reload the driver after installing a "
 			  "supported module.\n");
 		unregister_netdev(adapter->netdev);
+		adapter->netdev_registered = false;
 	}
 }
 
@@ -7772,7 +9047,7 @@ static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 cap_speed;
-	u32 speed;
+	u32 speed = 0;
 	bool autoneg = false;
 
 	if (!(adapter->flags & IXGBE_FLAG_NEED_LINK_CONFIG))
@@ -7786,12 +9061,15 @@ static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter)
 
 	hw->mac.ops.get_link_capabilities(hw, &cap_speed, &autoneg);
 
-	/* advertise highest capable link speed */
-	if (!autoneg && (cap_speed & IXGBE_LINK_SPEED_10GB_FULL))
-		speed = IXGBE_LINK_SPEED_10GB_FULL;
-	else
-		speed = cap_speed & (IXGBE_LINK_SPEED_10GB_FULL |
-				     IXGBE_LINK_SPEED_1GB_FULL);
+	/* Advertise highest capable link speed */
+	if (cap_speed & IXGBE_LINK_SPEED_10GB_FULL) {
+		if (!autoneg)
+			speed = IXGBE_LINK_SPEED_10GB_FULL;
+		else
+			speed = cap_speed;
+	} else if (cap_speed == IXGBE_LINK_SPEED_1GB_FULL) {
+		speed = IXGBE_LINK_SPEED_1GB_FULL;
+	}
 
 	if (hw->mac.ops.setup_link)
 		hw->mac.ops.setup_link(hw, speed, true);
@@ -7803,7 +9081,7 @@ static void ixgbe_sfp_link_config_subtask(struct ixgbe_adapter *adapter)
 
 /**
  * ixgbe_service_timer - Timer Call-back
- * @t: pointer to timer_list structure
+ * @t: pointer to timer_list
  **/
 static void ixgbe_service_timer(struct timer_list *t)
 {
@@ -7824,21 +9102,14 @@ static void ixgbe_service_timer(struct timer_list *t)
 
 static void ixgbe_phy_interrupt_subtask(struct ixgbe_adapter *adapter)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
 	u32 status;
 
 	if (!(adapter->flags2 & IXGBE_FLAG2_PHY_INTERRUPT))
 		return;
-
 	adapter->flags2 &= ~IXGBE_FLAG2_PHY_INTERRUPT;
-
-	if (!hw->phy.ops.handle_lasi)
-		return;
-
-	status = hw->phy.ops.handle_lasi(&adapter->hw);
+	status = ixgbe_handle_lasi(&adapter->hw);
 	if (status != IXGBE_ERR_OVERTEMP)
 		return;
-
 	e_crit(drv, "%s\n", ixgbe_overheat_msg);
 }
 
@@ -7848,7 +9119,7 @@ static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter)
 		return;
 
 	rtnl_lock();
-	/* If we're already down, removing or resetting, just bail */
+	/* If we're already down or resetting, just bail */
 	if (test_bit(__IXGBE_DOWN, &adapter->state) ||
 	    test_bit(__IXGBE_REMOVING, &adapter->state) ||
 	    test_bit(__IXGBE_RESETTING, &adapter->state)) {
@@ -7856,7 +9127,6 @@ static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter)
 		return;
 	}
 
-	ixgbe_dump(adapter);
 	netdev_err(adapter->netdev, "Reset adapter\n");
 	adapter->tx_timeout_count++;
 
@@ -7869,19 +9139,10 @@ static void ixgbe_reset_subtask(struct ixgbe_adapter *adapter)
  * @adapter: the adapter private structure
  *
  * Check firmware errors in register FWSM
- */
+ **/
 static bool ixgbe_check_fw_error(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u32 fwsm;
-
-	/* read fwsm.ext_err_ind register and log errors */
-	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));
-
-	if (fwsm & IXGBE_FWSM_EXT_ERR_IND_MASK ||
-	    !(fwsm & IXGBE_FWSM_FW_VAL_BIT))
-		e_dev_warn("Warning firmware error detected FWSM: 0x%08X\n",
-			   fwsm);
 
 	if (hw->mac.ops.fw_recovery_mode && hw->mac.ops.fw_recovery_mode(hw)) {
 		e_dev_err("Firmware recovery mode detected. Limiting functionality. Refer to the Intel(R) Ethernet Adapters and Devices User Guide for details on firmware recovery mode.\n");
@@ -7900,7 +9161,7 @@ static void ixgbe_service_task(struct work_struct *work)
 	struct ixgbe_adapter *adapter = container_of(work,
 						     struct ixgbe_adapter,
 						     service_task);
-	if (ixgbe_removed(adapter->hw.hw_addr)) {
+	if (IXGBE_REMOVED(adapter->hw.hw_addr)) {
 		if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
 			rtnl_lock();
 			ixgbe_down(adapter);
@@ -7909,36 +9170,54 @@ static void ixgbe_service_task(struct work_struct *work)
 		ixgbe_service_event_complete(adapter);
 		return;
 	}
+
 	if (ixgbe_check_fw_error(adapter)) {
-		if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		if (!test_bit(__IXGBE_DOWN, &adapter->state)) {
 			unregister_netdev(adapter->netdev);
+			adapter->netdev_registered = false;
+		}
 		ixgbe_service_event_complete(adapter);
 		return;
 	}
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+	if (adapter->flags2 & IXGBE_FLAG2_UDP_TUN_REREG_NEEDED) {
+		rtnl_lock();
+		adapter->flags2 &= ~IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+		udp_tunnel_get_rx_info(adapter->netdev);
+#else
+		vxlan_get_rx_port(adapter->netdev);
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
+		rtnl_unlock();
+	}
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
 	ixgbe_reset_subtask(adapter);
 	ixgbe_phy_interrupt_subtask(adapter);
 	ixgbe_sfp_detection_subtask(adapter);
 	ixgbe_sfp_link_config_subtask(adapter);
 	ixgbe_check_overtemp_subtask(adapter);
 	ixgbe_watchdog_subtask(adapter);
+#ifdef HAVE_TX_MQ
 	ixgbe_fdir_reinit_subtask(adapter);
+#endif
 	ixgbe_check_hang_subtask(adapter);
-
+#ifdef HAVE_PTP_1588_CLOCK
 	if (test_bit(__IXGBE_PTP_RUNNING, &adapter->state)) {
 		ixgbe_ptp_overflow_check(adapter);
-		if (adapter->flags & IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER)
+		if (unlikely(adapter->flags & IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER))
 			ixgbe_ptp_rx_hang(adapter);
 		ixgbe_ptp_tx_hang(adapter);
 	}
+#endif /* HAVE_PTP_1588_CLOCK */
 
 	ixgbe_service_event_complete(adapter);
 }
 
 static int ixgbe_tso(struct ixgbe_ring *tx_ring,
 		     struct ixgbe_tx_buffer *first,
-		     u8 *hdr_len,
-		     struct ixgbe_ipsec_tx_data *itd)
+		     u8 *hdr_len)
 {
+#ifdef NETIF_F_TSO
 	u32 vlan_macip_lens, type_tucmd, mss_l4len_idx;
 	struct sk_buff *skb = first->skb;
 	union {
@@ -7948,11 +9227,9 @@ static int ixgbe_tso(struct ixgbe_ring *tx_ring,
 	} ip;
 	union {
 		struct tcphdr *tcp;
-		struct udphdr *udp;
 		unsigned char *hdr;
 	} l4;
 	u32 paylen, l4_offset;
-	u32 fceof_saidx = 0;
 	int err;
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL)
@@ -7965,29 +9242,23 @@ static int ixgbe_tso(struct ixgbe_ring *tx_ring,
 	if (err < 0)
 		return err;
 
-	if (eth_p_mpls(first->protocol))
-		ip.hdr = skb_inner_network_header(skb);
-	else
-		ip.hdr = skb_network_header(skb);
+	ip.hdr = skb_network_header(skb);
 	l4.hdr = skb_checksum_start(skb);
 
 	/* ADV DTYP TUCMD MKRLOC/ISCSIHEDLEN */
-	type_tucmd = (skb_shinfo(skb)->gso_type & SKB_GSO_UDP_L4) ?
-		      IXGBE_ADVTXD_TUCMD_L4T_UDP : IXGBE_ADVTXD_TUCMD_L4T_TCP;
+	type_tucmd = IXGBE_ADVTXD_TUCMD_L4T_TCP;
 
 	/* initialize outer IP header fields */
 	if (ip.v4->version == 4) {
 		unsigned char *csum_start = skb_checksum_start(skb);
 		unsigned char *trans_start = ip.hdr + (ip.v4->ihl * 4);
-		int len = csum_start - trans_start;
 
 		/* IP header will have to cancel out any data that
-		 * is not a part of the outer IP header, so set to
-		 * a reverse csum if needed, else init check to 0.
+		 * is not a part of the outer IP header
 		 */
-		ip.v4->check = (skb_shinfo(skb)->gso_type & SKB_GSO_PARTIAL) ?
-					   csum_fold(csum_partial(trans_start,
-								  len, 0)) : 0;
+		ip.v4->check = csum_fold(csum_partial(trans_start,
+						      csum_start - trans_start,
+						      0));
 		type_tucmd |= IXGBE_ADVTXD_TUCMD_IPV4;
 
 		ip.v4->tot_len = 0;
@@ -8003,20 +9274,12 @@ static int ixgbe_tso(struct ixgbe_ring *tx_ring,
 	/* determine offset of inner transport header */
 	l4_offset = l4.hdr - skb->data;
 
+	/* compute length of segmentation header */
+	*hdr_len = (l4.tcp->doff * 4) + l4_offset;
+
 	/* remove payload length from inner checksum */
 	paylen = skb->len - l4_offset;
-
-	if (type_tucmd & IXGBE_ADVTXD_TUCMD_L4T_TCP) {
-		/* compute length of segmentation header */
-		*hdr_len = (l4.tcp->doff * 4) + l4_offset;
-		csum_replace_by_diff(&l4.tcp->check,
-				     (__force __wsum)htonl(paylen));
-	} else {
-		/* compute length of segmentation header */
-		*hdr_len = sizeof(*l4.udp) + l4_offset;
-		csum_replace_by_diff(&l4.udp->check,
-				     (__force __wsum)htonl(paylen));
-	}
+	csum_replace_by_diff(&l4.tcp->check, htonl(paylen));
 
 	/* update gso size and bytecount with header size */
 	first->gso_segs = skb_shinfo(skb)->gso_segs;
@@ -8026,18 +9289,18 @@ static int ixgbe_tso(struct ixgbe_ring *tx_ring,
 	mss_l4len_idx = (*hdr_len - l4_offset) << IXGBE_ADVTXD_L4LEN_SHIFT;
 	mss_l4len_idx |= skb_shinfo(skb)->gso_size << IXGBE_ADVTXD_MSS_SHIFT;
 
-	fceof_saidx |= itd->sa_idx;
-	type_tucmd |= itd->flags | itd->trailer_len;
-
 	/* vlan_macip_lens: HEADLEN, MACLEN, VLAN tag */
 	vlan_macip_lens = l4.hdr - ip.hdr;
 	vlan_macip_lens |= (ip.hdr - skb->data) << IXGBE_ADVTXD_MACLEN_SHIFT;
 	vlan_macip_lens |= first->tx_flags & IXGBE_TX_FLAGS_VLAN_MASK;
 
-	ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fceof_saidx, type_tucmd,
+	ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0, type_tucmd,
 			  mss_l4len_idx);
 
 	return 1;
+#else
+	return 0;
+#endif /* NETIF_F_TSO */
 }
 
 static inline bool ixgbe_ipv6_csum_is_sctp(struct sk_buff *skb)
@@ -8050,12 +9313,10 @@ static inline bool ixgbe_ipv6_csum_is_sctp(struct sk_buff *skb)
 }
 
 static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring,
-			  struct ixgbe_tx_buffer *first,
-			  struct ixgbe_ipsec_tx_data *itd)
+			  struct ixgbe_tx_buffer *first)
 {
 	struct sk_buff *skb = first->skb;
 	u32 vlan_macip_lens = 0;
-	u32 fceof_saidx = 0;
 	u32 type_tucmd = 0;
 
 	if (skb->ip_summed != CHECKSUM_PARTIAL) {
@@ -8069,7 +9330,7 @@ static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring,
 	switch (skb->csum_offset) {
 	case offsetof(struct tcphdr, check):
 		type_tucmd = IXGBE_ADVTXD_TUCMD_L4T_TCP;
-		fallthrough;
+		/* fall through */
 	case offsetof(struct udphdr, check):
 		break;
 	case offsetof(struct sctphdr, checksum):
@@ -8081,7 +9342,7 @@ static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring,
 			type_tucmd = IXGBE_ADVTXD_TUCMD_L4T_SCTP;
 			break;
 		}
-		fallthrough;
+		/* fall through */
 	default:
 		skb_checksum_help(skb);
 		goto csum_failed;
@@ -8096,10 +9357,7 @@ static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring,
 	vlan_macip_lens |= skb_network_offset(skb) << IXGBE_ADVTXD_MACLEN_SHIFT;
 	vlan_macip_lens |= first->tx_flags & IXGBE_TX_FLAGS_VLAN_MASK;
 
-	fceof_saidx |= itd->sa_idx;
-	type_tucmd |= itd->flags | itd->trailer_len;
-
-	ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, fceof_saidx, type_tucmd, 0);
+	ixgbe_tx_ctxtdesc(tx_ring, vlan_macip_lens, 0, type_tucmd, 0);
 }
 
 #define IXGBE_SET_FLAG(_input, _flag, _result) \
@@ -8107,7 +9365,7 @@ static void ixgbe_tx_csum(struct ixgbe_ring *tx_ring,
 	 ((u32)(_input & _flag) * (_result / _flag)) : \
 	 ((u32)(_input & _flag) / (_flag / _result)))
 
-static u32 ixgbe_tx_cmd_type(struct sk_buff *skb, u32 tx_flags)
+static u32 ixgbe_tx_cmd_type(u32 tx_flags)
 {
 	/* set type for advanced descriptor with frame checksum insertion */
 	u32 cmd_type = IXGBE_ADVTXD_DTYP_DATA |
@@ -8126,9 +9384,6 @@ static u32 ixgbe_tx_cmd_type(struct sk_buff *skb, u32 tx_flags)
 	cmd_type |= IXGBE_SET_FLAG(tx_flags, IXGBE_TX_FLAGS_TSTAMP,
 				   IXGBE_ADVTXD_MAC_TSTAMP);
 
-	/* insert frame checksum */
-	cmd_type ^= IXGBE_SET_FLAG(skb->no_fcs, 1, IXGBE_ADVTXD_DCMD_IFCS);
-
 	return cmd_type;
 }
 
@@ -8142,16 +9397,11 @@ static void ixgbe_tx_olinfo_status(union ixgbe_adv_tx_desc *tx_desc,
 					IXGBE_TX_FLAGS_CSUM,
 					IXGBE_ADVTXD_POPTS_TXSM);
 
-	/* enable IPv4 checksum for TSO */
+	/* enble IPv4 checksum for TSO */
 	olinfo_status |= IXGBE_SET_FLAG(tx_flags,
 					IXGBE_TX_FLAGS_IPV4,
 					IXGBE_ADVTXD_POPTS_IXSM);
 
-	/* enable IPsec */
-	olinfo_status |= IXGBE_SET_FLAG(tx_flags,
-					IXGBE_TX_FLAGS_IPSEC,
-					IXGBE_ADVTXD_POPTS_IPSEC);
-
 	/*
 	 * Check Context must be set if Tx switch is enabled, which it
 	 * always is for case where virtual functions are running
@@ -8204,7 +9454,7 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 	dma_addr_t dma;
 	unsigned int data_len, size;
 	u32 tx_flags = first->tx_flags;
-	u32 cmd_type = ixgbe_tx_cmd_type(skb, tx_flags);
+	u32 cmd_type = ixgbe_tx_cmd_type(tx_flags);
 	u16 i = tx_ring->next_to_use;
 
 	tx_desc = IXGBE_TX_DESC(tx_ring, i);
@@ -8214,7 +9464,7 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 	size = skb_headlen(skb);
 	data_len = skb->data_len;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	if (tx_flags & IXGBE_TX_FLAGS_FCOE) {
 		if (data_len < sizeof(struct fcoe_crc_eof)) {
 			size -= sizeof(struct fcoe_crc_eof) - data_len;
@@ -8223,8 +9473,8 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 			data_len -= sizeof(struct fcoe_crc_eof);
 		}
 	}
+#endif /* CONFIG_FCOE */
 
-#endif
 	dma = dma_map_single(tx_ring->dev, skb->data, size, DMA_TO_DEVICE);
 
 	tx_buffer = first;
@@ -8270,7 +9520,7 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 		}
 		tx_desc->read.olinfo_status = 0;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		size = min_t(unsigned int, data_len, skb_frag_size(frag));
 #else
 		size = skb_frag_size(frag);
@@ -8292,8 +9542,9 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 	/* set the timestamp */
 	first->time_stamp = jiffies;
 
-	skb_tx_timestamp(skb);
-
+#ifndef HAVE_TRANS_START_IN_QUEUE
+	netdev_ring(tx_ring)->trans_start = first->time_stamp;
+#endif
 	/*
 	 * Force memory writes to complete before letting h/w know there
 	 * are new descriptors to fetch.  (Only applicable for weak-ordered
@@ -8315,8 +9566,23 @@ static int ixgbe_tx_map(struct ixgbe_ring *tx_ring,
 
 	ixgbe_maybe_stop_tx(tx_ring, DESC_NEEDED);
 
+	skb_tx_timestamp(skb);
+
 	if (netif_xmit_stopped(txring_txq(tx_ring)) || !netdev_xmit_more()) {
 		writel(i, tx_ring->tail);
+#ifndef SPIN_UNLOCK_IMPLIES_MMIOWB
+
+		/* The following mmiowb() is required on certain
+		 * architechtures (IA64/Altix in particular) in order to
+		 * synchronize the I/O calls with respect to a spin lock. This
+		 * is because the wmb() on those architectures does not
+		 * guarantee anything for posted I/O writes.
+		 *
+		 * Note that the associated spin_unlock() is not within the
+		 * driver code, but in the networking core stack.
+		 */
+		mmiowb();
+#endif /* SPIN_UNLOCK_IMPLIES_MMIOWB */
 	}
 
 	return 0;
@@ -8359,8 +9625,8 @@ static void ixgbe_atr(struct ixgbe_ring *ring,
 		struct ipv6hdr *ipv6;
 	} hdr;
 	struct tcphdr *th;
-	unsigned int hlen;
 	struct sk_buff *skb;
+	unsigned int hlen;
 	__be16 vlan_id;
 	int l4_proto;
 
@@ -8375,15 +9641,18 @@ static void ixgbe_atr(struct ixgbe_ring *ring,
 	ring->atr_count++;
 
 	/* currently only IPv4/IPv6 with TCP is supported */
-	if ((first->protocol != htons(ETH_P_IP)) &&
-	    (first->protocol != htons(ETH_P_IPV6)))
+	if (first->protocol != htons(ETH_P_IP) &&
+	    first->protocol != htons(ETH_P_IPV6))
 		return;
 
 	/* snag network header to get L4 type and address */
 	skb = first->skb;
 	hdr.network = skb_network_header(skb);
+
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
 	if (unlikely(hdr.network <= skb->data))
 		return;
+
 	if (skb->encapsulation &&
 	    first->protocol == htons(ETH_P_IP) &&
 	    hdr.ipv4->protocol == IPPROTO_UDP) {
@@ -8393,15 +9662,18 @@ static void ixgbe_atr(struct ixgbe_ring *ring,
 			     VXLAN_HEADROOM))
 			return;
 
-		/* verify the port is recognized as VXLAN */
+		/* verify the port is recognized as VXLAN or GENEVE*/
 		if (adapter->vxlan_port &&
 		    udp_hdr(skb)->dest == adapter->vxlan_port)
 			hdr.network = skb_inner_network_header(skb);
 
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
 		if (adapter->geneve_port &&
 		    udp_hdr(skb)->dest == adapter->geneve_port)
 			hdr.network = skb_inner_network_header(skb);
+#endif
 	}
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
 
 	/* Make sure we have at least [minimum IPv4 header + TCP]
 	 * or [IPv6 header] bytes
@@ -8486,47 +9758,62 @@ static void ixgbe_atr(struct ixgbe_ring *ring,
 		break;
 	}
 
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
 	if (hdr.network != skb_network_header(skb))
 		input.formatted.flow_type |= IXGBE_ATR_L4TYPE_TUNNEL_MASK;
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
 
 	/* This assumes the Rx queue and Tx queue are bound to the same CPU */
 	ixgbe_fdir_add_signature_filter_82599(&q_vector->adapter->hw,
 					      input, common, ring->queue_index);
 }
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+#if IS_ENABLED(CONFIG_FCOE)
 
-#ifdef IXGBE_FCOE
+#if defined(HAVE_NDO_SELECT_QUEUE_FALLBACK_REMOVED)
 static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
 			      struct net_device *sb_dev)
+#elif defined(HAVE_NDO_SELECT_QUEUE_SB_DEV)
+static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
+			      __always_unused struct net_device *sb_dev,
+			      select_queue_fallback_t fallback)
+#elif defined(HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK)
+static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
+			      __always_unused void *accel,
+			      select_queue_fallback_t fallback)
+#elif defined(HAVE_NDO_SELECT_QUEUE_ACCEL)
+static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
+			      __always_unused void *accel)
+#else
+static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb)
+#endif /* HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK */
 {
-	struct ixgbe_adapter *adapter;
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_ring_feature *f;
 	int txq;
 
-	if (sb_dev) {
-		u8 tc = netdev_get_prio_tc_map(dev, skb->priority);
-		struct net_device *vdev = sb_dev;
-
-		txq = vdev->tc_to_txq[tc].offset;
-		txq += reciprocal_scale(skb_get_hash(skb),
-					vdev->tc_to_txq[tc].count);
-
-		return txq;
-	}
-
 	/*
 	 * only execute the code below if protocol is FCoE
 	 * or FIP and we have FCoE enabled on the adapter
 	 */
 	switch (vlan_get_protocol(skb)) {
-	case htons(ETH_P_FCOE):
-	case htons(ETH_P_FIP):
+	case __constant_htons(ETH_P_FCOE):
+	case __constant_htons(ETH_P_FIP):
 		adapter = netdev_priv(dev);
 
-		if (!sb_dev && (adapter->flags & IXGBE_FLAG_FCOE_ENABLED))
+		if (adapter->flags & IXGBE_FLAG_FCOE_ENABLED)
 			break;
-		fallthrough;
+		/* fall through */
 	default:
+#if defined(HAVE_NDO_SELECT_QUEUE_FALLBACK_REMOVED)
 		return netdev_pick_tx(dev, skb, sb_dev);
+#elif defined(HAVE_NDO_SELECT_QUEUE_SB_DEV)
+		return fallback(dev, skb, sb_dev);
+#elif defined(HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK)
+		return fallback(dev, skb);
+#else
+		return __netdev_pick_tx(dev, skb);
+#endif
 	}
 
 	f = &adapter->ring_feature[RING_F_FCOE];
@@ -8539,10 +9826,17 @@ static u16 ixgbe_select_queue(struct net_device *dev, struct sk_buff *skb,
 
 	return txq + f->offset;
 }
+#endif /* CONFIG_FCOE */
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
 
-#endif
+#ifdef HAVE_XDP_SUPPORT
+#ifdef HAVE_XDP_FRAME_STRUCT
 int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
 			struct xdp_frame *xdpf)
+#else
+int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
+			struct xdp_buff *xdp)
+#endif
 {
 	struct ixgbe_ring *ring = adapter->xdp_ring[smp_processor_id()];
 	struct ixgbe_tx_buffer *tx_buffer;
@@ -8551,12 +9845,20 @@ int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
 	dma_addr_t dma;
 	u16 i;
 
+#ifdef HAVE_XDP_FRAME_STRUCT
 	len = xdpf->len;
+#else
+	len = xdp->data_end - xdp->data;
+#endif
 
 	if (unlikely(!ixgbe_desc_unused(ring)))
 		return IXGBE_XDP_CONSUMED;
 
+#ifdef HAVE_XDP_FRAME_STRUCT
 	dma = dma_map_single(ring->dev, xdpf->data, len, DMA_TO_DEVICE);
+#else
+	dma = dma_map_single(ring->dev, xdp->data, len, DMA_TO_DEVICE);
+#endif
 	if (dma_mapping_error(ring->dev, dma))
 		return IXGBE_XDP_CONSUMED;
 
@@ -8571,7 +9873,11 @@ int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
 
 	dma_unmap_len_set(tx_buffer, len, len);
 	dma_unmap_addr_set(tx_buffer, dma, dma);
+#ifdef HAVE_XDP_FRAME_STRUCT
 	tx_buffer->xdpf = xdpf;
+#else
+	tx_buffer->data = xdp->data;
+#endif
 
 	tx_desc->read.buffer_addr = cpu_to_le64(dma);
 
@@ -8598,45 +9904,201 @@ int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
 	return IXGBE_XDP_TX;
 }
 
-netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
-			  struct ixgbe_adapter *adapter,
-			  struct ixgbe_ring *tx_ring)
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+static void ixgbe_disable_txr_hw(struct ixgbe_adapter *adapter,
+				 struct ixgbe_ring *tx_ring)
 {
-	struct ixgbe_tx_buffer *first;
-	int tso;
-	u32 tx_flags = 0;
-	unsigned short f;
-	u16 count = TXD_USE_COUNT(skb_headlen(skb));
-	struct ixgbe_ipsec_tx_data ipsec_tx = { 0 };
-	__be16 protocol = skb->protocol;
-	u8 hdr_len = 0;
+	unsigned long wait_delay, delay_interval;
+	struct ixgbe_hw *hw = &adapter->hw;
+	u8 reg_idx = tx_ring->reg_idx;
+	int wait_loop;
+	u32 txdctl;
 
-	/*
-	 * need: 1 descriptor per page * PAGE_SIZE/IXGBE_MAX_DATA_PER_TXD,
-	 *       + 1 desc for skb_headlen/IXGBE_MAX_DATA_PER_TXD,
-	 *       + 2 desc gap to keep tail from touching head,
-	 *       + 1 desc for context descriptor,
-	 * otherwise try next time
-	 */
-	for (f = 0; f < skb_shinfo(skb)->nr_frags; f++)
-		count += TXD_USE_COUNT(skb_frag_size(
-						&skb_shinfo(skb)->frags[f]));
+	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), IXGBE_TXDCTL_SWFLSH);
 
-	if (ixgbe_maybe_stop_tx(tx_ring, count + 3)) {
-		tx_ring->tx_stats.tx_busy++;
-		return NETDEV_TX_BUSY;
-	}
+	/* delay mechanism from ixgbe_disable_tx */
+	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
 
-	/* record the location of the first descriptor for this packet */
-	first = &tx_ring->tx_buffer_info[tx_ring->next_to_use];
-	first->skb = skb;
-	first->bytecount = skb->len;
-	first->gso_segs = 1;
+	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+	wait_delay = delay_interval;
 
-	/* if we have a HW VLAN tag being added default to the HW one */
-	if (skb_vlan_tag_present(skb)) {
-		tx_flags |= skb_vlan_tag_get(skb) << IXGBE_TX_FLAGS_VLAN_SHIFT;
-		tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
+	while (wait_loop--) {
+		usleep_range(wait_delay, wait_delay + 10);
+		wait_delay += delay_interval * 2;
+		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
+
+		if (!(txdctl & IXGBE_TXDCTL_ENABLE))
+			return;
+	}
+
+	e_err(drv, "TXDCTL.ENABLE not cleared within the polling period\n");
+}
+
+static void ixgbe_disable_txr(struct ixgbe_adapter *adapter,
+			      struct ixgbe_ring *tx_ring)
+{
+	set_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+	ixgbe_disable_txr_hw(adapter, tx_ring);
+}
+
+static void ixgbe_disable_rxr_hw(struct ixgbe_adapter *adapter,
+				 struct ixgbe_ring *rx_ring)
+{
+	unsigned long wait_delay, delay_interval;
+	struct ixgbe_hw *hw = &adapter->hw;
+	u8 reg_idx = rx_ring->reg_idx;
+	int wait_loop;
+	u32 rxdctl;
+
+	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
+	rxdctl |= IXGBE_RXDCTL_SWFLSH;
+
+	/* write value back with RXDCTL.ENABLE bit cleared */
+	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
+
+	/* RXDCTL.EN may not change on 82598 if link is down, so skip it */
+	if (hw->mac.type == ixgbe_mac_82598EB &&
+	    !(IXGBE_READ_REG(hw, IXGBE_LINKS) & IXGBE_LINKS_UP))
+		return;
+
+	/* delay mechanism from ixgbe_disable_rx */
+	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
+
+	wait_loop = IXGBE_MAX_RX_DESC_POLL;
+	wait_delay = delay_interval;
+
+	while (wait_loop--) {
+		usleep_range(wait_delay, wait_delay + 10);
+		wait_delay += delay_interval * 2;
+		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
+
+		if (!(rxdctl & IXGBE_RXDCTL_ENABLE))
+			return;
+	}
+
+	e_err(drv, "RXDCTL.ENABLE not cleared within the polling period\n");
+}
+
+static void ixgbe_reset_txr_stats(struct ixgbe_ring *tx_ring)
+{
+	memset(&tx_ring->stats, 0, sizeof(tx_ring->stats));
+	memset(&tx_ring->tx_stats, 0, sizeof(tx_ring->tx_stats));
+}
+
+static void ixgbe_reset_rxr_stats(struct ixgbe_ring *rx_ring)
+{
+	memset(&rx_ring->stats, 0, sizeof(rx_ring->stats));
+	memset(&rx_ring->rx_stats, 0, sizeof(rx_ring->rx_stats));
+}
+
+/**
+ * ixgbe_txrx_ring_disable - Disable Rx/Tx/XDP Tx rings
+ * @adapter: adapter structure
+ * @ring: ring index
+ *
+ * This function disables a certain Rx/Tx/XDP Tx ring. The function
+ * assumes that the netdev is running.
+ **/
+void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring)
+{
+	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+
+	rx_ring = adapter->rx_ring[ring];
+	tx_ring = adapter->tx_ring[ring];
+	xdp_ring = adapter->xdp_ring[ring];
+
+	ixgbe_disable_txr(adapter, tx_ring);
+	if (xdp_ring)
+		ixgbe_disable_txr(adapter, xdp_ring);
+	ixgbe_disable_rxr_hw(adapter, rx_ring);
+
+	if (xdp_ring)
+		synchronize_rcu();
+
+	/* Rx/Tx/XDP Tx share the same napi context. */
+	napi_disable(&rx_ring->q_vector->napi);
+
+	ixgbe_clean_tx_ring(tx_ring);
+	if (xdp_ring)
+		ixgbe_clean_tx_ring(xdp_ring);
+	ixgbe_clean_rx_ring(rx_ring);
+
+	ixgbe_reset_txr_stats(tx_ring);
+	if (xdp_ring)
+		ixgbe_reset_txr_stats(xdp_ring);
+	ixgbe_reset_rxr_stats(rx_ring);
+}
+
+/**
+ * ixgbe_txrx_ring_enable - Enable Rx/Tx/XDP Tx rings
+ * @adapter: adapter structure
+ * @ring: ring index
+ *
+ * This function enables a certain Rx/Tx/XDP Tx ring. The function
+ * assumes that the netdev is running.
+ **/
+void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring)
+{
+	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+
+	rx_ring = adapter->rx_ring[ring];
+	tx_ring = adapter->tx_ring[ring];
+	xdp_ring = adapter->xdp_ring[ring];
+
+	/* Rx/Tx/XDP Tx share the same napi context. */
+	napi_enable(&rx_ring->q_vector->napi);
+
+	ixgbe_configure_tx_ring(adapter, tx_ring);
+	if (xdp_ring)
+		ixgbe_configure_tx_ring(adapter, xdp_ring);
+	ixgbe_configure_rx_ring(adapter, rx_ring);
+
+	clear_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
+	if (xdp_ring)
+		clear_bit(__IXGBE_TX_DISABLED, &xdp_ring->state);
+}
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
+#endif /* HAVE_XDP_SUPPORT */
+
+netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
+				  struct ixgbe_adapter __maybe_unused *adapter,
+				  struct ixgbe_ring *tx_ring)
+{
+	struct ixgbe_tx_buffer *first;
+	int tso;
+	u32 tx_flags = 0;
+	unsigned short f;
+	u16 count = TXD_USE_COUNT(skb_headlen(skb));
+	__be16 protocol = skb->protocol;
+	u8 hdr_len = 0;
+
+	/*
+	 * need: 1 descriptor per page * PAGE_SIZE/IXGBE_MAX_DATA_PER_TXD,
+	 *       + 1 desc for skb_headlen/IXGBE_MAX_DATA_PER_TXD,
+	 *       + 2 desc gap to keep tail from touching head,
+	 *       + 1 desc for context descriptor,
+	 * otherwise try next time
+	 */
+	for (f = 0; f < skb_shinfo(skb)->nr_frags; f++)
+		count += TXD_USE_COUNT(skb_frag_size(&skb_shinfo(skb)->
+						     frags[f]));
+
+	if (ixgbe_maybe_stop_tx(tx_ring, count + 3)) {
+		tx_ring->tx_stats.tx_busy++;
+		return NETDEV_TX_BUSY;
+	}
+
+	/* record the location of the first descriptor for this packet */
+	first = &tx_ring->tx_buffer_info[tx_ring->next_to_use];
+	first->skb = skb;
+	first->bytecount = skb->len;
+	first->gso_segs = 1;
+
+	/* if we have a HW VLAN tag being added default to the HW one */
+	if (skb_vlan_tag_present(skb)) {
+		tx_flags |= skb_vlan_tag_get(skb) << IXGBE_TX_FLAGS_VLAN_SHIFT;
+		tx_flags |= IXGBE_TX_FLAGS_HW_VLAN;
 	/* else if it is a SW VLAN check the next protocol and store the tag */
 	} else if (protocol == htons(ETH_P_8021Q)) {
 		struct vlan_hdr *vhdr, _vhdr;
@@ -8644,18 +10106,26 @@ netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
 		if (!vhdr)
 			goto out_drop;
 
+		protocol = vhdr->h_vlan_encapsulated_proto;
 		tx_flags |= ntohs(vhdr->h_vlan_TCI) <<
 				  IXGBE_TX_FLAGS_VLAN_SHIFT;
 		tx_flags |= IXGBE_TX_FLAGS_SW_VLAN;
 	}
-	protocol = vlan_get_protocol(skb);
 
-	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+#ifdef HAVE_PTP_1588_CLOCK
+#ifdef SKB_SHARED_TX_IS_UNION
+	if (unlikely(skb_tx(skb)->hardware) &&
 	    adapter->ptp_clock) {
-		if (adapter->tstamp_config.tx_type == HWTSTAMP_TX_ON &&
-		    !test_and_set_bit_lock(__IXGBE_PTP_TX_IN_PROGRESS,
+		if (!test_and_set_bit_lock(__IXGBE_PTP_TX_IN_PROGRESS,
 					   &adapter->state)) {
+			skb_tx(skb)->in_progress = 1;
+#else
+	if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+	    adapter->ptp_clock) {
+		if (!test_and_set_bit_lock(__IXGBE_PTP_TX_IN_PROGRESS,
+				   &adapter->state)) {
 			skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+#endif
 			tx_flags |= IXGBE_TX_FLAGS_TSTAMP;
 
 			/* schedule check for Tx timestamp */
@@ -8667,26 +10137,37 @@ netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
 		}
 	}
 
+#endif
 #ifdef CONFIG_PCI_IOV
 	/*
 	 * Use the l2switch_enable flag - would be false if the DMA
 	 * Tx switch had been disabled.
 	 */
-	if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED)
+	if (adapter->flags & IXGBE_FLAG_SRIOV_L2SWITCH_ENABLE)
 		tx_flags |= IXGBE_TX_FLAGS_CC;
 
 #endif
-	/* DCB maps skb priorities 0-7 onto 3 bit PCP of VLAN tag. */
+#ifdef HAVE_TX_MQ
 	if ((adapter->flags & IXGBE_FLAG_DCB_ENABLED) &&
 	    ((tx_flags & (IXGBE_TX_FLAGS_HW_VLAN | IXGBE_TX_FLAGS_SW_VLAN)) ||
 	     (skb->priority != TC_PRIO_CONTROL))) {
 		tx_flags &= ~IXGBE_TX_FLAGS_VLAN_PRIO_MASK;
-		tx_flags |= (skb->priority & 0x7) <<
-					IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
+#if IS_ENABLED(CONFIG_FCOE)
+		/* for FCoE with DCB, we force the priority to what
+		 * was specified by the switch */
+		if ((adapter->flags & IXGBE_FLAG_FCOE_ENABLED) &&
+		    ((protocol == htons(ETH_P_FCOE)) ||
+		     (protocol == htons(ETH_P_FIP))))
+			tx_flags |= adapter->fcoe.up <<
+				    IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
+		else
+#endif /* CONFIG_FCOE */
+			tx_flags |= skb->priority <<
+				    IXGBE_TX_FLAGS_VLAN_PRIO_SHIFT;
 		if (tx_flags & IXGBE_TX_FLAGS_SW_VLAN) {
 			struct vlan_ethhdr *vhdr;
-
-			if (skb_cow_head(skb, 0))
+			if (skb_header_cloned(skb) &&
+			    pskb_expand_head(skb, 0, 0, GFP_ATOMIC))
 				goto out_drop;
 			vhdr = (struct vlan_ethhdr *)skb->data;
 			vhdr->h_vlan_TCI = htons(tx_flags >>
@@ -8696,11 +10177,12 @@ netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
 		}
 	}
 
+#endif /* HAVE_TX_MQ */
 	/* record initial flags and protocol */
 	first->tx_flags = tx_flags;
 	first->protocol = protocol;
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	/* setup tx offload for FCoE */
 	if ((protocol == htons(ETH_P_FCOE)) &&
 	    (tx_ring->netdev->features & (NETIF_F_FSO | NETIF_F_FCOE_CRC))) {
@@ -8709,53 +10191,77 @@ netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *skb,
 			goto out_drop;
 
 		goto xmit_fcoe;
+	} else if (protocol ==  htons(ETH_P_FIP)) {
+		/* FCoE stack has a bug where it does not set the network
+		 * header offset for FIP frames sent resulting into MACLEN
+		 * being set to ZERO in the Tx context descriptor.
+		 * This will cause MDD events when trying to Tx such frames.
+		 */
+		if (!skb_network_offset(skb)) {
+			if (tx_flags & (IXGBE_TX_FLAGS_HW_VLAN |
+			    IXGBE_TX_FLAGS_SW_VLAN))
+				skb_set_network_header(skb,
+						sizeof(struct ethhdr) +
+						sizeof(struct vlan_hdr));
+			else
+				skb_set_network_header(skb,
+						sizeof(struct ethhdr));
+		}
 	}
+#endif /* CONFIG_FCOE */
 
-#endif /* IXGBE_FCOE */
-
-#ifdef CONFIG_IXGBE_IPSEC
-	if (xfrm_offload(skb) &&
-	    !ixgbe_ipsec_tx(tx_ring, first, &ipsec_tx))
-		goto out_drop;
-#endif
-	tso = ixgbe_tso(tx_ring, first, &hdr_len, &ipsec_tx);
+	tso = ixgbe_tso(tx_ring, first, &hdr_len);
 	if (tso < 0)
 		goto out_drop;
 	else if (!tso)
-		ixgbe_tx_csum(tx_ring, first, &ipsec_tx);
+		ixgbe_tx_csum(tx_ring, first);
 
 	/* add the ATR filter if ATR is on */
 	if (test_bit(__IXGBE_TX_FDIR_INIT_DONE, &tx_ring->state))
 		ixgbe_atr(tx_ring, first);
 
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 xmit_fcoe:
-#endif /* IXGBE_FCOE */
+#endif /* CONFIG_FCOE */
+#ifdef HAVE_PTP_1588_CLOCK
 	if (ixgbe_tx_map(tx_ring, first, hdr_len))
-		goto cleanup_tx_timestamp;
+		goto cleanup_tx_tstamp;
+#else
+	ixgbe_tx_map(tx_ring, first, hdr_len);
+#endif
 
 	return NETDEV_TX_OK;
 
 out_drop:
 	dev_kfree_skb_any(first->skb);
 	first->skb = NULL;
-cleanup_tx_timestamp:
+#ifdef HAVE_PTP_1588_CLOCK
+cleanup_tx_tstamp:
 	if (unlikely(tx_flags & IXGBE_TX_FLAGS_TSTAMP)) {
 		dev_kfree_skb_any(adapter->ptp_tx_skb);
 		adapter->ptp_tx_skb = NULL;
 		cancel_work_sync(&adapter->ptp_tx_work);
 		clear_bit_unlock(__IXGBE_PTP_TX_IN_PROGRESS, &adapter->state);
 	}
+#endif
 
 	return NETDEV_TX_OK;
 }
 
 static netdev_tx_t __ixgbe_xmit_frame(struct sk_buff *skb,
 				      struct net_device *netdev,
-				      struct ixgbe_ring *ring)
+				      __always_unused struct ixgbe_ring *ring)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_ring *tx_ring;
+#ifdef HAVE_TX_MQ
+	unsigned int r_idx = skb->queue_mapping;
+#endif
+
+	if (!netif_carrier_ok(netdev)) {
+		dev_kfree_skb_any(skb);
+		return NETDEV_TX_OK;
+	}
 
 	/*
 	 * The minimum packet size for olinfo paylen is 17 so pad the skb
@@ -8764,9 +10270,18 @@ static netdev_tx_t __ixgbe_xmit_frame(struct sk_buff *skb,
 	if (skb_put_padto(skb, 17))
 		return NETDEV_TX_OK;
 
-	tx_ring = ring ? ring : adapter->tx_ring[skb_get_queue_mapping(skb)];
+#ifdef HAVE_TX_MQ
+	if (r_idx >= adapter->num_tx_queues)
+		r_idx = r_idx % adapter->num_tx_queues;
+	tx_ring = adapter->tx_ring[r_idx];
+#else
+	tx_ring = adapter->tx_ring[0];
+#endif
+
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 	if (unlikely(test_bit(__IXGBE_TX_DISABLED, &tx_ring->state)))
 		return NETDEV_TX_BUSY;
+#endif
 
 	return ixgbe_xmit_frame_ring(skb, adapter, tx_ring);
 }
@@ -8801,85 +10316,24 @@ static int ixgbe_set_mac(struct net_device *netdev, void *p)
 	return 0;
 }
 
-static int
-ixgbe_mdio_read(struct net_device *netdev, int prtad, int devad, u16 addr)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw *hw = &adapter->hw;
-	u16 value;
-	int rc;
-
-	if (adapter->mii_bus) {
-		int regnum = addr;
-
-		if (devad != MDIO_DEVAD_NONE)
-			regnum |= (devad << 16) | MII_ADDR_C45;
-
-		return mdiobus_read(adapter->mii_bus, prtad, regnum);
-	}
-
-	if (prtad != hw->phy.mdio.prtad)
-		return -EINVAL;
-	rc = hw->phy.ops.read_reg(hw, addr, devad, &value);
-	if (!rc)
-		rc = value;
-	return rc;
-}
-
-static int ixgbe_mdio_write(struct net_device *netdev, int prtad, int devad,
-			    u16 addr, u16 value)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	struct ixgbe_hw *hw = &adapter->hw;
-
-	if (adapter->mii_bus) {
-		int regnum = addr;
-
-		if (devad != MDIO_DEVAD_NONE)
-			regnum |= (devad << 16) | MII_ADDR_C45;
-
-		return mdiobus_write(adapter->mii_bus, prtad, regnum, value);
-	}
-
-	if (prtad != hw->phy.mdio.prtad)
-		return -EINVAL;
-	return hw->phy.ops.write_reg(hw, addr, devad, value);
-}
-
-static int ixgbe_ioctl(struct net_device *netdev, struct ifreq *req, int cmd)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-
-	switch (cmd) {
-	case SIOCSHWTSTAMP:
-		return ixgbe_ptp_set_ts_config(adapter, req);
-	case SIOCGHWTSTAMP:
-		return ixgbe_ptp_get_ts_config(adapter, req);
-	case SIOCGMIIPHY:
-		if (!adapter->hw.phy.ops.read_reg)
-			return -EOPNOTSUPP;
-		fallthrough;
-	default:
-		return mdio_mii_ioctl(&adapter->hw.phy.mdio, if_mii(req), cmd);
-	}
-}
-
+#if defined(HAVE_NETDEV_STORAGE_ADDRESS) && defined(NETDEV_HW_ADDR_T_SAN)
 /**
  * ixgbe_add_sanmac_netdev - Add the SAN MAC address to the corresponding
- * netdev->dev_addrs
+ * dev->dev_addr_list
  * @dev: network interface device structure
  *
  * Returns non-zero on failure
  **/
 static int ixgbe_add_sanmac_netdev(struct net_device *dev)
 {
-	int err = 0;
+	int err = IXGBE_SUCCESS;
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_hw *hw = &adapter->hw;
 
 	if (is_valid_ether_addr(hw->mac.san_addr)) {
 		rtnl_lock();
-		err = dev_addr_add(dev, hw->mac.san_addr, NETDEV_HW_ADDR_T_SAN);
+		err = dev_addr_add(dev, hw->mac.san_addr,
+				   NETDEV_HW_ADDR_T_SAN);
 		rtnl_unlock();
 
 		/* update SAN MAC vmdq pool selection */
@@ -8890,14 +10344,14 @@ static int ixgbe_add_sanmac_netdev(struct net_device *dev)
 
 /**
  * ixgbe_del_sanmac_netdev - Removes the SAN MAC address to the corresponding
- * netdev->dev_addrs
+ * netdev->dev_addr_list
  * @dev: network interface device structure
  *
  * Returns non-zero on failure
  **/
 static int ixgbe_del_sanmac_netdev(struct net_device *dev)
 {
-	int err = 0;
+	int err = IXGBE_SUCCESS;
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_mac_info *mac = &adapter->hw.mac;
 
@@ -8909,69 +10363,120 @@ static int ixgbe_del_sanmac_netdev(struct net_device *dev)
 	return err;
 }
 
-static void ixgbe_get_ring_stats64(struct rtnl_link_stats64 *stats,
-				   struct ixgbe_ring *ring)
+#endif /* (HAVE_NETDEV_STORAGE_ADDRESS) && defined(NETDEV_HW_ADDR_T_SAN) */
+
+static int ixgbe_mdio_read(struct net_device *netdev, int prtad, int devad,
+			   u16 addr)
 {
-	u64 bytes, packets;
-	unsigned int start;
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+	struct ixgbe_hw *hw = &adapter->hw;
+	u16 value;
+	int rc;
 
-	if (ring) {
-		do {
-			start = u64_stats_fetch_begin_irq(&ring->syncp);
-			packets = ring->stats.packets;
-			bytes   = ring->stats.bytes;
-		} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
-		stats->tx_packets += packets;
-		stats->tx_bytes   += bytes;
-	}
+	if (prtad != hw->phy.addr)
+		return -EINVAL;
+
+	if (!hw->phy.ops.read_reg)
+		return -EOPNOTSUPP;
+
+	rc = hw->phy.ops.read_reg(hw, addr, devad, &value);
+	if (!rc)
+		rc = value;
+
+	return rc;
 }
 
-static void ixgbe_get_stats64(struct net_device *netdev,
-			      struct rtnl_link_stats64 *stats)
+static int ixgbe_mdio_write(struct net_device *netdev, int prtad, int devad,
+			    u16 addr, u16 value)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	int i;
+	struct ixgbe_hw *hw = &adapter->hw;
 
-	rcu_read_lock();
-	for (i = 0; i < adapter->num_rx_queues; i++) {
-		struct ixgbe_ring *ring = READ_ONCE(adapter->rx_ring[i]);
-		u64 bytes, packets;
-		unsigned int start;
+	if (prtad != hw->phy.addr)
+		return -EINVAL;
 
-		if (ring) {
-			do {
-				start = u64_stats_fetch_begin_irq(&ring->syncp);
-				packets = ring->stats.packets;
-				bytes   = ring->stats.bytes;
-			} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
-			stats->rx_packets += packets;
-			stats->rx_bytes   += bytes;
-		}
-	}
+	if (!hw->phy.ops.write_reg)
+		return -EOPNOTSUPP;
 
-	for (i = 0; i < adapter->num_tx_queues; i++) {
-		struct ixgbe_ring *ring = READ_ONCE(adapter->tx_ring[i]);
+	return hw->phy.ops.write_reg(hw, addr, devad, value);
+}
 
-		ixgbe_get_ring_stats64(stats, ring);
+static int ixgbe_mii_ioctl(struct net_device *netdev, struct ifreq *ifr,
+			   int cmd)
+{
+	struct mii_ioctl_data *mii = (struct mii_ioctl_data *) &ifr->ifr_data;
+	int prtad, devad, ret;
+
+	prtad = (mii->phy_id & MDIO_PHY_ID_PRTAD) >> 5;
+	devad = (mii->phy_id & MDIO_PHY_ID_DEVAD);
+
+	if (cmd == SIOCGMIIREG) {
+		ret = ixgbe_mdio_read(netdev, prtad, devad, mii->reg_num);
+		if (ret < 0)
+			return ret;
+		mii->val_out = ret;
+		return 0;
+	} else {
+		return ixgbe_mdio_write(netdev, prtad, devad, mii->reg_num,
+					mii->val_in);
 	}
-	for (i = 0; i < adapter->num_xdp_queues; i++) {
-		struct ixgbe_ring *ring = READ_ONCE(adapter->xdp_ring[i]);
+}
 
-		ixgbe_get_ring_stats64(stats, ring);
+static int ixgbe_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+#ifdef HAVE_PTP_1588_CLOCK
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+#endif
+	switch (cmd) {
+#ifdef HAVE_PTP_1588_CLOCK
+#ifdef SIOCGHWTSTAMP
+	case SIOCGHWTSTAMP:
+		return ixgbe_ptp_get_ts_config(adapter, ifr);
+#endif
+	case SIOCSHWTSTAMP:
+		return ixgbe_ptp_set_ts_config(adapter, ifr);
+#endif
+#ifdef ETHTOOL_OPS_COMPAT
+	case SIOCETHTOOL:
+		return ethtool_ioctl(ifr);
+#endif
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		return ixgbe_mii_ioctl(netdev, ifr, cmd);
+	default:
+		return -EOPNOTSUPP;
 	}
-	rcu_read_unlock();
+}
 
-	/* following stats updated by ixgbe_watchdog_task() */
-	stats->multicast	= netdev->stats.multicast;
-	stats->rx_errors	= netdev->stats.rx_errors;
-	stats->rx_length_errors	= netdev->stats.rx_length_errors;
-	stats->rx_crc_errors	= netdev->stats.rx_crc_errors;
-	stats->rx_missed_errors	= netdev->stats.rx_missed_errors;
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void ixgbe_netpoll(struct net_device *netdev)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	/* if interface is down do nothing */
+	if (test_bit(__IXGBE_DOWN, &adapter->state))
+		return;
+
+	if (adapter->flags & IXGBE_FLAG_MSIX_ENABLED) {
+		int i;
+		for (i = 0; i < adapter->num_q_vectors; i++) {
+			adapter->q_vector[i]->netpoll_rx = true;
+			ixgbe_msix_clean_rings(0, adapter->q_vector[i]);
+			adapter->q_vector[i]->netpoll_rx = false;
+		}
+	} else {
+		ixgbe_intr(0, adapter);
+	}
 }
+#endif /* CONFIG_NET_POLL_CONTROLLER */
 
-#ifdef CONFIG_IXGBE_DCB
-/**
- * ixgbe_validate_rtr - verify 802.1Qp to Rx packet buffer mapping is valid.
+/* ixgbe_validate_rtr - verify 802.1Qp to Rx packet buffer mapping is valid.
  * @adapter: pointer to ixgbe_adapter
  * @tc: number of traffic classes currently enabled
  *
@@ -8993,7 +10498,7 @@ static void ixgbe_validate_rtr(struct ixgbe_adapter *adapter, u8 tc)
 	reg = IXGBE_READ_REG(hw, IXGBE_RTRUP2TC);
 	rsave = reg;
 
-	for (i = 0; i < MAX_TRAFFIC_CLASS; i++) {
+	for (i = 0; i < IXGBE_DCB_MAX_TRAFFIC_CLASS; i++) {
 		u8 up2tc = reg >> (i * IXGBE_RTRUP2TC_UP_SHIFT);
 
 		/* If up2tc is out of bounds default to zero */
@@ -9013,14 +10518,15 @@ static void ixgbe_validate_rtr(struct ixgbe_adapter *adapter, u8 tc)
  *
  * Populate the netdev user priority to tc map
  */
-static void ixgbe_set_prio_tc_map(struct ixgbe_adapter *adapter)
+static void ixgbe_set_prio_tc_map(struct ixgbe_adapter __maybe_unused *adapter)
 {
+#ifdef HAVE_DCBNL_IEEE
 	struct net_device *dev = adapter->netdev;
 	struct ixgbe_dcb_config *dcb_cfg = &adapter->dcb_cfg;
 	struct ieee_ets *ets = adapter->ixgbe_ieee_ets;
 	u8 prio;
 
-	for (prio = 0; prio < MAX_USER_PRIORITY; prio++) {
+	for (prio = 0; prio < IXGBE_DCB_MAX_USER_PRIORITY; prio++) {
 		u8 tc = 0;
 
 		if (adapter->dcbx_cap & DCB_CAP_DCBX_VER_CEE)
@@ -9030,137 +10536,11 @@ static void ixgbe_set_prio_tc_map(struct ixgbe_adapter *adapter)
 
 		netdev_set_prio_tc_map(dev, prio, tc);
 	}
+#endif
 }
 
-#endif /* CONFIG_IXGBE_DCB */
-static int ixgbe_reassign_macvlan_pool(struct net_device *vdev,
-				       struct netdev_nested_priv *priv)
-{
-	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)priv->data;
-	struct ixgbe_fwd_adapter *accel;
-	int pool;
-
-	/* we only care about macvlans... */
-	if (!netif_is_macvlan(vdev))
-		return 0;
-
-	/* that have hardware offload enabled... */
-	accel = macvlan_accel_priv(vdev);
-	if (!accel)
-		return 0;
-
-	/* If we can relocate to a different bit do so */
-	pool = find_first_zero_bit(adapter->fwd_bitmask, adapter->num_rx_pools);
-	if (pool < adapter->num_rx_pools) {
-		set_bit(pool, adapter->fwd_bitmask);
-		accel->pool = pool;
-		return 0;
-	}
-
-	/* if we cannot find a free pool then disable the offload */
-	netdev_err(vdev, "L2FW offload disabled due to lack of queue resources\n");
-	macvlan_release_l2fw_offload(vdev);
-
-	/* unbind the queues and drop the subordinate channel config */
-	netdev_unbind_sb_channel(adapter->netdev, vdev);
-	netdev_set_sb_channel(vdev, 0);
-
-	kfree(accel);
-
-	return 0;
-}
-
-static void ixgbe_defrag_macvlan_pools(struct net_device *dev)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	struct netdev_nested_priv priv = {
-		.data = (void *)adapter,
-	};
-
-	/* flush any stale bits out of the fwd bitmask */
-	bitmap_clear(adapter->fwd_bitmask, 1, 63);
-
-	/* walk through upper devices reassigning pools */
-	netdev_walk_all_upper_dev_rcu(dev, ixgbe_reassign_macvlan_pool,
-				      &priv);
-}
-
-/**
- * ixgbe_setup_tc - configure net_device for multiple traffic classes
- *
- * @dev: net device to configure
- * @tc: number of traffic classes to enable
- */
-int ixgbe_setup_tc(struct net_device *dev, u8 tc)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	struct ixgbe_hw *hw = &adapter->hw;
-
-	/* Hardware supports up to 8 traffic classes */
-	if (tc > adapter->dcb_cfg.num_tcs.pg_tcs)
-		return -EINVAL;
-
-	if (hw->mac.type == ixgbe_mac_82598EB && tc && tc < MAX_TRAFFIC_CLASS)
-		return -EINVAL;
-
-	/* Hardware has to reinitialize queues and interrupts to
-	 * match packet buffer alignment. Unfortunately, the
-	 * hardware is not flexible enough to do this dynamically.
-	 */
-	if (netif_running(dev))
-		ixgbe_close(dev);
-	else
-		ixgbe_reset(adapter);
-
-	ixgbe_clear_interrupt_scheme(adapter);
-
-#ifdef CONFIG_IXGBE_DCB
-	if (tc) {
-		if (adapter->xdp_prog) {
-			e_warn(probe, "DCB is not supported with XDP\n");
-
-			ixgbe_init_interrupt_scheme(adapter);
-			if (netif_running(dev))
-				ixgbe_open(dev);
-			return -EINVAL;
-		}
-
-		netdev_set_num_tc(dev, tc);
-		ixgbe_set_prio_tc_map(adapter);
-
-		adapter->hw_tcs = tc;
-		adapter->flags |= IXGBE_FLAG_DCB_ENABLED;
-
-		if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
-			adapter->last_lfc_mode = adapter->hw.fc.requested_mode;
-			adapter->hw.fc.requested_mode = ixgbe_fc_none;
-		}
-	} else {
-		netdev_reset_tc(dev);
-
-		if (adapter->hw.mac.type == ixgbe_mac_82598EB)
-			adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
-
-		adapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;
-		adapter->hw_tcs = tc;
-
-		adapter->temp_dcb_cfg.pfc_mode_enable = false;
-		adapter->dcb_cfg.pfc_mode_enable = false;
-	}
-
-	ixgbe_validate_rtr(adapter, tc);
-
-#endif /* CONFIG_IXGBE_DCB */
-	ixgbe_init_interrupt_scheme(adapter);
-
-	ixgbe_defrag_macvlan_pools(dev);
-
-	if (netif_running(dev))
-		return ixgbe_open(dev);
-
-	return 0;
-}
-
+#ifdef NETIF_F_HW_TC
+#ifdef HAVE_TC_SETUP_CLSU32
 static int ixgbe_delete_clsu32(struct ixgbe_adapter *adapter,
 			       struct tc_cls_u32_offload *cls)
 {
@@ -9218,9 +10598,16 @@ static int ixgbe_delete_clsu32(struct ixgbe_adapter *adapter,
 	return err;
 }
 
+#ifdef HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+static int ixgbe_configure_clsu32_add_hnode(struct ixgbe_adapter *adapter,
+					    struct tc_cls_u32_offload *cls)
+{
+#else
 static int ixgbe_configure_clsu32_add_hnode(struct ixgbe_adapter *adapter,
+					    __be16 protocol,
 					    struct tc_cls_u32_offload *cls)
 {
+#endif
 	u32 uhtid = TC_U32_USERHTID(cls->hnode.handle);
 
 	if (uhtid >= IXGBE_MAX_LINK_HANDLE)
@@ -9249,82 +10636,56 @@ static int ixgbe_configure_clsu32_del_hnode(struct ixgbe_adapter *adapter,
 }
 
 #ifdef CONFIG_NET_CLS_ACT
-struct upper_walk_data {
-	struct ixgbe_adapter *adapter;
-	u64 action;
-	int ifindex;
-	u8 queue;
-};
-
-static int get_macvlan_queue(struct net_device *upper,
-			     struct netdev_nested_priv *priv)
-{
-	if (netif_is_macvlan(upper)) {
-		struct ixgbe_fwd_adapter *vadapter = macvlan_accel_priv(upper);
-		struct ixgbe_adapter *adapter;
-		struct upper_walk_data *data;
-		int ifindex;
-
-		data = (struct upper_walk_data *)priv->data;
-		ifindex = data->ifindex;
-		adapter = data->adapter;
-		if (vadapter && upper->ifindex == ifindex) {
-			data->queue = adapter->rx_ring[vadapter->rx_base_queue]->reg_idx;
-			data->action = data->queue;
-			return 1;
-		}
-	}
-
-	return 0;
-}
-
+#ifdef HAVE_TCF_MIRRED_REDIRECT
 static int handle_redirect_action(struct ixgbe_adapter *adapter, int ifindex,
 				  u8 *queue, u64 *action)
 {
-	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	unsigned int num_vfs = adapter->num_vfs, vf;
-	struct netdev_nested_priv priv;
-	struct upper_walk_data data;
 	struct net_device *upper;
 
 	/* redirect to a SRIOV VF */
 	for (vf = 0; vf < num_vfs; ++vf) {
 		upper = pci_get_drvdata(adapter->vfinfo[vf].vfdev);
 		if (upper->ifindex == ifindex) {
-			*queue = vf * __ALIGN_MASK(1, ~vmdq->mask);
+			if (adapter->num_rx_pools > 1)
+				*queue = vf * 2;
+			else
+				*queue = vf * adapter->num_rx_queues_per_pool;
+
 			*action = vf + 1;
 			*action <<= ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;
 			return 0;
 		}
 	}
-
-	/* redirect to a offloaded macvlan netdev */
-	data.adapter = adapter;
-	data.ifindex = ifindex;
-	data.action = 0;
-	data.queue = 0;
-	priv.data = (void *)&data;
-	if (netdev_walk_all_upper_dev_rcu(adapter->netdev,
-					  get_macvlan_queue, &priv)) {
-		*action = data.action;
-		*queue = data.queue;
-
-		return 0;
-	}
-
 	return -EINVAL;
 }
+#endif
 
 static int parse_tc_actions(struct ixgbe_adapter *adapter,
 			    struct tcf_exts *exts, u64 *action, u8 *queue)
 {
 	const struct tc_action *a;
+#if defined(HAVE_TCF_EXTS_TO_LIST)
+	LIST_HEAD(actions);
+#elif defined(HAVE_TCF_EXTS_FOR_EACH_ACTION)
 	int i;
+#endif
 
+#ifdef HAVE_TCF_EXTS_HAS_ACTION
 	if (!tcf_exts_has_actions(exts))
+#else
+	if (tc_no_actions(exts))
+#endif
 		return -EINVAL;
 
+#if defined(HAVE_TCF_EXTS_TO_LIST)
+	tcf_exts_to_list(exts, &actions);
+	list_for_each_entry(a, &actions, list) {
+#elif defined(HAVE_TCF_EXTS_FOR_EACH_ACTION)
 	tcf_exts_for_each_action(i, a, exts) {
+#else
+	tc_for_each_action(a, exts) {
+#endif
 		/* Drop action */
 		if (is_tcf_gact_shot(a)) {
 			*action = IXGBE_FDIR_DROP_QUEUE;
@@ -9332,16 +10693,28 @@ static int parse_tc_actions(struct ixgbe_adapter *adapter,
 			return 0;
 		}
 
+#ifdef HAVE_TCF_MIRRED_REDIRECT
 		/* Redirect to a VF or a offloaded macvlan */
+#ifdef HAVE_TCF_MIRRED_EGRESS_REDIRECT
 		if (is_tcf_mirred_egress_redirect(a)) {
+#else
+		if (is_tcf_mirred_redirect(a)) {
+#endif
+#ifdef HAVE_TCF_MIRRED_DEV
 			struct net_device *dev = tcf_mirred_dev(a);
 
 			if (!dev)
 				return -EINVAL;
 			return handle_redirect_action(adapter, dev->ifindex,
 						      queue, action);
-		}
+#else
+			int ifindex = tcf_mirred_ifindex(a);
 
+			return handle_redirect_action(adapter, ifindex,
+						      queue, action);
+#endif
+		}
+#endif
 		return -EINVAL;
 	}
 
@@ -9372,8 +10745,7 @@ static int ixgbe_clsu32_build_input(struct ixgbe_fdir_filter *input,
 
 		for (j = 0; field_ptr[j].val; j++) {
 			if (field_ptr[j].off == off) {
-				field_ptr[j].val(input, mask, (__force u32)val,
-						 (__force u32)m);
+				field_ptr[j].val(input, mask, val, m);
 				input->filter.formatted.flow_type |=
 					field_ptr[j].type;
 				found_entry = true;
@@ -9382,10 +10754,8 @@ static int ixgbe_clsu32_build_input(struct ixgbe_fdir_filter *input,
 		}
 		if (nexthdr) {
 			if (nexthdr->off == cls->knode.sel->keys[i].off &&
-			    nexthdr->val ==
-			    (__force u32)cls->knode.sel->keys[i].val &&
-			    nexthdr->mask ==
-			    (__force u32)cls->knode.sel->keys[i].mask)
+			    nexthdr->val == cls->knode.sel->keys[i].val &&
+			    nexthdr->mask == cls->knode.sel->keys[i].mask)
 				found_jump_field = true;
 			else
 				continue;
@@ -9407,10 +10777,17 @@ static int ixgbe_clsu32_build_input(struct ixgbe_fdir_filter *input,
 	return 0;
 }
 
+#ifdef HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
 static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 				  struct tc_cls_u32_offload *cls)
 {
 	__be16 protocol = cls->common.protocol;
+#else
+static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
+				  __be16 protocol,
+				  struct tc_cls_u32_offload *cls)
+{
+#endif
 	u32 loc = cls->knode.handle & 0xfffff;
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct ixgbe_mat_field *field_ptr;
@@ -9489,8 +10866,7 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 		for (i = 0; nexthdr[i].jump; i++) {
 			if (nexthdr[i].o != cls->knode.sel->offoff ||
 			    nexthdr[i].s != cls->knode.sel->offshift ||
-			    nexthdr[i].m !=
-			    (__force u32)cls->knode.sel->offmask)
+			    nexthdr[i].m != cls->knode.sel->offmask)
 				return err;
 
 			jump = kzalloc(sizeof(*jump), GFP_KERNEL);
@@ -9516,12 +10892,9 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 				jump->mat = nexthdr[i].jump;
 				adapter->jump_tables[link_uhtid] = jump;
 				break;
-			} else {
-				kfree(mask);
-				kfree(input);
-				kfree(jump);
 			}
 		}
+
 		return 0;
 	}
 
@@ -9571,7 +10944,8 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 
 	if (hlist_empty(&adapter->fdir_filter_list)) {
 		memcpy(&adapter->fdir_mask, mask, sizeof(*mask));
-		err = ixgbe_fdir_set_input_mask_82599(hw, mask);
+		err = ixgbe_fdir_set_input_mask_82599(hw, mask,
+						      adapter->cloud_mode);
 		if (err)
 			goto err_out_w_lock;
 	} else if (memcmp(&adapter->fdir_mask, mask, sizeof(*mask))) {
@@ -9581,11 +10955,10 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 
 	ixgbe_atr_compute_perfect_hash_82599(&input->filter, mask);
 	err = ixgbe_fdir_write_perfect_filter_82599(hw, &input->filter,
-						    input->sw_idx, queue);
-	if (err)
-		goto err_out_w_lock;
-
-	ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
+						    input->sw_idx, queue,
+						    adapter->cloud_mode);
+	if (!err)
+		ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
 	spin_unlock(&adapter->fdir_perfect_lock);
 
 	if ((uhtid != 0x800) && (adapter->jump_tables[uhtid]))
@@ -9604,9 +10977,28 @@ static int ixgbe_configure_clsu32(struct ixgbe_adapter *adapter,
 	return err;
 }
 
+#ifdef HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+#ifdef HAVE_TCF_BLOCK
 static int ixgbe_setup_tc_cls_u32(struct ixgbe_adapter *adapter,
 				  struct tc_cls_u32_offload *cls_u32)
+#else
+static int ixgbe_setup_tc_cls_u32(struct net_device *dev,
+				  struct tc_cls_u32_offload *cls_u32)
+#endif /* HAVE_TCF_BLOCK */
 {
+#ifdef HAVE_TCF_BLOCK
+#ifndef HAVE_TCF_MIRRED_DEV
+	if (cls_u32->common.chain_index)
+		return -EOPNOTSUPP;
+#endif
+#else
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+
+	if (!is_classid_clsact_ingress(cls_u32->common.classid) ||
+	    cls_u32->common.chain_index)
+		return -EOPNOTSUPP;
+#endif
+
 	switch (cls_u32->command) {
 	case TC_CLSU32_NEW_KNODE:
 	case TC_CLSU32_REPLACE_KNODE:
@@ -9620,63 +11012,221 @@ static int ixgbe_setup_tc_cls_u32(struct ixgbe_adapter *adapter,
 		return ixgbe_configure_clsu32_del_hnode(adapter, cls_u32);
 	default:
 		return -EOPNOTSUPP;
+
 	}
 }
+#endif /* HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV */
+#endif /* HAVE_TC_SETUP_CLSU32 */
 
+#ifdef HAVE_TCF_BLOCK
 static int ixgbe_setup_tc_block_cb(enum tc_setup_type type, void *type_data,
 				   void *cb_priv)
 {
 	struct ixgbe_adapter *adapter = cb_priv;
 
+#ifdef HAVE_TCF_MIRRED_DEV
 	if (!tc_cls_can_offload_and_chain0(adapter->netdev, type_data))
+#else
+	if (!tc_can_offload(adapter->netdev))
+#endif
 		return -EOPNOTSUPP;
 
 	switch (type) {
+#ifdef HAVE_TC_SETUP_CLSU32
 	case TC_SETUP_CLSU32:
 		return ixgbe_setup_tc_cls_u32(adapter, type_data);
+#endif /* HAVE_TC_SETUP_CLSU32 */
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
+static LIST_HEAD(ixgbe_block_cb_list);
+
+#endif
+#ifdef TC_MQPRIO_HW_OFFLOAD_MAX
 static int ixgbe_setup_tc_mqprio(struct net_device *dev,
 				 struct tc_mqprio_qopt *mqprio)
 {
 	mqprio->hw = TC_MQPRIO_HW_OFFLOAD_TCS;
 	return ixgbe_setup_tc(dev, mqprio->num_tc);
 }
+#endif
 
-static LIST_HEAD(ixgbe_block_cb_list);
+#ifdef HAVE_TCF_BLOCK
+#define IXGBE_SETUP_TC_DECLARE_ADAPTER
+#endif /* HAVE_TCF_BLOCK */
 
-static int __ixgbe_setup_tc(struct net_device *dev, enum tc_setup_type type,
-			    void *type_data)
+#ifdef HAVE_TC_SETUP_CLSU32
+#ifndef HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+#define IXGBE_SETUP_TC_DECLARE_ADAPTER
+#endif /* !HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV */
+#endif /* HAVE_TC_SETUP_CLSU32 */
+
+#if defined(HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV)
+static int
+__ixgbe_setup_tc(struct net_device *dev, enum tc_setup_type type,
+		 void *type_data)
+#elif defined(HAVE_NDO_SETUP_TC_CHAIN_INDEX)
+static int
+__ixgbe_setup_tc(struct net_device *dev, __always_unused u32 handle,
+		 u32 chain_index, __always_unused __be16 proto,
+		 struct tc_to_netdev *tc)
+#else
+static int
+__ixgbe_setup_tc(struct net_device *dev, __always_unused u32 handle,
+		 __always_unused __be16 proto, struct tc_to_netdev *tc)
+#endif
 {
+#ifdef IXGBE_SETUP_TC_DECLARE_ADAPTER
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+#endif
+#ifndef HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+	unsigned int type = tc->type;
+#ifdef HAVE_NDO_SETUP_TC_CHAIN_INDEX
+
+	if (chain_index)
+		return -EOPNOTSUPP;
+#endif /* HAVE_NDO_SETUP_TC_CHAIN_INDEX */
+#ifdef HAVE_TC_SETUP_CLSU32
+
+	if (TC_H_MAJ(handle) == TC_H_MAJ(TC_H_INGRESS) &&
+	    type == TC_SETUP_CLSU32) {
+
+		switch (tc->cls_u32->command) {
+		case TC_CLSU32_NEW_KNODE:
+		case TC_CLSU32_REPLACE_KNODE:
+			return ixgbe_configure_clsu32(adapter,
+							  proto, tc->cls_u32);
+		case TC_CLSU32_DELETE_KNODE:
+			return ixgbe_delete_clsu32(adapter, tc->cls_u32);
+		case TC_CLSU32_NEW_HNODE:
+		case TC_CLSU32_REPLACE_HNODE:
+			return ixgbe_configure_clsu32_add_hnode(adapter, proto,
+								tc->cls_u32);
+		case TC_CLSU32_DELETE_HNODE:
+			return ixgbe_configure_clsu32_del_hnode(adapter,
+								tc->cls_u32);
+		default:
+			return -EINVAL;
+		}
+	}
+#endif /* HAVE_TC_SETUP_CLSU32 */
+#endif /* !HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV */
 
 	switch (type) {
+#if defined(HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV)
+#if defined(HAVE_TCF_BLOCK)
 	case TC_SETUP_BLOCK:
 		return flow_block_cb_setup_simple(type_data,
 						  &ixgbe_block_cb_list,
 						  ixgbe_setup_tc_block_cb,
 						  adapter, adapter, true);
-	case TC_SETUP_QDISC_MQPRIO:
+#else
+#ifdef HAVE_TC_SETUP_CLSU32
+	case TC_SETUP_CLSU32:
+		return ixgbe_setup_tc_cls_u32(dev, type_data);
+#endif /* HAVE_TC_SETUP_CLSU32 */
+#endif /* HAVE_TCF_BLOCK */
+#endif /* HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV */
+	case TC_SETUP_QDISC_MQPRIO:
+#if defined(HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV)
 		return ixgbe_setup_tc_mqprio(dev, type_data);
+#elif defined(TC_MQPRIO_HW_OFFLOAD_MAX)
+		return ixgbe_setup_tc_mqprio(dev, tc->mqprio);
+#else
+		return ixgbe_setup_tc(dev, tc->tc);
+#endif
 	default:
 		return -EOPNOTSUPP;
 	}
 }
 
+#endif /* NETIF_F_HW_TC */
+/**
+ * ixgbe_setup_tc - routine to configure net_device for multiple traffic
+ * classes.
+ *
+ * @dev: net device to configure
+ * @tc: number of traffic classes to enable
+ */
+int ixgbe_setup_tc(struct net_device *dev, u8 tc)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	struct ixgbe_hw *hw = &adapter->hw;
+
+	/* Hardware supports up to 8 traffic classes */
+	if (tc > adapter->dcb_cfg.num_tcs.pg_tcs)
+		return -EINVAL;
+
+	if (tc && hw->mac.type == ixgbe_mac_82598EB &&
+	    tc < IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return -EINVAL;
+
+	/* Hardware has to reinitialize queues and interrupts to
+	 * match packet buffer alignment. Unfortunately, the
+	 * hardware is not flexible enough to do this dynamically.
+	 */
+	if (netif_running(dev))
+		ixgbe_close(dev);
+	else
+		ixgbe_reset(adapter);
+
+	ixgbe_clear_interrupt_scheme(adapter);
+
+	if (tc) {
+#ifdef HAVE_XDP_SUPPORT
+		if (adapter->xdp_prog) {
+			e_warn(probe, "DCB is not supported  with XDP\n");
+
+			ixgbe_init_interrupt_scheme(adapter);
+			if (netif_running(dev))
+				ixgbe_open(dev);
+			return -EINVAL;
+		}
+#endif /* IXGBE_XDP_ENABLED */
+
+		netdev_set_num_tc(dev, tc);
+		ixgbe_set_prio_tc_map(adapter);
+
+		adapter->flags |= IXGBE_FLAG_DCB_ENABLED;
+
+		if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
+			adapter->last_lfc_mode = adapter->hw.fc.requested_mode;
+			adapter->hw.fc.requested_mode = ixgbe_fc_none;
+		}
+	} else {
+		netdev_reset_tc(dev);
+
+		if (adapter->hw.mac.type == ixgbe_mac_82598EB)
+			adapter->hw.fc.requested_mode = adapter->last_lfc_mode;
+
+		adapter->flags &= ~IXGBE_FLAG_DCB_ENABLED;
+
+		adapter->temp_dcb_cfg.pfc_mode_enable = false;
+		adapter->dcb_cfg.pfc_mode_enable = false;
+	}
+
+	ixgbe_validate_rtr(adapter, tc);
+
+	ixgbe_init_interrupt_scheme(adapter);
+	if (netif_running(dev))
+		ixgbe_open(dev);
+
+	return 0;
+}
+
 #ifdef CONFIG_PCI_IOV
 void ixgbe_sriov_reinit(struct ixgbe_adapter *adapter)
 {
 	struct net_device *netdev = adapter->netdev;
 
 	rtnl_lock();
-	ixgbe_setup_tc(netdev, adapter->hw_tcs);
+	ixgbe_setup_tc(netdev, netdev_get_num_tc(netdev));
 	rtnl_unlock();
 }
-
 #endif
+
 void ixgbe_do_reset(struct net_device *netdev)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
@@ -9687,11 +11237,25 @@ void ixgbe_do_reset(struct net_device *netdev)
 		ixgbe_reset(adapter);
 }
 
+#ifdef HAVE_NDO_SET_FEATURES
+#ifdef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+static u32 ixgbe_fix_features(struct net_device *netdev, u32 features)
+#else
 static netdev_features_t ixgbe_fix_features(struct net_device *netdev,
 					    netdev_features_t features)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
+#if IS_ENABLED(CONFIG_DCB)
+	if (adapter->flags & IXGBE_FLAG_DCB_ENABLED)
+#ifdef NETIF_F_HW_VLAN_CTAG_RX
+		features |= NETIF_F_HW_VLAN_CTAG_RX;
+#else
+		features |= NETIF_F_HW_VLAN_RX;
+#endif
+#endif /* CONFIG_DCB */
+
 	/* If Rx checksum is disabled, then RSC/LRO should also be disabled */
 	if (!(features & NETIF_F_RXCSUM))
 		features &= ~NETIF_F_LRO;
@@ -9708,28 +11272,16 @@ static netdev_features_t ixgbe_fix_features(struct net_device *netdev,
 	return features;
 }
 
-static void ixgbe_reset_l2fw_offload(struct ixgbe_adapter *adapter)
-{
-	int rss = min_t(int, ixgbe_max_rss_indices(adapter),
-			num_online_cpus());
-
-	/* go back to full RSS if we're not running SR-IOV */
-	if (!adapter->ring_feature[RING_F_VMDQ].offset)
-		adapter->flags &= ~(IXGBE_FLAG_VMDQ_ENABLED |
-				    IXGBE_FLAG_SRIOV_ENABLED);
-
-	adapter->ring_feature[RING_F_RSS].limit = rss;
-	adapter->ring_feature[RING_F_VMDQ].limit = 1;
-
-	ixgbe_setup_tc(adapter->netdev, adapter->hw_tcs);
-}
-
+#ifdef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+static int ixgbe_set_features(struct net_device *netdev, u32 features)
+#else
 static int ixgbe_set_features(struct net_device *netdev,
 			      netdev_features_t features)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	netdev_features_t changed = netdev->features ^ features;
 	bool need_reset = false;
+	netdev_features_t changed = netdev->features ^ features;
 
 	/* Make sure RSC matches LRO, reset if change */
 	if (!(features & NETIF_F_LRO)) {
@@ -9742,7 +11294,7 @@ static int ixgbe_set_features(struct net_device *netdev,
 		    adapter->rx_itr_setting > IXGBE_MIN_RSC_ITR) {
 			adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
 			need_reset = true;
-		} else if ((changed ^ features) & NETIF_F_LRO) {
+		} else if (changed & NETIF_F_LRO) {
 			e_info(probe, "rx-usecs set too low, "
 			       "disabling RSC\n");
 		}
@@ -9752,7 +11304,11 @@ static int ixgbe_set_features(struct net_device *netdev,
 	 * Check if Flow Director n-tuple support or hw_tc support was
 	 * enabled or disabled.  If the state changed, we need to reset.
 	 */
+#ifdef NETIF_F_HW_TC
 	if ((features & NETIF_F_NTUPLE) || (features & NETIF_F_HW_TC)) {
+#else
+	if (features & NETIF_F_NTUPLE) {
+#endif
 		/* turn off ATR, enable perfect filters and reset */
 		if (!(adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE))
 			need_reset = true;
@@ -9766,309 +11322,374 @@ static int ixgbe_set_features(struct net_device *netdev,
 
 		adapter->flags &= ~IXGBE_FLAG_FDIR_PERFECT_CAPABLE;
 
-		/* We cannot enable ATR if SR-IOV is enabled */
-		if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED ||
+		/* We cannot enable ATR if VMDq is enabled */
+		if (adapter->flags & IXGBE_FLAG_VMDQ_ENABLED ||
 		    /* We cannot enable ATR if we have 2 or more tcs */
-		    (adapter->hw_tcs > 1) ||
+		    netdev_get_num_tc(netdev) > 1 ||
 		    /* We cannot enable ATR if RSS is disabled */
-		    (adapter->ring_feature[RING_F_RSS].limit <= 1) ||
+		    adapter->ring_feature[RING_F_RSS].limit <= 1 ||
 		    /* A sample rate of 0 indicates ATR disabled */
-		    (!adapter->atr_sample_rate))
+		    !adapter->atr_sample_rate)
 			; /* do nothing not supported */
 		else /* otherwise supported and set the flag */
 			adapter->flags |= IXGBE_FLAG_FDIR_HASH_CAPABLE;
 	}
 
-	if (changed & NETIF_F_RXALL)
-		need_reset = true;
-
 	netdev->features = features;
 
-	if ((changed & NETIF_F_HW_L2FW_DOFFLOAD) && adapter->num_rx_pools > 1)
-		ixgbe_reset_l2fw_offload(adapter);
-	else if (need_reset)
-		ixgbe_do_reset(netdev);
-	else if (changed & (NETIF_F_HW_VLAN_CTAG_RX |
-			    NETIF_F_HW_VLAN_CTAG_FILTER))
-		ixgbe_set_rx_mode(netdev);
+#if defined(HAVE_UDP_ENC_RX_OFFLOAD) || defined(HAVE_VXLAN_RX_OFFLOAD)
+	if (adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE &&
+	    features & NETIF_F_RXCSUM) {
+		if (!need_reset)
+			adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+	} else {
+		u32 port_mask = IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK;
 
-	return 1;
-}
+		ixgbe_clear_udp_tunnel_port(adapter, port_mask);
+	}
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD || HAVE_VXLAN_RX_OFFLOAD */
 
-static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
-			     struct net_device *dev,
-			     const unsigned char *addr, u16 vid,
-			     u16 flags,
-			     struct netlink_ext_ack *extack)
-{
-	/* guarantee we can provide a unique filter for the unicast address */
-	if (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr)) {
-		struct ixgbe_adapter *adapter = netdev_priv(dev);
-		u16 pool = VMDQ_P(0);
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+	if (adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE &&
+	    features & NETIF_F_RXCSUM) {
+		if (!need_reset)
+			adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+	} else {
+		u32 port_mask = IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK;
 
-		if (netdev_uc_count(dev) >= ixgbe_available_rars(adapter, pool))
-			return -ENOMEM;
+		ixgbe_clear_udp_tunnel_port(adapter, port_mask);
 	}
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
+
+	if (need_reset)
+		ixgbe_do_reset(netdev);
+#ifdef NETIF_F_HW_VLAN_CTAG_FILTER
+	else if (changed & (NETIF_F_HW_VLAN_CTAG_RX |
+			    NETIF_F_HW_VLAN_CTAG_FILTER))
+		ixgbe_set_rx_mode(netdev);
+#endif
+#ifdef NETIF_F_HW_VLAN_FILTER
+	else if (changed & (NETIF_F_HW_VLAN_RX |
+			    NETIF_F_HW_VLAN_FILTER))
+		ixgbe_set_rx_mode(netdev);
+#endif
+	return 0;
 
-	return ndo_dflt_fdb_add(ndm, tb, dev, addr, vid, flags);
 }
+#endif /* HAVE_NDO_SET_FEATURES */
 
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
 /**
- * ixgbe_configure_bridge_mode - set various bridge modes
- * @adapter: the private structure
- * @mode: requested bridge mode
- *
- * Configure some settings require for various bridge modes.
+ * ixgbe_add_udp_tunnel_port - Get notifications about adding UDP tunnel ports
+ * @dev: The port's netdev
+ * @ti: Tunnel endpoint information
  **/
-static int ixgbe_configure_bridge_mode(struct ixgbe_adapter *adapter,
-				       __u16 mode)
+static void ixgbe_add_udp_tunnel_port(struct net_device *dev,
+				      struct udp_tunnel_info *ti)
 {
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_hw *hw = &adapter->hw;
-	unsigned int p, num_pools;
-	u32 vmdctl;
+	__be16 port = ti->port;
+	u32 port_shift = 0;
+	u32 reg;
 
-	switch (mode) {
-	case BRIDGE_MODE_VEPA:
-		/* disable Tx loopback, rely on switch hairpin mode */
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_PFDTXGSWC, 0);
+	if (ti->sa_family != AF_INET)
+		return;
 
-		/* must enable Rx switching replication to allow multicast
-		 * packet reception on all VFs, and to enable source address
-		 * pruning.
-		 */
-		vmdctl = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
-		vmdctl |= IXGBE_VT_CTL_REPLEN;
-		IXGBE_WRITE_REG(hw, IXGBE_VMD_CTL, vmdctl);
+	switch (ti->type) {
+	case UDP_TUNNEL_TYPE_VXLAN:
+		if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+			return;
 
-		/* enable Rx source address pruning. Note, this requires
-		 * replication to be enabled or else it does nothing.
-		 */
-		num_pools = adapter->num_vfs + adapter->num_rx_pools;
-		for (p = 0; p < num_pools; p++) {
-			if (hw->mac.ops.set_source_address_pruning)
-				hw->mac.ops.set_source_address_pruning(hw,
-								       true,
-								       p);
+		if (adapter->vxlan_port == port)
+			return;
+
+		if (adapter->vxlan_port) {
+			netdev_info(dev,
+				    "VXLAN port %d set, not adding port %d\n",
+				    ntohs(adapter->vxlan_port),
+				    ntohs(port));
+			return;
 		}
+
+		adapter->vxlan_port = port;
 		break;
-	case BRIDGE_MODE_VEB:
-		/* enable Tx loopback for internal VF/PF communication */
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_PFDTXGSWC,
-				IXGBE_PFDTXGSWC_VT_LBEN);
+	case UDP_TUNNEL_TYPE_GENEVE:
+		if (!(adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE))
+			return;
 
-		/* disable Rx switching replication unless we have SR-IOV
-		 * virtual functions
-		 */
-		vmdctl = IXGBE_READ_REG(hw, IXGBE_VMD_CTL);
-		if (!adapter->num_vfs)
-			vmdctl &= ~IXGBE_VT_CTL_REPLEN;
-		IXGBE_WRITE_REG(hw, IXGBE_VMD_CTL, vmdctl);
+		if (adapter->geneve_port == port)
+			return;
 
-		/* disable Rx source address pruning, since we don't expect to
-		 * be receiving external loopback of our transmitted frames.
-		 */
-		num_pools = adapter->num_vfs + adapter->num_rx_pools;
-		for (p = 0; p < num_pools; p++) {
-			if (hw->mac.ops.set_source_address_pruning)
-				hw->mac.ops.set_source_address_pruning(hw,
-								       false,
-								       p);
+		if (adapter->geneve_port) {
+			netdev_info(dev,
+				    "GENEVE port %d set, not adding port %d\n",
+				    ntohs(adapter->geneve_port),
+				    ntohs(port));
+			return;
 		}
+
+		port_shift = IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT;
+		adapter->geneve_port = port;
 		break;
 	default:
-		return -EINVAL;
+		return;
 	}
 
-	adapter->bridge_mode = mode;
-
-	e_info(drv, "enabling bridge mode: %s\n",
-	       mode == BRIDGE_MODE_VEPA ? "VEPA" : "VEB");
-
-	return 0;
+	reg = IXGBE_READ_REG(hw, IXGBE_VXLANCTRL) | ntohs(port) << port_shift;
+	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL, reg);
 }
 
-static int ixgbe_ndo_bridge_setlink(struct net_device *dev,
-				    struct nlmsghdr *nlh, u16 flags,
-				    struct netlink_ext_ack *extack)
+/**
+ * ixgbe_del_udp_tunnel_port - Get notifications about removing UDP tunnel ports
+ * @dev: The port's netdev
+ * @ti: Tunnel endpoint information
+ **/
+static void ixgbe_del_udp_tunnel_port(struct net_device *dev,
+				      struct udp_tunnel_info *ti)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	struct nlattr *attr, *br_spec;
-	int rem;
+	u32 port_mask;
 
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
-		return -EOPNOTSUPP;
+	if (ti->type != UDP_TUNNEL_TYPE_VXLAN &&
+	    ti->type != UDP_TUNNEL_TYPE_GENEVE)
+		return;
 
-	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
-	if (!br_spec)
-		return -EINVAL;
+	if (ti->sa_family != AF_INET)
+		return;
 
-	nla_for_each_nested(attr, br_spec, rem) {
-		int status;
-		__u16 mode;
+	switch (ti->type) {
+	case UDP_TUNNEL_TYPE_VXLAN:
+		if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE))
+			return;
 
-		if (nla_type(attr) != IFLA_BRIDGE_MODE)
-			continue;
+		if (adapter->vxlan_port != ti->port) {
+			netdev_info(dev, "VXLAN port %d not found\n",
+				    ntohs(ti->port));
+			return;
+		}
 
-		if (nla_len(attr) < sizeof(mode))
-			return -EINVAL;
+		port_mask = IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK;
+		break;
+	case UDP_TUNNEL_TYPE_GENEVE:
+		if (!(adapter->flags & IXGBE_FLAG_GENEVE_OFFLOAD_CAPABLE))
+			return;
 
-		mode = nla_get_u16(attr);
-		status = ixgbe_configure_bridge_mode(adapter, mode);
-		if (status)
-			return status;
+		if (adapter->geneve_port != ti->port) {
+			netdev_info(dev, "GENEVE port %d not found\n",
+				    ntohs(ti->port));
+			return;
+		}
 
+		port_mask = IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK;
 		break;
+	default:
+		return;
 	}
 
-	return 0;
+	ixgbe_clear_udp_tunnel_port(adapter, port_mask);
+	adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
 }
-
-static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
-				    struct net_device *dev,
-				    u32 filter_mask, int nlflags)
+#elif defined(HAVE_VXLAN_RX_OFFLOAD)
+/**
+ * ixgbe_add_vxlan_port - Get notifications about VXLAN ports that come up
+ * @dev: The port's netdev
+ * @sa_family: Socket Family that VXLAN is notifiying us about
+ * @port: New UDP port number that VXLAN started listening to
+ */
+static void ixgbe_add_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+				 __be16 port)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	struct ixgbe_hw *hw = &adapter->hw;
 
-	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
-		return 0;
+	if (sa_family != AF_INET)
+		return;
 
-	return ndo_dflt_bridge_getlink(skb, pid, seq, dev,
-				       adapter->bridge_mode, 0, 0, nlflags,
-				       filter_mask, NULL);
-}
+	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_ENABLE))
+		return;
 
-static void *ixgbe_fwd_add(struct net_device *pdev, struct net_device *vdev)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(pdev);
-	struct ixgbe_fwd_adapter *accel;
-	int tcs = adapter->hw_tcs ? : 1;
-	int pool, err;
+	if (adapter->vxlan_port == port)
+		return;
 
-	if (adapter->xdp_prog) {
-		e_warn(probe, "L2FW offload is not supported with XDP\n");
-		return ERR_PTR(-EINVAL);
+	if (adapter->vxlan_port) {
+		netdev_info(dev,
+			    "Hit Max num of VXLAN ports, not adding port %d\n",
+			    ntohs(port));
+		return;
 	}
 
-	/* The hardware supported by ixgbe only filters on the destination MAC
-	 * address. In order to avoid issues we only support offloading modes
-	 * where the hardware can actually provide the functionality.
-	 */
-	if (!macvlan_supports_dest_filter(vdev))
-		return ERR_PTR(-EMEDIUMTYPE);
+	adapter->vxlan_port = port;
+	IXGBE_WRITE_REG(hw, IXGBE_VXLANCTRL, ntohs(port));
+}
 
-	/* We need to lock down the macvlan to be a single queue device so that
-	 * we can reuse the tc_to_txq field in the macvlan netdev to represent
-	 * the queue mapping to our netdev.
-	 */
-	if (netif_is_multiqueue(vdev))
-		return ERR_PTR(-ERANGE);
-
-	pool = find_first_zero_bit(adapter->fwd_bitmask, adapter->num_rx_pools);
-	if (pool == adapter->num_rx_pools) {
-		u16 used_pools = adapter->num_vfs + adapter->num_rx_pools;
-		u16 reserved_pools;
-
-		if (((adapter->flags & IXGBE_FLAG_DCB_ENABLED) &&
-		     adapter->num_rx_pools >= (MAX_TX_QUEUES / tcs)) ||
-		    adapter->num_rx_pools > IXGBE_MAX_MACVLANS)
-			return ERR_PTR(-EBUSY);
-
-		/* Hardware has a limited number of available pools. Each VF,
-		 * and the PF require a pool. Check to ensure we don't
-		 * attempt to use more then the available number of pools.
-		 */
-		if (used_pools >= IXGBE_MAX_VF_FUNCTIONS)
-			return ERR_PTR(-EBUSY);
+/**
+ * ixgbe_del_vxlan_port - Get notifications about VXLAN ports that go away
+ * @dev: The port's netdev
+ * @sa_family: Socket Family that VXLAN is notifying us about
+ * @port: UDP port number that VXLAN stopped listening to
+ */
+static void ixgbe_del_vxlan_port(struct net_device *dev, sa_family_t sa_family,
+				 __be16 port)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
 
-		/* Enable VMDq flag so device will be set in VM mode */
-		adapter->flags |= IXGBE_FLAG_VMDQ_ENABLED |
-				  IXGBE_FLAG_SRIOV_ENABLED;
+	if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_ENABLE))
+		return;
 
-		/* Try to reserve as many queues per pool as possible,
-		 * we start with the configurations that support 4 queues
-		 * per pools, followed by 2, and then by just 1 per pool.
-		 */
-		if (used_pools < 32 && adapter->num_rx_pools < 16)
-			reserved_pools = min_t(u16,
-					       32 - used_pools,
-					       16 - adapter->num_rx_pools);
-		else if (adapter->num_rx_pools < 32)
-			reserved_pools = min_t(u16,
-					       64 - used_pools,
-					       32 - adapter->num_rx_pools);
-		else
-			reserved_pools = 64 - used_pools;
+	if (sa_family != AF_INET)
+		return;
 
+	if (adapter->vxlan_port != port) {
+		netdev_info(dev, "Port %d was not found, not deleting\n",
+			    ntohs(port));
+		return;
+	}
 
-		if (!reserved_pools)
-			return ERR_PTR(-EBUSY);
+	ixgbe_clear_udp_tunnel_port(adapter, IXGBE_VXLANCTRL_ALL_UDPPORT_MASK);
+	adapter->flags2 |= IXGBE_FLAG2_UDP_TUN_REREG_NEEDED;
+}
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
 
-		adapter->ring_feature[RING_F_VMDQ].limit += reserved_pools;
+#ifdef HAVE_NDO_GSO_CHECK
+static bool
+ixgbe_gso_check(struct sk_buff *skb, __always_unused struct net_device *dev)
+{
+	return vxlan_gso_check(skb);
+}
+#endif /* HAVE_NDO_GSO_CHECK */
 
-		/* Force reinit of ring allocation with VMDQ enabled */
-		err = ixgbe_setup_tc(pdev, adapter->hw_tcs);
-		if (err)
-			return ERR_PTR(err);
+#ifdef HAVE_FDB_OPS
+#ifdef USE_CONST_DEV_UC_CHAR
+static int ixgbe_ndo_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
+			     struct net_device *dev,
+			     const unsigned char *addr,
+#ifdef HAVE_NDO_FDB_ADD_VID
+			     u16 vid,
+#endif
+#ifdef HAVE_NDO_FDB_ADD_EXTACK
+			     u16 flags,
+			     struct netlink_ext_ack __always_unused *extack)
+#else
+			     u16 flags)
+#endif
+#else
+static int ixgbe_ndo_fdb_add(struct ndmsg *ndm,
+			     struct net_device *dev,
+			     unsigned char *addr,
+			     u16 flags)
+#endif /* USE_CONST_DEV_UC_CHAR */
+{
+	/* guarantee we can provide a unique filter for the unicast address */
+	if (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr)) {
+		struct ixgbe_adapter *adapter = netdev_priv(dev);
+		u16 pool = VMDQ_P(0);
 
-		if (pool >= adapter->num_rx_pools)
-			return ERR_PTR(-ENOMEM);
+		if (netdev_uc_count(dev) >= ixgbe_available_rars(adapter, pool))
+			return -ENOMEM;
 	}
 
-	accel = kzalloc(sizeof(*accel), GFP_KERNEL);
-	if (!accel)
-		return ERR_PTR(-ENOMEM);
+#ifdef USE_CONST_DEV_UC_CHAR
+#ifdef HAVE_NDO_FDB_ADD_VID
+	return ndo_dflt_fdb_add(ndm, tb, dev, addr, vid, flags);
+#else
+	return ndo_dflt_fdb_add(ndm, tb, dev, addr, flags);
+#endif /* HAVE_NDO_FDB_ADD_VID */
+#else
+	return ndo_dflt_fdb_add(ndm, dev, addr, flags);
+#endif /* USE_CONST_DEV_UC_CHAR */
+}
 
-	set_bit(pool, adapter->fwd_bitmask);
-	netdev_set_sb_channel(vdev, pool);
-	accel->pool = pool;
-	accel->netdev = vdev;
+#ifdef HAVE_BRIDGE_ATTRIBS
+#ifdef HAVE_NDO_BRIDGE_SETLINK_EXTACK
+static int ixgbe_ndo_bridge_setlink(struct net_device *dev,
+				    struct nlmsghdr *nlh,
+				    __always_unused u16 flags,
+				    struct netlink_ext_ack __always_unused *ext)
+#elif defined(HAVE_NDO_BRIDGE_SET_DEL_LINK_FLAGS)
+static int ixgbe_ndo_bridge_setlink(struct net_device *dev,
+				    struct nlmsghdr *nlh,
+				    __always_unused u16 flags)
+#else
+static int ixgbe_ndo_bridge_setlink(struct net_device *dev,
+				    struct nlmsghdr *nlh)
+#endif /* HAVE_NDO_BRIDGE_SETLINK_EXTACK */
+{
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	struct nlattr *attr, *br_spec;
+	int rem;
 
-	if (!netif_running(pdev))
-		return accel;
+	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+		return -EOPNOTSUPP;
 
-	err = ixgbe_fwd_ring_up(adapter, accel);
-	if (err)
-		return ERR_PTR(err);
+	br_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);
 
-	return accel;
-}
+	nla_for_each_nested(attr, br_spec, rem) {
+		__u16 mode;
 
-static void ixgbe_fwd_del(struct net_device *pdev, void *priv)
-{
-	struct ixgbe_fwd_adapter *accel = priv;
-	struct ixgbe_adapter *adapter = netdev_priv(pdev);
-	unsigned int rxbase = accel->rx_base_queue;
-	unsigned int i;
+		if (nla_type(attr) != IFLA_BRIDGE_MODE)
+			continue;
 
-	/* delete unicast filter associated with offloaded interface */
-	ixgbe_del_mac_filter(adapter, accel->netdev->dev_addr,
-			     VMDQ_P(accel->pool));
+		mode = nla_get_u16(attr);
+		if (mode == BRIDGE_MODE_VEPA) {
+			adapter->flags |= IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE;
+		} else if (mode == BRIDGE_MODE_VEB) {
+			adapter->flags &= ~IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE;
+		} else {
+			return -EINVAL;
+		}
 
-	/* Allow remaining Rx packets to get flushed out of the
-	 * Rx FIFO before we drop the netdev for the ring.
-	 */
-	usleep_range(10000, 20000);
+		adapter->bridge_mode = mode;
 
-	for (i = 0; i < adapter->num_rx_queues_per_pool; i++) {
-		struct ixgbe_ring *ring = adapter->rx_ring[rxbase + i];
-		struct ixgbe_q_vector *qv = ring->q_vector;
+		/* re-configure settings related to bridge mode */
+		ixgbe_configure_bridge_mode(adapter);
 
-		/* Make sure we aren't processing any packets and clear
-		 * netdev to shut down the ring.
-		 */
-		if (netif_running(adapter->netdev))
-			napi_synchronize(&qv->napi);
-		ring->netdev = NULL;
+		e_info(drv, "enabling bridge mode: %s\n",
+			mode == BRIDGE_MODE_VEPA ? "VEPA" : "VEB");
 	}
 
-	/* unbind the queues and drop the subordinate channel config */
-	netdev_unbind_sb_channel(pdev, accel->netdev);
-	netdev_set_sb_channel(accel->netdev, 0);
+	return 0;
+}
+
+#ifdef HAVE_NDO_BRIDGE_GETLINK_NLFLAGS
+static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+				    struct net_device *dev,
+				    u32 __maybe_unused filter_mask,
+				    int nlflags)
+#elif defined(HAVE_BRIDGE_FILTER)
+static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+				    struct net_device *dev,
+				    u32 __always_unused filter_mask)
+#else
+static int ixgbe_ndo_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+				    struct net_device *dev)
+#endif /* HAVE_NDO_BRIDGE_GETLINK_NLFLAGS */
+{
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	u16 mode;
+
+	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
+		return 0;
 
-	clear_bit(accel->pool, adapter->fwd_bitmask);
-	kfree(accel);
+	mode = adapter->bridge_mode;
+#ifdef HAVE_NDO_DFLT_BRIDGE_GETLINK_VLAN_SUPPORT
+	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode, 0, 0, nlflags,
+				       filter_mask, NULL);
+#elif defined(HAVE_NDO_BRIDGE_GETLINK_NLFLAGS)
+	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode, 0, 0, nlflags);
+#elif defined(HAVE_NDO_FDB_ADD_VID) || \
+      defined NDO_DFLT_BRIDGE_GETLINK_HAS_BRFLAGS
+	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode, 0, 0);
+#else
+	return ndo_dflt_bridge_getlink(skb, pid, seq, dev, mode);
+#endif /* HAVE_NDO_BRIDGE_GETLINK_NLFLAGS */
 }
+#endif /* HAVE_BRIDGE_ATTRIBS */
+#endif /* HAVE_FDB_OPS */
 
+#ifdef HAVE_NDO_FEATURES_CHECK
+#define IXGBE_MAX_TUNNEL_HDR_LEN 80
+#ifdef NETIF_F_GSO_PARTIAL
 #define IXGBE_MAX_MAC_HDR_LEN		127
 #define IXGBE_MAX_NETWORK_HDR_LEN	511
 
@@ -10083,7 +11704,6 @@ ixgbe_features_check(struct sk_buff *skb, struct net_device *dev,
 	if (unlikely(mac_hdr_len > IXGBE_MAX_MAC_HDR_LEN))
 		return features & ~(NETIF_F_HW_CSUM |
 				    NETIF_F_SCTP_CRC |
-				    NETIF_F_GSO_UDP_L4 |
 				    NETIF_F_HW_VLAN_CTAG_TX |
 				    NETIF_F_TSO |
 				    NETIF_F_TSO6);
@@ -10092,25 +11712,35 @@ ixgbe_features_check(struct sk_buff *skb, struct net_device *dev,
 	if (unlikely(network_hdr_len >  IXGBE_MAX_NETWORK_HDR_LEN))
 		return features & ~(NETIF_F_HW_CSUM |
 				    NETIF_F_SCTP_CRC |
-				    NETIF_F_GSO_UDP_L4 |
 				    NETIF_F_TSO |
 				    NETIF_F_TSO6);
 
 	/* We can only support IPV4 TSO in tunnels if we can mangle the
 	 * inner IP ID field, so strip TSO if MANGLEID is not supported.
-	 * IPsec offoad sets skb->encapsulation but still can handle
-	 * the TSO, so it's the exception.
 	 */
-	if (skb->encapsulation && !(features & NETIF_F_TSO_MANGLEID)) {
-#ifdef CONFIG_IXGBE_IPSEC
-		if (!secpath_exists(skb))
-#endif
-			features &= ~NETIF_F_TSO;
-	}
+	if (skb->encapsulation && !(features & NETIF_F_TSO_MANGLEID))
+		features &= ~NETIF_F_TSO;
+
+	return features;
+}
+#else
+static netdev_features_t
+ixgbe_features_check(struct sk_buff *skb, struct net_device *dev,
+		     netdev_features_t features)
+{
+	if (!skb->encapsulation)
+		return features;
+
+	if (unlikely(skb_inner_mac_header(skb) - skb_transport_header(skb) >
+		     IXGBE_MAX_TUNNEL_HDR_LEN))
+		return features & ~NETIF_F_CSUM_MASK;
 
 	return features;
 }
+#endif /* NETIF_F_GSO_PARTIAL */
+#endif /* HAVE_NDO_FEATURES_CHECK */
 
+#ifdef HAVE_XDP_SUPPORT
 static int ixgbe_xdp_setup(struct net_device *dev, struct bpf_prog *prog)
 {
 	int i, frame_size = dev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;
@@ -10143,12 +11773,7 @@ static int ixgbe_xdp_setup(struct net_device *dev, struct bpf_prog *prog)
 
 	/* If transitioning XDP modes reconfigure rings */
 	if (need_reset) {
-		int err;
-
-		if (!prog)
-			/* Wait until ndo_xsk_wakeup completes. */
-			synchronize_rcu();
-		err = ixgbe_setup_tc(dev, adapter->hw_tcs);
+		int err = ixgbe_setup_tc(dev, netdev_get_num_tc(dev));
 
 		if (err) {
 			rcu_assign_pointer(adapter->xdp_prog, old_prog);
@@ -10156,36 +11781,57 @@ static int ixgbe_xdp_setup(struct net_device *dev, struct bpf_prog *prog)
 		}
 	} else {
 		for (i = 0; i < adapter->num_rx_queues; i++)
-			(void)xchg(&adapter->rx_ring[i]->xdp_prog,
-			    adapter->xdp_prog);
+			xchg(&adapter->rx_ring[i]->xdp_prog, adapter->xdp_prog);
 	}
 
 	if (old_prog)
 		bpf_prog_put(old_prog);
 
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 	/* Kick start the NAPI context if there is an AF_XDP socket open
 	 * on that queue id. This so that receiving will start.
 	 */
 	if (need_reset && prog)
 		for (i = 0; i < adapter->num_rx_queues; i++)
-			if (adapter->xdp_ring[i]->xsk_pool)
+			if (adapter->xdp_ring[i]->xsk_umem)
+#ifdef HAVE_NDO_XSK_WAKEUP
 				(void)ixgbe_xsk_wakeup(adapter->netdev, i,
 						       XDP_WAKEUP_RX);
+#else
+				(void)ixgbe_xsk_async_xmit(adapter->netdev, i);
+#endif
 
+#endif
 	return 0;
 }
 
+#ifdef HAVE_NDO_BPF
 static int ixgbe_xdp(struct net_device *dev, struct netdev_bpf *xdp)
+#else
+static int ixgbe_xdp(struct net_device *dev, struct netdev_xdp *xdp)
+#endif
 {
+#if defined(HAVE_XDP_QUERY_PROG) || defined(HAVE_AF_XDP_ZC_SUPPORT)
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
+#endif
 
 	switch (xdp->command) {
 	case XDP_SETUP_PROG:
 		return ixgbe_xdp_setup(dev, xdp->prog);
-	case XDP_SETUP_XSK_POOL:
-		return ixgbe_xsk_pool_setup(adapter, xdp->xsk.pool,
+#ifdef HAVE_XDP_QUERY_PROG
+	case XDP_QUERY_PROG:
+#ifndef NO_NETDEV_BPF_PROG_ATTACHED
+		xdp->prog_attached = !!(adapter->xdp_prog);
+#endif /* !NO_NETDEV_BPF_PROG_ATTACHED */
+		xdp->prog_id = adapter->xdp_prog ?
+			       adapter->xdp_prog->aux->id : 0;
+		return 0;
+#endif
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	case XDP_SETUP_XSK_UMEM:
+		return ixgbe_xsk_umem_setup(adapter, xdp->xsk.umem,
 					    xdp->xsk.queue_id);
-
+#endif
 	default:
 		return -EINVAL;
 	}
@@ -10196,292 +11842,305 @@ void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring)
 	/* Force memory writes to complete before letting h/w know there
 	 * are new descriptors to fetch.
 	 */
-	wmb();
-	writel(ring->next_to_use, ring->tail);
-}
-
-static int ixgbe_xdp_xmit(struct net_device *dev, int n,
-			  struct xdp_frame **frames, u32 flags)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(dev);
-	struct ixgbe_ring *ring;
-	int drops = 0;
-	int i;
-
-	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
-		return -ENETDOWN;
-
-	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
-		return -EINVAL;
-
-	/* During program transitions its possible adapter->xdp_prog is assigned
-	 * but ring has not been configured yet. In this case simply abort xmit.
-	 */
-	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
-	if (unlikely(!ring))
-		return -ENXIO;
-
-	if (unlikely(test_bit(__IXGBE_TX_DISABLED, &ring->state)))
-		return -ENXIO;
-
-	for (i = 0; i < n; i++) {
-		struct xdp_frame *xdpf = frames[i];
-		int err;
-
-		err = ixgbe_xmit_xdp_ring(adapter, xdpf);
-		if (err != IXGBE_XDP_TX) {
-			xdp_return_frame_rx_napi(xdpf);
-			drops++;
-		}
-	}
-
-	if (unlikely(flags & XDP_XMIT_FLUSH))
-		ixgbe_xdp_ring_update_tail(ring);
-
-	return n - drops;
-}
-
-static const struct net_device_ops ixgbe_netdev_ops = {
-	.ndo_open		= ixgbe_open,
-	.ndo_stop		= ixgbe_close,
-	.ndo_start_xmit		= ixgbe_xmit_frame,
-	.ndo_set_rx_mode	= ixgbe_set_rx_mode,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_set_mac_address	= ixgbe_set_mac,
-	.ndo_change_mtu		= ixgbe_change_mtu,
-	.ndo_tx_timeout		= ixgbe_tx_timeout,
-	.ndo_set_tx_maxrate	= ixgbe_tx_maxrate,
-	.ndo_vlan_rx_add_vid	= ixgbe_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= ixgbe_vlan_rx_kill_vid,
-	.ndo_do_ioctl		= ixgbe_ioctl,
-	.ndo_set_vf_mac		= ixgbe_ndo_set_vf_mac,
-	.ndo_set_vf_vlan	= ixgbe_ndo_set_vf_vlan,
-	.ndo_set_vf_rate	= ixgbe_ndo_set_vf_bw,
-	.ndo_set_vf_spoofchk	= ixgbe_ndo_set_vf_spoofchk,
-	.ndo_set_vf_rss_query_en = ixgbe_ndo_set_vf_rss_query_en,
-	.ndo_set_vf_trust	= ixgbe_ndo_set_vf_trust,
-	.ndo_get_vf_config	= ixgbe_ndo_get_vf_config,
-	.ndo_get_stats64	= ixgbe_get_stats64,
-	.ndo_setup_tc		= __ixgbe_setup_tc,
-#ifdef IXGBE_FCOE
-	.ndo_select_queue	= ixgbe_select_queue,
-	.ndo_fcoe_ddp_setup = ixgbe_fcoe_ddp_get,
-	.ndo_fcoe_ddp_target = ixgbe_fcoe_ddp_target,
-	.ndo_fcoe_ddp_done = ixgbe_fcoe_ddp_put,
-	.ndo_fcoe_enable = ixgbe_fcoe_enable,
-	.ndo_fcoe_disable = ixgbe_fcoe_disable,
-	.ndo_fcoe_get_wwn = ixgbe_fcoe_get_wwn,
-	.ndo_fcoe_get_hbainfo = ixgbe_fcoe_get_hbainfo,
-#endif /* IXGBE_FCOE */
-	.ndo_set_features = ixgbe_set_features,
-	.ndo_fix_features = ixgbe_fix_features,
-	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
-	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
-	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
-	.ndo_dfwd_add_station	= ixgbe_fwd_add,
-	.ndo_dfwd_del_station	= ixgbe_fwd_del,
-	.ndo_udp_tunnel_add	= udp_tunnel_nic_add_port,
-	.ndo_udp_tunnel_del	= udp_tunnel_nic_del_port,
-	.ndo_features_check	= ixgbe_features_check,
-	.ndo_bpf		= ixgbe_xdp,
-	.ndo_xdp_xmit		= ixgbe_xdp_xmit,
-	.ndo_xsk_wakeup         = ixgbe_xsk_wakeup,
-};
-
-static void ixgbe_disable_txr_hw(struct ixgbe_adapter *adapter,
-				 struct ixgbe_ring *tx_ring)
-{
-	unsigned long wait_delay, delay_interval;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u8 reg_idx = tx_ring->reg_idx;
-	int wait_loop;
-	u32 txdctl;
-
-	IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(reg_idx), IXGBE_TXDCTL_SWFLSH);
-
-	/* delay mechanism from ixgbe_disable_tx */
-	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
-
-	wait_loop = IXGBE_MAX_RX_DESC_POLL;
-	wait_delay = delay_interval;
-
-	while (wait_loop--) {
-		usleep_range(wait_delay, wait_delay + 10);
-		wait_delay += delay_interval * 2;
-		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(reg_idx));
-
-		if (!(txdctl & IXGBE_TXDCTL_ENABLE))
-			return;
-	}
-
-	e_err(drv, "TXDCTL.ENABLE not cleared within the polling period\n");
-}
-
-static void ixgbe_disable_txr(struct ixgbe_adapter *adapter,
-			      struct ixgbe_ring *tx_ring)
-{
-	set_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
-	ixgbe_disable_txr_hw(adapter, tx_ring);
-}
-
-static void ixgbe_disable_rxr_hw(struct ixgbe_adapter *adapter,
-				 struct ixgbe_ring *rx_ring)
-{
-	unsigned long wait_delay, delay_interval;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u8 reg_idx = rx_ring->reg_idx;
-	int wait_loop;
-	u32 rxdctl;
-
-	rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
-	rxdctl &= ~IXGBE_RXDCTL_ENABLE;
-	rxdctl |= IXGBE_RXDCTL_SWFLSH;
-
-	/* write value back with RXDCTL.ENABLE bit cleared */
-	IXGBE_WRITE_REG(hw, IXGBE_RXDCTL(reg_idx), rxdctl);
-
-	/* RXDCTL.EN may not change on 82598 if link is down, so skip it */
-	if (hw->mac.type == ixgbe_mac_82598EB &&
-	    !(IXGBE_READ_REG(hw, IXGBE_LINKS) & IXGBE_LINKS_UP))
-		return;
-
-	/* delay mechanism from ixgbe_disable_rx */
-	delay_interval = ixgbe_get_completion_timeout(adapter) / 100;
-
-	wait_loop = IXGBE_MAX_RX_DESC_POLL;
-	wait_delay = delay_interval;
-
-	while (wait_loop--) {
-		usleep_range(wait_delay, wait_delay + 10);
-		wait_delay += delay_interval * 2;
-		rxdctl = IXGBE_READ_REG(hw, IXGBE_RXDCTL(reg_idx));
-
-		if (!(rxdctl & IXGBE_RXDCTL_ENABLE))
-			return;
-	}
-
-	e_err(drv, "RXDCTL.ENABLE not cleared within the polling period\n");
-}
-
-static void ixgbe_reset_txr_stats(struct ixgbe_ring *tx_ring)
-{
-	memset(&tx_ring->stats, 0, sizeof(tx_ring->stats));
-	memset(&tx_ring->tx_stats, 0, sizeof(tx_ring->tx_stats));
-}
-
-static void ixgbe_reset_rxr_stats(struct ixgbe_ring *rx_ring)
-{
-	memset(&rx_ring->stats, 0, sizeof(rx_ring->stats));
-	memset(&rx_ring->rx_stats, 0, sizeof(rx_ring->rx_stats));
+	wmb();
+	writel(ring->next_to_use, ring->tail);
 }
 
-/**
- * ixgbe_txrx_ring_disable - Disable Rx/Tx/XDP Tx rings
- * @adapter: adapter structure
- * @ring: ring index
- *
- * This function disables a certain Rx/Tx/XDP Tx ring. The function
- * assumes that the netdev is running.
- **/
-void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring)
+#ifdef HAVE_NDO_XDP_XMIT_BULK_AND_FLAGS
+static int ixgbe_xdp_xmit(struct net_device *dev, int n,
+			  struct xdp_frame **frames, u32 flags)
+#else
+static int ixgbe_xdp_xmit(struct net_device *dev, struct xdp_buff *xdp)
+#endif
 {
-	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
-
-	rx_ring = adapter->rx_ring[ring];
-	tx_ring = adapter->tx_ring[ring];
-	xdp_ring = adapter->xdp_ring[ring];
-
-	ixgbe_disable_txr(adapter, tx_ring);
-	if (xdp_ring)
-		ixgbe_disable_txr(adapter, xdp_ring);
-	ixgbe_disable_rxr_hw(adapter, rx_ring);
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	struct ixgbe_ring *ring;
+#ifdef HAVE_NDO_XDP_XMIT_BULK_AND_FLAGS
+	int drops = 0;
+	int i;
+#else
+	int err;
+#endif
 
-	if (xdp_ring)
-		synchronize_rcu();
+	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+		return -ENETDOWN;
 
-	/* Rx/Tx/XDP Tx share the same napi context. */
-	napi_disable(&rx_ring->q_vector->napi);
+#ifdef HAVE_NDO_XDP_XMIT_BULK_AND_FLAGS
+	if (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))
+		return -EINVAL;
+#endif
 
-	ixgbe_clean_tx_ring(tx_ring);
-	if (xdp_ring)
-		ixgbe_clean_tx_ring(xdp_ring);
-	ixgbe_clean_rx_ring(rx_ring);
+	/* During program transitions its possible adapter->xdp_prog is assigned
+	 * but ring has not been configured yet. In this case simply abort xmit.
+	 */
+	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+	if (unlikely(!ring))
+		return -ENXIO;
 
-	ixgbe_reset_txr_stats(tx_ring);
-	if (xdp_ring)
-		ixgbe_reset_txr_stats(xdp_ring);
-	ixgbe_reset_rxr_stats(rx_ring);
-}
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+	if (unlikely(test_bit(__IXGBE_TX_DISABLED, &ring->state)))
+		return -ENXIO;
+#endif
 
-/**
- * ixgbe_txrx_ring_enable - Enable Rx/Tx/XDP Tx rings
- * @adapter: adapter structure
- * @ring: ring index
- *
- * This function enables a certain Rx/Tx/XDP Tx ring. The function
- * assumes that the netdev is running.
- **/
-void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring)
-{
-	struct ixgbe_ring *rx_ring, *tx_ring, *xdp_ring;
+#ifdef HAVE_NDO_XDP_XMIT_BULK_AND_FLAGS
+	for (i = 0; i < n; i++) {
+		struct xdp_frame *xdpf = frames[i];
+		int err;
 
-	rx_ring = adapter->rx_ring[ring];
-	tx_ring = adapter->tx_ring[ring];
-	xdp_ring = adapter->xdp_ring[ring];
+		err = ixgbe_xmit_xdp_ring(adapter, xdpf);
+		if (err != IXGBE_XDP_TX) {
+			xdp_return_frame_rx_napi(xdpf);
+			drops++;
+		}
+	}
 
-	/* Rx/Tx/XDP Tx share the same napi context. */
-	napi_enable(&rx_ring->q_vector->napi);
+	if (unlikely(flags & XDP_XMIT_FLUSH))
+		ixgbe_xdp_ring_update_tail(ring);
 
-	ixgbe_configure_tx_ring(adapter, tx_ring);
-	if (xdp_ring)
-		ixgbe_configure_tx_ring(adapter, xdp_ring);
-	ixgbe_configure_rx_ring(adapter, rx_ring);
+	return n - drops;
+#else
+	err = ixgbe_xmit_xdp_ring(adapter, xdp);
+	if (err != IXGBE_XDP_TX)
+		return -ENOSPC;
 
-	clear_bit(__IXGBE_TX_DISABLED, &tx_ring->state);
-	if (xdp_ring)
-		clear_bit(__IXGBE_TX_DISABLED, &xdp_ring->state);
+	return 0;
+#endif
 }
 
-/**
- * ixgbe_enumerate_functions - Get the number of ports this device has
- * @adapter: adapter structure
- *
- * This function enumerates the phsyical functions co-located on a single slot,
- * in order to determine how many ports a device has. This is most useful in
- * determining the required GT/s of PCIe bandwidth necessary for optimal
- * performance.
- **/
-static inline int ixgbe_enumerate_functions(struct ixgbe_adapter *adapter)
+#ifndef NO_NDO_XDP_FLUSH
+static void ixgbe_xdp_flush(struct net_device *dev)
 {
-	struct pci_dev *entry, *pdev = adapter->pdev;
-	int physfns = 0;
+	struct ixgbe_adapter *adapter = netdev_priv(dev);
+	struct ixgbe_ring *ring;
 
-	/* Some cards can not use the generic count PCIe functions method,
-	 * because they are behind a parent switch, so we hardcode these with
-	 * the correct number of functions.
+	/* Its possible the device went down between xdp xmit and flush so
+	 * we need to ensure device is still up.
 	 */
-	if (ixgbe_pcie_from_parent(&adapter->hw))
-		physfns = 4;
+	if (unlikely(test_bit(__IXGBE_DOWN, &adapter->state)))
+		return;
 
-	list_for_each_entry(entry, &adapter->pdev->bus->devices, bus_list) {
-		/* don't count virtual functions */
-		if (entry->is_virtfn)
-			continue;
+	ring = adapter->xdp_prog ? adapter->xdp_ring[smp_processor_id()] : NULL;
+	if (unlikely(!ring))
+		return;
 
-		/* When the devices on the bus don't all match our device ID,
-		 * we can't reliably determine the correct number of
-		 * functions. This can occur if a function has been direct
-		 * attached to a virtual machine using VT-d, for example. In
-		 * this case, simply return -1 to indicate this.
-		 */
-		if ((entry->vendor != pdev->vendor) ||
-		    (entry->device != pdev->device))
-			return -1;
+	ixgbe_xdp_ring_update_tail(ring);
 
-		physfns++;
-	}
+	return;
+}
+#endif /* !NO_NDO_XDP_FLUSH */
+#endif /* HAVE_XDP_SUPPORT */
+#ifdef HAVE_NET_DEVICE_OPS
+static const struct net_device_ops ixgbe_netdev_ops = {
+	.ndo_open		= ixgbe_open,
+	.ndo_stop		= ixgbe_close,
+	.ndo_start_xmit		= ixgbe_xmit_frame,
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+#if IS_ENABLED(CONFIG_FCOE)
+	.ndo_select_queue	= ixgbe_select_queue,
+#else
+#ifndef HAVE_MQPRIO
+	.ndo_select_queue	= __netdev_pick_tx,
+#endif
+#endif /* CONFIG_FCOE */
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+	.ndo_set_rx_mode	= ixgbe_set_rx_mode,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= ixgbe_set_mac,
+#ifdef HAVE_RHEL7_EXTENDED_MIN_MAX_MTU
+	.extended.ndo_change_mtu = ixgbe_change_mtu,
+#else
+	.ndo_change_mtu		= ixgbe_change_mtu,
+#endif
+	.ndo_tx_timeout		= ixgbe_tx_timeout,
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+	.ndo_vlan_rx_add_vid	= ixgbe_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid	= ixgbe_vlan_rx_kill_vid,
+#endif
+	.ndo_do_ioctl		= ixgbe_ioctl,
+#ifdef HAVE_RHEL7_NET_DEVICE_OPS_EXT
+/* RHEL7 requires this to be defined to enable extended ops.  RHEL7 uses the
+ * function get_ndo_ext to retrieve offsets for extended fields from with the
+ * net_device_ops struct and ndo_size is checked to determine whether or not
+ * the offset is valid.
+ */
+	.ndo_size		= sizeof(const struct net_device_ops),
+#endif
+#ifdef IFLA_VF_MAX
+	.ndo_set_vf_mac		= ixgbe_ndo_set_vf_mac,
+#ifdef HAVE_RHEL7_NETDEV_OPS_EXT_NDO_SET_VF_VLAN
+	.extended.ndo_set_vf_vlan = ixgbe_ndo_set_vf_vlan,
+#else
+	.ndo_set_vf_vlan	= ixgbe_ndo_set_vf_vlan,
+#endif
+#ifdef HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
+	.ndo_set_vf_rate	= ixgbe_ndo_set_vf_bw,
+#else
+	.ndo_set_vf_tx_rate	= ixgbe_ndo_set_vf_bw,
+#endif /* HAVE_NDO_SET_VF_MIN_MAX_TX_RATE */
+#if defined(HAVE_VF_SPOOFCHK_CONFIGURE) && IS_ENABLED(CONFIG_PCI_IOV)
+	.ndo_set_vf_spoofchk	= ixgbe_ndo_set_vf_spoofchk,
+#endif
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
+	.ndo_set_vf_rss_query_en = ixgbe_ndo_set_vf_rss_query_en,
+#endif
+#ifdef HAVE_NDO_SET_VF_TRUST
+#ifdef HAVE_RHEL7_NET_DEVICE_OPS_EXT
+	.extended.ndo_set_vf_trust = ixgbe_ndo_set_vf_trust,
+#else
+	.ndo_set_vf_trust	= ixgbe_ndo_set_vf_trust,
+#endif /* HAVE_RHEL7_NET_DEVICE_OPS_EXT */
+#endif /* HAVE_NDO_SET_VF_TRUST */
+	.ndo_get_vf_config	= ixgbe_ndo_get_vf_config,
+#endif /* IFLA_VF_MAX */
+#ifdef HAVE_NDO_GET_STATS64
+	.ndo_get_stats64	= ixgbe_get_stats64,
+#else
+	.ndo_get_stats		= ixgbe_get_stats,
+#endif /* HAVE_NDO_GET_STATS64 */
+#ifdef HAVE_SETUP_TC
+#ifdef HAVE_RHEL7_NETDEV_OPS_EXT_NDO_SETUP_TC
+	.extended.ndo_setup_tc_rh = __ixgbe_setup_tc,
+#else
+#ifdef NETIF_F_HW_TC
+	.ndo_setup_tc		= __ixgbe_setup_tc,
+#else
+	.ndo_setup_tc		= ixgbe_setup_tc,
+#endif /* NETIF_F_HW_TC */
+#endif /* HAVE_RHEL7_NETDEV_OPS_EXT_NDO_SETUP_TC */
+#endif /* HAVE_SETUP_TC */
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= ixgbe_netpoll,
+#endif
+#ifndef HAVE_RHEL6_NET_DEVICE_EXTENDED
+#ifdef HAVE_NDO_BUSY_POLL
+	.ndo_busy_poll		= ixgbe_busy_poll_recv,
+#endif /* HAVE_NDO_BUSY_POLL */
+#endif /* !HAVE_RHEL6_NET_DEVICE_EXTENDED */
+#if IS_ENABLED(CONFIG_FCOE)
+	.ndo_fcoe_ddp_setup = ixgbe_fcoe_ddp_get,
+#ifdef HAVE_NETDEV_OPS_FCOE_DDP_TARGET
+	.ndo_fcoe_ddp_target = ixgbe_fcoe_ddp_target,
+#endif
+	.ndo_fcoe_ddp_done = ixgbe_fcoe_ddp_put,
+#ifdef HAVE_NETDEV_OPS_FCOE_ENABLE
+	.ndo_fcoe_enable = ixgbe_fcoe_enable,
+	.ndo_fcoe_disable = ixgbe_fcoe_disable,
+#endif
+#ifdef HAVE_NETDEV_OPS_FCOE_GETWWN
+	.ndo_fcoe_get_wwn = ixgbe_fcoe_get_wwn,
+#endif
+#endif /* CONFIG_FCOE */
+#ifdef HAVE_VLAN_RX_REGISTER
+	.ndo_vlan_rx_register	= &ixgbe_vlan_mode,
+#endif
+#ifdef HAVE_FDB_OPS
+	.ndo_fdb_add		= ixgbe_ndo_fdb_add,
+#ifndef USE_DEFAULT_FDB_DEL_DUMP
+	.ndo_fdb_del		= ndo_dflt_fdb_del,
+	.ndo_fdb_dump		= ndo_dflt_fdb_dump,
+#endif
+#ifdef HAVE_BRIDGE_ATTRIBS
+	.ndo_bridge_setlink	= ixgbe_ndo_bridge_setlink,
+	.ndo_bridge_getlink	= ixgbe_ndo_bridge_getlink,
+#endif /* HAVE_BRIDGE_ATTRIBS */
+#endif
+#ifdef HAVE_UDP_ENC_RX_OFFLOAD
+#ifdef HAVE_RHEL7_NETDEV_OPS_EXT_NDO_UDP_TUNNEL
+	.extended.ndo_udp_tunnel_add = ixgbe_add_udp_tunnel_port,
+	.extended.ndo_udp_tunnel_del = ixgbe_del_udp_tunnel_port,
+#else
+	.ndo_udp_tunnel_add	= ixgbe_add_udp_tunnel_port,
+	.ndo_udp_tunnel_del	= ixgbe_del_udp_tunnel_port,
+#endif
+#elif defined(HAVE_VXLAN_RX_OFFLOAD)
+	.ndo_add_vxlan_port	= ixgbe_add_vxlan_port,
+	.ndo_del_vxlan_port	= ixgbe_del_vxlan_port,
+#endif /* HAVE_UDP_ENC_RX_OFFLOAD */
+#ifdef HAVE_NDO_GSO_CHECK
+	.ndo_gso_check		= ixgbe_gso_check,
+#endif /* HAVE_NDO_GSO_CHECK */
+#ifdef HAVE_NDO_FEATURES_CHECK
+	.ndo_features_check	= ixgbe_features_check,
+#endif /* HAVE_NDO_FEATURES_CHECK */
+#ifdef HAVE_XDP_SUPPORT
+#ifdef HAVE_NDO_BPF
+	.ndo_bpf                = ixgbe_xdp,
+#else
+	.ndo_xdp                = ixgbe_xdp,
+#endif
+	.ndo_xdp_xmit           = ixgbe_xdp_xmit,
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+#ifdef HAVE_NDO_XSK_WAKEUP
+	.ndo_xsk_wakeup         = ixgbe_xsk_wakeup,
+#else
+	.ndo_xsk_async_xmit     = ixgbe_xsk_async_xmit,
+#endif
+#endif
+#ifndef NO_NDO_XDP_FLUSH
+	.ndo_xdp_flush          = ixgbe_xdp_flush,
+#endif /* !NO_NDO_XDP_FLUSH */
+#endif
+#ifdef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+};
 
-	return physfns;
+/* RHEL6 keeps these operations in a separate structure */
+static const struct net_device_ops_ext ixgbe_netdev_ops_ext = {
+	.size = sizeof(struct net_device_ops_ext),
+#endif /* HAVE_RHEL6_NET_DEVICE_OPS_EXT */
+#ifdef HAVE_NDO_SET_FEATURES
+	.ndo_set_features = ixgbe_set_features,
+	.ndo_fix_features = ixgbe_fix_features,
+#endif /* HAVE_NDO_SET_FEATURES */
+};
+#endif /* HAVE_NET_DEVICE_OPS */
+
+void ixgbe_assign_netdev_ops(struct net_device *dev)
+{
+#ifdef HAVE_NET_DEVICE_OPS
+	dev->netdev_ops = &ixgbe_netdev_ops;
+#ifdef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+	set_netdev_ops_ext(dev, &ixgbe_netdev_ops_ext);
+#endif /* HAVE_RHEL6_NET_DEVICE_OPS_EXT */
+#else /* HAVE_NET_DEVICE_OPS */
+	dev->open = &ixgbe_open;
+	dev->stop = &ixgbe_close;
+	dev->hard_start_xmit = &ixgbe_xmit_frame;
+	dev->get_stats = &ixgbe_get_stats;
+#ifdef HAVE_SET_RX_MODE
+	dev->set_rx_mode = &ixgbe_set_rx_mode;
+#endif
+	dev->set_multicast_list = &ixgbe_set_rx_mode;
+	dev->set_mac_address = &ixgbe_set_mac;
+	dev->change_mtu = &ixgbe_change_mtu;
+	dev->do_ioctl = &ixgbe_ioctl;
+#ifdef HAVE_TX_TIMEOUT
+	dev->tx_timeout = &ixgbe_tx_timeout;
+#endif
+#if defined(NETIF_F_HW_VLAN_TX) || defined(NETIF_F_HW_VLAN_CTAG_TX)
+	dev->vlan_rx_register = &ixgbe_vlan_mode;
+	dev->vlan_rx_add_vid = &ixgbe_vlan_rx_add_vid;
+	dev->vlan_rx_kill_vid = &ixgbe_vlan_rx_kill_vid;
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	dev->poll_controller = &ixgbe_netpoll;
+#endif
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+#if IS_ENABLED(CONFIG_FCOE)
+	dev->select_queue = &ixgbe_select_queue;
+#else
+	dev->select_queue = &__netdev_pick_tx;
+#endif
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+#endif /* HAVE_NET_DEVICE_OPS */
+
+#ifdef HAVE_RHEL6_NET_DEVICE_EXTENDED
+#ifdef HAVE_NDO_BUSY_POLL
+	netdev_extended(dev)->ndo_busy_poll		= ixgbe_busy_poll_recv;
+#endif /* HAVE_NDO_BUSY_POLL */
+#endif /* HAVE_RHEL6_NET_DEVICE_EXTENDED */
+
+	ixgbe_set_ethtool_ops(dev);
+	dev->watchdog_timeo = 5 * HZ;
 }
 
 /**
@@ -10524,7 +12183,7 @@ bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id,
 			/* only support first port */
 			if (hw->bus.func != 0)
 				break;
-			fallthrough;
+			/* fall through */
 		case IXGBE_SUBDEV_ID_82599_SP_560FLR:
 		case IXGBE_SUBDEV_ID_82599_SFP:
 		case IXGBE_SUBDEV_ID_82599_RNDC:
@@ -10536,7 +12195,7 @@ bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id,
 		}
 		break;
 	case IXGBE_DEV_ID_82599EN_SFP:
-		/* Only these subdevices support WOL */
+		/* Only these subdevices support WoL */
 		switch (subdevice_id) {
 		case IXGBE_SUBDEV_ID_82599EN_SFP_OCP1:
 			return true;
@@ -10562,33 +12221,76 @@ bool ixgbe_wol_supported(struct ixgbe_adapter *adapter, u16 device_id,
  *
  * This function is used by probe and ethtool to determine the FW version to
  * format to display. The FW version is taken from the EEPROM/NVM.
- */
+ *
+ **/
 static void ixgbe_set_fw_version(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	struct ixgbe_nvm_version nvm_ver;
-
-	ixgbe_get_oem_prod_version(hw, &nvm_ver);
-	if (nvm_ver.oem_valid) {
-		snprintf(adapter->eeprom_id, sizeof(adapter->eeprom_id),
-			 "%x.%x.%x", nvm_ver.oem_major, nvm_ver.oem_minor,
-			 nvm_ver.oem_release);
-		return;
+	u16 eeprom_verh = 0, eeprom_verl = 0;
+	u16 offset = 0;
+	u32 etrack_id;
+
+	/* Check for OEM Product Version block format */
+	hw->eeprom.ops.read(hw, 0x1b, &offset);
+
+	/* Make sure offset to OEM Product Version block is valid */
+	if (!(offset == 0x0) && !(offset == 0xffff)) {
+		u16 mod_len = 0, cap = 0, prod_ver = 0, rel_num = 0;
+		u16 build, major, patch;
+
+		/* Read product version block */
+		hw->eeprom.ops.read(hw, offset, &mod_len);
+		hw->eeprom.ops.read(hw, offset + 0x1, &cap);
+		hw->eeprom.ops.read(hw, offset + 0x2, &prod_ver);
+		hw->eeprom.ops.read(hw, offset + 0x3, &rel_num);
+
+		/* Only display OEM product version if valid block */
+		if (mod_len == 0x3 && (cap & 0xf) == 0x0) {
+			major = prod_ver >> 8;
+			build = prod_ver & 0xff;
+			patch = rel_num;
+
+			snprintf(adapter->eeprom_id, sizeof(adapter->eeprom_id),
+				 "%x.%x.%x", major, build, patch);
+			return;
+		}
 	}
 
-	ixgbe_get_etk_id(hw, &nvm_ver);
-	ixgbe_get_orom_version(hw, &nvm_ver);
-
-	if (nvm_ver.or_valid) {
-		snprintf(adapter->eeprom_id, sizeof(adapter->eeprom_id),
-			 "0x%08x, %d.%d.%d", nvm_ver.etk_id, nvm_ver.or_major,
-			 nvm_ver.or_build, nvm_ver.or_patch);
-		return;
+	/*
+	 * Save off EEPROM version number and Option Rom version which
+	 * together make a unique identify for the eeprom
+	 */
+	hw->eeprom.ops.read(hw, 0x2e, &eeprom_verh);
+	hw->eeprom.ops.read(hw, 0x2d, &eeprom_verl);
+	etrack_id = (eeprom_verh << 16) | eeprom_verl;
+
+	/* Check for SCSI block version format */
+	hw->eeprom.ops.read(hw, 0x17, &offset);
+
+	/* Make sure offset to SCSI block is valid */
+	if (!(offset == 0x0) && !(offset == 0xffff)) {
+		u16 eeprom_cfg_blkh = 0, eeprom_cfg_blkl = 0;
+		u16 build, major, patch;
+
+		hw->eeprom.ops.read(hw, offset + 0x84, &eeprom_cfg_blkh);
+		hw->eeprom.ops.read(hw, offset + 0x83, &eeprom_cfg_blkl);
+
+		/* Only display Option Rom if exist */
+		if (eeprom_cfg_blkl && eeprom_cfg_blkh) {
+			major = eeprom_cfg_blkl >> 8;
+			build = (eeprom_cfg_blkl << 8) | (eeprom_cfg_blkh >> 8);
+			patch = eeprom_cfg_blkh & 0x00ff;
+
+			snprintf(adapter->eeprom_id, sizeof(adapter->eeprom_id),
+				 "0x%08x, %d.%d.%d", etrack_id, major, build,
+				 patch);
+			return;
+		}
 	}
 
 	/* Set ETrack ID format */
 	snprintf(adapter->eeprom_id, sizeof(adapter->eeprom_id),
-		 "0x%08x", nvm_ver.etk_id);
+		 "0x%08x", etrack_id);
 }
 
 /**
@@ -10602,82 +12304,130 @@ static void ixgbe_set_fw_version(struct ixgbe_adapter *adapter)
  * The OS initialization, configuring of the adapter private structure,
  * and a hardware reset occur.
  **/
-static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+#ifdef HAVE_CONFIG_HOTPLUG
+static int __devinit ixgbe_probe(struct pci_dev *pdev,
+				 const struct pci_device_id __always_unused *ent)
+#else
+static int ixgbe_probe(struct pci_dev *pdev,
+		       const struct pci_device_id __always_unused *ent)
+#endif
 {
 	struct net_device *netdev;
 	struct ixgbe_adapter *adapter = NULL;
-	struct ixgbe_hw *hw;
-	const struct ixgbe_info *ii = ixgbe_info_tbl[ent->driver_data];
-	int i, err, pci_using_dac, expected_gts;
-	unsigned int indices = MAX_TX_QUEUES;
+	struct ixgbe_hw *hw = NULL;
+	static int cards_found;
+	int err, pci_using_dac;
+	char *info_string;
 	u8 part_str[IXGBE_PBANUM_LENGTH];
+	enum ixgbe_mac_type mac_type = ixgbe_mac_unknown;
+#ifdef HAVE_TX_MQ
+	unsigned int indices = MAX_TX_QUEUES;
+#endif /* HAVE_TX_MQ */
 	bool disable_dev = false;
-#ifdef IXGBE_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 	u16 device_caps;
 #endif
-	u32 eec;
-
-	/* Catch broken hardware that put the wrong VF device ID in
-	 * the PCIe SR-IOV capability.
-	 */
-	if (pdev->is_virtfn) {
-		WARN(1, KERN_ERR "%s (%hx:%hx) should not be a VF!\n",
-		     pci_name(pdev), pdev->vendor, pdev->device);
-		return -EINVAL;
-	}
-
+#ifndef NETIF_F_GSO_PARTIAL
+#ifdef HAVE_NDO_SET_FEATURES
+#ifndef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+	netdev_features_t hw_features;
+#else
+	u32 hw_features;
+#endif
+#endif
+#endif /* NETIF_F_GSO_PARTIAL */
+	int i;
 	err = pci_enable_device_mem(pdev);
 	if (err)
 		return err;
 
-	if (!dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64))) {
+	if (!dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64)) &&
+	    !dma_set_coherent_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(64))) {
 		pci_using_dac = 1;
 	} else {
-		err = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+		err = dma_set_mask(pci_dev_to_dev(pdev), DMA_BIT_MASK(32));
 		if (err) {
-			dev_err(&pdev->dev,
-				"No usable DMA configuration, aborting\n");
-			goto err_dma;
+			err = dma_set_coherent_mask(pci_dev_to_dev(pdev),
+						    DMA_BIT_MASK(32));
+			if (err) {
+				dev_err(pci_dev_to_dev(pdev), "No usable DMA "
+					"configuration, aborting\n");
+				goto err_dma;
+			}
 		}
 		pci_using_dac = 0;
 	}
 
 	err = pci_request_mem_regions(pdev, ixgbe_driver_name);
 	if (err) {
-		dev_err(&pdev->dev,
+		dev_err(pci_dev_to_dev(pdev),
 			"pci_request_selected_regions failed 0x%x\n", err);
 		goto err_pci_reg;
 	}
 
+	/*
+	 * The mac_type is needed before we have the adapter is  set up
+	 * so rather than maintain two devID -> MAC tables we dummy up
+	 * an ixgbe_hw stuct and use ixgbe_set_mac_type.
+	 */
+	hw = vmalloc(sizeof(struct ixgbe_hw));
+	if (!hw) {
+		pr_info("Unable to allocate memory for early mac "
+			"check\n");
+	} else {
+		hw->vendor_id = pdev->vendor;
+		hw->device_id = pdev->device;
+		ixgbe_set_mac_type(hw);
+		mac_type = hw->mac.type;
+		vfree(hw);
+	}
+
+	/*
+	 * Workaround of Silicon errata on 82598. Disable LOs in the PCI switch
+	 * port to which the 82598 is connected to prevent duplicate
+	 * completions caused by LOs.  We need the mac type so that we only
+	 * do this on 82598 devices, ixgbe_set_mac_type does this for us if
+	 * we set it's device ID.
+	 */
+	if (mac_type == ixgbe_mac_82598EB)
+		pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);
+
 	pci_enable_pcie_error_reporting(pdev);
 
 	pci_set_master(pdev);
-	pci_save_state(pdev);
 
-	if (ii->mac == ixgbe_mac_82598EB) {
-#ifdef CONFIG_IXGBE_DCB
-		/* 8 TC w/ 4 queues per TC */
-		indices = 4 * MAX_TRAFFIC_CLASS;
-#else
+#ifdef HAVE_TX_MQ
+	if (mac_type == ixgbe_mac_82598EB) {
+#if IS_ENABLED(CONFIG_DCB)
+		indices = IXGBE_MAX_DCB_INDICES * 4;
+#else /* CONFIG_DCB */
 		indices = IXGBE_MAX_RSS_INDICES;
-#endif
+#endif /* !CONFIG_DCB */
 	}
 
 	netdev = alloc_etherdev_mq(sizeof(struct ixgbe_adapter), indices);
+#else /* HAVE_TX_MQ */
+	netdev = alloc_etherdev(sizeof(struct ixgbe_adapter));
+#endif /* HAVE_TX_MQ */
 	if (!netdev) {
 		err = -ENOMEM;
 		goto err_alloc_etherdev;
 	}
 
-	SET_NETDEV_DEV(netdev, &pdev->dev);
+	SET_MODULE_OWNER(netdev);
+	SET_NETDEV_DEV(netdev, pci_dev_to_dev(pdev));
 
 	adapter = netdev_priv(netdev);
-
+#ifdef HAVE_TX_MQ
+#ifndef HAVE_NETDEV_SELECT_QUEUE
+	adapter->indices = indices;
+#endif
+#endif
 	adapter->netdev = netdev;
 	adapter->pdev = pdev;
 	hw = &adapter->hw;
 	hw->back = adapter;
-	adapter->msg_enable = netif_msg_init(debug, DEFAULT_MSG_ENABLE);
+	adapter->msg_enable = (1 << DEFAULT_DEBUG_LEVEL_SHIFT) - 1;
 
 	hw->hw_addr = ioremap(pci_resource_start(pdev, 0),
 			      pci_resource_len(pdev, 0));
@@ -10687,57 +12437,18 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto err_ioremap;
 	}
 
-	netdev->netdev_ops = &ixgbe_netdev_ops;
-	ixgbe_set_ethtool_ops(netdev);
-	netdev->watchdog_timeo = 5 * HZ;
-	strlcpy(netdev->name, pci_name(pdev), sizeof(netdev->name));
+	ixgbe_assign_netdev_ops(netdev);
 
-	/* Setup hw api */
-	hw->mac.ops   = *ii->mac_ops;
-	hw->mac.type  = ii->mac;
-	hw->mvals     = ii->mvals;
-	if (ii->link_ops)
-		hw->link.ops  = *ii->link_ops;
+	strscpy(netdev->name, pci_name(pdev), sizeof(netdev->name));
 
-	/* EEPROM */
-	hw->eeprom.ops = *ii->eeprom_ops;
-	eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
-	if (ixgbe_removed(hw->hw_addr)) {
-		err = -EIO;
-		goto err_ioremap;
-	}
-	/* If EEPROM is valid (bit 8 = 1), use default otherwise use bit bang */
-	if (!(eec & BIT(8)))
-		hw->eeprom.ops.read = &ixgbe_read_eeprom_bit_bang_generic;
-
-	/* PHY */
-	hw->phy.ops = *ii->phy_ops;
-	hw->phy.sfp_type = ixgbe_sfp_type_unknown;
-	/* ixgbe_identify_phy_generic will set prtad and mmds properly */
-	hw->phy.mdio.prtad = MDIO_PRTAD_NONE;
-	hw->phy.mdio.mmds = 0;
-	hw->phy.mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
-	hw->phy.mdio.dev = netdev;
-	hw->phy.mdio.mdio_read = ixgbe_mdio_read;
-	hw->phy.mdio.mdio_write = ixgbe_mdio_write;
+	adapter->bd_number = cards_found;
 
+	ixgbe_get_hw_control(adapter);
 	/* setup the private structure */
-	err = ixgbe_sw_init(adapter, ii);
+	err = ixgbe_sw_init(adapter);
 	if (err)
 		goto err_sw_init;
 
-	switch (adapter->hw.mac.type) {
-	case ixgbe_mac_X550:
-	case ixgbe_mac_X550EM_x:
-		netdev->udp_tunnel_nic_info = &ixgbe_udp_tunnels_x550;
-		break;
-	case ixgbe_mac_x550em_a:
-		netdev->udp_tunnel_nic_info = &ixgbe_udp_tunnels_x550em_a;
-		break;
-	default:
-		break;
-	}
-
 	/* Make sure the SWFW semaphore is in a valid state */
 	if (hw->mac.ops.init_swfw_sync)
 		hw->mac.ops.init_swfw_sync(hw);
@@ -10748,7 +12459,7 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_WUS, ~0);
 		break;
 	default:
@@ -10756,8 +12467,8 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 	/*
-	 * If there is a fan on this device and it has failed log the
-	 * failure.
+	 * If we have a fan, this is as early we know, warn if we
+	 * have had a failure.
 	 */
 	if (adapter->flags & IXGBE_FLAG_FAN_FAIL_CAPABLE) {
 		u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
@@ -10765,19 +12476,23 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			e_crit(probe, "Fan has stopped, replace the adapter\n");
 	}
 
-	if (allow_unsupported_sfp)
-		hw->allow_unsupported_sfp = allow_unsupported_sfp;
+	/*
+	 * check_options must be called before setup_link to set up
+	 * hw->fc completely
+	 */
+	ixgbe_check_options(adapter);
 
 	/* reset_hw fills in the perm_addr as well */
 	hw->phy.reset_if_overtemp = true;
 	err = hw->mac.ops.reset_hw(hw);
 	hw->phy.reset_if_overtemp = false;
-	ixgbe_set_eee_capable(adapter);
 	if (err == IXGBE_ERR_SFP_NOT_PRESENT) {
-		err = 0;
+		err = IXGBE_SUCCESS;
 	} else if (err == IXGBE_ERR_SFP_NOT_SUPPORTED) {
-		e_dev_err("failed to load because an unsupported SFP+ or QSFP module type was detected.\n");
-		e_dev_err("Reload the driver after installing a supported module.\n");
+		e_dev_err("failed to load because an unsupported SFP+ or QSFP "
+			  "module type was detected.\n");
+		e_dev_err("Reload the driver after installing a supported "
+			  "module.\n");
 		goto err_sw_init;
 	} else if (err) {
 		e_dev_err("HW Init failed: %d\n", err);
@@ -10785,53 +12500,49 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 
 #ifdef CONFIG_PCI_IOV
-	/* SR-IOV not supported on the 82598 */
-	if (adapter->hw.mac.type == ixgbe_mac_82598EB)
-		goto skip_sriov;
-	/* Mailbox */
-	ixgbe_init_mbx_params_pf(hw);
-	hw->mbx.ops = ii->mbx_ops;
-	pci_sriov_set_totalvfs(pdev, IXGBE_MAX_VFS_DRV_LIMIT);
-	ixgbe_enable_sriov(adapter, max_vfs);
-skip_sriov:
-
-#endif
-	netdev->features = NETIF_F_SG |
-			   NETIF_F_TSO |
-			   NETIF_F_TSO6 |
-			   NETIF_F_RXHASH |
-			   NETIF_F_RXCSUM |
-			   NETIF_F_HW_CSUM;
+#if defined(HAVE_SRIOV_CONFIGURE) || defined(HAVE_RHEL6_SRIOV_CONFIGURE)
+	if (adapter->max_vfs > 0) {
+		e_dev_warn("Enabling SR-IOV VFs using the max_vfs module parameter is deprecated.\n");
+		e_dev_warn("Please use the pci sysfs interface instead. Ex:\n");
+		e_dev_warn("echo '%d' > /sys/bus/pci/devices/%04x:%02x:%02x.%1x/sriov_numvfs\n",
+			   adapter->max_vfs,
+			   pci_domain_nr(pdev->bus),
+			   pdev->bus->number,
+			   PCI_SLOT(pdev->devfn),
+			   PCI_FUNC(pdev->devfn)
+			   );
+	}
 
-#define IXGBE_GSO_PARTIAL_FEATURES (NETIF_F_GSO_GRE | \
-				    NETIF_F_GSO_GRE_CSUM | \
-				    NETIF_F_GSO_IPXIP4 | \
-				    NETIF_F_GSO_IPXIP6 | \
-				    NETIF_F_GSO_UDP_TUNNEL | \
-				    NETIF_F_GSO_UDP_TUNNEL_CSUM)
+#endif
+	if (adapter->flags & IXGBE_FLAG_SRIOV_CAPABLE) {
+		pci_sriov_set_totalvfs(pdev, IXGBE_MAX_VFS_DRV_LIMIT);
+		ixgbe_enable_sriov(adapter);
+	}
+
+#endif /* CONFIG_PCI_IOV */
+
+#ifdef NETIF_F_GSO_PARTIAL
+	/* keep |= here to avoid conflict with features set in param.c */
+	netdev->features |= NETIF_F_SG |
+			    NETIF_F_TSO |
+			    NETIF_F_TSO6 |
+			    NETIF_F_RXHASH |
+			    NETIF_F_RXCSUM |
+			    NETIF_F_HW_CSUM;
 
 	netdev->gso_partial_features = IXGBE_GSO_PARTIAL_FEATURES;
 	netdev->features |= NETIF_F_GSO_PARTIAL |
 			    IXGBE_GSO_PARTIAL_FEATURES;
 
 	if (hw->mac.type >= ixgbe_mac_82599EB)
-		netdev->features |= NETIF_F_SCTP_CRC | NETIF_F_GSO_UDP_L4;
+		netdev->features |= NETIF_F_SCTP_CRC;
 
-#ifdef CONFIG_IXGBE_IPSEC
-#define IXGBE_ESP_FEATURES	(NETIF_F_HW_ESP | \
-				 NETIF_F_HW_ESP_TX_CSUM | \
-				 NETIF_F_GSO_ESP)
-
-	if (adapter->ipsec)
-		netdev->features |= IXGBE_ESP_FEATURES;
-#endif
 	/* copy netdev features into list of user selectable features */
 	netdev->hw_features |= netdev->features |
 			       NETIF_F_HW_VLAN_CTAG_FILTER |
 			       NETIF_F_HW_VLAN_CTAG_RX |
 			       NETIF_F_HW_VLAN_CTAG_TX |
-			       NETIF_F_RXALL |
-			       NETIF_F_HW_L2FW_DOFFLOAD;
+			       NETIF_F_RXALL;
 
 	if (hw->mac.type >= ixgbe_mac_82599EB)
 		netdev->hw_features |= NETIF_F_NTUPLE |
@@ -10842,11 +12553,7 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	netdev->vlan_features |= netdev->features | NETIF_F_TSO_MANGLEID;
 	netdev->hw_enc_features |= netdev->vlan_features;
-	netdev->mpls_features |= NETIF_F_SG |
-				 NETIF_F_TSO |
-				 NETIF_F_TSO6 |
-				 NETIF_F_HW_CSUM;
-	netdev->mpls_features |= IXGBE_GSO_PARTIAL_FEATURES;
+	netdev->mpls_features |= NETIF_F_HW_CSUM;
 
 	/* set this bit last since it cannot be part of vlan_features */
 	netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER |
@@ -10856,58 +12563,191 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	netdev->priv_flags |= IFF_UNICAST_FLT;
 	netdev->priv_flags |= IFF_SUPP_NOFCS;
 
+	/* give us the option of enabling RSC/LRO later */
+	if (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)
+		netdev->hw_features |= NETIF_F_LRO;
+
+#else	/* NETIF_F_GSO_PARTIAL */
+	/* keep |= here to avoid conflict with features set in param.c */
+	netdev->features |= NETIF_F_SG |
+			    NETIF_F_IP_CSUM;
+
+#ifdef NETIF_F_IPV6_CSUM
+	netdev->features |= NETIF_F_IPV6_CSUM;
+#endif
+
+#ifdef NETIF_F_HW_VLAN_CTAG_TX
+	netdev->features |= NETIF_F_HW_VLAN_CTAG_TX |
+			    NETIF_F_HW_VLAN_CTAG_FILTER |
+			    NETIF_F_HW_VLAN_CTAG_RX;
+#endif
+
+#ifdef NETIF_F_HW_VLAN_TX
+	netdev->features |= NETIF_F_HW_VLAN_TX |
+			    NETIF_F_HW_VLAN_FILTER |
+			    NETIF_F_HW_VLAN_RX;
+#endif
+	netdev->features |= ixgbe_tso_features();
+#ifdef NETIF_F_RXHASH
+	netdev->features |= NETIF_F_RXHASH;
+#endif /* NETIF_F_RXHASH */
+	netdev->features |= NETIF_F_RXCSUM;
+
+#ifdef HAVE_NDO_SET_FEATURES
+	/* copy netdev features into list of user selectable features */
+#ifndef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+	hw_features = netdev->hw_features;
+#else
+	hw_features = get_netdev_hw_features(netdev);
+#endif
+	hw_features |= netdev->features;
+
+	/* give us the option of enabling RSC/LRO later */
+	if (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)
+		hw_features |= NETIF_F_LRO;
+
+#else
+#ifdef NETIF_F_GRO
+
+	/* this is only needed on kernels prior to 2.6.39 */
+	netdev->features |= NETIF_F_GRO;
+#endif /* NETIF_F_GRO */
+#endif /* HAVE_NDO_SET_FEATURES */
+
+	switch (adapter->hw.mac.type) {
+	case ixgbe_mac_82599EB:
+	case ixgbe_mac_X540:
+	case ixgbe_mac_X550:
+	case ixgbe_mac_X550EM_x:
+	case ixgbe_mac_X550EM_a:
+		netdev->features |= NETIF_F_SCTP_CSUM;
+#ifdef HAVE_NDO_SET_FEATURES
+		hw_features |= NETIF_F_SCTP_CSUM |
+#ifdef NETIF_F_HW_TC
+			       NETIF_F_HW_TC |
+#endif
+			       NETIF_F_NTUPLE;
+#endif
+		break;
+	default:
+		break;
+	}
+#ifdef HAVE_NDO_SET_FEATURES
+#ifdef HAVE_RHEL6_NET_DEVICE_OPS_EXT
+	set_netdev_hw_features(netdev, hw_features);
+#else
+	netdev->hw_features = hw_features;
+#endif
+#endif
+
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+	netdev->vlan_features |= NETIF_F_SG |
+				 NETIF_F_IP_CSUM |
+				 NETIF_F_IPV6_CSUM |
+				 NETIF_F_TSO |
+				 NETIF_F_TSO6;
+
+#endif /* HAVE_NETDEV_VLAN_FEATURES */
+#ifdef HAVE_ENCAP_CSUM_OFFLOAD
+	netdev->hw_enc_features |= NETIF_F_SG;
+#endif /* HAVE_ENCAP_CSUM_OFFLOAD */
+#ifdef HAVE_VXLAN_RX_OFFLOAD
+	if (adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE) {
+		netdev->hw_enc_features |= NETIF_F_IP_CSUM |
+					   NETIF_F_IPV6_CSUM;
+	}
+#endif /* NETIF_F_GSO_PARTIAL */
+
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
+	if (netdev->features & NETIF_F_LRO) {
+		if ((adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) &&
+		    ((adapter->rx_itr_setting == 1) ||
+		     (adapter->rx_itr_setting > IXGBE_MIN_RSC_ITR))) {
+			adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
+		} else if (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) {
+			e_dev_info("InterruptThrottleRate set too high, "
+				   "disabling RSC\n");
+		}
+	}
+#ifdef IFF_UNICAST_FLT
+	netdev->priv_flags |= IFF_UNICAST_FLT;
+#endif
+#ifdef IFF_SUPP_NOFCS
+	netdev->priv_flags |= IFF_SUPP_NOFCS;
+#endif
+
+#ifdef HAVE_NETDEVICE_MIN_MAX_MTU
 	/* MTU range: 68 - 9710 */
+#ifdef HAVE_RHEL7_EXTENDED_MIN_MAX_MTU
+	netdev->extended->min_mtu = ETH_MIN_MTU;
+	netdev->extended->max_mtu = IXGBE_MAX_JUMBO_FRAME_SIZE -
+				    (ETH_HLEN + ETH_FCS_LEN);
+#else
 	netdev->min_mtu = ETH_MIN_MTU;
 	netdev->max_mtu = IXGBE_MAX_JUMBO_FRAME_SIZE - (ETH_HLEN + ETH_FCS_LEN);
+#endif
 
-#ifdef CONFIG_IXGBE_DCB
+#endif
+#if IS_ENABLED(CONFIG_DCB)
 	if (adapter->flags & IXGBE_FLAG_DCB_CAPABLE)
 		netdev->dcbnl_ops = &ixgbe_dcbnl_ops;
-#endif
 
-#ifdef IXGBE_FCOE
+#endif /* CONFIG_DCB */
+#if IS_ENABLED(CONFIG_FCOE)
+#ifdef NETIF_F_FSO
 	if (adapter->flags & IXGBE_FLAG_FCOE_CAPABLE) {
 		unsigned int fcoe_l;
 
-		if (hw->mac.ops.get_device_caps) {
-			hw->mac.ops.get_device_caps(hw, &device_caps);
-			if (device_caps & IXGBE_DEVICE_CAPS_FCOE_OFFLOADS)
-				adapter->flags &= ~IXGBE_FLAG_FCOE_CAPABLE;
+		hw->mac.ops.get_device_caps(hw, &device_caps);
+		if (device_caps & IXGBE_DEVICE_CAPS_FCOE_OFFLOADS) {
+			adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
+			adapter->flags &= ~IXGBE_FLAG_FCOE_CAPABLE;
+			e_dev_info("FCoE offload feature is not available. "
+				   "Disabling FCoE offload feature\n");
+		} else {
+			netdev->features |= NETIF_F_FSO |
+					    NETIF_F_FCOE_CRC;
+#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE
+			ixgbe_fcoe_ddp_enable(adapter);
+			adapter->flags |= IXGBE_FLAG_FCOE_ENABLED;
+			netdev->features |= NETIF_F_FCOE_MTU;
+#endif /* HAVE_NETDEV_OPS_FCOE_ENABLE */
 		}
 
-
 		fcoe_l = min_t(int, IXGBE_FCRETA_SIZE, num_online_cpus());
 		adapter->ring_feature[RING_F_FCOE].limit = fcoe_l;
 
-		netdev->features |= NETIF_F_FSO |
-				    NETIF_F_FCOE_CRC;
-
+#ifdef HAVE_NETDEV_VLAN_FEATURES
 		netdev->vlan_features |= NETIF_F_FSO |
 					 NETIF_F_FCOE_CRC |
 					 NETIF_F_FCOE_MTU;
+#endif /* HAVE_NETDEV_VLAN_FEATURES */
+	}
+#endif /* NETIF_F_FSO */
+#endif /* CONFIG_FCOE */
+	if (pci_using_dac) {
+		netdev->features |= NETIF_F_HIGHDMA;
+#ifdef HAVE_NETDEV_VLAN_FEATURES
+		netdev->vlan_features |= NETIF_F_HIGHDMA;
+#endif /* HAVE_NETDEV_VLAN_FEATURES */
 	}
-#endif /* IXGBE_FCOE */
-	if (adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)
-		netdev->hw_features |= NETIF_F_LRO;
-	if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)
-		netdev->features |= NETIF_F_LRO;
 
 	if (ixgbe_check_fw_error(adapter)) {
 		err = -EIO;
 		goto err_sw_init;
 	}
 
-	/* make sure the EEPROM is good */
-	if (hw->eeprom.ops.validate_checksum(hw, NULL) < 0) {
+	if (hw->eeprom.ops.validate_checksum  &&
+	    (hw->eeprom.ops.validate_checksum(hw, NULL) < 0)) {
 		e_dev_err("The EEPROM Checksum Is Not Valid\n");
 		err = -EIO;
 		goto err_sw_init;
 	}
 
-	eth_platform_get_mac_address(&adapter->pdev->dev,
-				     adapter->hw.mac.perm_addr);
-
 	memcpy(netdev->dev_addr, hw->mac.perm_addr, netdev->addr_len);
+#ifdef ETHTOOL_GPERMADDR
+	memcpy(netdev->perm_addr, hw->mac.perm_addr, netdev->addr_len);
+#endif
 
 	if (!is_valid_ether_addr(netdev->dev_addr)) {
 		e_dev_err("invalid MAC address\n");
@@ -10921,7 +12761,7 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	timer_setup(&adapter->service_timer, ixgbe_service_timer, 0);
 
-	if (ixgbe_removed(hw->hw_addr)) {
+	if (IXGBE_REMOVED(hw->hw_addr)) {
 		err = -EIO;
 		goto err_sw_init;
 	}
@@ -10933,62 +12773,19 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (err)
 		goto err_sw_init;
 
-	for (i = 0; i < adapter->num_rx_queues; i++)
-		u64_stats_init(&adapter->rx_ring[i]->syncp);
-	for (i = 0; i < adapter->num_tx_queues; i++)
-		u64_stats_init(&adapter->tx_ring[i]->syncp);
 	for (i = 0; i < adapter->num_xdp_queues; i++)
 		u64_stats_init(&adapter->xdp_ring[i]->syncp);
-
 	/* WOL not supported for all devices */
 	adapter->wol = 0;
 	hw->eeprom.ops.read(hw, 0x2c, &adapter->eeprom_cap);
-	hw->wol_enabled = ixgbe_wol_supported(adapter, pdev->device,
-						pdev->subsystem_device);
-	if (hw->wol_enabled)
+	if (ixgbe_wol_supported(adapter, pdev->device, pdev->subsystem_device))
 		adapter->wol = IXGBE_WUFC_MAG;
 
-	device_set_wakeup_enable(&adapter->pdev->dev, adapter->wol);
-
-	/* save off EEPROM version number */
-	ixgbe_set_fw_version(adapter);
-
-	/* pick up the PCI bus settings for reporting later */
-	if (ixgbe_pcie_from_parent(hw))
-		ixgbe_get_parent_bus_info(adapter);
-	else
-		 hw->mac.ops.get_bus_info(hw);
-
-	/* calculate the expected PCIe bandwidth required for optimal
-	 * performance. Note that some older parts will never have enough
-	 * bandwidth due to being older generation PCIe parts. We clamp these
-	 * parts to ensure no warning is displayed if it can't be fixed.
-	 */
-	switch (hw->mac.type) {
-	case ixgbe_mac_82598EB:
-		expected_gts = min(ixgbe_enumerate_functions(adapter) * 10, 16);
-		break;
-	default:
-		expected_gts = ixgbe_enumerate_functions(adapter) * 10;
-		break;
-	}
-
-	/* don't check link if we failed to enumerate functions */
-	if (expected_gts > 0)
-		ixgbe_check_minimum_link(adapter, expected_gts);
+	hw->wol_enabled = !!(adapter->wol);
 
-	err = ixgbe_read_pba_string_generic(hw, part_str, sizeof(part_str));
-	if (err)
-		strlcpy(part_str, "Unknown", sizeof(part_str));
-	if (ixgbe_is_sfp(hw) && hw->phy.sfp_type != ixgbe_sfp_type_not_present)
-		e_dev_info("MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n",
-			   hw->mac.type, hw->phy.type, hw->phy.sfp_type,
-			   part_str);
-	else
-		e_dev_info("MAC: %d, PHY: %d, PBA No: %s\n",
-			   hw->mac.type, hw->phy.type, part_str);
+	device_set_wakeup_enable(pci_dev_to_dev(adapter->pdev), adapter->wol);
 
-	e_dev_info("%pM\n", netdev->dev_addr);
+	ixgbe_set_fw_version(adapter);
 
 	/* reset the hardware with the new settings */
 	err = hw->mac.ops.start_hw(hw);
@@ -11000,13 +12797,36 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			   "problems please contact your Intel or hardware "
 			   "representative who provided you with this "
 			   "hardware.\n");
+	} else if (err == IXGBE_ERR_OVERTEMP) {
+		e_crit(drv, "%s\n", ixgbe_overheat_msg);
+		goto err_register;
+	} else if (err) {
+		e_dev_err("HW init failed\n");
+		goto err_register;
 	}
-	strcpy(netdev->name, "eth%d");
+
+	/* pick up the PCI bus settings for reporting later */
+	if (ixgbe_pcie_from_parent(hw))
+		ixgbe_get_parent_bus_info(hw);
+	else
+		if (hw->mac.ops.get_bus_info)
+			hw->mac.ops.get_bus_info(hw);
+
+	strscpy(netdev->name, "eth%d", sizeof(netdev->name));
 	pci_set_drvdata(pdev, adapter);
 	err = register_netdev(netdev);
 	if (err)
 		goto err_register;
+	adapter->netdev_registered = true;
 
+#ifdef HAVE_PCI_ERS
+	/*
+	 * call save state here in standalone driver because it relies on
+	 * adapter struct to exist, and needs to call netdev_priv
+	 */
+	pci_save_state(pdev);
+
+#endif
 
 	/* power down the optics for 82599 SFP+ fiber */
 	if (hw->mac.ops.disable_tx_laser)
@@ -11014,38 +12834,115 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	/* carrier off reporting is important to ethtool even BEFORE open */
 	netif_carrier_off(netdev);
+	/* keep stopping all the transmit queues for older kernels */
+	netif_tx_stop_all_queues(netdev);
 
-#ifdef CONFIG_IXGBE_DCA
-	if (dca_add_requester(&pdev->dev) == 0) {
-		adapter->flags |= IXGBE_FLAG_DCA_ENABLED;
-		ixgbe_setup_dca(adapter);
+#if IS_ENABLED(CONFIG_DCA)
+	if (adapter->flags & IXGBE_FLAG_DCA_CAPABLE) {
+		err = dca_add_requester(pci_dev_to_dev(pdev));
+		switch (err) {
+		case IXGBE_SUCCESS:
+			adapter->flags |= IXGBE_FLAG_DCA_ENABLED;
+			ixgbe_setup_dca(adapter);
+			break;
+		/* -19 is returned from the kernel when no provider is found */
+		case -19:
+			e_info(rx_err, "No DCA provider found. Please "
+			       "start ioatdma for DCA functionality.\n");
+			break;
+		default:
+			e_info(probe, "DCA registration failed: %d\n", err);
+			break;
+		}
 	}
 #endif
+
+	/* print all messages at the end so that we use our eth%d name */
+	ixgbe_check_minimum_link(adapter);
+
+	/* First try to read PBA as a string */
+	err = ixgbe_read_pba_string(hw, part_str, IXGBE_PBANUM_LENGTH);
+	if (err)
+		strscpy(part_str, "Unknown", IXGBE_PBANUM_LENGTH);
+	if (ixgbe_is_sfp(hw) && hw->phy.sfp_type != ixgbe_sfp_type_not_present)
+		e_info(probe, "MAC: %d, PHY: %d, SFP+: %d, PBA No: %s\n",
+		       hw->mac.type, hw->phy.type, hw->phy.sfp_type, part_str);
+	else
+		e_info(probe, "MAC: %d, PHY: %d, PBA No: %s\n",
+		      hw->mac.type, hw->phy.type, part_str);
+
+	e_dev_info("%02x:%02x:%02x:%02x:%02x:%02x\n",
+		   netdev->dev_addr[0], netdev->dev_addr[1],
+		   netdev->dev_addr[2], netdev->dev_addr[3],
+		   netdev->dev_addr[4], netdev->dev_addr[5]);
+
+#define INFO_STRING_LEN 255
+	info_string = kzalloc(INFO_STRING_LEN, GFP_KERNEL);
+	if (!info_string) {
+		e_err(probe, "allocation for info string failed\n");
+		goto no_info_string;
+	}
+	snprintf(info_string, INFO_STRING_LEN,
+		 "Enabled Features: RxQ: %d TxQ: %d",
+		 adapter->num_rx_queues, adapter->num_tx_queues);
+#if IS_ENABLED(CONFIG_FCOE)
+	if (adapter->flags & IXGBE_FLAG_FCOE_ENABLED)
+		strlcat(info_string, " FCoE", INFO_STRING_LEN);
+#endif
+	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE)
+		strlcat(info_string, " FdirHash", INFO_STRING_LEN);
+	if (adapter->flags & IXGBE_FLAG_DCB_ENABLED)
+		strlcat(info_string, " DCB", INFO_STRING_LEN);
+	if (adapter->flags & IXGBE_FLAG_DCA_ENABLED)
+		strlcat(info_string, " DCA", INFO_STRING_LEN);
+	if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)
+		strlcat(info_string, " RSC", INFO_STRING_LEN);
+	if (adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_ENABLE)
+		strlcat(info_string, " vxlan_rx", INFO_STRING_LEN);
+
+	/* end features printing */
+	e_info(probe, "%s\n", info_string);
+	kfree(info_string);
+no_info_string:
+#ifdef CONFIG_PCI_IOV
 	if (adapter->flags & IXGBE_FLAG_SRIOV_ENABLED) {
-		e_info(probe, "IOV is enabled with %d VFs\n", adapter->num_vfs);
+		int i;
 		for (i = 0; i < adapter->num_vfs; i++)
 			ixgbe_vf_configuration(pdev, (i | 0x10000000));
 	}
+#endif
 
-	/* firmware requires driver version to be 0xFFFFFFFF
-	 * since os does not support feature
-	 */
+	/* Initialize the LED link active for LED blink support */
+	if (hw->mac.ops.init_led_link_act)
+		hw->mac.ops.init_led_link_act(hw);
+
+	/* firmware requires blank numerical version */
 	if (hw->mac.ops.set_fw_drv_ver)
 		hw->mac.ops.set_fw_drv_ver(hw, 0xFF, 0xFF, 0xFF, 0xFF,
-					   sizeof(UTS_RELEASE) - 1,
-					   UTS_RELEASE);
+					   sizeof(ixgbe_driver_version) - 1,
+					   ixgbe_driver_version);
 
+#if defined(HAVE_NETDEV_STORAGE_ADDRESS) && defined(NETDEV_HW_ADDR_T_SAN)
 	/* add san mac addr to netdev */
 	ixgbe_add_sanmac_netdev(netdev);
 
-	e_dev_info("%s\n", ixgbe_default_device_descr);
+#endif /* (HAVE_NETDEV_STORAGE_ADDRESS) && (NETDEV_HW_ADDR_T_SAN) */
+	e_info(probe, "Intel(R) 10 Gigabit Network Connection\n");
+	cards_found++;
 
-#ifdef CONFIG_IXGBE_HWMON
+#ifdef IXGBE_SYSFS
 	if (ixgbe_sysfs_init(adapter))
 		e_err(probe, "failed to allocate sysfs resources\n");
-#endif /* CONFIG_IXGBE_HWMON */
+#else
+#ifdef IXGBE_PROCFS
+	if (ixgbe_procfs_init(adapter))
+		e_err(probe, "failed to allocate procfs resources\n");
+#endif /* IXGBE_PROCFS */
+#endif /* IXGBE_SYSFS */
+#ifdef HAVE_IXGBE_DEBUG_FS
 
 	ixgbe_dbg_adapter_init(adapter);
+#endif /* HAVE_IXGBE_DEBUG_FS */
 
 	/* setup link for SFP devices with MNG FW, else wait for IXGBE_UP */
 	if (ixgbe_mng_enabled(hw) && ixgbe_is_sfp(hw) && hw->mac.ops.setup_link)
@@ -11053,25 +12950,29 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			IXGBE_LINK_SPEED_10GB_FULL | IXGBE_LINK_SPEED_1GB_FULL,
 			true);
 
-	err = ixgbe_mii_bus_init(hw);
-	if (err)
-		goto err_netdev;
+	if (hw->mac.ops.setup_eee &&
+	    (adapter->flags2 & IXGBE_FLAG2_EEE_CAPABLE)) {
+		bool eee_enable = !!(adapter->flags2 & IXGBE_FLAG2_EEE_ENABLED);
+
+		hw->mac.ops.setup_eee(hw, eee_enable);
+	}
 
 	return 0;
 
-err_netdev:
-	unregister_netdev(netdev);
 err_register:
-	ixgbe_release_hw_control(adapter);
 	ixgbe_clear_interrupt_scheme(adapter);
 err_sw_init:
+	ixgbe_release_hw_control(adapter);
+#ifdef CONFIG_PCI_IOV
 	ixgbe_disable_sriov(adapter);
+#endif /* CONFIG_PCI_IOV */
 	adapter->flags2 &= ~IXGBE_FLAG2_SEARCH_FOR_SFP;
-	iounmap(adapter->io_addr);
+#ifdef HAVE_TC_SETUP_CLSU32
 	kfree(adapter->jump_tables[0]);
+#endif
 	kfree(adapter->mac_table);
 	kfree(adapter->rss_key);
-	bitmap_free(adapter->af_xdp_zc_qps);
+	iounmap(adapter->io_addr);
 err_ioremap:
 	disable_dev = !test_and_set_bit(__IXGBE_DISABLED, &adapter->state);
 	free_netdev(netdev);
@@ -11093,63 +12994,78 @@ static int ixgbe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  * Hot-Plug event, or because the driver is going to be removed from
  * memory.
  **/
+#ifdef HAVE_CONFIG_HOTPLUG
+static void __devexit ixgbe_remove(struct pci_dev *pdev)
+#else
 static void ixgbe_remove(struct pci_dev *pdev)
+#endif
 {
 	struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
 	struct net_device *netdev;
 	bool disable_dev;
+#ifdef HAVE_TC_SETUP_CLSU32
 	int i;
+#endif
 
 	/* if !adapter then we already cleaned up in probe */
 	if (!adapter)
 		return;
 
-	netdev  = adapter->netdev;
+	netdev = adapter->netdev;
+#ifdef HAVE_IXGBE_DEBUG_FS
 	ixgbe_dbg_adapter_exit(adapter);
 
+#endif /*HAVE_IXGBE_DEBUG_FS */
 	set_bit(__IXGBE_REMOVING, &adapter->state);
 	cancel_work_sync(&adapter->service_task);
 
-	if (adapter->mii_bus)
-		mdiobus_unregister(adapter->mii_bus);
-
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 	if (adapter->flags & IXGBE_FLAG_DCA_ENABLED) {
 		adapter->flags &= ~IXGBE_FLAG_DCA_ENABLED;
-		dca_remove_requester(&pdev->dev);
+		dca_remove_requester(pci_dev_to_dev(pdev));
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_DCA_CTRL,
 				IXGBE_DCA_CTRL_DCA_DISABLE);
 	}
+#endif /* CONFIG_DCA */
 
-#endif
-#ifdef CONFIG_IXGBE_HWMON
+#ifdef IXGBE_SYSFS
 	ixgbe_sysfs_exit(adapter);
-#endif /* CONFIG_IXGBE_HWMON */
+#else
+#ifdef IXGBE_PROCFS
+	ixgbe_procfs_exit(adapter);
+#endif /* IXGBE_PROCFS */
+#endif /* IXGBE-SYSFS */
 
+#if defined(HAVE_NETDEV_STORAGE_ADDRESS) && defined(NETDEV_HW_ADDR_T_SAN)
 	/* remove the added san mac */
 	ixgbe_del_sanmac_netdev(netdev);
 
+#endif /* (HAVE_NETDEV_STORAGE_ADDRESS) && (NETDEV_HW_ADDR_T_SAN) */
+
 #ifdef CONFIG_PCI_IOV
 	ixgbe_disable_sriov(adapter);
-#endif
-	if (netdev->reg_state == NETREG_REGISTERED)
+#endif /* CONFIG_PCI_IOV */
+	if (adapter->netdev_registered) {
 		unregister_netdev(netdev);
+		adapter->netdev_registered = false;
+	}
 
-	ixgbe_stop_ipsec_offload(adapter);
+#if IS_ENABLED(CONFIG_FCOE)
+#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE
+	ixgbe_fcoe_ddp_disable(adapter);
+#endif
+#endif /* CONFIG_FCOE */
 	ixgbe_clear_interrupt_scheme(adapter);
-
 	ixgbe_release_hw_control(adapter);
 
-#ifdef CONFIG_DCB
+#ifdef HAVE_DCBNL_IEEE
 	kfree(adapter->ixgbe_ieee_pfc);
 	kfree(adapter->ixgbe_ieee_ets);
 
 #endif
 	iounmap(adapter->io_addr);
 	pci_release_mem_regions(pdev);
-
-	e_dev_info("complete\n");
-
+#ifdef HAVE_TC_SETUP_CLSU32
 	for (i = 0; i < IXGBE_MAX_LINK_HANDLE; i++) {
 		if (adapter->jump_tables[i]) {
 			kfree(adapter->jump_tables[i]->input);
@@ -11157,10 +13073,9 @@ static void ixgbe_remove(struct pci_dev *pdev)
 		}
 		kfree(adapter->jump_tables[i]);
 	}
-
+#endif /* HAVE_TC_SETUP_CLSU32 */
 	kfree(adapter->mac_table);
 	kfree(adapter->rss_key);
-	bitmap_free(adapter->af_xdp_zc_qps);
 	disable_dev = !test_and_set_bit(__IXGBE_DISABLED, &adapter->state);
 	free_netdev(netdev);
 
@@ -11168,8 +13083,70 @@ static void ixgbe_remove(struct pci_dev *pdev)
 
 	if (disable_dev)
 		pci_disable_device(pdev);
+
+}
+
+static bool ixgbe_check_cfg_remove(struct ixgbe_hw *hw, struct pci_dev *pdev)
+{
+	u16 value;
+
+	pci_read_config_word(pdev, PCI_VENDOR_ID, &value);
+	if (value == IXGBE_FAILED_READ_CFG_WORD) {
+		ixgbe_remove_adapter(hw);
+		return true;
+	}
+	return false;
+}
+
+u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg)
+{
+	struct ixgbe_adapter *adapter = hw->back;
+	u16 value;
+
+	if (IXGBE_REMOVED(hw->hw_addr))
+		return IXGBE_FAILED_READ_CFG_WORD;
+	pci_read_config_word(adapter->pdev, reg, &value);
+	if (value == IXGBE_FAILED_READ_CFG_WORD &&
+	    ixgbe_check_cfg_remove(hw, adapter->pdev))
+		return IXGBE_FAILED_READ_CFG_WORD;
+	return value;
+}
+
+#ifdef HAVE_PCI_ERS
+#ifdef CONFIG_PCI_IOV
+static u32 ixgbe_read_pci_cfg_dword(struct ixgbe_hw *hw, u32 reg)
+{
+	struct ixgbe_adapter *adapter = hw->back;
+	u32 value;
+
+	if (IXGBE_REMOVED(hw->hw_addr))
+		return IXGBE_FAILED_READ_CFG_DWORD;
+	pci_read_config_dword(adapter->pdev, reg, &value);
+	if (value == IXGBE_FAILED_READ_CFG_DWORD &&
+	    ixgbe_check_cfg_remove(hw, adapter->pdev))
+		return IXGBE_FAILED_READ_CFG_DWORD;
+	return value;
+}
+#endif /* CONFIG_PCI_IOV */
+#endif /* HAVE_PCI_ERS */
+
+void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value)
+{
+	struct ixgbe_adapter *adapter = hw->back;
+
+	if (IXGBE_REMOVED(hw->hw_addr))
+		return;
+	pci_write_config_word(adapter->pdev, reg, value);
+}
+
+void ewarn(struct ixgbe_hw *hw, const char *st)
+{
+	struct ixgbe_adapter *adapter = hw->back;
+
+	netif_warn(adapter, drv, adapter->netdev,  "%s", st);
 }
 
+#ifdef HAVE_PCI_ERS
 /**
  * ixgbe_io_error_detected - called when PCI error is detected
  * @pdev: Pointer to PCI device
@@ -11210,7 +13187,7 @@ static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev,
 	dw1 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG + 4);
 	dw2 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG + 8);
 	dw3 = ixgbe_read_pci_cfg_dword(hw, pos + PCI_ERR_HEADER_LOG + 12);
-	if (ixgbe_removed(hw->hw_addr))
+	if (IXGBE_REMOVED(hw->hw_addr))
 		goto skip_bad_vf_detection;
 
 	req_id = dw1 >> 16;
@@ -11229,10 +13206,10 @@ static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev,
 		dw0, dw1, dw2, dw3);
 		switch (adapter->hw.mac.type) {
 		case ixgbe_mac_82599EB:
-			device_id = IXGBE_82599_VF_DEVICE_ID;
+			device_id = IXGBE_DEV_ID_82599_VF;
 			break;
 		case ixgbe_mac_X540:
-			device_id = IXGBE_X540_VF_DEVICE_ID;
+			device_id = IXGBE_DEV_ID_X540_VF;
 			break;
 		case ixgbe_mac_X550:
 			device_id = IXGBE_DEV_ID_X550_VF;
@@ -11240,7 +13217,7 @@ static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev,
 		case ixgbe_mac_X550EM_x:
 			device_id = IXGBE_DEV_ID_X550EM_X_VF;
 			break;
-		case ixgbe_mac_x550em_a:
+		case ixgbe_mac_X550EM_a:
 			device_id = IXGBE_DEV_ID_X550EM_A_VF;
 			break;
 		default:
@@ -11262,10 +13239,12 @@ static pci_ers_result_t ixgbe_io_error_detected(struct pci_dev *pdev,
 		 * VFLR.  Just clean up the AER in that case.
 		 */
 		if (vfdev) {
-			pcie_flr(vfdev);
+			ixgbe_issue_vf_flr(adapter, vfdev);
 			/* Free device reference count */
 			pci_dev_put(vfdev);
 		}
+
+		pci_aer_clear_nonfatal_status(pdev);
 	}
 
 	/*
@@ -11325,6 +13304,10 @@ static pci_ers_result_t ixgbe_io_slot_reset(struct pci_dev *pdev)
 		adapter->hw.hw_addr = adapter->io_addr;
 		pci_set_master(pdev);
 		pci_restore_state(pdev);
+		/*
+		 * After second error pci->state_saved is false, this
+		 * resets it so EEH doesn't break.
+		 */
 		pci_save_state(pdev);
 
 		pci_wake_from_d3(pdev, false);
@@ -11334,6 +13317,8 @@ static pci_ers_result_t ixgbe_io_slot_reset(struct pci_dev *pdev)
 		result = PCI_ERS_RESULT_RECOVERED;
 	}
 
+	pci_aer_clear_nonfatal_status(pdev);
+
 	return result;
 }
 
@@ -11365,25 +13350,87 @@ static void ixgbe_io_resume(struct pci_dev *pdev)
 	rtnl_unlock();
 }
 
+#ifdef HAVE_CONST_STRUCT_PCI_ERROR_HANDLERS
 static const struct pci_error_handlers ixgbe_err_handler = {
+#else
+static struct pci_error_handlers ixgbe_err_handler = {
+#endif
 	.error_detected = ixgbe_io_error_detected,
 	.slot_reset = ixgbe_io_slot_reset,
 	.resume = ixgbe_io_resume,
 };
+#endif /* HAVE_PCI_ERS */
+
+struct net_device *ixgbe_hw_to_netdev(const struct ixgbe_hw *hw)
+{
+	return ((struct ixgbe_adapter *)hw->back)->netdev;
+}
+struct ixgbe_msg *ixgbe_hw_to_msg(const struct ixgbe_hw *hw)
+{
+	struct ixgbe_adapter *adapter =
+		container_of(hw, struct ixgbe_adapter, hw);
+	return (struct ixgbe_msg *)&adapter->msg_enable;
+}
+
+#ifdef HAVE_RHEL6_SRIOV_CONFIGURE
+static struct pci_driver_rh ixgbe_driver_rh = {
+	.sriov_configure = ixgbe_pci_sriov_configure,
+};
+#endif
 
-static SIMPLE_DEV_PM_OPS(ixgbe_pm_ops, ixgbe_suspend, ixgbe_resume);
+#ifdef CONFIG_PM
+#ifndef USE_LEGACY_PM_SUPPORT
+static const struct dev_pm_ops ixgbe_pm_ops = {
+	.suspend        = ixgbe_suspend,
+	.resume         = ixgbe_resume,
+	.freeze         = ixgbe_freeze,
+	.thaw           = ixgbe_thaw,
+	.poweroff       = ixgbe_suspend,
+	.restore        = ixgbe_resume,
+};
+#endif /* USE_LEGACY_PM_SUPPORT */
+#endif
 
 static struct pci_driver ixgbe_driver = {
-	.name      = ixgbe_driver_name,
-	.id_table  = ixgbe_pci_tbl,
-	.probe     = ixgbe_probe,
-	.remove    = ixgbe_remove,
-	.driver.pm = &ixgbe_pm_ops,
-	.shutdown  = ixgbe_shutdown,
+	.name     = ixgbe_driver_name,
+	.id_table = ixgbe_pci_tbl,
+	.probe    = ixgbe_probe,
+#ifdef HAVE_CONFIG_HOTPLUG
+	.remove   = __devexit_p(ixgbe_remove),
+#else
+	.remove   = ixgbe_remove,
+#endif
+#ifdef CONFIG_PM
+#ifndef USE_LEGACY_PM_SUPPORT
+	.driver = {
+		.pm = &ixgbe_pm_ops,
+	},
+#else
+	.suspend  = ixgbe_suspend,
+	.resume   = ixgbe_resume,
+#endif /* USE_LEGACY_PM_SUPPORT */
+#endif
+#ifndef USE_REBOOT_NOTIFIER
+	.shutdown = ixgbe_shutdown,
+#endif
+#if defined(HAVE_SRIOV_CONFIGURE)
 	.sriov_configure = ixgbe_pci_sriov_configure,
+#elif defined(HAVE_RHEL6_SRIOV_CONFIGURE)
+	.rh_reserved = &ixgbe_driver_rh,
+#endif /* HAVE_SRIOV_CONFIGURE */
+#ifdef HAVE_PCI_ERS
 	.err_handler = &ixgbe_err_handler
+#endif
 };
 
+bool ixgbe_is_ixgbe(struct pci_dev *pcidev)
+{
+	if (pci_dev_driver(pcidev) != &ixgbe_driver)
+		return false;
+	else
+		return true;
+}
+
 /**
  * ixgbe_init_module - Driver Registration Routine
  *
@@ -11393,7 +13440,7 @@ static struct pci_driver ixgbe_driver = {
 static int __init ixgbe_init_module(void)
 {
 	int ret;
-	pr_info("%s\n", ixgbe_driver_string);
+	pr_info("%s - version %s\n", ixgbe_driver_string, ixgbe_driver_version);
 	pr_info("%s\n", ixgbe_copyright);
 
 	ixgbe_wq = create_singlethread_workqueue(ixgbe_driver_name);
@@ -11402,20 +13449,32 @@ static int __init ixgbe_init_module(void)
 		return -ENOMEM;
 	}
 
+#ifdef IXGBE_PROCFS
+	if (ixgbe_procfs_topdir_init())
+		pr_info("Procfs failed to initialize topdir\n");
+#endif
+
+#ifdef HAVE_IXGBE_DEBUG_FS
 	ixgbe_dbg_init();
+#endif /* HAVE_IXGBE_DEBUG_FS */
 
 	ret = pci_register_driver(&ixgbe_driver);
 	if (ret) {
 		destroy_workqueue(ixgbe_wq);
+#ifdef HAVE_IXGBE_DEBUG_FS
 		ixgbe_dbg_exit();
+#endif /* HAVE_IXGBE_DEBUG_FS */
+#ifdef IXGBE_PROCFS
+		ixgbe_procfs_topdir_exit();
+#endif
 		return ret;
-	}
+}
+#if IS_ENABLED(CONFIG_DCA)
 
-#ifdef CONFIG_IXGBE_DCA
 	dca_register_notify(&dca_notifier);
 #endif
 
-	return 0;
+	return ret;
 }
 
 module_init(ixgbe_init_module);
@@ -11428,21 +13487,22 @@ module_init(ixgbe_init_module);
  **/
 static void __exit ixgbe_exit_module(void)
 {
-#ifdef CONFIG_IXGBE_DCA
+#if IS_ENABLED(CONFIG_DCA)
 	dca_unregister_notify(&dca_notifier);
 #endif
 	pci_unregister_driver(&ixgbe_driver);
-
+#ifdef IXGBE_PROCFS
+	ixgbe_procfs_topdir_exit();
+#endif
+	destroy_workqueue(ixgbe_wq);
+#ifdef HAVE_IXGBE_DEBUG_FS
 	ixgbe_dbg_exit();
-	if (ixgbe_wq) {
-		destroy_workqueue(ixgbe_wq);
-		ixgbe_wq = NULL;
-	}
+#endif /* HAVE_IXGBE_DEBUG_FS */
 }
 
-#ifdef CONFIG_IXGBE_DCA
-static int ixgbe_notify_dca(struct notifier_block *nb, unsigned long event,
-			    void *p)
+#if IS_ENABLED(CONFIG_DCA)
+static int ixgbe_notify_dca(struct notifier_block __always_unused *nb, unsigned long event,
+			    void __always_unused *p)
 {
 	int ret_val;
 
@@ -11451,9 +13511,8 @@ static int ixgbe_notify_dca(struct notifier_block *nb, unsigned long event,
 
 	return ret_val ? NOTIFY_BAD : NOTIFY_DONE;
 }
-
-#endif /* CONFIG_IXGBE_DCA */
-
+#endif
 module_exit(ixgbe_exit_module);
 
 /* ixgbe_main.c */
+
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
index 5679293e53f7..0a1f7b37d088 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.c
@@ -1,435 +1,1170 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include "ixgbe.h"
+#include "ixgbe_type.h"
 #include "ixgbe_mbx.h"
 
+STATIC s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id);
+STATIC s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id);
+
 /**
- *  ixgbe_read_mbx - Reads a message from the mailbox
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @mbx_id: id of mailbox to read
+ * ixgbe_read_mbx - Reads a message from the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to read
  *
- *  returns SUCCESS if it successfully read message from buffer
+ * returns SUCCESS if it successfully read message from buffer
  **/
 s32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 
+	DEBUGFUNC("ixgbe_read_mbx");
+
 	/* limit read to size of mailbox */
-	if (size > mbx->size)
+	if (size > mbx->size) {
+		ERROR_REPORT3(IXGBE_ERROR_ARGUMENT,
+			      "Invalid mailbox message size %u, changing to %u",
+			      size, mbx->size);
 		size = mbx->size;
+	}
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	if (mbx->ops[mbx_id].read)
+		return mbx->ops[mbx_id].read(hw, msg, size, mbx_id);
 
-	return mbx->ops->read(hw, msg, size, mbx_id);
+	return IXGBE_ERR_CONFIG;
 }
 
 /**
- *  ixgbe_write_mbx - Write a message to the mailbox
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @mbx_id: id of mailbox to write
+ * ixgbe_poll_mbx - Wait for message and read it from the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to read
  *
- *  returns SUCCESS if it successfully copied message into the buffer
+ * returns SUCCESS if it successfully read message from buffer
  **/
-s32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
+s32 ixgbe_poll_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val;
+
+	DEBUGFUNC("ixgbe_poll_mbx");
 
-	if (size > mbx->size)
-		return IXGBE_ERR_MBX;
+	if (!mbx->ops[mbx_id].read || !mbx->ops[mbx_id].check_for_msg ||
+	    !mbx->timeout)
+		return IXGBE_ERR_CONFIG;
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	/* limit read to size of mailbox */
+	if (size > mbx->size) {
+		ERROR_REPORT3(IXGBE_ERROR_ARGUMENT,
+			      "Invalid mailbox message size %u, changing to %u",
+			      size, mbx->size);
+		size = mbx->size;
+	}
 
-	return mbx->ops->write(hw, msg, size, mbx_id);
+	ret_val = ixgbe_poll_for_msg(hw, mbx_id);
+	/* if ack received read message, otherwise we timed out */
+	if (!ret_val)
+		return mbx->ops[mbx_id].read(hw, msg, size, mbx_id);
+
+	return ret_val;
 }
 
 /**
- *  ixgbe_check_for_msg - checks to see if someone sent us mail
- *  @hw: pointer to the HW structure
- *  @mbx_id: id of mailbox to check
+ * ixgbe_write_mbx - Write a message to the mailbox and wait for ACK
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to write
  *
- *  returns SUCCESS if the Status bit was found or else ERR_MBX
+ * returns SUCCESS if it successfully copied message into the buffer and
+ * received an ACK to that message within specified period
+ **/
+s32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val = IXGBE_ERR_MBX;
+
+	DEBUGFUNC("ixgbe_write_mbx");
+
+	/*
+	 * exit if either we can't write, release
+	 * or there is no timeout defined
+	 */
+	if (!mbx->ops[mbx_id].write || !mbx->ops[mbx_id].check_for_ack ||
+	    !mbx->ops[mbx_id].release || !mbx->timeout)
+		return IXGBE_ERR_CONFIG;
+
+	if (size > mbx->size) {
+		ret_val = IXGBE_ERR_PARAM;
+		ERROR_REPORT2(IXGBE_ERROR_ARGUMENT,
+			     "Invalid mailbox message size %u", size);
+	} else {
+		ret_val = mbx->ops[mbx_id].write(hw, msg, size, mbx_id);
+	}
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_check_for_msg - checks to see if someone sent us mail
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
+ *
+ * returns SUCCESS if the Status bit was found or else ERR_MBX
  **/
 s32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val = IXGBE_ERR_CONFIG;
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	DEBUGFUNC("ixgbe_check_for_msg");
 
-	return mbx->ops->check_for_msg(hw, mbx_id);
+	if (mbx->ops[mbx_id].check_for_msg)
+		ret_val = mbx->ops[mbx_id].check_for_msg(hw, mbx_id);
+
+	return ret_val;
 }
 
 /**
- *  ixgbe_check_for_ack - checks to see if someone sent us ACK
- *  @hw: pointer to the HW structure
- *  @mbx_id: id of mailbox to check
+ * ixgbe_check_for_ack - checks to see if someone sent us ACK
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
  *
- *  returns SUCCESS if the Status bit was found or else ERR_MBX
+ * returns SUCCESS if the Status bit was found or else ERR_MBX
  **/
 s32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val = IXGBE_ERR_CONFIG;
+
+	DEBUGFUNC("ixgbe_check_for_ack");
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	if (mbx->ops[mbx_id].check_for_ack)
+		ret_val = mbx->ops[mbx_id].check_for_ack(hw, mbx_id);
 
-	return mbx->ops->check_for_ack(hw, mbx_id);
+	return ret_val;
 }
 
 /**
- *  ixgbe_check_for_rst - checks to see if other side has reset
- *  @hw: pointer to the HW structure
- *  @mbx_id: id of mailbox to check
+ * ixgbe_check_for_rst - checks to see if other side has reset
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
  *
- *  returns SUCCESS if the Status bit was found or else ERR_MBX
+ * returns SUCCESS if the Status bit was found or else ERR_MBX
  **/
 s32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val = IXGBE_ERR_CONFIG;
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	DEBUGFUNC("ixgbe_check_for_rst");
 
-	return mbx->ops->check_for_rst(hw, mbx_id);
+	if (mbx->ops[mbx_id].check_for_rst)
+		ret_val = mbx->ops[mbx_id].check_for_rst(hw, mbx_id);
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_clear_mbx - Clear Mailbox Memory
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to write
+ *
+ * Set VFMBMEM of given VF to 0x0.
+ **/
+s32 ixgbe_clear_mbx(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	s32 ret_val = IXGBE_ERR_CONFIG;
+
+	DEBUGFUNC("ixgbe_clear_mbx");
+
+	if (mbx->ops[mbx_id].clear)
+		ret_val = mbx->ops[mbx_id].clear(hw, mbx_id);
+
+	return ret_val;
 }
 
 /**
- *  ixgbe_poll_for_msg - Wait for message notification
- *  @hw: pointer to the HW structure
- *  @mbx_id: id of mailbox to write
+ * ixgbe_poll_for_msg - Wait for message notification
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to write
  *
- *  returns SUCCESS if it successfully received a message notification
+ * returns SUCCESS if it successfully received a message notification
  **/
-static s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id)
+STATIC s32 ixgbe_poll_for_msg(struct ixgbe_hw *hw, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 	int countdown = mbx->timeout;
 
-	if (!countdown || !mbx->ops)
-		return IXGBE_ERR_MBX;
+	DEBUGFUNC("ixgbe_poll_for_msg");
+
+	if (!countdown || !mbx->ops[mbx_id].check_for_msg)
+		return IXGBE_ERR_CONFIG;
 
-	while (mbx->ops->check_for_msg(hw, mbx_id)) {
+	while (countdown && mbx->ops[mbx_id].check_for_msg(hw, mbx_id)) {
 		countdown--;
 		if (!countdown)
-			return IXGBE_ERR_MBX;
-		udelay(mbx->usec_delay);
+			break;
+		usec_delay(mbx->usec_delay);
 	}
 
-	return 0;
+	if (countdown == 0) {
+		ERROR_REPORT2(IXGBE_ERROR_POLLING,
+			   "Polling for VF%u mailbox message timedout", mbx_id);
+		return IXGBE_ERR_TIMEOUT;
+	}
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_poll_for_ack - Wait for message acknowledgement
- *  @hw: pointer to the HW structure
- *  @mbx_id: id of mailbox to write
+ * ixgbe_poll_for_ack - Wait for message acknowledgment
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to write
  *
- *  returns SUCCESS if it successfully received a message acknowledgement
+ * returns SUCCESS if it successfully received a message acknowledgment
  **/
-static s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id)
+STATIC s32 ixgbe_poll_for_ack(struct ixgbe_hw *hw, u16 mbx_id)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 	int countdown = mbx->timeout;
 
-	if (!countdown || !mbx->ops)
-		return IXGBE_ERR_MBX;
+	DEBUGFUNC("ixgbe_poll_for_ack");
+
+	if (!countdown || !mbx->ops[mbx_id].check_for_ack)
+		return IXGBE_ERR_CONFIG;
 
-	while (mbx->ops->check_for_ack(hw, mbx_id)) {
+	while (countdown && mbx->ops[mbx_id].check_for_ack(hw, mbx_id)) {
 		countdown--;
 		if (!countdown)
-			return IXGBE_ERR_MBX;
-		udelay(mbx->usec_delay);
+			break;
+		usec_delay(mbx->usec_delay);
+	}
+
+	if (countdown == 0) {
+		ERROR_REPORT2(IXGBE_ERROR_POLLING,
+			     "Polling for VF%u mailbox ack timedout", mbx_id);
+		return IXGBE_ERR_TIMEOUT;
+	}
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_read_mailbox_vf - read VF's mailbox register
+ * @hw: pointer to the HW structure
+ *
+ * This function is used to read the mailbox register dedicated for VF without
+ * losing the read to clear status bits.
+ **/
+STATIC u32 ixgbe_read_mailbox_vf(struct ixgbe_hw *hw)
+{
+	u32 vf_mailbox = IXGBE_READ_REG(hw, IXGBE_VFMAILBOX);
+
+	vf_mailbox |= hw->mbx.vf_mailbox;
+	hw->mbx.vf_mailbox |= vf_mailbox & IXGBE_VFMAILBOX_R2C_BITS;
+
+	return vf_mailbox;
+}
+
+STATIC void ixgbe_clear_msg_vf(struct ixgbe_hw *hw)
+{
+	u32 vf_mailbox = ixgbe_read_mailbox_vf(hw);
+
+	if (vf_mailbox & IXGBE_VFMAILBOX_PFSTS) {
+		hw->mbx.stats.reqs++;
+		hw->mbx.vf_mailbox &= ~IXGBE_VFMAILBOX_PFSTS;
 	}
+}
+
+STATIC void ixgbe_clear_ack_vf(struct ixgbe_hw *hw)
+{
+	u32 vf_mailbox = ixgbe_read_mailbox_vf(hw);
+
+	if (vf_mailbox & IXGBE_VFMAILBOX_PFACK) {
+		hw->mbx.stats.acks++;
+		hw->mbx.vf_mailbox &= ~IXGBE_VFMAILBOX_PFACK;
+	}
+}
+
+STATIC void ixgbe_clear_rst_vf(struct ixgbe_hw *hw)
+{
+	u32 vf_mailbox = ixgbe_read_mailbox_vf(hw);
+
+	if (vf_mailbox & (IXGBE_VFMAILBOX_RSTI | IXGBE_VFMAILBOX_RSTD)) {
+		hw->mbx.stats.rsts++;
+		hw->mbx.vf_mailbox &= ~(IXGBE_VFMAILBOX_RSTI |
+					IXGBE_VFMAILBOX_RSTD);
+	}
+}
+
+/**
+ * ixgbe_check_for_bit_vf - Determine if a status bit was set
+ * @hw: pointer to the HW structure
+ * @mask: bitmask for bits to be tested and cleared
+ *
+ * This function is used to check for the read to clear bits within
+ * the V2P mailbox.
+ **/
+STATIC s32 ixgbe_check_for_bit_vf(struct ixgbe_hw *hw, u32 mask)
+{
+	u32 vf_mailbox = ixgbe_read_mailbox_vf(hw);
+
+	if (vf_mailbox & mask)
+		return IXGBE_SUCCESS;
 
-	return 0;
+	return IXGBE_ERR_MBX;
 }
 
 /**
- *  ixgbe_read_posted_mbx - Wait for message notification and receive message
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @mbx_id: id of mailbox to write
+ * ixgbe_check_for_msg_vf - checks to see if the PF has sent mail
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
  *
- *  returns SUCCESS if it successfully received a message notification and
- *  copied it into the receive buffer.
+ * returns SUCCESS if the PF has set the Status bit or else ERR_MBX
  **/
-static s32 ixgbe_read_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,
-				 u16 mbx_id)
+STATIC s32 ixgbe_check_for_msg_vf(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	UNREFERENCED_1PARAMETER(mbx_id);
+	DEBUGFUNC("ixgbe_check_for_msg_vf");
+
+	if (!ixgbe_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFSTS))
+		return IXGBE_SUCCESS;
+
+	return IXGBE_ERR_MBX;
+}
+
+/**
+ * ixgbe_check_for_ack_vf - checks to see if the PF has ACK'd
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
+ *
+ * returns SUCCESS if the PF has set the ACK bit or else ERR_MBX
+ **/
+STATIC s32 ixgbe_check_for_ack_vf(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	UNREFERENCED_1PARAMETER(mbx_id);
+	DEBUGFUNC("ixgbe_check_for_ack_vf");
+
+	if (!ixgbe_check_for_bit_vf(hw, IXGBE_VFMAILBOX_PFACK)) {
+		/* TODO: should this be autocleared? */
+		ixgbe_clear_ack_vf(hw);
+		return IXGBE_SUCCESS;
+	}
+
+	return IXGBE_ERR_MBX;
+}
+
+/**
+ * ixgbe_check_for_rst_vf - checks to see if the PF has reset
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to check
+ *
+ * returns true if the PF has set the reset done bit or else false
+ **/
+STATIC s32 ixgbe_check_for_rst_vf(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	UNREFERENCED_1PARAMETER(mbx_id);
+	DEBUGFUNC("ixgbe_check_for_rst_vf");
+
+	if (!ixgbe_check_for_bit_vf(hw, IXGBE_VFMAILBOX_RSTI |
+					  IXGBE_VFMAILBOX_RSTD)) {
+		/* TODO: should this be autocleared? */
+		ixgbe_clear_rst_vf(hw);
+		return IXGBE_SUCCESS;
+	}
+
+	return IXGBE_ERR_MBX;
+}
+
+/**
+ * ixgbe_obtain_mbx_lock_vf - obtain mailbox lock
+ * @hw: pointer to the HW structure
+ *
+ * return SUCCESS if we obtained the mailbox lock
+ **/
+STATIC s32 ixgbe_obtain_mbx_lock_vf(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	int countdown = mbx->timeout;
+	s32 ret_val = IXGBE_ERR_MBX;
+	u32 vf_mailbox;
+
+	DEBUGFUNC("ixgbe_obtain_mbx_lock_vf");
+
+	if (!mbx->timeout)
+		return IXGBE_ERR_CONFIG;
+
+	while (countdown--) {
+		/* Reserve mailbox for VF use */
+		vf_mailbox = ixgbe_read_mailbox_vf(hw);
+		vf_mailbox |= IXGBE_VFMAILBOX_VFU;
+		IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);
+
+		/* Verify that VF is the owner of the lock */
+		if (ixgbe_read_mailbox_vf(hw) & IXGBE_VFMAILBOX_VFU) {
+			ret_val = IXGBE_SUCCESS;
+			break;
+		}
+
+		/* Wait a bit before trying again */
+		usec_delay(mbx->usec_delay);
+	}
+
+	if (ret_val != IXGBE_SUCCESS) {
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+				"Failed to obtain mailbox lock");
+		ret_val = IXGBE_ERR_TIMEOUT;
+	}
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_release_mbx_lock_dummy - release mailbox lock
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to read
+ **/
+STATIC void ixgbe_release_mbx_lock_dummy(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	UNREFERENCED_2PARAMETER(hw, mbx_id);
+
+	DEBUGFUNC("ixgbe_release_mbx_lock_dummy");
+}
+
+/**
+ * ixgbe_release_mbx_lock_vf - release mailbox lock
+ * @hw: pointer to the HW structure
+ * @mbx_id: id of mailbox to read
+ **/
+STATIC void ixgbe_release_mbx_lock_vf(struct ixgbe_hw *hw, u16 mbx_id)
+{
+	u32 vf_mailbox;
+
+	UNREFERENCED_1PARAMETER(mbx_id);
+
+	DEBUGFUNC("ixgbe_release_mbx_lock_vf");
+
+	/* Return ownership of the buffer */
+	vf_mailbox = ixgbe_read_mailbox_vf(hw);
+	vf_mailbox &= ~IXGBE_VFMAILBOX_VFU;
+	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);
+}
+
+/**
+ * ixgbe_write_mbx_vf_legacy - Write a message to the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to write
+ *
+ * returns SUCCESS if it successfully copied message into the buffer
+ **/
+STATIC s32 ixgbe_write_mbx_vf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size,
+				     u16 mbx_id)
+{
 	s32 ret_val;
+	u16 i;
 
-	if (!mbx->ops)
-		return IXGBE_ERR_MBX;
+	UNREFERENCED_1PARAMETER(mbx_id);
+	DEBUGFUNC("ixgbe_write_mbx_vf_legacy");
 
-	ret_val = ixgbe_poll_for_msg(hw, mbx_id);
+	/* lock the mailbox to prevent pf/vf race condition */
+	ret_val = ixgbe_obtain_mbx_lock_vf(hw);
 	if (ret_val)
 		return ret_val;
 
-	/* if ack received read message */
-	return mbx->ops->read(hw, msg, size, mbx_id);
+	/* flush msg and acks as we are overwriting the message buffer */
+	ixgbe_check_for_msg_vf(hw, 0);
+	ixgbe_clear_msg_vf(hw);
+	ixgbe_check_for_ack_vf(hw, 0);
+	ixgbe_clear_ack_vf(hw);
+
+	/* copy the caller specified message to the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_VFMBMEM, i, msg[i]);
+
+	/* update stats */
+	hw->mbx.stats.msgs_tx++;
+
+	/* interrupt the PF to tell it a message has been sent */
+	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_REQ);
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_write_posted_mbx - Write a message to the mailbox, wait for ack
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @mbx_id: id of mailbox to write
+ * ixgbe_write_mbx_vf - Write a message to the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to write
  *
- *  returns SUCCESS if it successfully copied message into the buffer and
- *  received an ack to that message within delay * timeout period
+ * returns SUCCESS if it successfully copied message into the buffer
  **/
-static s32 ixgbe_write_posted_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size,
-			   u16 mbx_id)
+STATIC s32 ixgbe_write_mbx_vf(struct ixgbe_hw *hw, u32 *msg, u16 size,
+			      u16 mbx_id)
 {
-	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	u32 vf_mailbox;
 	s32 ret_val;
+	u16 i;
 
-	/* exit if either we can't write or there isn't a defined timeout */
-	if (!mbx->ops || !mbx->timeout)
-		return IXGBE_ERR_MBX;
+	UNREFERENCED_1PARAMETER(mbx_id);
 
-	/* send msg */
-	ret_val = mbx->ops->write(hw, msg, size, mbx_id);
+	DEBUGFUNC("ixgbe_write_mbx_vf");
+
+	/* lock the mailbox to prevent pf/vf race condition */
+	ret_val = ixgbe_obtain_mbx_lock_vf(hw);
 	if (ret_val)
-		return ret_val;
+		goto out;
+
+	/* flush msg and acks as we are overwriting the message buffer */
+	ixgbe_clear_msg_vf(hw);
+	ixgbe_clear_ack_vf(hw);
+
+	/* copy the caller specified message to the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_VFMBMEM, i, msg[i]);
+
+	/* update stats */
+	hw->mbx.stats.msgs_tx++;
+
+	/* interrupt the PF to tell it a message has been sent */
+	vf_mailbox = ixgbe_read_mailbox_vf(hw);
+	vf_mailbox |= IXGBE_VFMAILBOX_REQ;
+	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);
 
 	/* if msg sent wait until we receive an ack */
-	return ixgbe_poll_for_ack(hw, mbx_id);
+	ixgbe_poll_for_ack(hw, mbx_id);
+
+out:
+	hw->mbx.ops[mbx_id].release(hw, mbx_id);
+
+	return ret_val;
 }
 
-static s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, u32 mask, s32 index)
+/**
+ * ixgbe_read_mbx_vf_legacy - Reads a message from the inbox intended for vf
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to read
+ *
+ * returns SUCCESS if it successfully read message from buffer
+ **/
+STATIC s32 ixgbe_read_mbx_vf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size,
+				    u16 mbx_id)
 {
-	u32 mbvficr = IXGBE_READ_REG(hw, IXGBE_MBVFICR(index));
+	s32 ret_val;
+	u16 i;
 
-	if (mbvficr & mask) {
-		IXGBE_WRITE_REG(hw, IXGBE_MBVFICR(index), mask);
-		return 0;
-	}
+	DEBUGFUNC("ixgbe_read_mbx_vf_legacy");
+	UNREFERENCED_1PARAMETER(mbx_id);
 
-	return IXGBE_ERR_MBX;
+	/* lock the mailbox to prevent pf/vf race condition */
+	ret_val = ixgbe_obtain_mbx_lock_vf(hw);
+	if (ret_val)
+		return ret_val;
+
+	/* copy the message from the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_VFMBMEM, i);
+
+	/* Acknowledge receipt and release mailbox, then we're done */
+	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, IXGBE_VFMAILBOX_ACK);
+
+	/* update stats */
+	hw->mbx.stats.msgs_rx++;
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_check_for_msg_pf - checks to see if the VF has sent mail
- *  @hw: pointer to the HW structure
- *  @vf_number: the VF index
+ * ixgbe_read_mbx_vf - Reads a message from the inbox intended for vf
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @mbx_id: id of mailbox to read
  *
- *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
+ * returns SUCCESS if it successfully read message from buffer
  **/
-static s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, u16 vf_number)
+STATIC s32 ixgbe_read_mbx_vf(struct ixgbe_hw *hw, u32 *msg, u16 size,
+			     u16 mbx_id)
 {
-	s32 index = IXGBE_MBVFICR_INDEX(vf_number);
-	u32 vf_bit = vf_number % 16;
+	u32 vf_mailbox;
+	s32 ret_val;
+	u16 i;
 
-	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFREQ_VF1 << vf_bit,
-				    index)) {
+	DEBUGFUNC("ixgbe_read_mbx_vf");
+	UNREFERENCED_1PARAMETER(mbx_id);
+
+	/* check if there is a message from PF */
+	ret_val = ixgbe_check_for_msg_vf(hw, 0);
+	if (ret_val != IXGBE_SUCCESS)
+		return IXGBE_ERR_MBX_NOMSG;
+
+	ixgbe_clear_msg_vf(hw);
+
+	/* copy the message from the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_VFMBMEM, i);
+
+	/* Acknowledge receipt */
+	vf_mailbox = ixgbe_read_mailbox_vf(hw);
+	vf_mailbox |= IXGBE_VFMAILBOX_ACK;
+	IXGBE_WRITE_REG(hw, IXGBE_VFMAILBOX, vf_mailbox);
+
+	/* update stats */
+	hw->mbx.stats.msgs_rx++;
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_init_mbx_params_vf - set initial values for vf mailbox
+ * @hw: pointer to the HW structure
+ *
+ * Initializes single set the hw->mbx struct to correct values for vf mailbox
+ * Set of legacy functions is being used here
+ */
+void ixgbe_init_mbx_params_vf(struct ixgbe_hw *hw)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+
+	/* start mailbox as timed out and let the reset_hw call set the timeout
+	 * value to begin communications */
+	mbx->timeout = 0;
+	mbx->usec_delay = IXGBE_VF_MBX_INIT_DELAY;
+
+	mbx->size = IXGBE_VFMAILBOX_SIZE;
+
+	/* VF has only one mailbox connection, no need for more IDs */
+	mbx->ops[0].release = ixgbe_release_mbx_lock_dummy;
+	mbx->ops[0].read = ixgbe_read_mbx_vf_legacy;
+	mbx->ops[0].write = ixgbe_write_mbx_vf_legacy;
+	mbx->ops[0].check_for_msg = ixgbe_check_for_msg_vf;
+	mbx->ops[0].check_for_ack = ixgbe_check_for_ack_vf;
+	mbx->ops[0].check_for_rst = ixgbe_check_for_rst_vf;
+	mbx->ops[0].clear = NULL;
+
+	mbx->stats.msgs_tx = 0;
+	mbx->stats.msgs_rx = 0;
+	mbx->stats.reqs = 0;
+	mbx->stats.acks = 0;
+	mbx->stats.rsts = 0;
+}
+
+/**
+ * ixgbe_upgrade_mbx_params_vf - set initial values for vf mailbox
+ * @hw: pointer to the HW structure
+ *
+ * Initializes the hw->mbx struct to correct values for vf mailbox
+ */
+void ixgbe_upgrade_mbx_params_vf(struct ixgbe_hw *hw)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+
+	mbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;
+	mbx->usec_delay = IXGBE_VF_MBX_INIT_DELAY;
+
+	mbx->size = IXGBE_VFMAILBOX_SIZE;
+
+	/* VF has only one mailbox connection, no need for more IDs */
+	mbx->ops[0].release = ixgbe_release_mbx_lock_vf;
+	mbx->ops[0].read = ixgbe_read_mbx_vf;
+	mbx->ops[0].write = ixgbe_write_mbx_vf;
+	mbx->ops[0].check_for_msg = ixgbe_check_for_msg_vf;
+	mbx->ops[0].check_for_ack = ixgbe_check_for_ack_vf;
+	mbx->ops[0].check_for_rst = ixgbe_check_for_rst_vf;
+	mbx->ops[0].clear = NULL;
+
+	mbx->stats.msgs_tx = 0;
+	mbx->stats.msgs_rx = 0;
+	mbx->stats.reqs = 0;
+	mbx->stats.acks = 0;
+	mbx->stats.rsts = 0;
+}
+
+STATIC void ixgbe_clear_msg_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	u32 vf_shift = IXGBE_PFMBICR_SHIFT(vf_id);
+	s32 index = IXGBE_PFMBICR_INDEX(vf_id);
+	u32 pfmbicr;
+
+	pfmbicr = IXGBE_READ_REG(hw, IXGBE_PFMBICR(index));
+
+	if (pfmbicr & (IXGBE_PFMBICR_VFREQ_VF1 << vf_shift))
 		hw->mbx.stats.reqs++;
-		return 0;
-	}
+
+	IXGBE_WRITE_REG(hw, IXGBE_PFMBICR(index),
+			IXGBE_PFMBICR_VFREQ_VF1 << vf_shift);
+}
+
+STATIC void ixgbe_clear_ack_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	u32 vf_shift = IXGBE_PFMBICR_SHIFT(vf_id);
+	s32 index = IXGBE_PFMBICR_INDEX(vf_id);
+	u32 pfmbicr;
+
+	pfmbicr = IXGBE_READ_REG(hw, IXGBE_PFMBICR(index));
+
+	if (pfmbicr & (IXGBE_PFMBICR_VFACK_VF1 << vf_shift))
+		hw->mbx.stats.acks++;
+
+	IXGBE_WRITE_REG(hw, IXGBE_PFMBICR(index),
+			IXGBE_PFMBICR_VFACK_VF1 << vf_shift);
+}
+
+STATIC s32 ixgbe_check_for_bit_pf(struct ixgbe_hw *hw, u32 mask, s32 index)
+{
+	u32 pfmbicr = IXGBE_READ_REG(hw, IXGBE_PFMBICR(index));
+
+	if (pfmbicr & mask)
+		return IXGBE_SUCCESS;
 
 	return IXGBE_ERR_MBX;
 }
 
 /**
- *  ixgbe_check_for_ack_pf - checks to see if the VF has ACKed
- *  @hw: pointer to the HW structure
- *  @vf_number: the VF index
+ * ixgbe_check_for_msg_pf - checks to see if the VF has sent mail
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
  *
- *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
+ * returns SUCCESS if the VF has set the Status bit or else ERR_MBX
  **/
-static s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, u16 vf_number)
+STATIC s32 ixgbe_check_for_msg_pf(struct ixgbe_hw *hw, u16 vf_id)
 {
-	s32 index = IXGBE_MBVFICR_INDEX(vf_number);
-	u32 vf_bit = vf_number % 16;
+	u32 vf_shift = IXGBE_PFMBICR_SHIFT(vf_id);
+	s32 index = IXGBE_PFMBICR_INDEX(vf_id);
+
+	DEBUGFUNC("ixgbe_check_for_msg_pf");
 
-	if (!ixgbe_check_for_bit_pf(hw, IXGBE_MBVFICR_VFACK_VF1 << vf_bit,
+	if (!ixgbe_check_for_bit_pf(hw, IXGBE_PFMBICR_VFREQ_VF1 << vf_shift,
+				    index))
+		return IXGBE_SUCCESS;
+
+	return IXGBE_ERR_MBX;
+}
+
+/**
+ * ixgbe_check_for_ack_pf - checks to see if the VF has ACKed
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
+ *
+ * returns SUCCESS if the VF has set the Status bit or else ERR_MBX
+ **/
+STATIC s32 ixgbe_check_for_ack_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	u32 vf_shift = IXGBE_PFMBICR_SHIFT(vf_id);
+	s32 index = IXGBE_PFMBICR_INDEX(vf_id);
+	s32 ret_val = IXGBE_ERR_MBX;
+
+	DEBUGFUNC("ixgbe_check_for_ack_pf");
+
+	if (!ixgbe_check_for_bit_pf(hw, IXGBE_PFMBICR_VFACK_VF1 << vf_shift,
 				    index)) {
-		hw->mbx.stats.acks++;
-		return 0;
+		ret_val = IXGBE_SUCCESS;
+		/* TODO: should this be autocleared? */
+		ixgbe_clear_ack_pf(hw, vf_id);
 	}
 
-	return IXGBE_ERR_MBX;
+	return ret_val;
 }
 
 /**
- *  ixgbe_check_for_rst_pf - checks to see if the VF has reset
- *  @hw: pointer to the HW structure
- *  @vf_number: the VF index
+ * ixgbe_check_for_rst_pf - checks to see if the VF has reset
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
  *
- *  returns SUCCESS if the VF has set the Status bit or else ERR_MBX
+ * returns SUCCESS if the VF has set the Status bit or else ERR_MBX
  **/
-static s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_number)
+STATIC s32 ixgbe_check_for_rst_pf(struct ixgbe_hw *hw, u16 vf_id)
 {
-	u32 reg_offset = (vf_number < 32) ? 0 : 1;
-	u32 vf_shift = vf_number % 32;
+	u32 vf_shift = IXGBE_PFVFLRE_SHIFT(vf_id);
+	u32 index = IXGBE_PFVFLRE_INDEX(vf_id);
+	s32 ret_val = IXGBE_ERR_MBX;
 	u32 vflre = 0;
 
+	DEBUGFUNC("ixgbe_check_for_rst_pf");
+
 	switch (hw->mac.type) {
 	case ixgbe_mac_82599EB:
-		vflre = IXGBE_READ_REG(hw, IXGBE_VFLRE(reg_offset));
+		vflre = IXGBE_READ_REG(hw, IXGBE_PFVFLRE(index));
 		break;
-	case ixgbe_mac_X540:
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
-		vflre = IXGBE_READ_REG(hw, IXGBE_VFLREC(reg_offset));
+	case ixgbe_mac_X550EM_a:
+	case ixgbe_mac_X540:
+		vflre = IXGBE_READ_REG(hw, IXGBE_PFVFLREC(index));
 		break;
 	default:
 		break;
 	}
 
-	if (vflre & BIT(vf_shift)) {
-		IXGBE_WRITE_REG(hw, IXGBE_VFLREC(reg_offset), BIT(vf_shift));
+	if (vflre & (1 << vf_shift)) {
+		ret_val = IXGBE_SUCCESS;
+		IXGBE_WRITE_REG(hw, IXGBE_PFVFLREC(index), (1 << vf_shift));
 		hw->mbx.stats.rsts++;
-		return 0;
 	}
 
-	return IXGBE_ERR_MBX;
+	return ret_val;
 }
 
 /**
- *  ixgbe_obtain_mbx_lock_pf - obtain mailbox lock
- *  @hw: pointer to the HW structure
- *  @vf_number: the VF index
+ * ixgbe_obtain_mbx_lock_pf - obtain mailbox lock
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
  *
- *  return SUCCESS if we obtained the mailbox lock
+ * return SUCCESS if we obtained the mailbox lock
  **/
-static s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_number)
+STATIC s32 ixgbe_obtain_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_id)
 {
-	u32 p2v_mailbox;
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+	int countdown = mbx->timeout;
+	s32 ret_val = IXGBE_ERR_MBX;
+	u32 pf_mailbox;
 
-	/* Take ownership of the buffer */
-	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_PFU);
+	DEBUGFUNC("ixgbe_obtain_mbx_lock_pf");
 
-	/* reserve mailbox for vf use */
-	p2v_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_number));
-	if (p2v_mailbox & IXGBE_PFMAILBOX_PFU)
-		return 0;
+	if (!mbx->timeout)
+		return IXGBE_ERR_CONFIG;
 
-	return IXGBE_ERR_MBX;
+	while (countdown--) {
+		/* Reserve mailbox for PF use */
+		pf_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_id));
+		pf_mailbox |= IXGBE_PFMAILBOX_PFU;
+		IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), pf_mailbox);
+
+		/* Verify that PF is the owner of the lock */
+		pf_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_id));
+		if (pf_mailbox & IXGBE_PFMAILBOX_PFU) {
+			ret_val = IXGBE_SUCCESS;
+			break;
+		}
+
+		/* Wait a bit before trying again */
+		usec_delay(mbx->usec_delay);
+	}
+
+	if (ret_val != IXGBE_SUCCESS) {
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+			      "Failed to obtain mailbox lock");
+		ret_val = IXGBE_ERR_TIMEOUT;
+	}
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_release_mbx_lock_pf - release mailbox lock
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
+ **/
+STATIC void ixgbe_release_mbx_lock_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	u32 pf_mailbox;
+
+	DEBUGFUNC("ixgbe_release_mbx_lock_pf");
+
+	/* Return ownership of the buffer */
+	pf_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_id));
+	pf_mailbox &= ~IXGBE_PFMAILBOX_PFU;
+	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), pf_mailbox);
 }
 
 /**
- *  ixgbe_write_mbx_pf - Places a message in the mailbox
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @vf_number: the VF index
+ * ixgbe_write_mbx_pf_legacy - Places a message in the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @vf_id: the VF index
  *
- *  returns SUCCESS if it successfully copied message into the buffer
+ * returns SUCCESS if it successfully copied message into the buffer
  **/
-static s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,
-			      u16 vf_number)
+STATIC s32 ixgbe_write_mbx_pf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size,
+				     u16 vf_id)
 {
 	s32 ret_val;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_write_mbx_pf_legacy");
+
 	/* lock the mailbox to prevent pf/vf race condition */
-	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);
+	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_id);
 	if (ret_val)
 		return ret_val;
 
 	/* flush msg and acks as we are overwriting the message buffer */
-	ixgbe_check_for_msg_pf(hw, vf_number);
-	ixgbe_check_for_ack_pf(hw, vf_number);
+	ixgbe_check_for_msg_pf(hw, vf_id);
+	ixgbe_clear_msg_pf(hw, vf_id);
+	ixgbe_check_for_ack_pf(hw, vf_id);
+	ixgbe_clear_ack_pf(hw, vf_id);
 
 	/* copy the caller specified message to the mailbox memory buffer */
 	for (i = 0; i < size; i++)
-		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i, msg[i]);
+		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_id), i, msg[i]);
 
 	/* Interrupt VF to tell it a message has been sent and release buffer*/
-	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_STS);
+	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), IXGBE_PFMAILBOX_STS);
 
 	/* update stats */
 	hw->mbx.stats.msgs_tx++;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_mbx_pf - Read a message from the mailbox
- *  @hw: pointer to the HW structure
- *  @msg: The message buffer
- *  @size: Length of buffer
- *  @vf_number: the VF index
+ * ixgbe_write_mbx_pf - Places a message in the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @vf_id: the VF index
  *
- *  This function copies a message from the mailbox buffer to the caller's
- *  memory buffer.  The presumption is that the caller knows that there was
- *  a message due to a VF request so no polling for message is needed.
+ * returns SUCCESS if it successfully copied message into the buffer
  **/
-static s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,
-			     u16 vf_number)
+STATIC s32 ixgbe_write_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,
+			      u16 vf_id)
 {
+	u32 pf_mailbox;
 	s32 ret_val;
 	u16 i;
 
+	DEBUGFUNC("ixgbe_write_mbx_pf");
+
 	/* lock the mailbox to prevent pf/vf race condition */
-	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_number);
+	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_id);
 	if (ret_val)
+		goto out;
+
+	/* flush msg and acks as we are overwriting the message buffer */
+	ixgbe_clear_msg_pf(hw, vf_id);
+	ixgbe_clear_ack_pf(hw, vf_id);
+
+	/* copy the caller specified message to the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_id), i, msg[i]);
+
+	/* Interrupt VF to tell it a message has been sent */
+	pf_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_id));
+	pf_mailbox |= IXGBE_PFMAILBOX_STS;
+	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), pf_mailbox);
+
+	/* if msg sent wait until we receive an ack */
+	ixgbe_poll_for_ack(hw, vf_id);
+
+	/* update stats */
+	hw->mbx.stats.msgs_tx++;
+
+out:
+	hw->mbx.ops[vf_id].release(hw, vf_id);
+
+	return ret_val;
+
+}
+
+/**
+ * ixgbe_read_mbx_pf_legacy - Read a message from the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @vf_id: the VF index
+ *
+ * This function copies a message from the mailbox buffer to the caller's
+ * memory buffer.  The presumption is that the caller knows that there was
+ * a message due to a VF request so no polling for message is needed.
+ **/
+STATIC s32 ixgbe_read_mbx_pf_legacy(struct ixgbe_hw *hw, u32 *msg, u16 size,
+				    u16 vf_id)
+{
+	s32 ret_val;
+	u16 i;
+
+	DEBUGFUNC("ixgbe_read_mbx_pf_legacy");
+
+	/* lock the mailbox to prevent pf/vf race condition */
+	ret_val = ixgbe_obtain_mbx_lock_pf(hw, vf_id);
+	if (ret_val != IXGBE_SUCCESS)
 		return ret_val;
 
 	/* copy the message to the mailbox memory buffer */
 	for (i = 0; i < size; i++)
-		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_number), i);
+		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_id), i);
 
 	/* Acknowledge the message and release buffer */
-	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_number), IXGBE_PFMAILBOX_ACK);
+	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), IXGBE_PFMAILBOX_ACK);
 
 	/* update stats */
 	hw->mbx.stats.msgs_rx++;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
-#ifdef CONFIG_PCI_IOV
 /**
- *  ixgbe_init_mbx_params_pf - set initial values for pf mailbox
- *  @hw: pointer to the HW structure
+ * ixgbe_read_mbx_pf - Read a message from the mailbox
+ * @hw: pointer to the HW structure
+ * @msg: The message buffer
+ * @size: Length of buffer
+ * @vf_id: the VF index
  *
- *  Initializes the hw->mbx struct to correct values for pf mailbox
+ * This function copies a message from the mailbox buffer to the caller's
+ * memory buffer.  The presumption is that the caller knows that there was
+ * a message due to a VF request so no polling for message is needed.
+ **/
+STATIC s32 ixgbe_read_mbx_pf(struct ixgbe_hw *hw, u32 *msg, u16 size,
+			     u16 vf_id)
+{
+	u32 pf_mailbox;
+	s32 ret_val;
+	u16 i;
+
+	DEBUGFUNC("ixgbe_read_mbx_pf");
+
+	/* check if there is a message from VF */
+	ret_val = ixgbe_check_for_msg_pf(hw, vf_id);
+	if (ret_val != IXGBE_SUCCESS)
+		return IXGBE_ERR_MBX_NOMSG;
+
+	ixgbe_clear_msg_pf(hw, vf_id);
+
+	/* copy the message to the mailbox memory buffer */
+	for (i = 0; i < size; i++)
+		msg[i] = IXGBE_READ_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_id), i);
+
+	/* Acknowledge the message and release buffer */
+	pf_mailbox = IXGBE_READ_REG(hw, IXGBE_PFMAILBOX(vf_id));
+	pf_mailbox |= IXGBE_PFMAILBOX_ACK;
+	IXGBE_WRITE_REG(hw, IXGBE_PFMAILBOX(vf_id), pf_mailbox);
+
+	/* update stats */
+	hw->mbx.stats.msgs_rx++;
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_clear_mbx_pf - Clear Mailbox Memory
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
+ *
+ * Set VFMBMEM of given VF to 0x0.
+ **/
+STATIC s32 ixgbe_clear_mbx_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	u16 mbx_size = hw->mbx.size;
+	u16 i;
+
+	if (vf_id > 63)
+		return IXGBE_ERR_PARAM;
+
+	for (i = 0; i < mbx_size; ++i)
+		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf_id), i, 0x0);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_init_mbx_params_pf_id - set initial values for pf mailbox
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
+ *
+ * Initializes single set of the hw->mbx struct to correct values for pf mailbox
+ * Set of legacy functions is being used here
+ */
+void ixgbe_init_mbx_params_pf_id(struct ixgbe_hw *hw, u16 vf_id)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+
+	mbx->ops[vf_id].release = ixgbe_release_mbx_lock_dummy;
+	mbx->ops[vf_id].read = ixgbe_read_mbx_pf_legacy;
+	mbx->ops[vf_id].write = ixgbe_write_mbx_pf_legacy;
+	mbx->ops[vf_id].check_for_msg = ixgbe_check_for_msg_pf;
+	mbx->ops[vf_id].check_for_ack = ixgbe_check_for_ack_pf;
+	mbx->ops[vf_id].check_for_rst = ixgbe_check_for_rst_pf;
+	mbx->ops[vf_id].clear = ixgbe_clear_mbx_pf;
+}
+
+/**
+ * ixgbe_init_mbx_params_pf - set initial values for pf mailbox
+ * @hw: pointer to the HW structure
+ *
+ * Initializes all sets of the hw->mbx struct to correct values for pf
+ * mailbox. One set corresponds to single VF. It also initializes counters
+ * and general variables. A set of legacy functions is used by default.
  */
 void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw)
 {
+	u16 i;
 	struct ixgbe_mbx_info *mbx = &hw->mbx;
 
+	/* Ensure we are not calling this function from VF */
 	if (hw->mac.type != ixgbe_mac_82599EB &&
 	    hw->mac.type != ixgbe_mac_X550 &&
 	    hw->mac.type != ixgbe_mac_X550EM_x &&
-	    hw->mac.type != ixgbe_mac_x550em_a &&
+	    hw->mac.type != ixgbe_mac_X550EM_a &&
 	    hw->mac.type != ixgbe_mac_X540)
 		return;
 
-	mbx->timeout = 0;
-	mbx->usec_delay = 0;
+	/* Initialize common mailbox settings */
+	mbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;
+	mbx->usec_delay = IXGBE_VF_MBX_INIT_DELAY;
+	mbx->size = IXGBE_VFMAILBOX_SIZE;
 
+	/* Initialize counters with zeroes */
 	mbx->stats.msgs_tx = 0;
 	mbx->stats.msgs_rx = 0;
 	mbx->stats.reqs = 0;
 	mbx->stats.acks = 0;
 	mbx->stats.rsts = 0;
 
-	mbx->size = IXGBE_VFMAILBOX_SIZE;
+	/* No matter of VF number, we initialize params for all 64 VFs. */
+	/* TODO: 1. Add a define for max VF and refactor SHARED to get rid
+	 * of magic number for that (63 or 64 depending on use case.)
+	 * 2. rewrite the code to dynamically allocate mbx->ops[vf_id] for
+	 * certain number of VFs instead of default maximum value of 64 (0..63)
+	 */
+	for (i = 0; i < 64; i++)
+		ixgbe_init_mbx_params_pf_id(hw, i);
 }
-#endif /* CONFIG_PCI_IOV */
 
-const struct ixgbe_mbx_operations mbx_ops_generic = {
-	.read                   = ixgbe_read_mbx_pf,
-	.write                  = ixgbe_write_mbx_pf,
-	.read_posted            = ixgbe_read_posted_mbx,
-	.write_posted           = ixgbe_write_posted_mbx,
-	.check_for_msg          = ixgbe_check_for_msg_pf,
-	.check_for_ack          = ixgbe_check_for_ack_pf,
-	.check_for_rst          = ixgbe_check_for_rst_pf,
-};
+/**
+ * ixgbe_upgrade_mbx_params_pf - Upgrade initial values for pf mailbox
+ * @hw: pointer to the HW structure
+ * @vf_id: the VF index
+ *
+ * Initializes the hw->mbx struct to new function set for improved
+ * stability and handling of messages.
+ */
+void ixgbe_upgrade_mbx_params_pf(struct ixgbe_hw *hw, u16 vf_id)
+{
+	struct ixgbe_mbx_info *mbx = &hw->mbx;
+
+   /* Ensure we are not calling this function from VF */
+	if (hw->mac.type != ixgbe_mac_82599EB &&
+	    hw->mac.type != ixgbe_mac_X550 &&
+	    hw->mac.type != ixgbe_mac_X550EM_x &&
+	    hw->mac.type != ixgbe_mac_X550EM_a &&
+	    hw->mac.type != ixgbe_mac_X540)
+		return;
+
+	mbx->timeout = IXGBE_VF_MBX_INIT_TIMEOUT;
+	mbx->usec_delay = IXGBE_VF_MBX_INIT_DELAY;
+	mbx->size = IXGBE_VFMAILBOX_SIZE;
+
+	mbx->ops[vf_id].release = ixgbe_release_mbx_lock_pf;
+	mbx->ops[vf_id].read = ixgbe_read_mbx_pf;
+	mbx->ops[vf_id].write = ixgbe_write_mbx_pf;
+	mbx->ops[vf_id].check_for_msg = ixgbe_check_for_msg_pf;
+	mbx->ops[vf_id].check_for_ack = ixgbe_check_for_ack_pf;
+	mbx->ops[vf_id].check_for_rst = ixgbe_check_for_rst_pf;
+	mbx->ops[vf_id].clear = ixgbe_clear_mbx_pf;
 
+	mbx->stats.msgs_tx = 0;
+	mbx->stats.msgs_rx = 0;
+	mbx->stats.reqs = 0;
+	mbx->stats.acks = 0;
+	mbx->stats.rsts = 0;
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h
index a148534d7256..c3c72a613a01 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_mbx.h
@@ -1,47 +1,93 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_MBX_H_
 #define _IXGBE_MBX_H_
 
 #include "ixgbe_type.h"
 
-#define IXGBE_VFMAILBOX_SIZE        16 /* 16 32 bit words - 64 bytes */
-#define IXGBE_ERR_MBX               -100
+struct ixgbe_mbx_operations {
+	void (*init_params)(struct ixgbe_hw *hw);
+	void (*release)(struct ixgbe_hw *hw, u16 mbx_id);
+	s32  (*read)(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
+	s32  (*write)(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
+	s32  (*check_for_msg)(struct ixgbe_hw *hw, u16 vf_number);
+	s32  (*check_for_ack)(struct ixgbe_hw *hw, u16 vf_number);
+	s32  (*check_for_rst)(struct ixgbe_hw *hw, u16 vf_number);
+	s32  (*clear)(struct ixgbe_hw *hw, u16 vf_number);
+};
 
-#define IXGBE_VFMAILBOX             0x002FC
-#define IXGBE_VFMBMEM               0x00200
+struct ixgbe_mbx_stats {
+	u32 msgs_tx;
+	u32 msgs_rx;
 
-#define IXGBE_PFMAILBOX_STS   0x00000001 /* Initiate message send to VF */
-#define IXGBE_PFMAILBOX_ACK   0x00000002 /* Ack message recv'd from VF */
-#define IXGBE_PFMAILBOX_VFU   0x00000004 /* VF owns the mailbox buffer */
-#define IXGBE_PFMAILBOX_PFU   0x00000008 /* PF owns the mailbox buffer */
-#define IXGBE_PFMAILBOX_RVFU  0x00000010 /* Reset VFU - used when VF stuck */
+	u32 acks;
+	u32 reqs;
+	u32 rsts;
+};
 
-#define IXGBE_MBVFICR_VFREQ_MASK 0x0000FFFF /* bits for VF messages */
-#define IXGBE_MBVFICR_VFREQ_VF1  0x00000001 /* bit for VF 1 message */
-#define IXGBE_MBVFICR_VFACK_MASK 0xFFFF0000 /* bits for VF acks */
-#define IXGBE_MBVFICR_VFACK_VF1  0x00010000 /* bit for VF 1 ack */
+struct ixgbe_mbx_info {
+	/*
+	 * PF: One set of operations for each VF to handle various API versions
+	 *     at the same time
+	 * VF: Only the very first (0) set should be used
+	 */
+	struct ixgbe_mbx_operations ops[64];
+	struct ixgbe_mbx_stats stats;
+	u32 timeout;
+	u32 usec_delay;
+	u32 vf_mailbox;
+	u16 size;
+};
 
+#define IXGBE_VFMAILBOX_SIZE	16 /* 16 32 bit words - 64 bytes */
+
+#define IXGBE_VFMAILBOX		0x002FC
+#define IXGBE_VFMBMEM		0x00200
+
+/* Define mailbox register bits */
+#define IXGBE_VFMAILBOX_REQ	0x00000001 /* Request for PF Ready bit */
+#define IXGBE_VFMAILBOX_ACK	0x00000002 /* Ack PF message received */
+#define IXGBE_VFMAILBOX_VFU	0x00000004 /* VF owns the mailbox buffer */
+#define IXGBE_VFMAILBOX_PFU	0x00000008 /* PF owns the mailbox buffer */
+#define IXGBE_VFMAILBOX_PFSTS	0x00000010 /* PF wrote a message in the MB */
+#define IXGBE_VFMAILBOX_PFACK	0x00000020 /* PF ack the previous VF msg */
+#define IXGBE_VFMAILBOX_RSTI	0x00000040 /* PF has reset indication */
+#define IXGBE_VFMAILBOX_RSTD	0x00000080 /* PF has indicated reset done */
+#define IXGBE_VFMAILBOX_R2C_BITS	0x000000B0 /* All read to clear bits */
+
+#define IXGBE_PFMAILBOX_STS	0x00000001 /* Initiate message send to VF */
+#define IXGBE_PFMAILBOX_ACK	0x00000002 /* Ack message recv'd from VF */
+#define IXGBE_PFMAILBOX_VFU	0x00000004 /* VF owns the mailbox buffer */
+#define IXGBE_PFMAILBOX_PFU	0x00000008 /* PF owns the mailbox buffer */
+#define IXGBE_PFMAILBOX_RVFU	0x00000010 /* Reset VFU - used when VF stuck */
+
+#define IXGBE_PFMBICR_VFREQ_MASK	0x0000FFFF /* bits for VF messages */
+#define IXGBE_PFMBICR_VFREQ_VF1		0x00000001 /* bit for VF 1 message */
+#define IXGBE_PFMBICR_VFACK_MASK	0xFFFF0000 /* bits for VF acks */
+#define IXGBE_PFMBICR_VFACK_VF1		0x00010000 /* bit for VF 1 ack */
 
 /* If it's a IXGBE_VF_* msg then it originates in the VF and is sent to the
  * PF.  The reverse is true if it is IXGBE_PF_*.
- * Message ACK's are the value or'd with 0xF0000000
+ * Message results are the value or'd with 0xF0000000
  */
-#define IXGBE_VT_MSGTYPE_ACK      0x80000000  /* Messages below or'd with
-					       * this are the ACK */
-#define IXGBE_VT_MSGTYPE_NACK     0x40000000  /* Messages below or'd with
-					       * this are the NACK */
-#define IXGBE_VT_MSGTYPE_CTS      0x20000000  /* Indicates that VF is still
-						 clear to send requests */
-#define IXGBE_VT_MSGINFO_SHIFT    16
-/* bits 23:16 are used for exra info for certain messages */
-#define IXGBE_VT_MSGINFO_MASK     (0xFF << IXGBE_VT_MSGINFO_SHIFT)
+#define IXGBE_VT_MSGTYPE_SUCCESS	0x80000000 /* Messages or'd with this
+						    * have succeeded
+						    */
+#define IXGBE_VT_MSGTYPE_FAILURE	0x40000000 /* Messages or'd with this
+						    * have failed
+						    */
+#define IXGBE_VT_MSGTYPE_CTS		0x20000000 /* Indicates that VF is still
+						    * clear to send requests
+						    */
+#define IXGBE_VT_MSGINFO_SHIFT	16
+/* bits 23:16 are used for extra info for certain messages */
+#define IXGBE_VT_MSGINFO_MASK	(0xFF << IXGBE_VT_MSGINFO_SHIFT)
 
 /* definitions to support mailbox API version negotiation */
 
 /*
- * Each element denotes a version of the API; existing numbers may not
+ * each element denotes a version of the API; existing numbers may not
  * change; any additions must go at the end
  */
 enum ixgbe_pfvf_api_rev {
@@ -50,16 +96,18 @@ enum ixgbe_pfvf_api_rev {
 	ixgbe_mbox_api_11,	/* API version 1.1, linux/freebsd VF driver */
 	ixgbe_mbox_api_12,	/* API version 1.2, linux/freebsd VF driver */
 	ixgbe_mbox_api_13,	/* API version 1.3, linux/freebsd VF driver */
+	/* API 1.4 is being used in the upstream for IPsec */
 	ixgbe_mbox_api_14,	/* API version 1.4, linux/freebsd VF driver */
+	ixgbe_mbox_api_15,	/* API version 1.5, linux/freebsd VF driver */
 	/* This value should always be last */
 	ixgbe_mbox_api_unknown,	/* indicates that API version is not known */
 };
 
 /* mailbox API, legacy requests */
-#define IXGBE_VF_RESET            0x01 /* VF requests reset */
-#define IXGBE_VF_SET_MAC_ADDR     0x02 /* VF requests PF to set MAC addr */
-#define IXGBE_VF_SET_MULTICAST    0x03 /* VF requests PF to set MC addr */
-#define IXGBE_VF_SET_VLAN         0x04 /* VF requests PF to set VLAN */
+#define IXGBE_VF_RESET		0x01 /* VF requests reset */
+#define IXGBE_VF_SET_MAC_ADDR	0x02 /* VF requests PF to set MAC addr */
+#define IXGBE_VF_SET_MULTICAST	0x03 /* VF requests PF to set MC addr */
+#define IXGBE_VF_SET_VLAN	0x04 /* VF requests PF to set VLAN */
 
 /* mailbox API, version 1.0 VF requests */
 #define IXGBE_VF_SET_LPE	0x05 /* VF requests PF to set VMOLR.LPE */
@@ -69,41 +117,59 @@ enum ixgbe_pfvf_api_rev {
 /* mailbox API, version 1.1 VF requests */
 #define IXGBE_VF_GET_QUEUES	0x09 /* get queue configuration */
 
+/* mailbox API, version 1.2 VF requests */
+#define IXGBE_VF_GET_RETA      0x0a    /* VF request for RETA */
+#define IXGBE_VF_GET_RSS_KEY	0x0b    /* get RSS key */
+#define IXGBE_VF_UPDATE_XCAST_MODE	0x0c
+
+/* mode choices for IXGBE_VF_UPDATE_XCAST_MODE */
+enum ixgbevf_xcast_modes {
+	IXGBEVF_XCAST_MODE_NONE = 0,
+	IXGBEVF_XCAST_MODE_MULTI,
+	IXGBEVF_XCAST_MODE_ALLMULTI,
+	IXGBEVF_XCAST_MODE_PROMISC,
+};
+
 /* GET_QUEUES return data indices within the mailbox */
 #define IXGBE_VF_TX_QUEUES	1	/* number of Tx queues supported */
 #define IXGBE_VF_RX_QUEUES	2	/* number of Rx queues supported */
 #define IXGBE_VF_TRANS_VLAN	3	/* Indication of port vlan */
 #define IXGBE_VF_DEF_QUEUE	4	/* Default queue offset */
 
-/* mailbox API, version 1.2 VF requests */
-#define IXGBE_VF_GET_RETA	0x0a	/* VF request for RETA */
-#define IXGBE_VF_GET_RSS_KEY	0x0b	/* get RSS key */
-
-#define IXGBE_VF_UPDATE_XCAST_MODE	0x0c
-
-/* mailbox API, version 1.4 VF requests */
-#define IXGBE_VF_IPSEC_ADD	0x0d
-#define IXGBE_VF_IPSEC_DEL	0x0e
-
 /* length of permanent address message returned from PF */
-#define IXGBE_VF_PERMADDR_MSG_LEN 4
+#define IXGBE_VF_PERMADDR_MSG_LEN	4
 /* word in permanent address message with the current multicast type */
-#define IXGBE_VF_MC_TYPE_WORD     3
-
-#define IXGBE_PF_CONTROL_MSG      0x0100 /* PF control message */
-
-#define IXGBE_VF_MBX_INIT_TIMEOUT 2000 /* number of retries on mailbox */
-#define IXGBE_VF_MBX_INIT_DELAY   500  /* microseconds between retries */
-
-s32 ixgbe_read_mbx(struct ixgbe_hw *, u32 *, u16, u16);
-s32 ixgbe_write_mbx(struct ixgbe_hw *, u32 *, u16, u16);
-s32 ixgbe_check_for_msg(struct ixgbe_hw *, u16);
-s32 ixgbe_check_for_ack(struct ixgbe_hw *, u16);
-s32 ixgbe_check_for_rst(struct ixgbe_hw *, u16);
-#ifdef CONFIG_PCI_IOV
-void ixgbe_init_mbx_params_pf(struct ixgbe_hw *);
-#endif /* CONFIG_PCI_IOV */
-
-extern const struct ixgbe_mbx_operations mbx_ops_generic;
+#define IXGBE_VF_MC_TYPE_WORD		3
+
+#define IXGBE_PF_CONTROL_MSG		0x0100 /* PF control message */
+
+/* mailbox API, version 2.0 VF requests */
+#define IXGBE_VF_API_NEGOTIATE		0x08 /* negotiate API version */
+#define IXGBE_VF_GET_QUEUES		0x09 /* get queue configuration */
+#define IXGBE_VF_ENABLE_MACADDR		0x0A /* enable MAC address */
+#define IXGBE_VF_DISABLE_MACADDR	0x0B /* disable MAC address */
+#define IXGBE_VF_GET_MACADDRS		0x0C /* get all configured MAC addrs */
+#define IXGBE_VF_SET_MCAST_PROMISC	0x0D /* enable multicast promiscuous */
+#define IXGBE_VF_GET_MTU		0x0E /* get bounds on MTU */
+#define IXGBE_VF_SET_MTU		0x0F /* set a specific MTU */
+
+/* mailbox API, version 2.0 PF requests */
+#define IXGBE_PF_TRANSPARENT_VLAN	0x0101 /* enable transparent vlan */
+
+#define IXGBE_VF_MBX_INIT_TIMEOUT	2000 /* number of retries on mailbox */
+#define IXGBE_VF_MBX_INIT_DELAY		500  /* microseconds between retries */
+
+s32 ixgbe_read_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
+s32 ixgbe_poll_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
+s32 ixgbe_write_mbx(struct ixgbe_hw *hw, u32 *msg, u16 size, u16 mbx_id);
+s32 ixgbe_check_for_msg(struct ixgbe_hw *hw, u16 mbx_id);
+s32 ixgbe_check_for_ack(struct ixgbe_hw *hw, u16 mbx_id);
+s32 ixgbe_check_for_rst(struct ixgbe_hw *hw, u16 mbx_id);
+s32 ixgbe_clear_mbx(struct ixgbe_hw *hw, u16 vf_number);
+void ixgbe_init_mbx_params_vf(struct ixgbe_hw *);
+void ixgbe_upgrade_mbx_params_vf(struct ixgbe_hw *hw);
+void ixgbe_init_mbx_params_pf(struct ixgbe_hw *hw);
+void ixgbe_init_mbx_params_pf_id(struct ixgbe_hw *hw, u16 vf_id);
+void ixgbe_upgrade_mbx_params_pf(struct ixgbe_hw *hw, u16 vf_id);
 
 #endif /* _IXGBE_MBX_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h
index 1e6cf220f543..d5f876a3f02a 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_model.h
@@ -1,5 +1,5 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_MODEL_H_
 #define _IXGBE_MODEL_H_
@@ -29,8 +29,8 @@ static inline int ixgbe_mat_prgm_sip(struct ixgbe_fdir_filter *input,
 				     union ixgbe_atr_input *mask,
 				     u32 val, u32 m)
 {
-	input->filter.formatted.src_ip[0] = (__force __be32)val;
-	mask->formatted.src_ip[0] = (__force __be32)m;
+	input->filter.formatted.src_ip[0] = val;
+	mask->formatted.src_ip[0] = m;
 	return 0;
 }
 
@@ -38,8 +38,8 @@ static inline int ixgbe_mat_prgm_dip(struct ixgbe_fdir_filter *input,
 				     union ixgbe_atr_input *mask,
 				     u32 val, u32 m)
 {
-	input->filter.formatted.dst_ip[0] = (__force __be32)val;
-	mask->formatted.dst_ip[0] = (__force __be32)m;
+	input->filter.formatted.dst_ip[0] = val;
+	mask->formatted.dst_ip[0] = m;
 	return 0;
 }
 
@@ -55,10 +55,11 @@ static inline int ixgbe_mat_prgm_ports(struct ixgbe_fdir_filter *input,
 				       union ixgbe_atr_input *mask,
 				       u32 val, u32 m)
 {
-	input->filter.formatted.src_port = (__force __be16)(val & 0xffff);
-	mask->formatted.src_port = (__force __be16)(m & 0xffff);
-	input->filter.formatted.dst_port = (__force __be16)(val >> 16);
-	mask->formatted.dst_port = (__force __be16)(m >> 16);
+	input->filter.formatted.src_port = val & 0xffff;
+	mask->formatted.src_port = m & 0xffff;
+
+	input->filter.formatted.dst_port = val >> 16;
+	mask->formatted.dst_port = m >> 16;
 
 	return 0;
 };
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep.h
new file mode 100644
index 000000000000..dbd04679ac42
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep.h
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+
+/* glue for the OS independent part of ixgbe
+ * includes register access macros
+ */
+
+#ifndef _IXGBE_OSDEP_H_
+#define _IXGBE_OSDEP_H_
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/if_ether.h>
+#include <linux/sched.h>
+#include "kcompat.h"
+
+#define IXGBE_CPU_TO_BE16(_x) cpu_to_be16(_x)
+#define IXGBE_BE16_TO_CPU(_x) be16_to_cpu(_x)
+#define IXGBE_CPU_TO_BE32(_x) cpu_to_be32(_x)
+#define IXGBE_BE32_TO_CPU(_x) be32_to_cpu(_x)
+
+#define msec_delay(_x) msleep(_x)
+
+#define usec_delay(_x) udelay(_x)
+
+#define STATIC static
+
+#define IOMEM __iomem
+
+#ifdef DBG
+#define ASSERT(_x)		BUG_ON(!(_x))
+#else
+#define ASSERT(_x)		do {} while (0)
+#endif
+
+#define DEBUGFUNC(S)		do {} while (0)
+
+#define IXGBE_SFP_DETECT_RETRIES	2
+
+struct ixgbe_hw;
+struct ixgbe_msg {
+	u16 msg_enable;
+};
+struct net_device *ixgbe_hw_to_netdev(const struct ixgbe_hw *hw);
+struct ixgbe_msg *ixgbe_hw_to_msg(const struct ixgbe_hw *hw);
+
+#ifdef DBG
+#define hw_dbg(hw, format, arg...) \
+	netdev_dbg(ixgbe_hw_to_netdev(hw), format, ## arg)
+#else
+#define hw_dbg(hw, format, arg...) do {} while (0)
+#endif
+
+#define hw_err(hw, format, arg...) \
+	netdev_err(ixgbe_hw_to_netdev(hw), format, ## arg)
+#define e_dev_info(format, arg...) \
+	dev_info(pci_dev_to_dev(adapter->pdev), format, ## arg)
+#define e_dev_warn(format, arg...) \
+	dev_warn(pci_dev_to_dev(adapter->pdev), format, ## arg)
+#define e_dev_err(format, arg...) \
+	dev_err(pci_dev_to_dev(adapter->pdev), format, ## arg)
+#define e_dev_notice(format, arg...) \
+	dev_notice(pci_dev_to_dev(adapter->pdev), format, ## arg)
+#define e_dbg(msglvl, format, arg...) \
+	netif_dbg(adapter, msglvl, adapter->netdev, format, ## arg)
+#define e_info(msglvl, format, arg...) \
+	netif_info(adapter, msglvl, adapter->netdev, format, ## arg)
+#define e_err(msglvl, format, arg...) \
+	netif_err(adapter, msglvl, adapter->netdev, format, ## arg)
+#define e_warn(msglvl, format, arg...) \
+	netif_warn(adapter, msglvl, adapter->netdev, format, ## arg)
+#define e_crit(msglvl, format, arg...) \
+	netif_crit(adapter, msglvl, adapter->netdev, format, ## arg)
+
+#define IXGBE_DEAD_READ_RETRIES 10
+#define IXGBE_DEAD_READ_REG 0xdeadbeefU
+#define IXGBE_FAILED_READ_REG 0xffffffffU
+#define IXGBE_FAILED_READ_RETRIES 5
+#define IXGBE_FAILED_READ_CFG_DWORD 0xffffffffU
+#define IXGBE_FAILED_READ_CFG_WORD 0xffffU
+#define IXGBE_FAILED_READ_CFG_BYTE 0xffU
+
+#define IXGBE_WRITE_REG_ARRAY(a, reg, offset, value) \
+	IXGBE_WRITE_REG((a), (reg) + ((offset) << 2), (value))
+
+#define IXGBE_READ_REG(h, r) ixgbe_read_reg(h, r, false)
+#define IXGBE_R32_Q(h, r) ixgbe_read_reg(h, r, true)
+#define IXGBE_R8_Q(h, r) readb(READ_ONCE(h->hw_addr) + r)
+
+#define IXGBE_READ_REG_ARRAY(a, reg, offset) ( \
+	IXGBE_READ_REG((a), (reg) + ((offset) << 2)))
+
+#ifndef writeq
+#define writeq(val, addr)	do { writel((u32) (val), addr); \
+				     writel((u32) (val >> 32), (addr + 4)); \
+				} while (0);
+#endif
+
+#define IXGBE_WRITE_FLUSH(a) IXGBE_READ_REG(a, IXGBE_STATUS)
+
+u32 ixgbe_read_reg(struct ixgbe_hw *, u32 reg, bool quiet);
+extern u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg);
+extern void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value);
+extern void ewarn(struct ixgbe_hw *hw, const char *str);
+
+#define IXGBE_READ_PCIE_WORD ixgbe_read_pci_cfg_word
+#define IXGBE_WRITE_PCIE_WORD ixgbe_write_pci_cfg_word
+#define IXGBE_EEPROM_GRANT_ATTEMPS 100
+#define IXGBE_HTONL(_i) htonl(_i)
+#define IXGBE_NTOHL(_i) ntohl(_i)
+#define IXGBE_NTOHS(_i) ntohs(_i)
+#define IXGBE_CPU_TO_LE32(_i) cpu_to_le32(_i)
+#define IXGBE_CPU_TO_LE16(_i) cpu_to_le16(_i)
+#define IXGBE_LE32_TO_CPU(_i) le32_to_cpu(_i)
+#define IXGBE_LE32_TO_CPUS(_i) le32_to_cpus(_i)
+#define EWARN(H, W) ewarn(H, W)
+
+enum {
+	IXGBE_ERROR_SOFTWARE,
+	IXGBE_ERROR_POLLING,
+	IXGBE_ERROR_INVALID_STATE,
+	IXGBE_ERROR_UNSUPPORTED,
+	IXGBE_ERROR_ARGUMENT,
+	IXGBE_ERROR_CAUTION,
+};
+
+#define ERROR_REPORT(level, format, arg...) do {				\
+	switch (level) {							\
+	case IXGBE_ERROR_SOFTWARE:						\
+	case IXGBE_ERROR_CAUTION:						\
+	case IXGBE_ERROR_POLLING:						\
+		netif_warn(ixgbe_hw_to_msg(hw), drv, ixgbe_hw_to_netdev(hw),	\
+			   format, ## arg);					\
+		break;								\
+	case IXGBE_ERROR_INVALID_STATE:						\
+	case IXGBE_ERROR_UNSUPPORTED:						\
+	case IXGBE_ERROR_ARGUMENT:						\
+		netif_err(ixgbe_hw_to_msg(hw), hw, ixgbe_hw_to_netdev(hw),	\
+			  format, ## arg);					\
+		break;								\
+	default:								\
+		break;								\
+	}									\
+} while (0)
+
+#define ERROR_REPORT1 ERROR_REPORT
+#define ERROR_REPORT2 ERROR_REPORT
+#define ERROR_REPORT3 ERROR_REPORT
+
+#define UNREFERENCED_XPARAMETER
+#define UNREFERENCED_1PARAMETER(_p) do {		\
+	uninitialized_var(_p);				\
+} while (0)
+#define UNREFERENCED_2PARAMETER(_p, _q) do {		\
+	uninitialized_var(_p);				\
+	uninitialized_var(_q);				\
+} while (0)
+#define UNREFERENCED_3PARAMETER(_p, _q, _r) do {	\
+	uninitialized_var(_p);				\
+	uninitialized_var(_q);				\
+	uninitialized_var(_r);				\
+} while (0)
+#define UNREFERENCED_4PARAMETER(_p, _q, _r, _s) do {	\
+	uninitialized_var(_p);				\
+	uninitialized_var(_q);				\
+	uninitialized_var(_r);				\
+	uninitialized_var(_s);				\
+} while (0)
+
+#endif /* _IXGBE_OSDEP_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep2.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep2.h
new file mode 100644
index 000000000000..6147aa3960bd
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_osdep2.h
@@ -0,0 +1,50 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_OSDEP2_H_
+#define _IXGBE_OSDEP2_H_
+
+static inline bool ixgbe_removed(void __iomem *addr)
+{
+	return unlikely(!addr);
+}
+#define IXGBE_REMOVED(a) ixgbe_removed(a)
+
+static inline void IXGBE_WRITE_REG(struct ixgbe_hw *hw, u32 reg, u32 value)
+{
+	u8 __iomem *reg_addr;
+
+	reg_addr = READ_ONCE(hw->hw_addr);
+	if (IXGBE_REMOVED(reg_addr))
+		return;
+#ifdef DBG
+	{
+		struct net_device *netdev = ixgbe_hw_to_netdev(hw);
+
+		switch (reg) {
+		case IXGBE_EIMS:
+		case IXGBE_EIMC:
+		case IXGBE_EIAM:
+		case IXGBE_EIAC:
+		case IXGBE_EICR:
+		case IXGBE_EICS:
+			netdev_info(netdev,
+				    "%s: Reg - 0x%05X, value - 0x%08X\n",
+				    __func__, reg, value);
+		}
+	}
+#endif /* DBG */
+	writel(value, reg_addr + reg);
+}
+
+static inline void IXGBE_WRITE_REG64(struct ixgbe_hw *hw, u32 reg, u64 value)
+{
+	u8 __iomem *reg_addr;
+
+	reg_addr = READ_ONCE(hw->hw_addr);
+	if (IXGBE_REMOVED(reg_addr))
+		return;
+	writeq(value, reg_addr + reg);
+}
+
+#endif /* _IXGBE_OSDEP2_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_param.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_param.c
new file mode 100644
index 000000000000..b025e208a552
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_param.c
@@ -0,0 +1,1267 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#include <linux/types.h>
+#include <linux/module.h>
+
+#include "ixgbe.h"
+
+/* This is the only thing that needs to be changed to adjust the
+ * maximum number of ports that the driver can manage.
+ */
+
+#define IXGBE_MAX_NIC	32
+
+#define OPTION_UNSET	-1
+#define OPTION_DISABLED	0
+#define OPTION_ENABLED	1
+
+#define STRINGIFY(foo)	#foo /* magic for getting defines into strings */
+#define XSTRINGIFY(bar)	STRINGIFY(bar)
+
+/* All parameters are treated the same, as an integer array of values.
+ * This macro just reduces the need to repeat the same declaration code
+ * over and over (plus this helps to avoid typo bugs).
+ */
+
+#define IXGBE_PARAM_INIT { [0 ... IXGBE_MAX_NIC] = OPTION_UNSET }
+#ifndef module_param_array
+/* Module Parameters are always initialized to -1, so that the driver
+ * can tell the difference between no user specified value or the
+ * user asking for the default value.
+ * The true default values are loaded in when ixgbe_check_options is called.
+ *
+ * This is a GCC extension to ANSI C.
+ * See the item "Labelled Elements in Initializers" in the section
+ * "Extensions to the C Language Family" of the GCC documentation.
+ */
+
+#define IXGBE_PARAM(X, desc) \
+	static const int __devinitdata X[IXGBE_MAX_NIC+1] = IXGBE_PARAM_INIT; \
+	MODULE_PARM(X, "1-" __MODULE_STRING(IXGBE_MAX_NIC) "i"); \
+	MODULE_PARM_DESC(X, desc);
+#else
+#define IXGBE_PARAM(X, desc) \
+	static int __devinitdata X[IXGBE_MAX_NIC+1] = IXGBE_PARAM_INIT; \
+	static unsigned int num_##X; \
+	module_param_array_named(X, X, int, &num_##X, 0); \
+	MODULE_PARM_DESC(X, desc);
+#endif
+
+/* IntMode (Interrupt Mode)
+ *
+ * Valid Range: 0-2
+ *  - 0 - Legacy Interrupt
+ *  - 1 - MSI Interrupt
+ *  - 2 - MSI-X Interrupt(s)
+ *
+ * Default Value: 2
+ */
+IXGBE_PARAM(IntMode, "Change Interrupt Mode (0=Legacy, 1=MSI, 2=MSI-X), "
+	    "default 2");
+#define IXGBE_INT_LEGACY		0
+#define IXGBE_INT_MSI			1
+#define IXGBE_INT_MSIX			2
+
+IXGBE_PARAM(InterruptType, "Change Interrupt Mode (0=Legacy, 1=MSI, 2=MSI-X), "
+	    "default IntMode (deprecated)");
+
+/* MQ - Multiple Queue enable/disable
+ *
+ * Valid Range: 0, 1
+ *  - 0 - disables MQ
+ *  - 1 - enables MQ
+ *
+ * Default Value: 1
+ */
+
+IXGBE_PARAM(MQ, "Disable or enable Multiple Queues, default 1");
+
+#if IS_ENABLED(CONFIG_DCA)
+/* DCA - Direct Cache Access (DCA) Control
+ *
+ * This option allows the device to hint to DCA enabled processors
+ * which CPU should have its cache warmed with the data being
+ * transferred over PCIe.  This can increase performance by reducing
+ * cache misses.  ixgbe hardware supports DCA for:
+ * tx descriptor writeback
+ * rx descriptor writeback
+ * rx data
+ * rx data header only (in packet split mode)
+ *
+ * enabling option 2 can cause cache thrash in some tests, particularly
+ * if the CPU is completely utilized
+ *
+ * Valid Range: 0 - 2
+ *  - 0 - disables DCA
+ *  - 1 - enables DCA
+ *  - 2 - enables DCA with rx data included
+ *
+ * Default Value: 2
+ */
+
+#define IXGBE_MAX_DCA 2
+
+IXGBE_PARAM(DCA, "Disable or enable Direct Cache Access, 0=disabled, "
+	    "1=descriptor only, 2=descriptor and data");
+#endif /* CONFIG_DCA */
+
+/* RSS - Receive-Side Scaling (RSS) Descriptor Queues
+ *
+ * Valid Range: 0-16
+ *  - 0 - enables RSS and sets the Desc. Q's to min(16, num_online_cpus()).
+ *  - 1-16 - enables RSS and sets the Desc. Q's to the specified value.
+ *
+ * Default Value: 0
+ */
+
+IXGBE_PARAM(RSS, "Number of Receive-Side Scaling Descriptor Queues, "
+	    "default 0=number of cpus");
+
+/* VMDQ - Virtual Machine Device Queues (VMDQ)
+ *
+ * Valid Range: 1-16
+ *  - 0/1 Disables VMDQ by allocating only a single queue.
+ *  - 2-16 - enables VMDQ and sets the Desc. Q's to the specified value.
+ *
+ * Default Value: 8
+ */
+
+#define IXGBE_DEFAULT_NUM_VMDQ 8
+
+IXGBE_PARAM(VMDQ, "Number of Virtual Machine Device Queues: 0/1 = disable (1 queue) "
+	    "2-16 enable (default=" XSTRINGIFY(IXGBE_DEFAULT_NUM_VMDQ) ")");
+
+#ifdef CONFIG_PCI_IOV
+/* max_vfs - SR I/O Virtualization
+ *
+ * Valid Range: 0-63
+ *  - 0 Disables SR-IOV
+ *  - 1-63 - enables SR-IOV and sets the number of VFs enabled
+ *
+ * Default Value: 0
+ */
+
+#define MAX_SRIOV_VFS 63
+
+IXGBE_PARAM(max_vfs, "Number of Virtual Functions: 0 = disable (default), "
+	    "1-" XSTRINGIFY(MAX_SRIOV_VFS) " = enable "
+	    "this many VFs");
+
+/* VEPA - Set internal bridge to VEPA mode
+ *
+ * Valid Range: 0-1
+ *  - 0 Set bridge to VEB mode
+ *  - 1 Set bridge to VEPA mode
+ *
+ * Default Value: 0
+ */
+/*
+ *Note:
+ *=====
+ * This provides ability to ensure VEPA mode on the internal bridge even if
+ * the kernel does not support the netdev bridge setting operations.
+*/
+IXGBE_PARAM(VEPA, "VEPA Bridge Mode: 0 = VEB (default), 1 = VEPA");
+#endif
+
+/* Interrupt Throttle Rate (interrupts/sec)
+ *
+ * Valid Range: 956-488281 (0=off, 1=dynamic)
+ *
+ * Default Value: 1
+ */
+#define DEFAULT_ITR		1
+IXGBE_PARAM(InterruptThrottleRate, "Maximum interrupts per second, per vector, "
+	    "(0,1,956-488281), default 1");
+#define MAX_ITR		IXGBE_MAX_INT_RATE
+#define MIN_ITR		IXGBE_MIN_INT_RATE
+
+#ifndef IXGBE_NO_LLI
+
+/* LLIPort (Low Latency Interrupt TCP Port)
+ *
+ * Valid Range: 0 - 65535
+ *
+ * Default Value: 0 (disabled)
+ */
+IXGBE_PARAM(LLIPort, "Low Latency Interrupt TCP Port (0-65535)");
+
+#define DEFAULT_LLIPORT		0
+#define MAX_LLIPORT		0xFFFF
+#define MIN_LLIPORT		0
+
+/* LLIPush (Low Latency Interrupt on TCP Push flag)
+ *
+ * Valid Range: 0,1
+ *
+ * Default Value: 0 (disabled)
+ */
+IXGBE_PARAM(LLIPush, "Low Latency Interrupt on TCP Push flag (0,1)");
+
+#define DEFAULT_LLIPUSH		0
+#define MAX_LLIPUSH		1
+#define MIN_LLIPUSH		0
+
+/* LLISize (Low Latency Interrupt on Packet Size)
+ *
+ * Valid Range: 0 - 1500
+ *
+ * Default Value: 0 (disabled)
+ */
+IXGBE_PARAM(LLISize, "Low Latency Interrupt on Packet Size (0-1500)");
+
+#define DEFAULT_LLISIZE		0
+#define MAX_LLISIZE		1500
+#define MIN_LLISIZE		0
+
+/* LLIEType (Low Latency Interrupt Ethernet Type)
+ *
+ * Valid Range: 0 - 0x8fff
+ *
+ * Default Value: 0 (disabled)
+ */
+IXGBE_PARAM(LLIEType, "Low Latency Interrupt Ethernet Protocol Type");
+
+#define DEFAULT_LLIETYPE	0
+#define MAX_LLIETYPE		0x8fff
+#define MIN_LLIETYPE		0
+
+/* LLIVLANP (Low Latency Interrupt on VLAN priority threshold)
+ *
+ * Valid Range: 0 - 7
+ *
+ * Default Value: 0 (disabled)
+ */
+IXGBE_PARAM(LLIVLANP, "Low Latency Interrupt on VLAN priority threshold");
+
+#define DEFAULT_LLIVLANP	0
+#define MAX_LLIVLANP		7
+#define MIN_LLIVLANP		0
+
+#endif /* IXGBE_NO_LLI */
+#ifdef HAVE_TX_MQ
+/* Flow Director packet buffer allocation level
+ *
+ * Valid Range: 1-3
+ *   1 = 8k hash/2k perfect,
+ *   2 = 16k hash/4k perfect,
+ *   3 = 32k hash/8k perfect
+ *
+ * Default Value: 0
+ */
+IXGBE_PARAM(FdirPballoc, "Flow Director packet buffer allocation level:\n"
+	    "\t\t\t1 = 8k hash filters or 2k perfect filters\n"
+	    "\t\t\t2 = 16k hash filters or 4k perfect filters\n"
+	    "\t\t\t3 = 32k hash filters or 8k perfect filters");
+
+#define IXGBE_DEFAULT_FDIR_PBALLOC IXGBE_FDIR_PBALLOC_64K
+
+/* Software ATR packet sample rate
+ *
+ * Valid Range: 0-255  0 = off, 1-255 = rate of Tx packet inspection
+ *
+ * Default Value: 20
+ */
+IXGBE_PARAM(AtrSampleRate, "Software ATR Tx packet sample rate");
+
+#define IXGBE_MAX_ATR_SAMPLE_RATE	255
+#define IXGBE_MIN_ATR_SAMPLE_RATE	1
+#define IXGBE_ATR_SAMPLE_RATE_OFF	0
+#define IXGBE_DEFAULT_ATR_SAMPLE_RATE	20
+#endif /* HAVE_TX_MQ */
+
+#if IS_ENABLED(CONFIG_FCOE)
+/* FCoE - Fibre Channel over Ethernet Offload  Enable/Disable
+ *
+ * Valid Range: 0, 1
+ *  - 0 - disables FCoE Offload
+ *  - 1 - enables FCoE Offload
+ *
+ * Default Value: 1
+ */
+IXGBE_PARAM(FCoE, "Disable or enable FCoE Offload, default 1");
+#endif /* CONFIG_FCOE */
+
+/* Enable/disable Malicious Driver Detection
+ *
+ * Valid Values: 0(off), 1(on)
+ *
+ * Default Value: 1
+ */
+IXGBE_PARAM(MDD, "Malicious Driver Detection: (0,1), default 1 = on");
+
+/* Enable/disable Large Receive Offload
+ *
+ * Valid Values: 0(off), 1(on)
+ *
+ * Default Value: 1
+ */
+IXGBE_PARAM(LRO, "Large Receive Offload (0,1), default 0 = off");
+
+/* Enable/disable support for untested SFP+ modules on 82599-based adapters
+ *
+ * Valid Values: 0(Disable), 1(Enable)
+ *
+ * Default Value: 0
+ */
+IXGBE_PARAM(allow_unsupported_sfp, "Allow unsupported and untested "
+	    "SFP+ modules on 82599 based adapters, default 0 = Disable");
+
+/* Enable/disable support for DMA coalescing
+ *
+ * Valid Values: 0(off), 41 - 10000(on)
+ *
+ * Default Value: 0
+ */
+IXGBE_PARAM(dmac_watchdog,
+	    "DMA coalescing watchdog in microseconds (0,41-10000), default 0 = off");
+
+/* Enable/disable support for VXLAN rx checksum offload
+ *
+ * Valid Values: 0(Disable), 1(Enable)
+ *
+ * Default Value: 1 on hardware that supports it
+ */
+IXGBE_PARAM(vxlan_rx,
+	    "VXLAN receive checksum offload (0,1), default 1 = Enable");
+
+
+struct ixgbe_option {
+	enum { enable_option, range_option, list_option } type;
+	const char *name;
+	const char *err;
+	const char *msg;
+	int def;
+	union {
+		struct { /* range_option info */
+			int min;
+			int max;
+		} r;
+		struct { /* list_option info */
+			int nr;
+			const struct ixgbe_opt_list {
+				int i;
+				char *str;
+			} *p;
+		} l;
+	} arg;
+};
+
+#ifndef IXGBE_NO_LLI
+#ifdef module_param_array
+/**
+ * helper function to determine LLI support
+ * @adapter: board private structure
+ * @opt: pointer to option struct
+ *
+ * LLI is only supported for 82599 and X540
+ * LLIPush is not supported on 82599
+ **/
+#ifdef HAVE_CONFIG_HOTPLUG
+static bool __devinit ixgbe_lli_supported(struct ixgbe_adapter *adapter,
+					  struct ixgbe_option *opt)
+#else
+static bool ixgbe_lli_supported(struct ixgbe_adapter *adapter,
+				struct ixgbe_option *opt)
+#endif
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+
+	if (hw->mac.type == ixgbe_mac_82599EB) {
+
+		if (LLIPush[adapter->bd_number] > 0)
+			goto not_supp;
+
+		return true;
+	}
+
+	if (hw->mac.type == ixgbe_mac_X540)
+		return true;
+
+not_supp:
+	DPRINTK(PROBE, INFO, "%s not supported on this HW\n", opt->name);
+	return false;
+}
+#endif /* module_param_array */
+#endif /* IXGBE_NO_LLI */
+
+#ifdef HAVE_CONFIG_HOTPLUG
+static int __devinit ixgbe_validate_option(struct net_device *netdev,
+					   unsigned int *value,
+					   struct ixgbe_option *opt)
+#else
+static int ixgbe_validate_option(struct net_device *netdev,
+				 unsigned int *value,
+				 struct ixgbe_option *opt)
+#endif
+{
+	if (*value == OPTION_UNSET) {
+		netdev_info(netdev, "Invalid %s specified (%d),  %s\n",
+			    opt->name, *value, opt->err);
+		*value = opt->def;
+		return 0;
+	}
+
+	switch (opt->type) {
+	case enable_option:
+		switch (*value) {
+		case OPTION_ENABLED:
+			netdev_info(netdev, "%s Enabled\n", opt->name);
+			return 0;
+		case OPTION_DISABLED:
+			netdev_info(netdev, "%s Disabled\n", opt->name);
+			return 0;
+		}
+		break;
+	case range_option:
+		if ((*value >= opt->arg.r.min && *value <= opt->arg.r.max) ||
+		    *value == opt->def) {
+			if (opt->msg)
+				netdev_info(netdev, "%s set to %d, %s\n",
+					    opt->name, *value, opt->msg);
+			else
+				netdev_info(netdev, "%s set to %d\n",
+					    opt->name, *value);
+			return 0;
+		}
+		break;
+	case list_option: {
+		int i;
+
+		for (i = 0; i < opt->arg.l.nr; i++) {
+			const struct ixgbe_opt_list *ent = &opt->arg.l.p[i];
+			if (*value == ent->i) {
+				if (ent->str[0] != '\0')
+					netdev_info(netdev, "%s\n", ent->str);
+				return 0;
+			}
+		}
+	}
+		break;
+	default:
+		BUG();
+	}
+
+	netdev_info(netdev, "Invalid %s specified (%d),  %s\n",
+		    opt->name, *value, opt->err);
+	*value = opt->def;
+	return -1;
+}
+
+#define LIST_LEN(l) (sizeof(l) / sizeof(l[0]))
+#define PSTR_LEN 10
+
+/**
+ * ixgbe_check_options - Range Checking for Command Line Parameters
+ * @adapter: board private structure
+ *
+ * This routine checks all command line parameters for valid user
+ * input.  If an invalid value is given, or if no user specified
+ * value exists, a default value is used.  The final value is stored
+ * in a variable in the adapter structure.
+ **/
+#ifdef HAVE_CONFIG_HOTPLUG
+void __devinit ixgbe_check_options(struct ixgbe_adapter *adapter)
+#else
+void ixgbe_check_options(struct ixgbe_adapter *adapter)
+#endif
+{
+	unsigned int mdd;
+	int bd = adapter->bd_number;
+	u32 *aflags = &adapter->flags;
+	struct ixgbe_ring_feature *feature = adapter->ring_feature;
+	unsigned int vmdq;
+
+	if (bd >= IXGBE_MAX_NIC) {
+		netdev_notice(adapter->netdev,
+			      "Warning: no configuration for board #%d\n", bd);
+		netdev_notice(adapter->netdev,
+			      "Using defaults for all values\n");
+#ifndef module_param_array
+		bd = IXGBE_MAX_NIC;
+#endif
+	}
+
+	{ /* Interrupt Mode */
+		unsigned int int_mode;
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Interrupt Mode",
+			.err =
+			  "using default of " __MODULE_STRING(IXGBE_INT_MSIX),
+			.def = IXGBE_INT_MSIX,
+			.arg = { .r = { .min = IXGBE_INT_LEGACY,
+					.max = IXGBE_INT_MSIX} }
+		};
+
+#ifdef module_param_array
+		if (num_IntMode > bd || num_InterruptType > bd) {
+#endif
+			int_mode = IntMode[bd];
+			if (int_mode == OPTION_UNSET)
+				int_mode = InterruptType[bd];
+			ixgbe_validate_option(adapter->netdev,
+					      &int_mode, &opt);
+			switch (int_mode) {
+			case IXGBE_INT_MSIX:
+				if (!(*aflags & IXGBE_FLAG_MSIX_CAPABLE))
+					netdev_info(adapter->netdev,
+						    "Ignoring MSI-X setting; "
+						    "support unavailable\n");
+				break;
+			case IXGBE_INT_MSI:
+				if (!(*aflags & IXGBE_FLAG_MSI_CAPABLE)) {
+					netdev_info(adapter->netdev,
+						    "Ignoring MSI setting; "
+						    "support unavailable\n");
+				} else {
+					*aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
+				}
+				break;
+			case IXGBE_INT_LEGACY:
+			default:
+				*aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
+				*aflags &= ~IXGBE_FLAG_MSI_CAPABLE;
+				break;
+			}
+#ifdef module_param_array
+		} else {
+			/* default settings */
+			if (*aflags & IXGBE_FLAG_MSIX_CAPABLE) {
+				*aflags |= IXGBE_FLAG_MSI_CAPABLE;
+			} else {
+				*aflags &= ~IXGBE_FLAG_MSIX_CAPABLE;
+				*aflags &= ~IXGBE_FLAG_MSI_CAPABLE;
+			}
+		}
+#endif
+	}
+	{ /* Multiple Queue Support */
+		static struct ixgbe_option opt = {
+			.type = enable_option,
+			.name = "Multiple Queue Support",
+			.err  = "defaulting to Enabled",
+			.def  = OPTION_ENABLED
+		};
+
+#ifdef module_param_array
+		if (num_MQ > bd) {
+#endif
+			unsigned int mq = MQ[bd];
+			ixgbe_validate_option(adapter->netdev, &mq, &opt);
+			if (mq)
+				*aflags |= IXGBE_FLAG_MQ_CAPABLE;
+			else
+				*aflags &= ~IXGBE_FLAG_MQ_CAPABLE;
+#ifdef module_param_array
+		} else {
+			*aflags |= IXGBE_FLAG_MQ_CAPABLE;
+		}
+#endif
+		/* Check Interoperability */
+		if ((*aflags & IXGBE_FLAG_MQ_CAPABLE) &&
+		    !(*aflags & IXGBE_FLAG_MSIX_CAPABLE)) {
+			DPRINTK(PROBE, INFO,
+				"Multiple queues are not supported while MSI-X "
+				"is disabled.  Disabling Multiple Queues.\n");
+			*aflags &= ~IXGBE_FLAG_MQ_CAPABLE;
+		}
+	}
+#if IS_ENABLED(CONFIG_DCA)
+	{ /* Direct Cache Access (DCA) */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Direct Cache Access (DCA)",
+			.err  = "defaulting to Enabled",
+			.def  = IXGBE_MAX_DCA,
+			.arg  = { .r = { .min = OPTION_DISABLED,
+					 .max = IXGBE_MAX_DCA} }
+		};
+		unsigned int dca = opt.def;
+
+#ifdef module_param_array
+		if (num_DCA > bd) {
+#endif
+			dca = DCA[bd];
+			ixgbe_validate_option(adapter->netdev, &dca, &opt);
+			if (!dca)
+				*aflags &= ~IXGBE_FLAG_DCA_CAPABLE;
+
+			/* Check Interoperability */
+			if (!(*aflags & IXGBE_FLAG_DCA_CAPABLE)) {
+				DPRINTK(PROBE, INFO, "DCA is disabled\n");
+				*aflags &= ~IXGBE_FLAG_DCA_ENABLED;
+			}
+
+			if (dca == IXGBE_MAX_DCA) {
+				DPRINTK(PROBE, INFO,
+					"DCA enabled for rx data\n");
+				adapter->flags |= IXGBE_FLAG_DCA_ENABLED_DATA;
+			}
+#ifdef module_param_array
+		} else {
+			/* make sure to clear the capability flag if the
+			 * option is disabled by default above */
+			if (opt.def == OPTION_DISABLED)
+				*aflags &= ~IXGBE_FLAG_DCA_CAPABLE;
+		}
+#endif
+		if (dca == IXGBE_MAX_DCA)
+			adapter->flags |= IXGBE_FLAG_DCA_ENABLED_DATA;
+	}
+#endif /* CONFIG_DCA */
+	{ /* Receive-Side Scaling (RSS) */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Receive-Side Scaling (RSS)",
+			.err  = "using default.",
+			.def  = 0,
+			.arg  = { .r = { .min = 0,
+					 .max = 16} }
+		};
+		unsigned int rss = RSS[bd];
+		/* adjust Max allowed RSS queues based on MAC type */
+		opt.arg.r.max = ixgbe_max_rss_indices(adapter);
+
+#ifdef module_param_array
+		if (num_RSS > bd) {
+#endif
+			ixgbe_validate_option(adapter->netdev, &rss, &opt);
+			/* base it off num_online_cpus() with hardware limit */
+			if (!rss)
+				rss = min_t(int, opt.arg.r.max,
+					    num_online_cpus());
+			else
+				feature[RING_F_FDIR].limit = rss;
+
+			feature[RING_F_RSS].limit = rss;
+#ifdef module_param_array
+		} else if (opt.def == 0) {
+			rss = min_t(int, ixgbe_max_rss_indices(adapter),
+				    num_online_cpus());
+			feature[RING_F_RSS].limit = rss;
+		}
+#endif
+		/* Check Interoperability */
+		if (rss > 1) {
+			if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
+				DPRINTK(PROBE, INFO,
+					"Multiqueue is disabled.  "
+					"Limiting RSS.\n");
+				feature[RING_F_RSS].limit = 1;
+			}
+		}
+	}
+	{ /* Virtual Machine Device Queues (VMDQ) */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Virtual Machine Device Queues (VMDQ)",
+			.err  = "defaulting to Disabled",
+			.def  = OPTION_DISABLED,
+			.arg  = { .r = { .min = OPTION_DISABLED,
+					 .max = IXGBE_MAX_VMDQ_INDICES
+				} }
+		};
+
+		switch (adapter->hw.mac.type) {
+		case ixgbe_mac_82598EB:
+			/* 82598 only supports up to 16 pools */
+				opt.arg.r.max = 16;
+			break;
+		default:
+			break;
+		}
+
+#ifdef module_param_array
+		if (num_VMDQ > bd) {
+#endif
+			vmdq = VMDQ[bd];
+
+			ixgbe_validate_option(adapter->netdev, &vmdq, &opt);
+
+			/* zero or one both mean disabled from our driver's
+			 * perspective */
+			if (vmdq > 1) {
+				*aflags |= IXGBE_FLAG_VMDQ_ENABLED;
+			} else
+				*aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
+
+			feature[RING_F_VMDQ].limit = vmdq;
+#ifdef module_param_array
+		} else {
+			if (opt.def == OPTION_DISABLED)
+				*aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
+			else
+				*aflags |= IXGBE_FLAG_VMDQ_ENABLED;
+
+			feature[RING_F_VMDQ].limit = opt.def;
+		}
+#endif
+		/* Check Interoperability */
+		if (*aflags & IXGBE_FLAG_VMDQ_ENABLED) {
+			if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
+				DPRINTK(PROBE, INFO,
+					"VMDQ is not supported while multiple "
+					"queues are disabled.  "
+					"Disabling VMDQ.\n");
+				*aflags &= ~IXGBE_FLAG_VMDQ_ENABLED;
+				feature[RING_F_VMDQ].limit = 0;
+			}
+		}
+	}
+#ifdef CONFIG_PCI_IOV
+	{ /* Single Root I/O Virtualization (SR-IOV) */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "I/O Virtualization (IOV)",
+			.err  = "defaulting to Disabled",
+			.def  = OPTION_DISABLED,
+			.arg  = { .r = { .min = OPTION_DISABLED,
+					 .max = MAX_SRIOV_VFS} }
+		};
+
+#ifdef module_param_array
+		if (num_max_vfs > bd) {
+#endif
+			unsigned int vfs = max_vfs[bd];
+			if (ixgbe_validate_option(adapter->netdev,
+						  &vfs, &opt)) {
+				vfs = 0;
+				DPRINTK(PROBE, INFO,
+					"max_vfs out of range "
+					"Disabling SR-IOV.\n");
+			}
+
+			adapter->max_vfs = vfs;
+
+			if (vfs)
+				*aflags |= IXGBE_FLAG_SRIOV_ENABLED;
+			else
+				*aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
+#ifdef module_param_array
+		} else {
+			if (opt.def == OPTION_DISABLED) {
+				adapter->max_vfs = 0;
+				*aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
+			} else {
+				adapter->max_vfs = opt.def;
+				*aflags |= IXGBE_FLAG_SRIOV_ENABLED;
+			}
+		}
+#endif
+
+		/* Check Interoperability */
+		if (*aflags & IXGBE_FLAG_SRIOV_ENABLED) {
+			if (!(*aflags & IXGBE_FLAG_SRIOV_CAPABLE)) {
+				DPRINTK(PROBE, INFO,
+					"IOV is not supported on this "
+					"hardware.  Disabling IOV.\n");
+				*aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
+				adapter->max_vfs = 0;
+			} else if (!(*aflags & IXGBE_FLAG_MQ_CAPABLE)) {
+				DPRINTK(PROBE, INFO,
+					"IOV is not supported while multiple "
+					"queues are disabled.  "
+					"Disabling IOV.\n");
+				*aflags &= ~IXGBE_FLAG_SRIOV_ENABLED;
+				adapter->max_vfs = 0;
+			} 
+		}
+	}
+	{ /* VEPA Bridge Mode enable for SR-IOV mode */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "VEPA Bridge Mode Enable",
+			.err  = "defaulting to disabled",
+			.def  = OPTION_DISABLED,
+			.arg  = { .r = { .min = OPTION_DISABLED,
+					 .max = OPTION_ENABLED} }
+		};
+
+#ifdef module_param_array
+		if (num_VEPA > bd) {
+#endif
+			unsigned int vepa = VEPA[bd];
+			ixgbe_validate_option(adapter->netdev, &vepa, &opt);
+			if (vepa)
+				adapter->flags |=
+					IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE;
+#ifdef module_param_array
+		} else {
+			if (opt.def == OPTION_ENABLED)
+				adapter->flags |=
+					IXGBE_FLAG_SRIOV_VEPA_BRIDGE_MODE;
+		}
+#endif
+	}
+#endif /* CONFIG_PCI_IOV */
+	{ /* Interrupt Throttling Rate */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Interrupt Throttling Rate (ints/sec)",
+			.err  = "using default of "__MODULE_STRING(DEFAULT_ITR),
+			.def  = DEFAULT_ITR,
+			.arg  = { .r = { .min = MIN_ITR,
+					 .max = MAX_ITR } }
+		};
+
+#ifdef module_param_array
+		if (num_InterruptThrottleRate > bd) {
+#endif
+			u32 itr = InterruptThrottleRate[bd];
+			switch (itr) {
+			case 0:
+				DPRINTK(PROBE, INFO, "%s turned off\n",
+					opt.name);
+				adapter->rx_itr_setting = 0;
+				break;
+			case 1:
+				DPRINTK(PROBE, INFO, "dynamic interrupt "
+					"throttling enabled\n");
+				adapter->rx_itr_setting = 1;
+				break;
+			default:
+				ixgbe_validate_option(adapter->netdev,
+						      &itr, &opt);
+				/* the first bit is used as control */
+				adapter->rx_itr_setting = (1000000/itr) << 2;
+				break;
+			}
+			adapter->tx_itr_setting = adapter->rx_itr_setting;
+#ifdef module_param_array
+		} else {
+			adapter->rx_itr_setting = opt.def;
+			adapter->tx_itr_setting = opt.def;
+		}
+#endif
+	}
+#ifndef IXGBE_NO_LLI
+	{ /* Low Latency Interrupt TCP Port*/
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Low Latency Interrupt TCP Port",
+			.err  = "using default of "
+					__MODULE_STRING(DEFAULT_LLIPORT),
+			.def  = DEFAULT_LLIPORT,
+			.arg  = { .r = { .min = MIN_LLIPORT,
+					 .max = MAX_LLIPORT } }
+		};
+
+#ifdef module_param_array
+		if (num_LLIPort > bd && ixgbe_lli_supported(adapter, &opt)) {
+#endif
+			adapter->lli_port = LLIPort[bd];
+			if (adapter->lli_port) {
+				ixgbe_validate_option(adapter->netdev,
+						      &adapter->lli_port, &opt);
+			} else {
+				DPRINTK(PROBE, INFO, "%s turned off\n",
+					opt.name);
+			}
+#ifdef module_param_array
+		} else {
+			adapter->lli_port = opt.def;
+		}
+#endif
+	}
+	{ /* Low Latency Interrupt on Packet Size */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Low Latency Interrupt on Packet Size",
+			.err  = "using default of "
+					__MODULE_STRING(DEFAULT_LLISIZE),
+			.def  = DEFAULT_LLISIZE,
+			.arg  = { .r = { .min = MIN_LLISIZE,
+					 .max = MAX_LLISIZE } }
+		};
+
+#ifdef module_param_array
+		if (num_LLISize > bd && ixgbe_lli_supported(adapter, &opt)) {
+#endif
+			adapter->lli_size = LLISize[bd];
+			if (adapter->lli_size) {
+				ixgbe_validate_option(adapter->netdev,
+						      &adapter->lli_size, &opt);
+			} else {
+				DPRINTK(PROBE, INFO, "%s turned off\n",
+					opt.name);
+			}
+#ifdef module_param_array
+		} else {
+			adapter->lli_size = opt.def;
+		}
+#endif
+	}
+	{ /*Low Latency Interrupt on TCP Push flag*/
+		static struct ixgbe_option opt = {
+			.type = enable_option,
+			.name = "Low Latency Interrupt on TCP Push flag",
+			.err  = "defaulting to Disabled",
+			.def  = OPTION_DISABLED
+		};
+
+#ifdef module_param_array
+		if (num_LLIPush > bd && ixgbe_lli_supported(adapter, &opt)) {
+#endif
+			unsigned int lli_push = LLIPush[bd];
+
+			ixgbe_validate_option(adapter->netdev,
+					      &lli_push, &opt);
+			if (lli_push)
+				*aflags |= IXGBE_FLAG_LLI_PUSH;
+			else
+				*aflags &= ~IXGBE_FLAG_LLI_PUSH;
+#ifdef module_param_array
+		} else {
+			*aflags &= ~IXGBE_FLAG_LLI_PUSH;
+		}
+#endif
+	}
+	{ /* Low Latency Interrupt EtherType*/
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Low Latency Interrupt on Ethernet Protocol "
+				"Type",
+			.err  = "using default of "
+					__MODULE_STRING(DEFAULT_LLIETYPE),
+			.def  = DEFAULT_LLIETYPE,
+			.arg  = { .r = { .min = MIN_LLIETYPE,
+					 .max = MAX_LLIETYPE } }
+		};
+
+#ifdef module_param_array
+		if (num_LLIEType > bd && ixgbe_lli_supported(adapter, &opt)) {
+#endif
+			adapter->lli_etype = LLIEType[bd];
+			if (adapter->lli_etype) {
+				ixgbe_validate_option(adapter->netdev,
+						      &adapter->lli_etype,
+						      &opt);
+			} else {
+				DPRINTK(PROBE, INFO, "%s turned off\n",
+					opt.name);
+			}
+#ifdef module_param_array
+		} else {
+			adapter->lli_etype = opt.def;
+		}
+#endif
+	}
+	{ /* LLI VLAN Priority */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Low Latency Interrupt on VLAN priority "
+				"threshold",
+			.err  = "using default of "
+					__MODULE_STRING(DEFAULT_LLIVLANP),
+			.def  = DEFAULT_LLIVLANP,
+			.arg  = { .r = { .min = MIN_LLIVLANP,
+					 .max = MAX_LLIVLANP } }
+		};
+
+#ifdef module_param_array
+		if (num_LLIVLANP > bd && ixgbe_lli_supported(adapter, &opt)) {
+#endif
+			adapter->lli_vlan_pri = LLIVLANP[bd];
+			if (adapter->lli_vlan_pri) {
+				ixgbe_validate_option(adapter->netdev,
+						      &adapter->lli_vlan_pri,
+						      &opt);
+			} else {
+				DPRINTK(PROBE, INFO, "%s turned off\n",
+					opt.name);
+			}
+#ifdef module_param_array
+		} else {
+			adapter->lli_vlan_pri = opt.def;
+		}
+#endif
+	}
+#endif /* IXGBE_NO_LLI */
+#ifdef HAVE_TX_MQ
+	{ /* Flow Director packet buffer allocation */
+		unsigned int fdir_pballoc_mode;
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Flow Director packet buffer allocation",
+			.err = "using default of "
+				__MODULE_STRING(IXGBE_DEFAULT_FDIR_PBALLOC),
+			.def = IXGBE_DEFAULT_FDIR_PBALLOC,
+			.arg = {.r = {.min = IXGBE_FDIR_PBALLOC_64K,
+				      .max = IXGBE_FDIR_PBALLOC_256K} }
+		};
+		char pstring[PSTR_LEN];
+
+		if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
+			adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_NONE;
+		} else if (num_FdirPballoc > bd) {
+			fdir_pballoc_mode = FdirPballoc[bd];
+			ixgbe_validate_option(adapter->netdev,
+					      &fdir_pballoc_mode, &opt);
+			switch (fdir_pballoc_mode) {
+			case IXGBE_FDIR_PBALLOC_256K:
+				adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_256K;
+				snprintf(pstring, PSTR_LEN, "256kB");
+				break;
+			case IXGBE_FDIR_PBALLOC_128K:
+				adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_128K;
+				snprintf(pstring, PSTR_LEN, "128kB");
+				break;
+			case IXGBE_FDIR_PBALLOC_64K:
+			default:
+				adapter->fdir_pballoc = IXGBE_FDIR_PBALLOC_64K;
+				snprintf(pstring, PSTR_LEN, "64kB");
+				break;
+			}
+			DPRINTK(PROBE, INFO, "Flow Director will be allocated "
+				"%s of packet buffer\n", pstring);
+		} else {
+			adapter->fdir_pballoc = opt.def;
+		}
+		
+	}
+	{ /* Flow Director ATR Tx sample packet rate */
+		static struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "Software ATR Tx packet sample rate",
+			.err = "using default of "
+				__MODULE_STRING(IXGBE_DEFAULT_ATR_SAMPLE_RATE),
+			.def = IXGBE_DEFAULT_ATR_SAMPLE_RATE,
+			.arg = {.r = {.min = IXGBE_ATR_SAMPLE_RATE_OFF,
+				      .max = IXGBE_MAX_ATR_SAMPLE_RATE} }
+		};
+		static const char atr_string[] =
+					    "ATR Tx Packet sample rate set to";
+
+		if (adapter->hw.mac.type == ixgbe_mac_82598EB) {
+			adapter->atr_sample_rate = IXGBE_ATR_SAMPLE_RATE_OFF;
+		} else if (num_AtrSampleRate > bd) {
+			adapter->atr_sample_rate = AtrSampleRate[bd];
+
+			if (adapter->atr_sample_rate) {
+				ixgbe_validate_option(adapter->netdev,
+						      &adapter->atr_sample_rate,
+						      &opt);
+				DPRINTK(PROBE, INFO, "%s %d\n", atr_string,
+					adapter->atr_sample_rate);
+			}
+		} else {
+			adapter->atr_sample_rate = opt.def;
+		}
+	}
+#endif /* HAVE_TX_MQ */
+#if IS_ENABLED(CONFIG_FCOE)
+	{
+		*aflags &= ~IXGBE_FLAG_FCOE_CAPABLE;
+
+		switch (adapter->hw.mac.type) {
+		case ixgbe_mac_X540:
+		case ixgbe_mac_X550:
+		case ixgbe_mac_82599EB: {
+			struct ixgbe_option opt = {
+				.type = enable_option,
+				.name = "Enabled/Disable FCoE offload",
+				.err = "defaulting to Enabled",
+				.def = OPTION_ENABLED
+			};
+#ifdef module_param_array
+			if (num_FCoE > bd) {
+#endif
+				unsigned int fcoe = FCoE[bd];
+
+				ixgbe_validate_option(adapter->netdev,
+						      &fcoe, &opt);
+				if (fcoe)
+					*aflags |= IXGBE_FLAG_FCOE_CAPABLE;
+#ifdef module_param_array
+			} else {
+				if (opt.def == OPTION_ENABLED)
+					*aflags |= IXGBE_FLAG_FCOE_CAPABLE;
+			}
+#endif
+			DPRINTK(PROBE, INFO, "FCoE Offload feature %sabled\n",
+				(*aflags & IXGBE_FLAG_FCOE_CAPABLE) ?
+				"en" : "dis");
+		}
+			break;
+		default:
+			break;
+		}
+	}
+#endif /* CONFIG_FCOE */
+	{ /* LRO - Set Large Receive Offload */
+		struct ixgbe_option opt = {
+			.type = enable_option,
+			.name = "LRO - Large Receive Offload",
+			.err  = "defaulting to Disabled",
+			.def  = OPTION_DISABLED
+		};
+		struct net_device *netdev = adapter->netdev;
+
+		if (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE))
+			opt.def = OPTION_DISABLED;
+
+#ifdef module_param_array
+		if (num_LRO > bd) {
+#endif
+			unsigned int lro = LRO[bd];
+			ixgbe_validate_option(adapter->netdev, &lro, &opt);
+			if (lro)
+				netdev->features |= NETIF_F_LRO;
+			else
+				netdev->features &= ~NETIF_F_LRO;
+#ifdef module_param_array
+		} else {
+			netdev->features &= ~NETIF_F_LRO;
+		}
+#endif
+		if ((netdev->features & NETIF_F_LRO) &&
+		    !(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE)) {
+			DPRINTK(PROBE, INFO,
+				"RSC is not supported on this "
+				"hardware.  Disabling RSC.\n");
+			netdev->features &= ~NETIF_F_LRO;
+		}
+	}
+	{ /*
+	   * allow_unsupported_sfp - Enable/Disable support for unsupported
+	   * and untested SFP+ modules.
+	   */
+	struct ixgbe_option opt = {
+			.type = enable_option,
+			.name = "allow_unsupported_sfp",
+			.err  = "defaulting to Disabled",
+			.def  = OPTION_DISABLED
+		};
+#ifdef module_param_array
+		if (num_allow_unsupported_sfp > bd) {
+#endif
+			unsigned int enable_unsupported_sfp =
+						      allow_unsupported_sfp[bd];
+			ixgbe_validate_option(adapter->netdev,
+					      &enable_unsupported_sfp, &opt);
+			if (enable_unsupported_sfp) {
+				adapter->hw.allow_unsupported_sfp = true;
+			} else {
+				adapter->hw.allow_unsupported_sfp = false;
+			}
+#ifdef module_param_array
+		} else {
+				adapter->hw.allow_unsupported_sfp = false;
+		}
+#endif
+	}
+	{ /* DMA Coalescing */
+		struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "dmac_watchdog",
+			.err  = "defaulting to 0 (disabled)",
+			.def  = 0,
+			.arg  = { .r = { .min = 41, .max = 10000 } },
+		};
+		const char *cmsg = "DMA coalescing not supported on this hardware";
+
+		switch (adapter->hw.mac.type) {
+		case ixgbe_mac_X550:
+		case ixgbe_mac_X550EM_x:
+		case ixgbe_mac_X550EM_a:
+			if (adapter->rx_itr_setting || adapter->tx_itr_setting)
+				break;
+			opt.err = "interrupt throttling disabled also disables DMA coalescing";
+			opt.arg.r.min = 0;
+			opt.arg.r.max = 0;
+			break;
+		default:
+			opt.err = cmsg;
+			opt.msg = cmsg;
+			opt.arg.r.min = 0;
+			opt.arg.r.max = 0;
+		}
+#ifdef module_param_array
+		if (num_dmac_watchdog > bd) {
+#endif
+			unsigned int dmac_wd = dmac_watchdog[bd];
+
+			ixgbe_validate_option(adapter->netdev, &dmac_wd, &opt);
+			adapter->hw.mac.dmac_config.watchdog_timer = dmac_wd;
+#ifdef module_param_array
+		} else {
+			adapter->hw.mac.dmac_config.watchdog_timer = opt.def;
+		}
+#endif
+	}
+	{ /* VXLAN rx offload */
+		struct ixgbe_option opt = {
+			.type = range_option,
+			.name = "vxlan_rx",
+			.err  = "defaulting to 1 (enabled)",
+			.def  = 1,
+			.arg  = { .r = { .min = 0, .max = 1 } },
+		};
+		const char *cmsg = "VXLAN rx offload not supported on this hardware";
+		const u32 flag = IXGBE_FLAG_VXLAN_OFFLOAD_ENABLE;
+
+		if (!(adapter->flags & IXGBE_FLAG_VXLAN_OFFLOAD_CAPABLE)) {
+			opt.err = cmsg;
+			opt.msg = cmsg;
+			opt.def = 0;
+			opt.arg.r.max = 0;
+		}
+#ifdef module_param_array
+		if (num_vxlan_rx > bd) {
+#endif
+			unsigned int enable_vxlan_rx = vxlan_rx[bd];
+
+			ixgbe_validate_option(adapter->netdev,
+					      &enable_vxlan_rx, &opt);
+			if (enable_vxlan_rx)
+				adapter->flags |= flag;
+			else
+				adapter->flags &= ~flag;
+#ifdef module_param_array
+		} else if (opt.def) {
+			adapter->flags |= flag;
+		} else {
+			adapter->flags &= ~flag;
+		}
+#endif
+	}
+
+	{ /* MDD support */
+		struct ixgbe_option opt = {
+			.type = enable_option,
+			.name = "Malicious Driver Detection",
+			.err  = "defaulting to Enabled",
+			.def  = OPTION_ENABLED,
+		};
+
+		switch (adapter->hw.mac.type) {
+		case ixgbe_mac_X550:
+		case ixgbe_mac_X550EM_x:
+		case ixgbe_mac_X550EM_a:
+#ifdef module_param_array
+			if (num_MDD > bd) {
+#endif
+				mdd = MDD[bd];
+				ixgbe_validate_option(adapter->netdev,
+						      &mdd, &opt);
+
+				if (mdd){
+					*aflags |= IXGBE_FLAG_MDD_ENABLED;
+
+				} else{
+					*aflags &= ~IXGBE_FLAG_MDD_ENABLED;
+				}
+#ifdef module_param_array
+			} else {
+				*aflags |= IXGBE_FLAG_MDD_ENABLED;
+			}
+#endif
+			break;
+		default:
+			*aflags &= ~IXGBE_FLAG_MDD_ENABLED;
+			break;
+		}
+	}
+}
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
index fc389eecdd2b..68c9302d89f2 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.c
@@ -1,38 +1,32 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/iopoll.h>
-#include <linux/sched.h>
-
-#include "ixgbe.h"
+#include "ixgbe_api.h"
+#include "ixgbe_common.h"
 #include "ixgbe_phy.h"
 
-static void ixgbe_i2c_start(struct ixgbe_hw *hw);
-static void ixgbe_i2c_stop(struct ixgbe_hw *hw);
-static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data);
-static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data);
-static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw);
-static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data);
-static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data);
-static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
-static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
-static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data);
-static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl);
-static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw);
-static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);
-static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);
-static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
+STATIC void ixgbe_i2c_start(struct ixgbe_hw *hw);
+STATIC void ixgbe_i2c_stop(struct ixgbe_hw *hw);
+STATIC void ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data);
+STATIC s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data);
+STATIC s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw);
+STATIC void ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data);
+STATIC s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data);
+STATIC void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
+STATIC void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
+STATIC s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data);
+STATIC bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl);
+STATIC s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,
+					  u8 *sff8472_data);
 
 /**
- *  ixgbe_out_i2c_byte_ack - Send I2C byte with ack
- *  @hw: pointer to the hardware structure
- *  @byte: byte to send
+ * ixgbe_out_i2c_byte_ack - Send I2C byte with ack
+ * @hw: pointer to the hardware structure
+ * @byte: byte to send
  *
- *  Returns an error code on error.
- **/
-static s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)
+ * Returns an error code on error.
+ */
+STATIC s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)
 {
 	s32 status;
 
@@ -43,31 +37,27 @@ static s32 ixgbe_out_i2c_byte_ack(struct ixgbe_hw *hw, u8 byte)
 }
 
 /**
- *  ixgbe_in_i2c_byte_ack - Receive an I2C byte and send ack
- *  @hw: pointer to the hardware structure
- *  @byte: pointer to a u8 to receive the byte
+ * ixgbe_in_i2c_byte_ack - Receive an I2C byte and send ack
+ * @hw: pointer to the hardware structure
+ * @byte: pointer to a u8 to receive the byte
  *
- *  Returns an error code on error.
- **/
-static s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw, u8 *byte)
+ * Returns an error code on error.
+ */
+STATIC s32 ixgbe_in_i2c_byte_ack(struct ixgbe_hw *hw, u8 *byte)
 {
-	s32 status;
-
-	status = ixgbe_clock_in_i2c_byte(hw, byte);
-	if (status)
-		return status;
+	ixgbe_clock_in_i2c_byte(hw, byte);
 	/* ACK */
 	return ixgbe_clock_out_i2c_bit(hw, false);
 }
 
 /**
- *  ixgbe_ones_comp_byte_add - Perform one's complement addition
- *  @add1: addend 1
- *  @add2: addend 2
+ * ixgbe_ones_comp_byte_add - Perform one's complement addition
+ * @add1: addend 1
+ * @add2: addend 2
  *
- *  Returns one's complement 8-bit sum.
- **/
-static u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)
+ * Returns one's complement 8-bit sum.
+ */
+STATIC u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)
 {
 	u16 sum = add1 + add2;
 
@@ -76,17 +66,17 @@ static u8 ixgbe_ones_comp_byte_add(u8 add1, u8 add2)
 }
 
 /**
- *  ixgbe_read_i2c_combined_generic_int - Perform I2C read combined operation
- *  @hw: pointer to the hardware structure
- *  @addr: I2C bus address to read from
- *  @reg: I2C device register to read from
- *  @val: pointer to location to receive read value
- *  @lock: true if to take and release semaphore
+ * ixgbe_read_i2c_combined_generic_int - Perform I2C read combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to read from
+ * @reg: I2C device register to read from
+ * @val: pointer to location to receive read value
+ * @lock: true if to take and release semaphore
  *
- *  Returns an error code on error.
+ * Returns an error code on error.
  */
-s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
-					u16 reg, u16 *val, bool lock)
+s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg,
+					u16 *val, bool lock)
 {
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
 	int max_retry = 3;
@@ -97,7 +87,7 @@ s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
 	u8 reg_high;
 	u8 csum;
 
-	reg_high = ((reg >> 7) & 0xFE) | 1;     /* Indicate read combined */
+	reg_high = ((reg >> 7) & 0xFE) | 1;	/* Indicate read combined */
 	csum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);
 	csum = ~csum;
 	do {
@@ -128,8 +118,7 @@ s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
 		if (ixgbe_in_i2c_byte_ack(hw, &low_bits))
 			goto fail;
 		/* Get csum */
-		if (ixgbe_clock_in_i2c_byte(hw, &csum_byte))
-			goto fail;
+		ixgbe_clock_in_i2c_byte(hw, &csum_byte);
 		/* NACK */
 		if (ixgbe_clock_out_i2c_bit(hw, false))
 			goto fail;
@@ -143,28 +132,28 @@ s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
 		ixgbe_i2c_bus_clear(hw);
 		if (lock)
 			hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-		retry++;
 		if (retry < max_retry)
-			hw_dbg(hw, "I2C byte read combined error - Retry.\n");
+			hw_dbg(hw, "I2C byte read combined error - Retrying.\n");
 		else
 			hw_dbg(hw, "I2C byte read combined error.\n");
-	} while (retry < max_retry);
+		retry++;
+	} while (retry <= max_retry);
 
 	return IXGBE_ERR_I2C;
 }
 
 /**
- *  ixgbe_write_i2c_combined_generic_int - Perform I2C write combined operation
- *  @hw: pointer to the hardware structure
- *  @addr: I2C bus address to write to
- *  @reg: I2C device register to write to
- *  @val: value to write
- *  @lock: true if to take and release semaphore
+ * ixgbe_write_i2c_combined_generic_int - Perform I2C write combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to write to
+ * @reg: I2C device register to write to
+ * @val: value to write
+ * @lock: true if to take and release semaphore
  *
- *  Returns an error code on error.
+ * Returns an error code on error.
  */
-s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
-					 u16 reg, u16 val, bool lock)
+s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr, u16 reg,
+					 u16 val, bool lock)
 {
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
 	int max_retry = 1;
@@ -172,7 +161,7 @@ s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
 	u8 reg_high;
 	u8 csum;
 
-	reg_high = (reg >> 7) & 0xFE;   /* Indicate write combined */
+	reg_high = (reg >> 7) & 0xFE;	/* Indicate write combined */
 	csum = ixgbe_ones_comp_byte_add(reg_high, reg & 0xFF);
 	csum = ixgbe_ones_comp_byte_add(csum, val >> 8);
 	csum = ixgbe_ones_comp_byte_add(csum, val & 0xFF);
@@ -208,30 +197,70 @@ s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *hw, u8 addr,
 		ixgbe_i2c_bus_clear(hw);
 		if (lock)
 			hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-		retry++;
 		if (retry < max_retry)
-			hw_dbg(hw, "I2C byte write combined error - Retry.\n");
+			hw_dbg(hw, "I2C byte write combined error - Retrying.\n");
 		else
 			hw_dbg(hw, "I2C byte write combined error.\n");
-	} while (retry < max_retry);
+		retry++;
+	} while (retry <= max_retry);
 
 	return IXGBE_ERR_I2C;
 }
 
 /**
- *  ixgbe_probe_phy - Probe a single address for a PHY
- *  @hw: pointer to hardware structure
- *  @phy_addr: PHY address to probe
+ * ixgbe_init_phy_ops_generic - Inits PHY function ptrs
+ * @hw: pointer to the hardware structure
  *
- *  Returns true if PHY found
+ * Initialize the function pointers.
  **/
+s32 ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw)
+{
+	struct ixgbe_phy_info *phy = &hw->phy;
+
+	DEBUGFUNC("ixgbe_init_phy_ops_generic");
+
+	/* PHY */
+	phy->ops.identify = ixgbe_identify_phy_generic;
+	phy->ops.reset = ixgbe_reset_phy_generic;
+	phy->ops.read_reg = ixgbe_read_phy_reg_generic;
+	phy->ops.write_reg = ixgbe_write_phy_reg_generic;
+	phy->ops.read_reg_mdi = ixgbe_read_phy_reg_mdi;
+	phy->ops.write_reg_mdi = ixgbe_write_phy_reg_mdi;
+	phy->ops.setup_link = ixgbe_setup_phy_link_generic;
+	phy->ops.setup_link_speed = ixgbe_setup_phy_link_speed_generic;
+	phy->ops.check_link = NULL;
+	phy->ops.get_firmware_version = ixgbe_get_phy_firmware_version_generic;
+	phy->ops.read_i2c_byte = ixgbe_read_i2c_byte_generic;
+	phy->ops.write_i2c_byte = ixgbe_write_i2c_byte_generic;
+	phy->ops.read_i2c_sff8472 = ixgbe_read_i2c_sff8472_generic;
+	phy->ops.read_i2c_eeprom = ixgbe_read_i2c_eeprom_generic;
+	phy->ops.write_i2c_eeprom = ixgbe_write_i2c_eeprom_generic;
+	phy->ops.i2c_bus_clear = ixgbe_i2c_bus_clear;
+	phy->ops.identify_sfp = ixgbe_identify_module_generic;
+	phy->sfp_type = ixgbe_sfp_type_unknown;
+	phy->ops.read_i2c_byte_unlocked = ixgbe_read_i2c_byte_generic_unlocked;
+	phy->ops.write_i2c_byte_unlocked =
+				ixgbe_write_i2c_byte_generic_unlocked;
+	phy->ops.check_overtemp = ixgbe_tn_check_overtemp;
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_probe_phy - Probe a single address for a PHY
+ * @hw: pointer to hardware structure
+ * @phy_addr: PHY address to probe
+ *
+ * Returns true if PHY found
+ */
 static bool ixgbe_probe_phy(struct ixgbe_hw *hw, u16 phy_addr)
 {
 	u16 ext_ability = 0;
 
-	hw->phy.mdio.prtad = phy_addr;
-	if (mdio45_probe(&hw->phy.mdio, phy_addr) != 0)
+	if (!ixgbe_validate_phy_addr(hw, phy_addr)) {
+		hw_dbg(hw, "Unable to validate PHY address 0x%04X\n",
+			phy_addr);
 		return false;
+	}
 
 	if (ixgbe_get_phy_id(hw))
 		return false;
@@ -239,13 +268,11 @@ static bool ixgbe_probe_phy(struct ixgbe_hw *hw, u16 phy_addr)
 	hw->phy.type = ixgbe_get_phy_type_from_id(hw->phy.id);
 
 	if (hw->phy.type == ixgbe_phy_unknown) {
-		hw->phy.ops.read_reg(hw,
-				     MDIO_PMA_EXTABLE,
-				     MDIO_MMD_PMAPMD,
-				     &ext_ability);
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
+				     IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
 		if (ext_ability &
-		    (MDIO_PMA_EXTABLE_10GBT |
-		     MDIO_PMA_EXTABLE_1000BT))
+		    (IXGBE_MDIO_PHY_10GBASET_ABILITY |
+		     IXGBE_MDIO_PHY_1000BASET_ABILITY))
 			hw->phy.type = ixgbe_phy_cu_unknown;
 		else
 			hw->phy.type = ixgbe_phy_generic;
@@ -255,15 +282,17 @@ static bool ixgbe_probe_phy(struct ixgbe_hw *hw, u16 phy_addr)
 }
 
 /**
- *  ixgbe_identify_phy_generic - Get physical layer module
- *  @hw: pointer to hardware structure
+ * ixgbe_identify_phy_generic - Get physical layer module
+ * @hw: pointer to hardware structure
  *
- *  Determines the physical layer module found on the current adapter.
+ * Determines the physical layer module found on the current adapter.
  **/
 s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
 {
-	u32 phy_addr;
-	u32 status = IXGBE_ERR_PHY_ADDR_INVALID;
+	s32 status = IXGBE_ERR_PHY_ADDR_INVALID;
+	u16 phy_addr;
+
+	DEBUGFUNC("ixgbe_identify_phy_generic");
 
 	if (!hw->phy.phy_semaphore_mask) {
 		if (hw->bus.lan_id)
@@ -273,21 +302,21 @@ s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
 	}
 
 	if (hw->phy.type != ixgbe_phy_unknown)
-		return 0;
+		return IXGBE_SUCCESS;
 
 	if (hw->phy.nw_mng_if_sel) {
 		phy_addr = (hw->phy.nw_mng_if_sel &
 			    IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>
 			   IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;
 		if (ixgbe_probe_phy(hw, phy_addr))
-			return 0;
+			return IXGBE_SUCCESS;
 		else
 			return IXGBE_ERR_PHY_ADDR_INVALID;
 	}
 
 	for (phy_addr = 0; phy_addr < IXGBE_MAX_PHY_ADDR; phy_addr++) {
 		if (ixgbe_probe_phy(hw, phy_addr)) {
-			status = 0;
+			status = IXGBE_SUCCESS;
 			break;
 		}
 	}
@@ -296,8 +325,8 @@ s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
 	 * be found and the code will take this path.  Caller has to
 	 * decide if it is an error or not.
 	 */
-	if (status)
-		hw->phy.mdio.prtad = MDIO_PRTAD_NONE;
+	if (status != IXGBE_SUCCESS)
+		hw->phy.addr = 0;
 
 	return status;
 }
@@ -308,20 +337,23 @@ s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
  *
  * This function checks the MMNGC.MNG_VETO bit to see if there are
  * any constraints on link from manageability.  For MAC's that don't
- * have this bit just return false since the link can not be blocked
+ * have this bit just return faluse since the link can not be blocked
  * via this method.
  **/
-bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw)
+s32 ixgbe_check_reset_blocked(struct ixgbe_hw *hw)
 {
 	u32 mmngc;
 
+	DEBUGFUNC("ixgbe_check_reset_blocked");
+
 	/* If we don't have this bit, it can't be blocking */
 	if (hw->mac.type == ixgbe_mac_82598EB)
 		return false;
 
 	mmngc = IXGBE_READ_REG(hw, IXGBE_MMNGC);
 	if (mmngc & IXGBE_MMNGC_MNG_VETO) {
-		hw_dbg(hw, "MNG_VETO bit detected.\n");
+		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE,
+			      "MNG_VETO bit detected.\n");
 		return true;
 	}
 
@@ -329,44 +361,77 @@ bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_get_phy_id - Get the phy type
- *  @hw: pointer to hardware structure
+ * ixgbe_validate_phy_addr - Determines phy address is valid
+ * @hw: pointer to hardware structure
+ * @phy_addr: PHY address
  *
  **/
-static s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)
+bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, u32 phy_addr)
 {
-	s32 status;
+	u16 phy_id = 0;
+	bool valid = false;
+
+	DEBUGFUNC("ixgbe_validate_phy_addr");
+
+	hw->phy.addr = phy_addr;
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_ID_HIGH,
+			     IXGBE_MDIO_PMA_PMD_DEV_TYPE, &phy_id);
+
+	if (phy_id != 0xFFFF && phy_id != 0x0)
+		valid = true;
+
+	hw_dbg(hw, "PHY ID HIGH is 0x%04X\n", phy_id);
+
+	return valid;
+}
+
+/**
+ * ixgbe_get_phy_id - Get the phy type
+ * @hw: pointer to hardware structure
+ *
+ **/
+s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)
+{
+	u32 status;
 	u16 phy_id_high = 0;
 	u16 phy_id_low = 0;
 
-	status = hw->phy.ops.read_reg(hw, MDIO_DEVID1, MDIO_MMD_PMAPMD,
+	DEBUGFUNC("ixgbe_get_phy_id");
+
+	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_ID_HIGH,
+				      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
 				      &phy_id_high);
 
-	if (!status) {
+	if (status == IXGBE_SUCCESS) {
 		hw->phy.id = (u32)(phy_id_high << 16);
-		status = hw->phy.ops.read_reg(hw, MDIO_DEVID2, MDIO_MMD_PMAPMD,
+		status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_ID_LOW,
+					      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
 					      &phy_id_low);
 		hw->phy.id |= (u32)(phy_id_low & IXGBE_PHY_REVISION_MASK);
 		hw->phy.revision = (u32)(phy_id_low & ~IXGBE_PHY_REVISION_MASK);
 	}
+	hw_dbg(hw, "PHY_ID_HIGH 0x%04X, PHY_ID_LOW 0x%04X\n",
+		  phy_id_high, phy_id_low);
+
 	return status;
 }
 
 /**
- *  ixgbe_get_phy_type_from_id - Get the phy type
- *  @phy_id: hardware phy id
+ * ixgbe_get_phy_type_from_id - Get the phy type
+ * @phy_id: PHY ID information
  *
  **/
-static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)
+enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)
 {
 	enum ixgbe_phy_type phy_type;
 
+	DEBUGFUNC("ixgbe_get_phy_type_from_id");
+
 	switch (phy_id) {
 	case TN1010_PHY_ID:
 		phy_type = ixgbe_phy_tn;
 		break;
-	case X550_PHY_ID2:
-	case X550_PHY_ID3:
+	case X550_PHY_ID:
 	case X540_PHY_ID:
 		phy_type = ixgbe_phy_aq;
 		break;
@@ -380,46 +445,51 @@ static enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)
 	case X557_PHY_ID2:
 		phy_type = ixgbe_phy_x550em_ext_t;
 		break;
+	case IXGBE_M88E1500_E_PHY_ID:
+	case IXGBE_M88E1543_E_PHY_ID:
+		phy_type = ixgbe_phy_ext_1g_t;
+		break;
 	default:
 		phy_type = ixgbe_phy_unknown;
 		break;
 	}
-
 	return phy_type;
 }
 
 /**
- *  ixgbe_reset_phy_generic - Performs a PHY reset
- *  @hw: pointer to hardware structure
+ * ixgbe_reset_phy_generic - Performs a PHY reset
+ * @hw: pointer to hardware structure
  **/
 s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
 {
 	u32 i;
 	u16 ctrl = 0;
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_reset_phy_generic");
 
 	if (hw->phy.type == ixgbe_phy_unknown)
 		status = ixgbe_identify_phy_generic(hw);
 
-	if (status != 0 || hw->phy.type == ixgbe_phy_none)
-		return status;
+	if (status != IXGBE_SUCCESS || hw->phy.type == ixgbe_phy_none)
+		goto out;
 
 	/* Don't reset PHY if it's shut down due to overtemp. */
 	if (!hw->phy.reset_if_overtemp &&
 	    (IXGBE_ERR_OVERTEMP == hw->phy.ops.check_overtemp(hw)))
-		return 0;
+		goto out;
 
 	/* Blocked by MNG FW so bail */
 	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+		goto out;
 
 	/*
 	 * Perform soft PHY reset to the PHY_XS.
 	 * This will cause a soft reset to the PHY
 	 */
-	hw->phy.ops.write_reg(hw, MDIO_CTRL1,
-			      MDIO_MMD_PHYXS,
-			      MDIO_CTRL1_RESET);
+	hw->phy.ops.write_reg(hw, IXGBE_MDIO_PHY_XS_CONTROL,
+			      IXGBE_MDIO_PHY_XS_DEV_TYPE,
+			      IXGBE_MDIO_PHY_XS_RESET);
 
 	/*
 	 * Poll for reset bit to self-clear indicating reset is complete.
@@ -427,94 +497,123 @@ s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
 	 * 1.7 usec delay after the reset is complete.
 	 */
 	for (i = 0; i < 30; i++) {
-		msleep(100);
+		msec_delay(100);
 		if (hw->phy.type == ixgbe_phy_x550em_ext_t) {
 			status = hw->phy.ops.read_reg(hw,
 						  IXGBE_MDIO_TX_VENDOR_ALARMS_3,
-						  MDIO_MMD_PMAPMD, &ctrl);
-			if (status)
+						  IXGBE_MDIO_PMA_PMD_DEV_TYPE,
+						  &ctrl);
+			if (status != IXGBE_SUCCESS)
 				return status;
 
 			if (ctrl & IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK) {
-				udelay(2);
+				usec_delay(2);
 				break;
 			}
 		} else {
-			status = hw->phy.ops.read_reg(hw, MDIO_CTRL1,
-						      MDIO_MMD_PHYXS, &ctrl);
-			if (status)
+			status = hw->phy.ops.read_reg(hw,
+						     IXGBE_MDIO_PHY_XS_CONTROL,
+						     IXGBE_MDIO_PHY_XS_DEV_TYPE,
+						     &ctrl);
+			if (status != IXGBE_SUCCESS)
 				return status;
 
-			if (!(ctrl & MDIO_CTRL1_RESET)) {
-				udelay(2);
+			if (!(ctrl & IXGBE_MDIO_PHY_XS_RESET)) {
+				usec_delay(2);
 				break;
 			}
 		}
 	}
 
-	if (ctrl & MDIO_CTRL1_RESET) {
-		hw_dbg(hw, "PHY reset polling failed to complete.\n");
-		return IXGBE_ERR_RESET_FAILED;
+	if (ctrl & IXGBE_MDIO_PHY_XS_RESET) {
+		status = IXGBE_ERR_RESET_FAILED;
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "PHY reset polling failed to complete.\n");
 	}
 
-	return 0;
+out:
+	return status;
+}
+
+/**
+ * ixgbe_restart_auto_neg - Restart auto negotiation on the PHY
+ * @hw: pointer to hardware structure
+ **/
+void ixgbe_restart_auto_neg(struct ixgbe_hw *hw)
+{
+	u16 autoneg_reg;
+
+	/* Check if PHY reset is blocked by MNG FW */
+	if (ixgbe_check_reset_blocked(hw))
+		return;
+
+	/* Restart PHY auto-negotiation. */
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_CONTROL,
+				IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &autoneg_reg);
+	autoneg_reg |= IXGBE_MII_RESTART;
+	hw->phy.ops.write_reg(hw, IXGBE_MDIO_AUTO_NEG_CONTROL,
+				IXGBE_MDIO_AUTO_NEG_DEV_TYPE, autoneg_reg);
 }
 
 /**
- *  ixgbe_read_phy_mdi - Reads a value from a specified PHY register without
- *  the SWFW lock
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit address of PHY register to read
- *  @device_type: 5 bit device type
- *  @phy_data: Pointer to read data from PHY register
+ * ixgbe_read_phy_mdi - Reads a value from a specified PHY register without
+ * the SWFW lock
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit address of PHY register to read
+ * @device_type: 5 bit device type
+ * @phy_data: Pointer to read data from PHY register
  **/
 s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
-		       u16 *phy_data)
+			   u16 *phy_data)
 {
 	u32 i, data, command;
 
 	/* Setup and write the address cycle command */
 	command = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |
 		   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |
-		   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |
+		   (hw->phy.addr << IXGBE_MSCA_PHY_ADDR_SHIFT) |
 		   (IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));
 
 	IXGBE_WRITE_REG(hw, IXGBE_MSCA, command);
 
-	/* Check every 10 usec to see if the address cycle completed.
+	/*
+	 * Check every 10 usec to see if the address cycle completed.
 	 * The MDI Command bit will clear when the operation is
 	 * complete
 	 */
 	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
-		udelay(10);
+		usec_delay(10);
 
 		command = IXGBE_READ_REG(hw, IXGBE_MSCA);
 		if ((command & IXGBE_MSCA_MDI_COMMAND) == 0)
-				break;
+			break;
 	}
 
 
 	if ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {
-		hw_dbg(hw, "PHY address command did not complete.\n");
+		ERROR_REPORT1(IXGBE_ERROR_POLLING, "PHY address command did not complete.\n");
+		hw_dbg(hw, "PHY address command did not complete, returning IXGBE_ERR_PHY\n");
 		return IXGBE_ERR_PHY;
 	}
 
-	/* Address cycle complete, setup and write the read
+	/*
+	 * Address cycle complete, setup and write the read
 	 * command
 	 */
 	command = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |
 		   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |
-		   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |
+		   (hw->phy.addr << IXGBE_MSCA_PHY_ADDR_SHIFT) |
 		   (IXGBE_MSCA_READ | IXGBE_MSCA_MDI_COMMAND));
 
 	IXGBE_WRITE_REG(hw, IXGBE_MSCA, command);
 
-	/* Check every 10 usec to see if the address cycle
+	/*
+	 * Check every 10 usec to see if the address cycle
 	 * completed. The MDI Command bit will clear when the
 	 * operation is complete
 	 */
 	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
-		udelay(10);
+		usec_delay(10);
 
 		command = IXGBE_READ_REG(hw, IXGBE_MSCA);
 		if ((command & IXGBE_MSCA_MDI_COMMAND) == 0)
@@ -522,27 +621,29 @@ s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
 	}
 
 	if ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {
-		hw_dbg(hw, "PHY read command didn't complete\n");
+		ERROR_REPORT1(IXGBE_ERROR_POLLING, "PHY read command didn't complete\n");
+		hw_dbg(hw, "PHY read command didn't complete, returning IXGBE_ERR_PHY\n");
 		return IXGBE_ERR_PHY;
 	}
 
-	/* Read operation is complete.  Get the data
+	/*
+	 * Read operation is complete.  Get the data
 	 * from MSRWD
 	 */
 	data = IXGBE_READ_REG(hw, IXGBE_MSRWD);
 	data >>= IXGBE_MSRWD_READ_DATA_SHIFT;
 	*phy_data = (u16)(data);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register
- *  using the SWFW lock - this function is needed in most cases
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit address of PHY register to read
- *  @device_type: 5 bit device type
- *  @phy_data: Pointer to read data from PHY register
+ * ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register
+ * using the SWFW lock - this function is needed in most cases
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit address of PHY register to read
+ * @device_type: 5 bit device type
+ * @phy_data: Pointer to read data from PHY register
  **/
 s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 			       u32 device_type, u16 *phy_data)
@@ -550,24 +651,25 @@ s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 	s32 status;
 	u32 gssr = hw->phy.phy_semaphore_mask;
 
-	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {
-		status = ixgbe_read_phy_reg_mdi(hw, reg_addr, device_type,
-						phy_data);
-		hw->mac.ops.release_swfw_sync(hw, gssr);
-	} else {
+	DEBUGFUNC("ixgbe_read_phy_reg_generic");
+
+	if (hw->mac.ops.acquire_swfw_sync(hw, gssr))
 		return IXGBE_ERR_SWFW_SYNC;
-	}
+
+	status = hw->phy.ops.read_reg_mdi(hw, reg_addr, device_type, phy_data);
+
+	hw->mac.ops.release_swfw_sync(hw, gssr);
 
 	return status;
 }
 
 /**
- *  ixgbe_write_phy_reg_mdi - Writes a value to specified PHY register
- *  without SWFW lock
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 5 bit device type
- *  @phy_data: Data to write to the PHY register
+ * ixgbe_write_phy_reg_mdi - Writes a value to specified PHY register
+ * without SWFW lock
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 5 bit device type
+ * @phy_data: Data to write to the PHY register
  **/
 s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 				u32 device_type, u16 phy_data)
@@ -580,7 +682,7 @@ s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 	/* Setup and write the address cycle command */
 	command = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |
 		   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |
-		   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |
+		   (hw->phy.addr << IXGBE_MSCA_PHY_ADDR_SHIFT) |
 		   (IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND));
 
 	IXGBE_WRITE_REG(hw, IXGBE_MSCA, command);
@@ -591,7 +693,7 @@ s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 	 * complete
 	 */
 	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
-		udelay(10);
+		usec_delay(10);
 
 		command = IXGBE_READ_REG(hw, IXGBE_MSCA);
 		if ((command & IXGBE_MSCA_MDI_COMMAND) == 0)
@@ -599,7 +701,7 @@ s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 	}
 
 	if ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {
-		hw_dbg(hw, "PHY address cmd didn't complete\n");
+		ERROR_REPORT1(IXGBE_ERROR_POLLING, "PHY address cmd didn't complete\n");
 		return IXGBE_ERR_PHY;
 	}
 
@@ -609,17 +711,18 @@ s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 	 */
 	command = ((reg_addr << IXGBE_MSCA_NP_ADDR_SHIFT)  |
 		   (device_type << IXGBE_MSCA_DEV_TYPE_SHIFT) |
-		   (hw->phy.mdio.prtad << IXGBE_MSCA_PHY_ADDR_SHIFT) |
+		   (hw->phy.addr << IXGBE_MSCA_PHY_ADDR_SHIFT) |
 		   (IXGBE_MSCA_WRITE | IXGBE_MSCA_MDI_COMMAND));
 
 	IXGBE_WRITE_REG(hw, IXGBE_MSCA, command);
 
-	/* Check every 10 usec to see if the address cycle
+	/*
+	 * Check every 10 usec to see if the address cycle
 	 * completed. The MDI Command bit will clear when the
 	 * operation is complete
 	 */
 	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
-		udelay(10);
+		usec_delay(10);
 
 		command = IXGBE_READ_REG(hw, IXGBE_MSCA);
 		if ((command & IXGBE_MSCA_MDI_COMMAND) == 0)
@@ -627,20 +730,20 @@ s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
 	}
 
 	if ((command & IXGBE_MSCA_MDI_COMMAND) != 0) {
-		hw_dbg(hw, "PHY write cmd didn't complete\n");
+		ERROR_REPORT1(IXGBE_ERROR_POLLING, "PHY write cmd didn't complete\n");
 		return IXGBE_ERR_PHY;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_write_phy_reg_generic - Writes a value to specified PHY register
- *  using SWFW lock- this function is needed in most cases
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 5 bit device type
- *  @phy_data: Data to write to the PHY register
+ * ixgbe_write_phy_reg_generic - Writes a value to specified PHY register
+ * using SWFW lock- this function is needed in most cases
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 5 bit device type
+ * @phy_data: Data to write to the PHY register
  **/
 s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 				u32 device_type, u16 phy_data)
@@ -648,341 +751,53 @@ s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 	s32 status;
 	u32 gssr = hw->phy.phy_semaphore_mask;
 
-	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) == 0) {
-		status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type,
+	DEBUGFUNC("ixgbe_write_phy_reg_generic");
+
+	if (hw->mac.ops.acquire_swfw_sync(hw, gssr) == IXGBE_SUCCESS) {
+		status = hw->phy.ops.write_reg_mdi(hw, reg_addr, device_type,
 						 phy_data);
 		hw->mac.ops.release_swfw_sync(hw, gssr);
 	} else {
-		return IXGBE_ERR_SWFW_SYNC;
+		status = IXGBE_ERR_SWFW_SYNC;
 	}
 
 	return status;
 }
 
-#define IXGBE_HW_READ_REG(addr) IXGBE_READ_REG(hw, addr)
-
-/**
- *  ixgbe_msca_cmd - Write the command register and poll for completion/timeout
- *  @hw: pointer to hardware structure
- *  @cmd: command register value to write
- **/
-static s32 ixgbe_msca_cmd(struct ixgbe_hw *hw, u32 cmd)
-{
-	IXGBE_WRITE_REG(hw, IXGBE_MSCA, cmd);
-
-	return readx_poll_timeout(IXGBE_HW_READ_REG, IXGBE_MSCA, cmd,
-				  !(cmd & IXGBE_MSCA_MDI_COMMAND), 10,
-				  10 * IXGBE_MDIO_COMMAND_TIMEOUT);
-}
-
-/**
- *  ixgbe_mii_bus_read_generic - Read a clause 22/45 register with gssr flags
- *  @hw: pointer to hardware structure
- *  @addr: address
- *  @regnum: register number
- *  @gssr: semaphore flags to acquire
- **/
-static s32 ixgbe_mii_bus_read_generic(struct ixgbe_hw *hw, int addr,
-				      int regnum, u32 gssr)
-{
-	u32 hwaddr, cmd;
-	s32 data;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, gssr))
-		return -EBUSY;
-
-	hwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;
-	if (regnum & MII_ADDR_C45) {
-		hwaddr |= regnum & GENMASK(21, 0);
-		cmd = hwaddr | IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND;
-	} else {
-		hwaddr |= (regnum & GENMASK(5, 0)) << IXGBE_MSCA_DEV_TYPE_SHIFT;
-		cmd = hwaddr | IXGBE_MSCA_OLD_PROTOCOL |
-			IXGBE_MSCA_READ_AUTOINC | IXGBE_MSCA_MDI_COMMAND;
-	}
-
-	data = ixgbe_msca_cmd(hw, cmd);
-	if (data < 0)
-		goto mii_bus_read_done;
-
-	/* For a clause 45 access the address cycle just completed, we still
-	 * need to do the read command, otherwise just get the data
-	 */
-	if (!(regnum & MII_ADDR_C45))
-		goto do_mii_bus_read;
-
-	cmd = hwaddr | IXGBE_MSCA_READ | IXGBE_MSCA_MDI_COMMAND;
-	data = ixgbe_msca_cmd(hw, cmd);
-	if (data < 0)
-		goto mii_bus_read_done;
-
-do_mii_bus_read:
-	data = IXGBE_READ_REG(hw, IXGBE_MSRWD);
-	data = (data >> IXGBE_MSRWD_READ_DATA_SHIFT) & GENMASK(16, 0);
-
-mii_bus_read_done:
-	hw->mac.ops.release_swfw_sync(hw, gssr);
-	return data;
-}
-
-/**
- *  ixgbe_mii_bus_write_generic - Write a clause 22/45 register with gssr flags
- *  @hw: pointer to hardware structure
- *  @addr: address
- *  @regnum: register number
- *  @val: value to write
- *  @gssr: semaphore flags to acquire
- **/
-static s32 ixgbe_mii_bus_write_generic(struct ixgbe_hw *hw, int addr,
-				       int regnum, u16 val, u32 gssr)
-{
-	u32 hwaddr, cmd;
-	s32 err;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, gssr))
-		return -EBUSY;
-
-	IXGBE_WRITE_REG(hw, IXGBE_MSRWD, (u32)val);
-
-	hwaddr = addr << IXGBE_MSCA_PHY_ADDR_SHIFT;
-	if (regnum & MII_ADDR_C45) {
-		hwaddr |= regnum & GENMASK(21, 0);
-		cmd = hwaddr | IXGBE_MSCA_ADDR_CYCLE | IXGBE_MSCA_MDI_COMMAND;
-	} else {
-		hwaddr |= (regnum & GENMASK(5, 0)) << IXGBE_MSCA_DEV_TYPE_SHIFT;
-		cmd = hwaddr | IXGBE_MSCA_OLD_PROTOCOL | IXGBE_MSCA_WRITE |
-			IXGBE_MSCA_MDI_COMMAND;
-	}
-
-	/* For clause 45 this is an address cycle, for clause 22 this is the
-	 * entire transaction
-	 */
-	err = ixgbe_msca_cmd(hw, cmd);
-	if (err < 0 || !(regnum & MII_ADDR_C45))
-		goto mii_bus_write_done;
-
-	cmd = hwaddr | IXGBE_MSCA_WRITE | IXGBE_MSCA_MDI_COMMAND;
-	err = ixgbe_msca_cmd(hw, cmd);
-
-mii_bus_write_done:
-	hw->mac.ops.release_swfw_sync(hw, gssr);
-	return err;
-}
-
-/**
- *  ixgbe_mii_bus_read - Read a clause 22/45 register
- *  @bus: pointer to mii_bus structure which points to our driver private
- *  @addr: address
- *  @regnum: register number
- **/
-static s32 ixgbe_mii_bus_read(struct mii_bus *bus, int addr, int regnum)
-{
-	struct ixgbe_adapter *adapter = bus->priv;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 gssr = hw->phy.phy_semaphore_mask;
-
-	return ixgbe_mii_bus_read_generic(hw, addr, regnum, gssr);
-}
-
-/**
- *  ixgbe_mii_bus_write - Write a clause 22/45 register
- *  @bus: pointer to mii_bus structure which points to our driver private
- *  @addr: address
- *  @regnum: register number
- *  @val: value to write
- **/
-static s32 ixgbe_mii_bus_write(struct mii_bus *bus, int addr, int regnum,
-			       u16 val)
-{
-	struct ixgbe_adapter *adapter = bus->priv;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 gssr = hw->phy.phy_semaphore_mask;
-
-	return ixgbe_mii_bus_write_generic(hw, addr, regnum, val, gssr);
-}
-
-/**
- *  ixgbe_x550em_a_mii_bus_read - Read a clause 22/45 register on x550em_a
- *  @bus: pointer to mii_bus structure which points to our driver private
- *  @addr: address
- *  @regnum: register number
- **/
-static s32 ixgbe_x550em_a_mii_bus_read(struct mii_bus *bus, int addr,
-				       int regnum)
-{
-	struct ixgbe_adapter *adapter = bus->priv;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 gssr = hw->phy.phy_semaphore_mask;
-
-	gssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;
-	return ixgbe_mii_bus_read_generic(hw, addr, regnum, gssr);
-}
-
-/**
- *  ixgbe_x550em_a_mii_bus_write - Write a clause 22/45 register on x550em_a
- *  @bus: pointer to mii_bus structure which points to our driver private
- *  @addr: address
- *  @regnum: register number
- *  @val: value to write
- **/
-static s32 ixgbe_x550em_a_mii_bus_write(struct mii_bus *bus, int addr,
-					int regnum, u16 val)
-{
-	struct ixgbe_adapter *adapter = bus->priv;
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 gssr = hw->phy.phy_semaphore_mask;
-
-	gssr |= IXGBE_GSSR_TOKEN_SM | IXGBE_GSSR_PHY0_SM;
-	return ixgbe_mii_bus_write_generic(hw, addr, regnum, val, gssr);
-}
-
-/**
- * ixgbe_get_first_secondary_devfn - get first device downstream of root port
- * @devfn: PCI_DEVFN of root port on domain 0, bus 0
- *
- * Returns pci_dev pointer to PCI_DEVFN(0, 0) on subordinate side of root
- * on domain 0, bus 0, devfn = 'devfn'
- **/
-static struct pci_dev *ixgbe_get_first_secondary_devfn(unsigned int devfn)
-{
-	struct pci_dev *rp_pdev;
-	int bus;
-
-	rp_pdev = pci_get_domain_bus_and_slot(0, 0, devfn);
-	if (rp_pdev && rp_pdev->subordinate) {
-		bus = rp_pdev->subordinate->number;
-		return pci_get_domain_bus_and_slot(0, bus, 0);
-	}
-
-	return NULL;
-}
-
-/**
- * ixgbe_x550em_a_has_mii - is this the first ixgbe x550em_a PCI function?
- * @hw: pointer to hardware structure
- *
- * Returns true if hw points to lowest numbered PCI B:D.F x550_em_a device in
- * the SoC.  There are up to 4 MACs sharing a single MDIO bus on the x550em_a,
- * but we only want to register one MDIO bus.
- **/
-static bool ixgbe_x550em_a_has_mii(struct ixgbe_hw *hw)
-{
-	struct ixgbe_adapter *adapter = hw->back;
-	struct pci_dev *pdev = adapter->pdev;
-	struct pci_dev *func0_pdev;
-
-	/* For the C3000 family of SoCs (x550em_a) the internal ixgbe devices
-	 * are always downstream of root ports @ 0000:00:16.0 & 0000:00:17.0
-	 * It's not valid for function 0 to be disabled and function 1 is up,
-	 * so the lowest numbered ixgbe dev will be device 0 function 0 on one
-	 * of those two root ports
-	 */
-	func0_pdev = ixgbe_get_first_secondary_devfn(PCI_DEVFN(0x16, 0));
-	if (func0_pdev) {
-		if (func0_pdev == pdev)
-			return true;
-		else
-			return false;
-	}
-	func0_pdev = ixgbe_get_first_secondary_devfn(PCI_DEVFN(0x17, 0));
-	if (func0_pdev == pdev)
-		return true;
-
-	return false;
-}
-
 /**
- * ixgbe_mii_bus_init - mii_bus structure setup
+ * ixgbe_setup_phy_link_generic - Set and restart auto-neg
  * @hw: pointer to hardware structure
  *
- * Returns 0 on success, negative on failure
- *
- * ixgbe_mii_bus_init initializes a mii_bus structure in adapter
- **/
-s32 ixgbe_mii_bus_init(struct ixgbe_hw *hw)
-{
-	s32 (*write)(struct mii_bus *bus, int addr, int regnum, u16 val);
-	s32 (*read)(struct mii_bus *bus, int addr, int regnum);
-	struct ixgbe_adapter *adapter = hw->back;
-	struct pci_dev *pdev = adapter->pdev;
-	struct device *dev = &adapter->netdev->dev;
-	struct mii_bus *bus;
-
-	switch (hw->device_id) {
-	/* C3000 SoCs */
-	case IXGBE_DEV_ID_X550EM_A_KR:
-	case IXGBE_DEV_ID_X550EM_A_KR_L:
-	case IXGBE_DEV_ID_X550EM_A_SFP_N:
-	case IXGBE_DEV_ID_X550EM_A_SGMII:
-	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
-	case IXGBE_DEV_ID_X550EM_A_10G_T:
-	case IXGBE_DEV_ID_X550EM_A_SFP:
-	case IXGBE_DEV_ID_X550EM_A_1G_T:
-	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
-		if (!ixgbe_x550em_a_has_mii(hw))
-			return 0;
-		read = &ixgbe_x550em_a_mii_bus_read;
-		write = &ixgbe_x550em_a_mii_bus_write;
-		break;
-	default:
-		read = &ixgbe_mii_bus_read;
-		write = &ixgbe_mii_bus_write;
-		break;
-	}
-
-	bus = devm_mdiobus_alloc(dev);
-	if (!bus)
-		return -ENOMEM;
-
-	bus->read = read;
-	bus->write = write;
-
-	/* Use the position of the device in the PCI hierarchy as the id */
-	snprintf(bus->id, MII_BUS_ID_SIZE, "%s-mdio-%s", ixgbe_driver_name,
-		 pci_name(pdev));
-
-	bus->name = "ixgbe-mdio";
-	bus->priv = adapter;
-	bus->parent = dev;
-	bus->phy_mask = GENMASK(31, 0);
-
-	/* Support clause 22/45 natively.  ixgbe_probe() sets MDIO_EMULATE_C22
-	 * unfortunately that causes some clause 22 frames to be sent with
-	 * clause 45 addressing.  We don't want that.
-	 */
-	hw->phy.mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22;
-
-	adapter->mii_bus = bus;
-	return mdiobus_register(bus);
-}
-
-/**
- *  ixgbe_setup_phy_link_generic - Set and restart autoneg
- *  @hw: pointer to hardware structure
- *
- *  Restart autonegotiation and PHY and waits for completion.
+ * Restart auto-negotiation and PHY and waits for completion.
  **/
 s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)
 {
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	u16 autoneg_reg = IXGBE_MII_AUTONEG_REG;
 	bool autoneg = false;
 	ixgbe_link_speed speed;
 
+	DEBUGFUNC("ixgbe_setup_phy_link_generic");
+
 	ixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);
 
 	/* Set or unset auto-negotiation 10G advertisement */
-	hw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL, MDIO_MMD_AN, &autoneg_reg);
+	hw->phy.ops.read_reg(hw, IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			     &autoneg_reg);
 
-	autoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;
+	autoneg_reg &= ~IXGBE_MII_10GBASE_T_ADVERTISE;
 	if ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL) &&
 	    (speed & IXGBE_LINK_SPEED_10GB_FULL))
-		autoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;
+		autoneg_reg |= IXGBE_MII_10GBASE_T_ADVERTISE;
 
-	hw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL, MDIO_MMD_AN, autoneg_reg);
+	hw->phy.ops.write_reg(hw, IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG,
+			      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			      autoneg_reg);
 
 	hw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,
-			     MDIO_MMD_AN, &autoneg_reg);
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			     &autoneg_reg);
 
 	if (hw->mac.type == ixgbe_mac_X550) {
 		/* Set or unset auto-negotiation 5G advertisement */
@@ -1006,45 +821,44 @@ s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)
 		autoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE;
 
 	hw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,
-			      MDIO_MMD_AN, autoneg_reg);
+			      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			      autoneg_reg);
 
 	/* Set or unset auto-negotiation 100M advertisement */
-	hw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE, MDIO_MMD_AN, &autoneg_reg);
+	hw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_ADVERTISE_REG,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			     &autoneg_reg);
 
-	autoneg_reg &= ~(ADVERTISE_100FULL | ADVERTISE_100HALF);
+	autoneg_reg &= ~(IXGBE_MII_100BASE_T_ADVERTISE |
+			 IXGBE_MII_100BASE_T_ADVERTISE_HALF);
 	if ((hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL) &&
 	    (speed & IXGBE_LINK_SPEED_100_FULL))
-		autoneg_reg |= ADVERTISE_100FULL;
-
-	hw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE, MDIO_MMD_AN, autoneg_reg);
-
-	/* Blocked by MNG FW so don't reset PHY */
-	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+		autoneg_reg |= IXGBE_MII_100BASE_T_ADVERTISE;
 
-	/* Restart PHY autonegotiation and wait for completion */
-	hw->phy.ops.read_reg(hw, MDIO_CTRL1,
-			     MDIO_MMD_AN, &autoneg_reg);
-
-	autoneg_reg |= MDIO_AN_CTRL1_RESTART;
-
-	hw->phy.ops.write_reg(hw, MDIO_CTRL1,
-			      MDIO_MMD_AN, autoneg_reg);
+	hw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_ADVERTISE_REG,
+			      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			      autoneg_reg);
 
+	ixgbe_restart_auto_neg(hw);
 	return status;
 }
 
 /**
- *  ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: unused
+ * ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: unused
  **/
 s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
 				       ixgbe_link_speed speed,
 				       bool autoneg_wait_to_complete)
 {
-	/* Clear autoneg_advertised and set new values based on input link
+	UNREFERENCED_1PARAMETER(autoneg_wait_to_complete);
+
+	DEBUGFUNC("ixgbe_setup_phy_link_speed_generic");
+
+	/*
+	 * Clear autoneg_advertised and set new values based on input link
 	 * speed.
 	 */
 	hw->phy.autoneg_advertised = 0;
@@ -1068,34 +882,34 @@ s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
 		hw->phy.autoneg_advertised |= IXGBE_LINK_SPEED_10_FULL;
 
 	/* Setup link based on the new speed settings */
-	if (hw->phy.ops.setup_link)
-		hw->phy.ops.setup_link(hw);
+	ixgbe_setup_phy_link(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- * ixgbe_get_copper_speeds_supported - Get copper link speed from phy
+ * ixgbe_get_copper_speeds_supported - Get copper link speeds from phy
  * @hw: pointer to hardware structure
  *
  * Determines the supported link capabilities by reading the PHY auto
  * negotiation register.
- */
+ **/
 static s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)
 {
-	u16 speed_ability;
 	s32 status;
+	u16 speed_ability;
 
-	status = hw->phy.ops.read_reg(hw, MDIO_SPEED, MDIO_MMD_PMAPMD,
+	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_SPEED_ABILITY,
+				      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
 				      &speed_ability);
 	if (status)
 		return status;
 
-	if (speed_ability & MDIO_SPEED_10G)
+	if (speed_ability & IXGBE_MDIO_PHY_SPEED_10G)
 		hw->phy.speeds_supported |= IXGBE_LINK_SPEED_10GB_FULL;
-	if (speed_ability & MDIO_PMA_SPEED_1000)
+	if (speed_ability & IXGBE_MDIO_PHY_SPEED_1G)
 		hw->phy.speeds_supported |= IXGBE_LINK_SPEED_1GB_FULL;
-	if (speed_ability & MDIO_PMA_SPEED_100)
+	if (speed_ability & IXGBE_MDIO_PHY_SPEED_100M)
 		hw->phy.speeds_supported |= IXGBE_LINK_SPEED_100_FULL;
 
 	switch (hw->mac.type) {
@@ -1104,14 +918,14 @@ static s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)
 		hw->phy.speeds_supported |= IXGBE_LINK_SPEED_5GB_FULL;
 		break;
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		hw->phy.speeds_supported &= ~IXGBE_LINK_SPEED_100_FULL;
 		break;
 	default:
 		break;
 	}
 
-	return 0;
+	return status;
 }
 
 /**
@@ -1119,12 +933,14 @@ static s32 ixgbe_get_copper_speeds_supported(struct ixgbe_hw *hw)
  * @hw: pointer to hardware structure
  * @speed: pointer to link speed
  * @autoneg: boolean auto-negotiation value
- */
+ **/
 s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
 					       ixgbe_link_speed *speed,
 					       bool *autoneg)
 {
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_get_copper_link_capabilities_generic");
 
 	*autoneg = true;
 	if (!hw->phy.speeds_supported)
@@ -1135,24 +951,26 @@ s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
 }
 
 /**
- *  ixgbe_check_phy_link_tnx - Determine link and speed status
- *  @hw: pointer to hardware structure
- *  @speed: link speed
- *  @link_up: status of link
+ * ixgbe_check_phy_link_tnx - Determine link and speed status
+ * @hw: pointer to hardware structure
+ * @speed: current link speed
+ * @link_up: true is link is up, false otherwise
  *
- *  Reads the VS1 register to determine if link is up and the current speed for
- *  the PHY.
+ * Reads the VS1 register to determine if link is up and the current speed for
+ * the PHY.
  **/
 s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 			     bool *link_up)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	u32 time_out;
 	u32 max_time_out = 10;
 	u16 phy_link = 0;
 	u16 phy_speed = 0;
 	u16 phy_data = 0;
 
+	DEBUGFUNC("ixgbe_check_phy_link_tnx");
+
 	/* Initialize speed and link to default case */
 	*link_up = false;
 	*speed = IXGBE_LINK_SPEED_10GB_FULL;
@@ -1163,15 +981,14 @@ s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 	 * be changed for other copper PHYs.
 	 */
 	for (time_out = 0; time_out < max_time_out; time_out++) {
-		udelay(10);
+		usec_delay(10);
 		status = hw->phy.ops.read_reg(hw,
-					      MDIO_STAT1,
-					      MDIO_MMD_VEND1,
-					      &phy_data);
-		phy_link = phy_data &
-			    IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS;
+					IXGBE_MDIO_VENDOR_SPECIFIC_1_STATUS,
+					IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+					&phy_data);
+		phy_link = phy_data & IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS;
 		phy_speed = phy_data &
-			    IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS;
+				 IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS;
 		if (phy_link == IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS) {
 			*link_up = true;
 			if (phy_speed ==
@@ -1185,41 +1002,41 @@ s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
 }
 
 /**
- *	ixgbe_setup_phy_link_tnx - Set and restart autoneg
+ *	ixgbe_setup_phy_link_tnx - Set and restart auto-neg
  *	@hw: pointer to hardware structure
  *
- *	Restart autonegotiation and PHY and waits for completion.
- *      This function always returns success, this is nessary since
- *	it is called via a function pointer that could call other
- *	functions that could return an error.
+ *	Restart auto-negotiation and PHY and waits for completion.
  **/
 s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u16 autoneg_reg = IXGBE_MII_AUTONEG_REG;
 	bool autoneg = false;
 	ixgbe_link_speed speed;
 
+	DEBUGFUNC("ixgbe_setup_phy_link_tnx");
+
 	ixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);
 
 	if (speed & IXGBE_LINK_SPEED_10GB_FULL) {
 		/* Set or unset auto-negotiation 10G advertisement */
-		hw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,
-				     MDIO_MMD_AN,
+		hw->phy.ops.read_reg(hw, IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG,
+				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				     &autoneg_reg);
 
-		autoneg_reg &= ~MDIO_AN_10GBT_CTRL_ADV10G;
+		autoneg_reg &= ~IXGBE_MII_10GBASE_T_ADVERTISE;
 		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_10GB_FULL)
-			autoneg_reg |= MDIO_AN_10GBT_CTRL_ADV10G;
+			autoneg_reg |= IXGBE_MII_10GBASE_T_ADVERTISE;
 
-		hw->phy.ops.write_reg(hw, MDIO_AN_10GBT_CTRL,
-				      MDIO_MMD_AN,
+		hw->phy.ops.write_reg(hw, IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				      autoneg_reg);
 	}
 
 	if (speed & IXGBE_LINK_SPEED_1GB_FULL) {
 		/* Set or unset auto-negotiation 1G advertisement */
 		hw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,
-				     MDIO_MMD_AN,
+				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				     &autoneg_reg);
 
 		autoneg_reg &= ~IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;
@@ -1227,44 +1044,70 @@ s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
 			autoneg_reg |= IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX;
 
 		hw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_XNP_TX_REG,
-				      MDIO_MMD_AN,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				      autoneg_reg);
 	}
 
 	if (speed & IXGBE_LINK_SPEED_100_FULL) {
 		/* Set or unset auto-negotiation 100M advertisement */
-		hw->phy.ops.read_reg(hw, MDIO_AN_ADVERTISE,
-				     MDIO_MMD_AN,
+		hw->phy.ops.read_reg(hw, IXGBE_MII_AUTONEG_ADVERTISE_REG,
+				     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				     &autoneg_reg);
 
-		autoneg_reg &= ~(ADVERTISE_100FULL |
-				 ADVERTISE_100HALF);
+		autoneg_reg &= ~IXGBE_MII_100BASE_T_ADVERTISE;
 		if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_100_FULL)
-			autoneg_reg |= ADVERTISE_100FULL;
+			autoneg_reg |= IXGBE_MII_100BASE_T_ADVERTISE;
 
-		hw->phy.ops.write_reg(hw, MDIO_AN_ADVERTISE,
-				      MDIO_MMD_AN,
+		hw->phy.ops.write_reg(hw, IXGBE_MII_AUTONEG_ADVERTISE_REG,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				      autoneg_reg);
 	}
 
-	/* Blocked by MNG FW so don't reset PHY */
-	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+	ixgbe_restart_auto_neg(hw);
+	return status;
+}
+
+/**
+ * ixgbe_get_phy_firmware_version_tnx - Gets the PHY Firmware Version
+ * @hw: pointer to hardware structure
+ * @firmware_version: pointer to the PHY Firmware Version
+ **/
+s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
+				       u16 *firmware_version)
+{
+	s32 status;
+
+	DEBUGFUNC("ixgbe_get_phy_firmware_version_tnx");
+
+	status = hw->phy.ops.read_reg(hw, TNX_FW_REV,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				      firmware_version);
+
+	return status;
+}
+
+/**
+ * ixgbe_get_phy_firmware_version_generic - Gets the PHY Firmware Version
+ * @hw: pointer to hardware structure
+ * @firmware_version: pointer to the PHY Firmware Version
+ **/
+s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
+					   u16 *firmware_version)
+{
+	s32 status;
 
-	/* Restart PHY autonegotiation and wait for completion */
-	hw->phy.ops.read_reg(hw, MDIO_CTRL1,
-			     MDIO_MMD_AN, &autoneg_reg);
+	DEBUGFUNC("ixgbe_get_phy_firmware_version_generic");
 
-	autoneg_reg |= MDIO_AN_CTRL1_RESTART;
+	status = hw->phy.ops.read_reg(hw, AQ_FW_REV,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				      firmware_version);
 
-	hw->phy.ops.write_reg(hw, MDIO_CTRL1,
-			      MDIO_MMD_AN, autoneg_reg);
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_reset_phy_nl - Performs a PHY reset
- *  @hw: pointer to hardware structure
+ * ixgbe_reset_phy_nl - Performs a PHY reset
+ * @hw: pointer to hardware structure
  **/
 s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
 {
@@ -1272,37 +1115,42 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
 	bool end_data = false;
 	u16 list_offset, data_offset;
 	u16 phy_data = 0;
-	s32 ret_val;
+	s32 ret_val = IXGBE_SUCCESS;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_reset_phy_nl");
+
 	/* Blocked by MNG FW so bail */
 	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+		goto out;
 
-	hw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS, &phy_data);
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_XS_CONTROL,
+			     IXGBE_MDIO_PHY_XS_DEV_TYPE, &phy_data);
 
 	/* reset the PHY and poll for completion */
-	hw->phy.ops.write_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,
-			      (phy_data | MDIO_CTRL1_RESET));
+	hw->phy.ops.write_reg(hw, IXGBE_MDIO_PHY_XS_CONTROL,
+			      IXGBE_MDIO_PHY_XS_DEV_TYPE,
+			      (phy_data | IXGBE_MDIO_PHY_XS_RESET));
 
 	for (i = 0; i < 100; i++) {
-		hw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_PHYXS,
-				     &phy_data);
-		if ((phy_data & MDIO_CTRL1_RESET) == 0)
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_XS_CONTROL,
+				     IXGBE_MDIO_PHY_XS_DEV_TYPE, &phy_data);
+		if ((phy_data & IXGBE_MDIO_PHY_XS_RESET) == 0)
 			break;
-		usleep_range(10000, 20000);
+		msec_delay(10);
 	}
 
-	if ((phy_data & MDIO_CTRL1_RESET) != 0) {
+	if ((phy_data & IXGBE_MDIO_PHY_XS_RESET) != 0) {
 		hw_dbg(hw, "PHY reset did not complete.\n");
-		return IXGBE_ERR_PHY;
+		ret_val = IXGBE_ERR_PHY;
+		goto out;
 	}
 
 	/* Get init offsets */
 	ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
 						      &data_offset);
-	if (ret_val)
-		return ret_val;
+	if (ret_val != IXGBE_SUCCESS)
+		goto out;
 
 	ret_val = hw->eeprom.ops.read(hw, data_offset, &block_crc);
 	data_offset++;
@@ -1320,24 +1168,25 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
 		case IXGBE_DELAY_NL:
 			data_offset++;
 			hw_dbg(hw, "DELAY: %d MS\n", edata);
-			usleep_range(edata * 1000, edata * 2000);
+			msec_delay(edata);
 			break;
 		case IXGBE_DATA_NL:
 			hw_dbg(hw, "DATA:\n");
 			data_offset++;
-			ret_val = hw->eeprom.ops.read(hw, data_offset++,
+			ret_val = hw->eeprom.ops.read(hw, data_offset,
 						      &phy_offset);
 			if (ret_val)
 				goto err_eeprom;
+			data_offset++;
 			for (i = 0; i < edata; i++) {
 				ret_val = hw->eeprom.ops.read(hw, data_offset,
 							      &eword);
 				if (ret_val)
 					goto err_eeprom;
 				hw->phy.ops.write_reg(hw, phy_offset,
-						      MDIO_MMD_PMAPMD, eword);
+						      IXGBE_TWINAX_DEV, eword);
 				hw_dbg(hw, "Wrote %4.4x to %4.4x\n", eword,
-				       phy_offset);
+					  phy_offset);
 				data_offset++;
 				phy_offset++;
 			}
@@ -1352,53 +1201,65 @@ s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
 				hw_dbg(hw, "SOL\n");
 			} else {
 				hw_dbg(hw, "Bad control value\n");
-				return IXGBE_ERR_PHY;
+				ret_val = IXGBE_ERR_PHY;
+				goto out;
 			}
 			break;
 		default:
 			hw_dbg(hw, "Bad control type\n");
-			return IXGBE_ERR_PHY;
+			ret_val = IXGBE_ERR_PHY;
+			goto out;
 		}
 	}
 
+out:
 	return ret_val;
 
 err_eeprom:
-	hw_err(hw, "eeprom read at offset %d failed\n", data_offset);
+	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+		      "eeprom read at offset %d failed", data_offset);
 	return IXGBE_ERR_PHY;
 }
 
 /**
- *  ixgbe_identify_module_generic - Identifies module type
- *  @hw: pointer to hardware structure
+ * ixgbe_identify_module_generic - Identifies module type
+ * @hw: pointer to hardware structure
  *
- *  Determines HW type and calls appropriate function.
+ * Determines HW type and calls appropriate function.
  **/
 s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_ERR_SFP_NOT_PRESENT;
+
+	DEBUGFUNC("ixgbe_identify_module_generic");
+
 	switch (hw->mac.ops.get_media_type(hw)) {
 	case ixgbe_media_type_fiber:
-		return ixgbe_identify_sfp_module_generic(hw);
+		status = ixgbe_identify_sfp_module_generic(hw);
+		break;
+
 	case ixgbe_media_type_fiber_qsfp:
-		return ixgbe_identify_qsfp_module_generic(hw);
+		status = ixgbe_identify_qsfp_module_generic(hw);
+		break;
+
 	default:
 		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
-		return IXGBE_ERR_SFP_NOT_PRESENT;
+		status = IXGBE_ERR_SFP_NOT_PRESENT;
+		break;
 	}
 
-	return IXGBE_ERR_SFP_NOT_PRESENT;
+	return status;
 }
 
 /**
- *  ixgbe_identify_sfp_module_generic - Identifies SFP modules
- *  @hw: pointer to hardware structure
+ * ixgbe_identify_sfp_module_generic - Identifies SFP modules
+ * @hw: pointer to hardware structure
  *
- *  Searches for and identifies the SFP module and assigns appropriate PHY type.
+ * Searches for and identifies the SFP module and assigns appropriate PHY type.
  **/
 s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)
 {
-	struct ixgbe_adapter *adapter = hw->back;
-	s32 status;
+	s32 status = IXGBE_ERR_PHY_ADDR_INVALID;
 	u32 vendor_oui = 0;
 	enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
 	u8 identifier = 0;
@@ -1409,241 +1270,258 @@ s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)
 	u8 cable_spec = 0;
 	u16 enforce_sfp = 0;
 
+	DEBUGFUNC("ixgbe_identify_sfp_module_generic");
+
 	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber) {
 		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
-		return IXGBE_ERR_SFP_NOT_PRESENT;
+		status = IXGBE_ERR_SFP_NOT_PRESENT;
+		goto out;
 	}
 
-	/* LAN ID is needed for sfp_type determination */
+	/* LAN ID is needed for I2C access */
 	hw->mac.ops.set_lan_id(hw);
 
 	status = hw->phy.ops.read_i2c_eeprom(hw,
 					     IXGBE_SFF_IDENTIFIER,
 					     &identifier);
 
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		goto err_read_i2c_eeprom;
 
 	if (identifier != IXGBE_SFF_IDENTIFIER_SFP) {
 		hw->phy.type = ixgbe_phy_sfp_unsupported;
-		return IXGBE_ERR_SFP_NOT_SUPPORTED;
-	}
-	status = hw->phy.ops.read_i2c_eeprom(hw,
-					     IXGBE_SFF_1GBE_COMP_CODES,
-					     &comp_codes_1g);
-
-	if (status)
-		goto err_read_i2c_eeprom;
-
-	status = hw->phy.ops.read_i2c_eeprom(hw,
-					     IXGBE_SFF_10GBE_COMP_CODES,
-					     &comp_codes_10g);
-
-	if (status)
-		goto err_read_i2c_eeprom;
-	status = hw->phy.ops.read_i2c_eeprom(hw,
-					     IXGBE_SFF_CABLE_TECHNOLOGY,
-					     &cable_tech);
-
-	if (status)
-		goto err_read_i2c_eeprom;
-
-	 /* ID Module
-	  * =========
-	  * 0   SFP_DA_CU
-	  * 1   SFP_SR
-	  * 2   SFP_LR
-	  * 3   SFP_DA_CORE0 - 82599-specific
-	  * 4   SFP_DA_CORE1 - 82599-specific
-	  * 5   SFP_SR/LR_CORE0 - 82599-specific
-	  * 6   SFP_SR/LR_CORE1 - 82599-specific
-	  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific
-	  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific
-	  * 9   SFP_1g_cu_CORE0 - 82599-specific
-	  * 10  SFP_1g_cu_CORE1 - 82599-specific
-	  * 11  SFP_1g_sx_CORE0 - 82599-specific
-	  * 12  SFP_1g_sx_CORE1 - 82599-specific
-	  */
-	if (hw->mac.type == ixgbe_mac_82598EB) {
-		if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
-			hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
-		else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
-			hw->phy.sfp_type = ixgbe_sfp_type_sr;
-		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
-			hw->phy.sfp_type = ixgbe_sfp_type_lr;
-		else
-			hw->phy.sfp_type = ixgbe_sfp_type_unknown;
+		status = IXGBE_ERR_SFP_NOT_SUPPORTED;
 	} else {
-		if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
-			if (hw->bus.lan_id == 0)
-				hw->phy.sfp_type =
-					     ixgbe_sfp_type_da_cu_core0;
-			else
-				hw->phy.sfp_type =
-					     ixgbe_sfp_type_da_cu_core1;
-		} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {
-			hw->phy.ops.read_i2c_eeprom(
-					hw, IXGBE_SFF_CABLE_SPEC_COMP,
-					&cable_spec);
-			if (cable_spec &
-			    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {
-				if (hw->bus.lan_id == 0)
-					hw->phy.sfp_type =
-					ixgbe_sfp_type_da_act_lmt_core0;
-				else
-					hw->phy.sfp_type =
-					ixgbe_sfp_type_da_act_lmt_core1;
-			} else {
-				hw->phy.sfp_type =
-						ixgbe_sfp_type_unknown;
-			}
-		} else if (comp_codes_10g &
-			   (IXGBE_SFF_10GBASESR_CAPABLE |
-			    IXGBE_SFF_10GBASELR_CAPABLE)) {
-			if (hw->bus.lan_id == 0)
-				hw->phy.sfp_type =
-					      ixgbe_sfp_type_srlr_core0;
-			else
-				hw->phy.sfp_type =
-					      ixgbe_sfp_type_srlr_core1;
-		} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {
-			if (hw->bus.lan_id == 0)
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_cu_core0;
-			else
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_cu_core1;
-		} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {
-			if (hw->bus.lan_id == 0)
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_sx_core0;
-			else
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_sx_core1;
-		} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {
-			if (hw->bus.lan_id == 0)
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_lx_core0;
-			else
-				hw->phy.sfp_type =
-					ixgbe_sfp_type_1g_lx_core1;
-		} else {
-			hw->phy.sfp_type = ixgbe_sfp_type_unknown;
-		}
-	}
-
-	if (hw->phy.sfp_type != stored_sfp_type)
-		hw->phy.sfp_setup_needed = true;
-
-	/* Determine if the SFP+ PHY is dual speed or not. */
-	hw->phy.multispeed_fiber = false;
-	if (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&
-	     (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||
-	    ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&
-	     (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))
-		hw->phy.multispeed_fiber = true;
-
-	/* Determine PHY vendor */
-	if (hw->phy.type != ixgbe_phy_nl) {
-		hw->phy.id = identifier;
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					    IXGBE_SFF_VENDOR_OUI_BYTE0,
-					    &oui_bytes[0]);
+						     IXGBE_SFF_1GBE_COMP_CODES,
+						     &comp_codes_1g);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
 
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					    IXGBE_SFF_VENDOR_OUI_BYTE1,
-					    &oui_bytes[1]);
+						     IXGBE_SFF_10GBE_COMP_CODES,
+						     &comp_codes_10g);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
-
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					    IXGBE_SFF_VENDOR_OUI_BYTE2,
-					    &oui_bytes[2]);
+						     IXGBE_SFF_CABLE_TECHNOLOGY,
+						     &cable_tech);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
 
-		vendor_oui =
-		  ((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |
-		   (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |
-		   (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));
-
-		switch (vendor_oui) {
-		case IXGBE_SFF_VENDOR_OUI_TYCO:
-			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
-				hw->phy.type =
-					    ixgbe_phy_sfp_passive_tyco;
-			break;
-		case IXGBE_SFF_VENDOR_OUI_FTL:
-			if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
-				hw->phy.type = ixgbe_phy_sfp_ftl_active;
-			else
-				hw->phy.type = ixgbe_phy_sfp_ftl;
-			break;
-		case IXGBE_SFF_VENDOR_OUI_AVAGO:
-			hw->phy.type = ixgbe_phy_sfp_avago;
-			break;
-		case IXGBE_SFF_VENDOR_OUI_INTEL:
-			hw->phy.type = ixgbe_phy_sfp_intel;
-			break;
-		default:
+		 /* ID Module
+		  * =========
+		  * 0   SFP_DA_CU
+		  * 1   SFP_SR
+		  * 2   SFP_LR
+		  * 3   SFP_DA_CORE0 - 82599-specific
+		  * 4   SFP_DA_CORE1 - 82599-specific
+		  * 5   SFP_SR/LR_CORE0 - 82599-specific
+		  * 6   SFP_SR/LR_CORE1 - 82599-specific
+		  * 7   SFP_act_lmt_DA_CORE0 - 82599-specific
+		  * 8   SFP_act_lmt_DA_CORE1 - 82599-specific
+		  * 9   SFP_1g_cu_CORE0 - 82599-specific
+		  * 10  SFP_1g_cu_CORE1 - 82599-specific
+		  * 11  SFP_1g_sx_CORE0 - 82599-specific
+		  * 12  SFP_1g_sx_CORE1 - 82599-specific
+		  */
+		if (hw->mac.type == ixgbe_mac_82598EB) {
 			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
-				hw->phy.type =
-					 ixgbe_phy_sfp_passive_unknown;
-			else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
-				hw->phy.type =
-					ixgbe_phy_sfp_active_unknown;
+				hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
+			else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
+				hw->phy.sfp_type = ixgbe_sfp_type_sr;
+			else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
+				hw->phy.sfp_type = ixgbe_sfp_type_lr;
 			else
-				hw->phy.type = ixgbe_phy_sfp_unknown;
-			break;
+				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
+		} else {
+			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
+				if (hw->bus.lan_id == 0)
+					hw->phy.sfp_type =
+						     ixgbe_sfp_type_da_cu_core0;
+				else
+					hw->phy.sfp_type =
+						     ixgbe_sfp_type_da_cu_core1;
+			} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {
+				hw->phy.ops.read_i2c_eeprom(
+						hw, IXGBE_SFF_CABLE_SPEC_COMP,
+						&cable_spec);
+				if (cable_spec &
+				    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {
+					if (hw->bus.lan_id == 0)
+						hw->phy.sfp_type =
+						ixgbe_sfp_type_da_act_lmt_core0;
+					else
+						hw->phy.sfp_type =
+						ixgbe_sfp_type_da_act_lmt_core1;
+				} else {
+					hw->phy.sfp_type =
+							ixgbe_sfp_type_unknown;
+				}
+			} else if (comp_codes_10g &
+				   (IXGBE_SFF_10GBASESR_CAPABLE |
+				    IXGBE_SFF_10GBASELR_CAPABLE)) {
+				if (hw->bus.lan_id == 0)
+					hw->phy.sfp_type =
+						      ixgbe_sfp_type_srlr_core0;
+				else
+					hw->phy.sfp_type =
+						      ixgbe_sfp_type_srlr_core1;
+			} else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE) {
+				if (hw->bus.lan_id == 0)
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_cu_core0;
+				else
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_cu_core1;
+			} else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) {
+				if (hw->bus.lan_id == 0)
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_sx_core0;
+				else
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_sx_core1;
+			} else if (comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) {
+				if (hw->bus.lan_id == 0)
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_lx_core0;
+				else
+					hw->phy.sfp_type =
+						ixgbe_sfp_type_1g_lx_core1;
+			} else {
+				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
+			}
 		}
-	}
 
-	/* Allow any DA cable vendor */
-	if (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |
-	    IXGBE_SFF_DA_ACTIVE_CABLE))
-		return 0;
+		if (hw->phy.sfp_type != stored_sfp_type)
+			hw->phy.sfp_setup_needed = true;
+
+		/* Determine if the SFP+ PHY is dual speed or not. */
+		hw->phy.multispeed_fiber = false;
+		if (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&
+		   (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||
+		   ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&
+		   (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))
+			hw->phy.multispeed_fiber = true;
+
+		/* Determine PHY vendor */
+		if (hw->phy.type != ixgbe_phy_nl) {
+			hw->phy.id = identifier;
+			status = hw->phy.ops.read_i2c_eeprom(hw,
+						    IXGBE_SFF_VENDOR_OUI_BYTE0,
+						    &oui_bytes[0]);
+
+			if (status != IXGBE_SUCCESS)
+				goto err_read_i2c_eeprom;
+
+			status = hw->phy.ops.read_i2c_eeprom(hw,
+						    IXGBE_SFF_VENDOR_OUI_BYTE1,
+						    &oui_bytes[1]);
+
+			if (status != IXGBE_SUCCESS)
+				goto err_read_i2c_eeprom;
+
+			status = hw->phy.ops.read_i2c_eeprom(hw,
+						    IXGBE_SFF_VENDOR_OUI_BYTE2,
+						    &oui_bytes[2]);
+
+			if (status != IXGBE_SUCCESS)
+				goto err_read_i2c_eeprom;
+
+			vendor_oui =
+			  ((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |
+			   (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |
+			   (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));
+
+			switch (vendor_oui) {
+			case IXGBE_SFF_VENDOR_OUI_TYCO:
+				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
+					hw->phy.type =
+						    ixgbe_phy_sfp_passive_tyco;
+				break;
+			case IXGBE_SFF_VENDOR_OUI_FTL:
+				if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
+					hw->phy.type = ixgbe_phy_sfp_ftl_active;
+				else
+					hw->phy.type = ixgbe_phy_sfp_ftl;
+				break;
+			case IXGBE_SFF_VENDOR_OUI_AVAGO:
+				hw->phy.type = ixgbe_phy_sfp_avago;
+				break;
+			case IXGBE_SFF_VENDOR_OUI_INTEL:
+				hw->phy.type = ixgbe_phy_sfp_intel;
+				break;
+			default:
+				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
+					hw->phy.type =
+						 ixgbe_phy_sfp_passive_unknown;
+				else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
+					hw->phy.type =
+						ixgbe_phy_sfp_active_unknown;
+				else
+					hw->phy.type = ixgbe_phy_sfp_unknown;
+				break;
+			}
+		}
 
-	/* Verify supported 1G SFP modules */
-	if (comp_codes_10g == 0 &&
-	    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
-		hw->phy.type = ixgbe_phy_sfp_unsupported;
-		return IXGBE_ERR_SFP_NOT_SUPPORTED;
-	}
+		/* Allow any DA cable vendor */
+		if (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |
+		    IXGBE_SFF_DA_ACTIVE_CABLE)) {
+			status = IXGBE_SUCCESS;
+			goto out;
+		}
 
-	/* Anything else 82598-based is supported */
-	if (hw->mac.type == ixgbe_mac_82598EB)
-		return 0;
+		/* Verify supported 1G SFP modules */
+		if (comp_codes_10g == 0 &&
+		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
+			hw->phy.type = ixgbe_phy_sfp_unsupported;
+			status = IXGBE_ERR_SFP_NOT_SUPPORTED;
+			goto out;
+		}
 
-	hw->mac.ops.get_device_caps(hw, &enforce_sfp);
-	if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&
-	    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
-	      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
-		/* Make sure we're a supported PHY type */
-		if (hw->phy.type == ixgbe_phy_sfp_intel)
-			return 0;
-		if (hw->allow_unsupported_sfp) {
-			e_warn(drv, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics.  Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter.  Intel Corporation is not responsible for any harm caused by using untested modules.\n");
-			return 0;
+		/* Anything else 82598-based is supported */
+		if (hw->mac.type == ixgbe_mac_82598EB) {
+			status = IXGBE_SUCCESS;
+			goto out;
+		}
+
+		ixgbe_get_device_caps(hw, &enforce_sfp);
+		if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&
+		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
+		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
+			/* Make sure we're a supported PHY type */
+			if (hw->phy.type == ixgbe_phy_sfp_intel) {
+				status = IXGBE_SUCCESS;
+			} else {
+				if (hw->allow_unsupported_sfp == true) {
+					EWARN(hw, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
+					status = IXGBE_SUCCESS;
+				} else {
+					hw_dbg(hw, "SFP+ module not supported\n");
+					hw->phy.type =
+						ixgbe_phy_sfp_unsupported;
+					status = IXGBE_ERR_SFP_NOT_SUPPORTED;
+				}
+			}
+		} else {
+			status = IXGBE_SUCCESS;
 		}
-		hw_dbg(hw, "SFP+ module not supported\n");
-		hw->phy.type = ixgbe_phy_sfp_unsupported;
-		return IXGBE_ERR_SFP_NOT_SUPPORTED;
 	}
-	return 0;
+
+out:
+	return status;
 
 err_read_i2c_eeprom:
 	hw->phy.sfp_type = ixgbe_sfp_type_not_present;
@@ -1654,16 +1532,77 @@ s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)
 	return IXGBE_ERR_SFP_NOT_PRESENT;
 }
 
+/**
+ * ixgbe_get_supported_phy_sfp_layer_generic - Returns physical layer type
+ * @hw: pointer to hardware structure
+ *
+ * Determines physical layer capabilities of the current SFP.
+ */
+u64 ixgbe_get_supported_phy_sfp_layer_generic(struct ixgbe_hw *hw)
+{
+	u64 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+	u8 comp_codes_10g = 0;
+	u8 comp_codes_1g = 0;
+
+	DEBUGFUNC("ixgbe_get_supported_phy_sfp_layer_generic");
+
+	hw->phy.ops.identify_sfp(hw);
+	if (hw->phy.sfp_type == ixgbe_sfp_type_not_present)
+		return physical_layer;
+
+	switch (hw->phy.type) {
+	case ixgbe_phy_sfp_passive_tyco:
+	case ixgbe_phy_sfp_passive_unknown:
+	case ixgbe_phy_qsfp_passive_unknown:
+		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
+		break;
+	case ixgbe_phy_sfp_ftl_active:
+	case ixgbe_phy_sfp_active_unknown:
+	case ixgbe_phy_qsfp_active_unknown:
+		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA;
+		break;
+	case ixgbe_phy_sfp_avago:
+	case ixgbe_phy_sfp_ftl:
+	case ixgbe_phy_sfp_intel:
+	case ixgbe_phy_sfp_unknown:
+		hw->phy.ops.read_i2c_eeprom(hw,
+		      IXGBE_SFF_1GBE_COMP_CODES, &comp_codes_1g);
+		hw->phy.ops.read_i2c_eeprom(hw,
+		      IXGBE_SFF_10GBE_COMP_CODES, &comp_codes_10g);
+		if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
+		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
+		else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_T;
+		else if (comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_SX;
+		break;
+	case ixgbe_phy_qsfp_intel:
+	case ixgbe_phy_qsfp_unknown:
+		hw->phy.ops.read_i2c_eeprom(hw,
+		      IXGBE_SFF_QSFP_10GBE_COMP, &comp_codes_10g);
+		if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
+		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
+			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
+		break;
+	default:
+		break;
+	}
+
+	return physical_layer;
+}
+
 /**
  * ixgbe_identify_qsfp_module_generic - Identifies QSFP modules
  * @hw: pointer to hardware structure
  *
  * Searches for and identifies the QSFP module and assigns appropriate PHY type
  **/
-static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
+s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 {
-	struct ixgbe_adapter *adapter = hw->back;
-	s32 status;
+	s32 status = IXGBE_ERR_PHY_ADDR_INVALID;
 	u32 vendor_oui = 0;
 	enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
 	u8 identifier = 0;
@@ -1676,23 +1615,27 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 	u8 device_tech = 0;
 	bool active_cable = false;
 
+	DEBUGFUNC("ixgbe_identify_qsfp_module_generic");
+
 	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber_qsfp) {
 		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
-		return IXGBE_ERR_SFP_NOT_PRESENT;
+		status = IXGBE_ERR_SFP_NOT_PRESENT;
+		goto out;
 	}
 
-	/* LAN ID is needed for sfp_type determination */
+	/* LAN ID is needed for I2C access */
 	hw->mac.ops.set_lan_id(hw);
 
 	status = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_IDENTIFIER,
 					     &identifier);
 
-	if (status != 0)
+	if (status != IXGBE_SUCCESS)
 		goto err_read_i2c_eeprom;
 
 	if (identifier != IXGBE_SFF_IDENTIFIER_QSFP_PLUS) {
 		hw->phy.type = ixgbe_phy_sfp_unsupported;
-		return IXGBE_ERR_SFP_NOT_SUPPORTED;
+		status = IXGBE_ERR_SFP_NOT_SUPPORTED;
+		goto out;
 	}
 
 	hw->phy.id = identifier;
@@ -1700,13 +1643,13 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 	status = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_10GBE_COMP,
 					     &comp_codes_10g);
 
-	if (status != 0)
+	if (status != IXGBE_SUCCESS)
 		goto err_read_i2c_eeprom;
 
 	status = hw->phy.ops.read_i2c_eeprom(hw, IXGBE_SFF_QSFP_1GBE_COMP,
 					     &comp_codes_1g);
 
-	if (status != 0)
+	if (status != IXGBE_SUCCESS)
 		goto err_read_i2c_eeprom;
 
 	if (comp_codes_10g & IXGBE_SFF_QSFP_DA_PASSIVE_CABLE) {
@@ -1727,8 +1670,7 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 
 		if (!active_cable) {
 			/* check for active DA cables that pre-date
-			 * SFF-8436 v3.6
-			 */
+			 * SFF-8436 v3.6 */
 			hw->phy.ops.read_i2c_eeprom(hw,
 					IXGBE_SFF_QSFP_CONNECTOR,
 					&connector);
@@ -1760,7 +1702,8 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 		} else {
 			/* unsupported module type */
 			hw->phy.type = ixgbe_phy_sfp_unsupported;
-			return IXGBE_ERR_SFP_NOT_SUPPORTED;
+			status = IXGBE_ERR_SFP_NOT_SUPPORTED;
+			goto out;
 		}
 	}
 
@@ -1770,61 +1713,68 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 	/* Determine if the QSFP+ PHY is dual speed or not. */
 	hw->phy.multispeed_fiber = false;
 	if (((comp_codes_1g & IXGBE_SFF_1GBASESX_CAPABLE) &&
-	     (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||
-	    ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&
-	     (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))
+	   (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)) ||
+	   ((comp_codes_1g & IXGBE_SFF_1GBASELX_CAPABLE) &&
+	   (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)))
 		hw->phy.multispeed_fiber = true;
 
 	/* Determine PHY vendor for optical modules */
 	if (comp_codes_10g & (IXGBE_SFF_10GBASESR_CAPABLE |
-			      IXGBE_SFF_10GBASELR_CAPABLE)) {
+			      IXGBE_SFF_10GBASELR_CAPABLE))  {
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					IXGBE_SFF_QSFP_VENDOR_OUI_BYTE0,
-					&oui_bytes[0]);
+					    IXGBE_SFF_QSFP_VENDOR_OUI_BYTE0,
+					    &oui_bytes[0]);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
 
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					IXGBE_SFF_QSFP_VENDOR_OUI_BYTE1,
-					&oui_bytes[1]);
+					    IXGBE_SFF_QSFP_VENDOR_OUI_BYTE1,
+					    &oui_bytes[1]);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
 
 		status = hw->phy.ops.read_i2c_eeprom(hw,
-					IXGBE_SFF_QSFP_VENDOR_OUI_BYTE2,
-					&oui_bytes[2]);
+					    IXGBE_SFF_QSFP_VENDOR_OUI_BYTE2,
+					    &oui_bytes[2]);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto err_read_i2c_eeprom;
 
 		vendor_oui =
-			((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |
-			 (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |
-			 (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));
+		  ((oui_bytes[0] << IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT) |
+		   (oui_bytes[1] << IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT) |
+		   (oui_bytes[2] << IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT));
 
 		if (vendor_oui == IXGBE_SFF_VENDOR_OUI_INTEL)
 			hw->phy.type = ixgbe_phy_qsfp_intel;
 		else
 			hw->phy.type = ixgbe_phy_qsfp_unknown;
 
-		hw->mac.ops.get_device_caps(hw, &enforce_sfp);
+		ixgbe_get_device_caps(hw, &enforce_sfp);
 		if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP)) {
 			/* Make sure we're a supported PHY type */
-			if (hw->phy.type == ixgbe_phy_qsfp_intel)
-				return 0;
-			if (hw->allow_unsupported_sfp) {
-				e_warn(drv, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
-				return 0;
+			if (hw->phy.type == ixgbe_phy_qsfp_intel) {
+				status = IXGBE_SUCCESS;
+			} else {
+				if (hw->allow_unsupported_sfp == true) {
+					EWARN(hw, "WARNING: Intel (R) Network Connections are quality tested using Intel (R) Ethernet Optics. Using untested modules is not supported and may cause unstable operation or damage to the module or the adapter. Intel Corporation is not responsible for any harm caused by using untested modules.\n");
+					status = IXGBE_SUCCESS;
+				} else {
+					hw_dbg(hw, "QSFP module not supported\n");
+					hw->phy.type =
+						ixgbe_phy_sfp_unsupported;
+					status = IXGBE_ERR_SFP_NOT_SUPPORTED;
+				}
 			}
-			hw_dbg(hw, "QSFP module not supported\n");
-			hw->phy.type = ixgbe_phy_sfp_unsupported;
-			return IXGBE_ERR_SFP_NOT_SUPPORTED;
+		} else {
+			status = IXGBE_SUCCESS;
 		}
-		return 0;
 	}
-	return 0;
+
+out:
+	return status;
 
 err_read_i2c_eeprom:
 	hw->phy.sfp_type = ixgbe_sfp_type_not_present;
@@ -1835,13 +1785,13 @@ static s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence
- *  @hw: pointer to hardware structure
- *  @list_offset: offset to the SFP ID list
- *  @data_offset: offset to the SFP data block
+ * ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence
+ * @hw: pointer to hardware structure
+ * @list_offset: offset to the SFP ID list
+ * @data_offset: offset to the SFP data block
  *
- *  Checks the MAC's EEPROM to see if it supports a given SFP+ module type, if
- *  so it returns the offsets to the phy init sequence block.
+ * Checks the MAC's EEPROM to see if it supports a given SFP+ module type, if
+ * so it returns the offsets to the phy init sequence block.
  **/
 s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
 					u16 *list_offset,
@@ -1850,6 +1800,8 @@ s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
 	u16 sfp_id;
 	u16 sfp_type = hw->phy.sfp_type;
 
+	DEBUGFUNC("ixgbe_get_sfp_init_sequence_offsets");
+
 	if (hw->phy.sfp_type == ixgbe_sfp_type_unknown)
 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
 
@@ -1877,8 +1829,9 @@ s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
 
 	/* Read offset to PHY init contents */
 	if (hw->eeprom.ops.read(hw, IXGBE_PHY_INIT_OFFSET_NL, list_offset)) {
-		hw_err(hw, "eeprom read at %d failed\n",
-		       IXGBE_PHY_INIT_OFFSET_NL);
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			      "eeprom read at offset %d failed",
+			      IXGBE_PHY_INIT_OFFSET_NL);
 		return IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT;
 	}
 
@@ -1918,39 +1871,42 @@ s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 
 err_phy:
-	hw_err(hw, "eeprom read at offset %d failed\n", *list_offset);
+	ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+		      "eeprom read at offset %d failed", *list_offset);
 	return IXGBE_ERR_PHY;
 }
 
 /**
- *  ixgbe_read_i2c_eeprom_generic - Reads 8 bit EEPROM word over I2C interface
- *  @hw: pointer to hardware structure
- *  @byte_offset: EEPROM byte offset to read
- *  @eeprom_data: value read
+ * ixgbe_read_i2c_eeprom_generic - Reads 8 bit EEPROM word over I2C interface
+ * @hw: pointer to hardware structure
+ * @byte_offset: EEPROM byte offset to read
+ * @eeprom_data: value read
  *
- *  Performs byte read operation to SFP module's EEPROM over I2C interface.
+ * Performs byte read operation to SFP module's EEPROM over I2C interface.
  **/
 s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				  u8 *eeprom_data)
 {
+	DEBUGFUNC("ixgbe_read_i2c_eeprom_generic");
+
 	return hw->phy.ops.read_i2c_byte(hw, byte_offset,
 					 IXGBE_I2C_EEPROM_DEV_ADDR,
 					 eeprom_data);
 }
 
 /**
- *  ixgbe_read_i2c_sff8472_generic - Reads 8 bit word over I2C interface
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset at address 0xA2
- *  @sff8472_data: value read
+ * ixgbe_read_i2c_sff8472_generic - Reads 8 bit word over I2C interface
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset at address 0xA2
+ * @sff8472_data: value read
  *
- *  Performs byte read operation to SFP module's SFF-8472 data over I2C
+ * Performs byte read operation to SFP module's SFF-8472 data over I2C
  **/
-s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,
-				   u8 *sff8472_data)
+STATIC s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,
+					  u8 *sff8472_data)
 {
 	return hw->phy.ops.read_i2c_byte(hw, byte_offset,
 					 IXGBE_I2C_EEPROM_DEV_ADDR2,
@@ -1958,16 +1914,18 @@ s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_write_i2c_eeprom_generic - Writes 8 bit EEPROM word over I2C interface
- *  @hw: pointer to hardware structure
- *  @byte_offset: EEPROM byte offset to write
- *  @eeprom_data: value to write
+ * ixgbe_write_i2c_eeprom_generic - Writes 8 bit EEPROM word over I2C interface
+ * @hw: pointer to hardware structure
+ * @byte_offset: EEPROM byte offset to write
+ * @eeprom_data: value to write
  *
- *  Performs byte write operation to SFP module's EEPROM over I2C interface.
+ * Performs byte write operation to SFP module's EEPROM over I2C interface.
  **/
 s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				   u8 eeprom_data)
 {
+	DEBUGFUNC("ixgbe_write_i2c_eeprom_generic");
+
 	return hw->phy.ops.write_i2c_byte(hw, byte_offset,
 					  IXGBE_I2C_EEPROM_DEV_ADDR,
 					  eeprom_data);
@@ -1979,7 +1937,7 @@ s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
  * @offset: eeprom offset to be read
  * @addr: I2C address to be read
  */
-static bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)
+STATIC bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)
 {
 	if (addr == IXGBE_I2C_EEPROM_DEV_ADDR &&
 	    offset == IXGBE_SFF_IDENTIFIER &&
@@ -1989,32 +1947,33 @@ static bool ixgbe_is_sfp_probe(struct ixgbe_hw *hw, u8 offset, u8 addr)
 }
 
 /**
- *  ixgbe_read_i2c_byte_generic_int - Reads 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to read
- *  @dev_addr: device address
- *  @data: value read
- *  @lock: true if to take and release semaphore
+ * ixgbe_read_i2c_byte_generic_int - Reads 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: address to read from
+ * @data: value read
+ * @lock: true if to take and release semaphore
  *
- *  Performs byte read operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
-static s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
+ * Performs byte read operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
+STATIC s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
 					   u8 dev_addr, u8 *data, bool lock)
 {
 	s32 status;
 	u32 max_retry = 10;
 	u32 retry = 0;
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
-	bool nack = true;
+	bool nack = 1;
+	*data = 0;
+
+	DEBUGFUNC("ixgbe_read_i2c_byte_generic");
 
 	if (hw->mac.type >= ixgbe_mac_X550)
 		max_retry = 3;
 	if (ixgbe_is_sfp_probe(hw, byte_offset, dev_addr))
 		max_retry = IXGBE_SFP_DETECT_RETRIES;
 
-	*data = 0;
-
 	do {
 		if (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))
 			return IXGBE_ERR_SWFW_SYNC;
@@ -2023,72 +1982,70 @@ static s32 ixgbe_read_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
 
 		/* Device Address and write indication */
 		status = ixgbe_clock_out_i2c_byte(hw, dev_addr);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_clock_out_i2c_byte(hw, byte_offset);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		ixgbe_i2c_start(hw);
 
 		/* Device Address and read indication */
 		status = ixgbe_clock_out_i2c_byte(hw, (dev_addr | 0x1));
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
-		status = ixgbe_clock_in_i2c_byte(hw, data);
-		if (status != 0)
-			goto fail;
+		ixgbe_clock_in_i2c_byte(hw, data);
 
 		status = ixgbe_clock_out_i2c_bit(hw, nack);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		ixgbe_i2c_stop(hw);
 		if (lock)
 			hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-		return 0;
+		return IXGBE_SUCCESS;
 
 fail:
 		ixgbe_i2c_bus_clear(hw);
 		if (lock) {
 			hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-			msleep(100);
+			msec_delay(100);
 		}
-		retry++;
 		if (retry < max_retry)
 			hw_dbg(hw, "I2C byte read error - Retrying.\n");
 		else
 			hw_dbg(hw, "I2C byte read error.\n");
+		retry++;
 
-	} while (retry < max_retry);
+	} while (retry <= max_retry);
 
 	return status;
 }
 
 /**
- *  ixgbe_read_i2c_byte_generic - Reads 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to read
- *  @dev_addr: device address
- *  @data: value read
+ * ixgbe_read_i2c_byte_generic - Reads 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: address to read from
+ * @data: value read
  *
- *  Performs byte read operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
+ * Performs byte read operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
 s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				u8 dev_addr, u8 *data)
 {
@@ -2097,15 +2054,15 @@ s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_read_i2c_byte_generic_unlocked - Reads 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to read
- *  @dev_addr: device address
- *  @data: value read
+ * ixgbe_read_i2c_byte_generic_unlocked - Reads 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to read
+ * @dev_addr: address to read from
+ * @data: value read
  *
- *  Performs byte read operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
+ * Performs byte read operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
 s32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
 					 u8 dev_addr, u8 *data)
 {
@@ -2114,17 +2071,17 @@ s32 ixgbe_read_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_write_i2c_byte_generic_int - Writes 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to write
- *  @dev_addr: device address
- *  @data: value to write
- *  @lock: true if to take and release semaphore
+ * ixgbe_write_i2c_byte_generic_int - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: address to write to
+ * @data: value to write
+ * @lock: true if to take and release semaphore
  *
- *  Performs byte write operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
-static s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
+ * Performs byte write operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
+STATIC s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
 					    u8 dev_addr, u8 data, bool lock)
 {
 	s32 status;
@@ -2132,49 +2089,52 @@ static s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
 	u32 retry = 0;
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
 
-	if (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask))
+	DEBUGFUNC("ixgbe_write_i2c_byte_generic");
+
+	if (lock && hw->mac.ops.acquire_swfw_sync(hw, swfw_mask) !=
+	    IXGBE_SUCCESS)
 		return IXGBE_ERR_SWFW_SYNC;
 
 	do {
 		ixgbe_i2c_start(hw);
 
 		status = ixgbe_clock_out_i2c_byte(hw, dev_addr);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_clock_out_i2c_byte(hw, byte_offset);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_clock_out_i2c_byte(hw, data);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		status = ixgbe_get_i2c_ack(hw);
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			goto fail;
 
 		ixgbe_i2c_stop(hw);
 		if (lock)
 			hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-		return 0;
+		return IXGBE_SUCCESS;
 
 fail:
 		ixgbe_i2c_bus_clear(hw);
-		retry++;
 		if (retry < max_retry)
 			hw_dbg(hw, "I2C byte write error - Retrying.\n");
 		else
 			hw_dbg(hw, "I2C byte write error.\n");
-	} while (retry < max_retry);
+		retry++;
+	} while (retry <= max_retry);
 
 	if (lock)
 		hw->mac.ops.release_swfw_sync(hw, swfw_mask);
@@ -2183,15 +2143,15 @@ static s32 ixgbe_write_i2c_byte_generic_int(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_write_i2c_byte_generic - Writes 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to write
- *  @dev_addr: device address
- *  @data: value to write
+ * ixgbe_write_i2c_byte_generic - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: address to write to
+ * @data: value to write
  *
- *  Performs byte write operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
+ * Performs byte write operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
 s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				 u8 dev_addr, u8 data)
 {
@@ -2200,15 +2160,15 @@ s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_write_i2c_byte_generic_unlocked - Writes 8 bit word over I2C
- *  @hw: pointer to hardware structure
- *  @byte_offset: byte offset to write
- *  @dev_addr: device address
- *  @data: value to write
+ * ixgbe_write_i2c_byte_generic_unlocked - Writes 8 bit word over I2C
+ * @hw: pointer to hardware structure
+ * @byte_offset: byte offset to write
+ * @dev_addr: address to write to
+ * @data: value to write
  *
- *  Performs byte write operation to SFP module's EEPROM over I2C interface at
- *  a specified device address.
- */
+ * Performs byte write operation to SFP module's EEPROM over I2C interface at
+ * a specified device address.
+ **/
 s32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
 					  u8 dev_addr, u8 data)
 {
@@ -2217,163 +2177,171 @@ s32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
 }
 
 /**
- *  ixgbe_i2c_start - Sets I2C start condition
- *  @hw: pointer to hardware structure
+ * ixgbe_i2c_start - Sets I2C start condition
+ * @hw: pointer to hardware structure
  *
- *  Sets I2C start condition (High -> Low on SDA while SCL is High)
- *  Set bit-bang mode on X550 hardware.
+ * Sets I2C start condition (High -> Low on SDA while SCL is High)
+ * Set bit-bang mode on X550 hardware.
  **/
-static void ixgbe_i2c_start(struct ixgbe_hw *hw)
+STATIC void ixgbe_i2c_start(struct ixgbe_hw *hw)
 {
-	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+
+	DEBUGFUNC("ixgbe_i2c_start");
 
-	i2cctl |= IXGBE_I2C_BB_EN(hw);
+	i2cctl |= IXGBE_I2C_BB_EN_BY_MAC(hw);
 
 	/* Start condition must begin with data and clock high */
 	ixgbe_set_i2c_data(hw, &i2cctl, 1);
 	ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 	/* Setup time for start condition (4.7us) */
-	udelay(IXGBE_I2C_T_SU_STA);
+	usec_delay(IXGBE_I2C_T_SU_STA);
 
 	ixgbe_set_i2c_data(hw, &i2cctl, 0);
 
 	/* Hold time for start condition (4us) */
-	udelay(IXGBE_I2C_T_HD_STA);
+	usec_delay(IXGBE_I2C_T_HD_STA);
 
 	ixgbe_lower_i2c_clk(hw, &i2cctl);
 
 	/* Minimum low period of clock is 4.7 us */
-	udelay(IXGBE_I2C_T_LOW);
+	usec_delay(IXGBE_I2C_T_LOW);
 
 }
 
 /**
- *  ixgbe_i2c_stop - Sets I2C stop condition
- *  @hw: pointer to hardware structure
+ * ixgbe_i2c_stop - Sets I2C stop condition
+ * @hw: pointer to hardware structure
  *
- *  Sets I2C stop condition (Low -> High on SDA while SCL is High)
- *  Disables bit-bang mode and negates data output enable on X550
- *  hardware.
+ * Sets I2C stop condition (Low -> High on SDA while SCL is High)
+ * Disables bit-bang mode and negates data output enable on X550
+ * hardware.
  **/
-static void ixgbe_i2c_stop(struct ixgbe_hw *hw)
+STATIC void ixgbe_i2c_stop(struct ixgbe_hw *hw)
 {
-	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
-	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);
-	u32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);
-	u32 bb_en_bit = IXGBE_I2C_BB_EN(hw);
+	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+	u32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN_BY_MAC(hw);
+	u32 bb_en_bit = IXGBE_I2C_BB_EN_BY_MAC(hw);
+
+	DEBUGFUNC("ixgbe_i2c_stop");
 
 	/* Stop condition must begin with data low and clock high */
 	ixgbe_set_i2c_data(hw, &i2cctl, 0);
 	ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 	/* Setup time for stop condition (4us) */
-	udelay(IXGBE_I2C_T_SU_STO);
+	usec_delay(IXGBE_I2C_T_SU_STO);
 
 	ixgbe_set_i2c_data(hw, &i2cctl, 1);
 
 	/* bus free time between stop and start (4.7us)*/
-	udelay(IXGBE_I2C_T_BUF);
+	usec_delay(IXGBE_I2C_T_BUF);
 
 	if (bb_en_bit || data_oe_bit || clk_oe_bit) {
 		i2cctl &= ~bb_en_bit;
 		i2cctl |= data_oe_bit | clk_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
 	}
 }
 
 /**
- *  ixgbe_clock_in_i2c_byte - Clocks in one byte via I2C
- *  @hw: pointer to hardware structure
- *  @data: data byte to clock in
+ * ixgbe_clock_in_i2c_byte - Clocks in one byte via I2C
+ * @hw: pointer to hardware structure
+ * @data: data byte to clock in
  *
- *  Clocks in one byte data via I2C data/clock
+ * Clocks in one byte data via I2C data/clock
  **/
-static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)
+STATIC void ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)
 {
 	s32 i;
-	bool bit = false;
+	bool bit = 0;
+
+	DEBUGFUNC("ixgbe_clock_in_i2c_byte");
 
 	*data = 0;
 	for (i = 7; i >= 0; i--) {
 		ixgbe_clock_in_i2c_bit(hw, &bit);
 		*data |= bit << i;
 	}
-
-	return 0;
 }
 
 /**
- *  ixgbe_clock_out_i2c_byte - Clocks out one byte via I2C
- *  @hw: pointer to hardware structure
- *  @data: data byte clocked out
+ * ixgbe_clock_out_i2c_byte - Clocks out one byte via I2C
+ * @hw: pointer to hardware structure
+ * @data: data byte clocked out
  *
- *  Clocks out one byte data via I2C data/clock
+ * Clocks out one byte data via I2C data/clock
  **/
-static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)
+STATIC s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)
 {
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
 	s32 i;
 	u32 i2cctl;
-	bool bit = false;
+	bool bit;
+
+	DEBUGFUNC("ixgbe_clock_out_i2c_byte");
 
 	for (i = 7; i >= 0; i--) {
 		bit = (data >> i) & 0x1;
 		status = ixgbe_clock_out_i2c_bit(hw, bit);
 
-		if (status != 0)
+		if (status != IXGBE_SUCCESS)
 			break;
 	}
 
 	/* Release SDA line (set high) */
-	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
-	i2cctl |= IXGBE_I2C_DATA_OUT(hw);
-	i2cctl |= IXGBE_I2C_DATA_OE_N_EN(hw);
-	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);
+	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+	i2cctl |= IXGBE_I2C_DATA_OUT_BY_MAC(hw);
+	i2cctl |= IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), i2cctl);
 	IXGBE_WRITE_FLUSH(hw);
 
 	return status;
 }
 
 /**
- *  ixgbe_get_i2c_ack - Polls for I2C ACK
- *  @hw: pointer to hardware structure
+ * ixgbe_get_i2c_ack - Polls for I2C ACK
+ * @hw: pointer to hardware structure
  *
- *  Clocks in/out one bit via I2C data/clock
+ * Clocks in/out one bit via I2C data/clock
  **/
-static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)
 {
-	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);
-	s32 status = 0;
+	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+	s32 status = IXGBE_SUCCESS;
 	u32 i = 0;
-	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 	u32 timeout = 10;
-	bool ack = true;
+	bool ack = 1;
+
+	DEBUGFUNC("ixgbe_get_i2c_ack");
 
 	if (data_oe_bit) {
-		i2cctl |= IXGBE_I2C_DATA_OUT(hw);
+		i2cctl |= IXGBE_I2C_DATA_OUT_BY_MAC(hw);
 		i2cctl |= data_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
 	}
 	ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 	/* Minimum high period of clock is 4us */
-	udelay(IXGBE_I2C_T_HIGH);
+	usec_delay(IXGBE_I2C_T_HIGH);
 
 	/* Poll for ACK.  Note that ACK in I2C spec is
 	 * transition from 1 to 0 */
 	for (i = 0; i < timeout; i++) {
-		i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+		i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 		ack = ixgbe_get_i2c_data(hw, &i2cctl);
 
-		udelay(1);
-		if (ack == 0)
+		usec_delay(1);
+		if (!ack)
 			break;
 	}
 
-	if (ack == 1) {
+	if (ack) {
 		hw_dbg(hw, "I2C ack was not received.\n");
 		status = IXGBE_ERR_I2C;
 	}
@@ -2381,212 +2349,233 @@ static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)
 	ixgbe_lower_i2c_clk(hw, &i2cctl);
 
 	/* Minimum low period of clock is 4.7 us */
-	udelay(IXGBE_I2C_T_LOW);
+	usec_delay(IXGBE_I2C_T_LOW);
 
 	return status;
 }
 
 /**
- *  ixgbe_clock_in_i2c_bit - Clocks in one bit via I2C data/clock
- *  @hw: pointer to hardware structure
- *  @data: read data value
+ * ixgbe_clock_in_i2c_bit - Clocks in one bit via I2C data/clock
+ * @hw: pointer to hardware structure
+ * @data: read data value
  *
- *  Clocks in one bit via I2C data/clock
+ * Clocks in one bit via I2C data/clock
  **/
-static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)
+STATIC void ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)
 {
-	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
-	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);
+	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+
+	DEBUGFUNC("ixgbe_clock_in_i2c_bit");
 
 	if (data_oe_bit) {
-		i2cctl |= IXGBE_I2C_DATA_OUT(hw);
+		i2cctl |= IXGBE_I2C_DATA_OUT_BY_MAC(hw);
 		i2cctl |= data_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
 	}
 	ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 	/* Minimum high period of clock is 4us */
-	udelay(IXGBE_I2C_T_HIGH);
+	usec_delay(IXGBE_I2C_T_HIGH);
 
-	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 	*data = ixgbe_get_i2c_data(hw, &i2cctl);
 
 	ixgbe_lower_i2c_clk(hw, &i2cctl);
 
 	/* Minimum low period of clock is 4.7 us */
-	udelay(IXGBE_I2C_T_LOW);
-
-	return 0;
+	usec_delay(IXGBE_I2C_T_LOW);
 }
 
 /**
- *  ixgbe_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock
- *  @hw: pointer to hardware structure
- *  @data: data value to write
+ * ixgbe_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock
+ * @hw: pointer to hardware structure
+ * @data: data value to write
  *
- *  Clocks out one bit via I2C data/clock
+ * Clocks out one bit via I2C data/clock
  **/
-static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)
+STATIC s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)
 {
 	s32 status;
-	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	u32 i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+
+	DEBUGFUNC("ixgbe_clock_out_i2c_bit");
 
 	status = ixgbe_set_i2c_data(hw, &i2cctl, data);
-	if (status == 0) {
+	if (status == IXGBE_SUCCESS) {
 		ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 		/* Minimum high period of clock is 4us */
-		udelay(IXGBE_I2C_T_HIGH);
+		usec_delay(IXGBE_I2C_T_HIGH);
 
 		ixgbe_lower_i2c_clk(hw, &i2cctl);
 
 		/* Minimum low period of clock is 4.7 us.
 		 * This also takes care of the data hold time.
 		 */
-		udelay(IXGBE_I2C_T_LOW);
+		usec_delay(IXGBE_I2C_T_LOW);
 	} else {
-		hw_dbg(hw, "I2C data was not set to %X\n", data);
-		return IXGBE_ERR_I2C;
+		status = IXGBE_ERR_I2C;
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			     "I2C data was not set to %X\n", data);
 	}
 
-	return 0;
+	return status;
 }
+
 /**
- *  ixgbe_raise_i2c_clk - Raises the I2C SCL clock
- *  @hw: pointer to hardware structure
- *  @i2cctl: Current value of I2CCTL register
+ * ixgbe_raise_i2c_clk - Raises the I2C SCL clock
+ * @hw: pointer to hardware structure
+ * @i2cctl: Current value of I2CCTL register
  *
- *  Raises the I2C clock line '0'->'1'
- *  Negates the I2C clock output enable on X550 hardware.
+ * Raises the I2C clock line '0'->'1'
+ * Negates the I2C clock output enable on X550 hardware.
  **/
-static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
+STATIC void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
 {
-	u32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN(hw);
+	u32 clk_oe_bit = IXGBE_I2C_CLK_OE_N_EN_BY_MAC(hw);
 	u32 i = 0;
 	u32 timeout = IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT;
 	u32 i2cctl_r = 0;
 
+	DEBUGFUNC("ixgbe_raise_i2c_clk");
+
 	if (clk_oe_bit) {
 		*i2cctl |= clk_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 	}
 
 	for (i = 0; i < timeout; i++) {
-		*i2cctl |= IXGBE_I2C_CLK_OUT(hw);
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+		*i2cctl |= IXGBE_I2C_CLK_OUT_BY_MAC(hw);
+
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
 		/* SCL rise time (1000ns) */
-		udelay(IXGBE_I2C_T_RISE);
+		usec_delay(IXGBE_I2C_T_RISE);
 
-		i2cctl_r = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
-		if (i2cctl_r & IXGBE_I2C_CLK_IN(hw))
+		i2cctl_r = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
+		if (i2cctl_r & IXGBE_I2C_CLK_IN_BY_MAC(hw))
 			break;
 	}
 }
 
 /**
- *  ixgbe_lower_i2c_clk - Lowers the I2C SCL clock
- *  @hw: pointer to hardware structure
- *  @i2cctl: Current value of I2CCTL register
+ * ixgbe_lower_i2c_clk - Lowers the I2C SCL clock
+ * @hw: pointer to hardware structure
+ * @i2cctl: Current value of I2CCTL register
  *
- *  Lowers the I2C clock line '1'->'0'
- *  Asserts the I2C clock output enable on X550 hardware.
+ * Lowers the I2C clock line '1'->'0'
+ * Asserts the I2C clock output enable on X550 hardware.
  **/
-static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
+STATIC void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
 {
+	DEBUGFUNC("ixgbe_lower_i2c_clk");
 
-	*i2cctl &= ~IXGBE_I2C_CLK_OUT(hw);
-	*i2cctl &= ~IXGBE_I2C_CLK_OE_N_EN(hw);
+	*i2cctl &= ~(IXGBE_I2C_CLK_OUT_BY_MAC(hw));
+	*i2cctl &= ~IXGBE_I2C_CLK_OE_N_EN_BY_MAC(hw);
 
-	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 	IXGBE_WRITE_FLUSH(hw);
 
 	/* SCL fall time (300ns) */
-	udelay(IXGBE_I2C_T_FALL);
+	usec_delay(IXGBE_I2C_T_FALL);
 }
 
 /**
- *  ixgbe_set_i2c_data - Sets the I2C data bit
- *  @hw: pointer to hardware structure
- *  @i2cctl: Current value of I2CCTL register
- *  @data: I2C data value (0 or 1) to set
+ * ixgbe_set_i2c_data - Sets the I2C data bit
+ * @hw: pointer to hardware structure
+ * @i2cctl: Current value of I2CCTL register
+ * @data: I2C data value (0 or 1) to set
  *
- *  Sets the I2C data bit
- *  Asserts the I2C data output enable on X550 hardware.
+ * Sets the I2C data bit
+ * Asserts the I2C data output enable on X550 hardware.
  **/
-static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)
+STATIC s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)
 {
-	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);
+	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_set_i2c_data");
 
 	if (data)
-		*i2cctl |= IXGBE_I2C_DATA_OUT(hw);
+		*i2cctl |= IXGBE_I2C_DATA_OUT_BY_MAC(hw);
 	else
-		*i2cctl &= ~IXGBE_I2C_DATA_OUT(hw);
+		*i2cctl &= ~(IXGBE_I2C_DATA_OUT_BY_MAC(hw));
 	*i2cctl &= ~data_oe_bit;
 
-	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+	IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 	IXGBE_WRITE_FLUSH(hw);
 
 	/* Data rise/fall (1000ns/300ns) and set-up time (250ns) */
-	udelay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);
+	usec_delay(IXGBE_I2C_T_RISE + IXGBE_I2C_T_FALL + IXGBE_I2C_T_SU_DATA);
 
 	if (!data)	/* Can't verify data in this case */
-		return 0;
+		return IXGBE_SUCCESS;
 	if (data_oe_bit) {
 		*i2cctl |= data_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
 	}
 
 	/* Verify data was set correctly */
-	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	*i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 	if (data != ixgbe_get_i2c_data(hw, i2cctl)) {
-		hw_dbg(hw, "Error - I2C data was not set to %X.\n", data);
-		return IXGBE_ERR_I2C;
+		status = IXGBE_ERR_I2C;
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			     "Error - I2C data was not set to %X.\n",
+			     data);
 	}
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_get_i2c_data - Reads the I2C SDA data bit
- *  @hw: pointer to hardware structure
- *  @i2cctl: Current value of I2CCTL register
+ * ixgbe_get_i2c_data - Reads the I2C SDA data bit
+ * @hw: pointer to hardware structure
+ * @i2cctl: Current value of I2CCTL register
  *
- *  Returns the I2C data bit value
- *  Negates the I2C data output enable on X550 hardware.
+ * Returns the I2C data bit value
+ * Negates the I2C data output enable on X550 hardware.
  **/
-static bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)
+STATIC bool ixgbe_get_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl)
 {
-	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN(hw);
+	u32 data_oe_bit = IXGBE_I2C_DATA_OE_N_EN_BY_MAC(hw);
+	bool data;
+
+	DEBUGFUNC("ixgbe_get_i2c_data");
 
 	if (data_oe_bit) {
 		*i2cctl |= data_oe_bit;
-		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL(hw), *i2cctl);
+		IXGBE_WRITE_REG(hw, IXGBE_I2CCTL_BY_MAC(hw), *i2cctl);
 		IXGBE_WRITE_FLUSH(hw);
-		udelay(IXGBE_I2C_T_FALL);
+		usec_delay(IXGBE_I2C_T_FALL);
 	}
 
-	if (*i2cctl & IXGBE_I2C_DATA_IN(hw))
-		return true;
-	return false;
+	if (*i2cctl & IXGBE_I2C_DATA_IN_BY_MAC(hw))
+		data = 1;
+	else
+		data = 0;
+
+	return data;
 }
 
 /**
- *  ixgbe_i2c_bus_clear - Clears the I2C bus
- *  @hw: pointer to hardware structure
+ * ixgbe_i2c_bus_clear - Clears the I2C bus
+ * @hw: pointer to hardware structure
  *
- *  Clears the I2C bus by sending nine clock pulses.
- *  Used when data line is stuck low.
+ * Clears the I2C bus by sending nine clock pulses.
+ * Used when data line is stuck low.
  **/
-static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
+void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
 {
 	u32 i2cctl;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_i2c_bus_clear");
+
 	ixgbe_i2c_start(hw);
-	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL(hw));
+	i2cctl = IXGBE_READ_REG(hw, IXGBE_I2CCTL_BY_MAC(hw));
 
 	ixgbe_set_i2c_data(hw, &i2cctl, 1);
 
@@ -2594,12 +2583,12 @@ static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
 		ixgbe_raise_i2c_clk(hw, &i2cctl);
 
 		/* Min high period of clock is 4us */
-		udelay(IXGBE_I2C_T_HIGH);
+		usec_delay(IXGBE_I2C_T_HIGH);
 
 		ixgbe_lower_i2c_clk(hw, &i2cctl);
 
 		/* Min low period of clock is 4.7us*/
-		udelay(IXGBE_I2C_T_LOW);
+		usec_delay(IXGBE_I2C_T_LOW);
 	}
 
 	ixgbe_i2c_start(hw);
@@ -2609,45 +2598,50 @@ static void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_tn_check_overtemp - Checks if an overtemp occurred.
- *  @hw: pointer to hardware structure
+ * ixgbe_tn_check_overtemp - Checks if an overtemp occurred.
+ * @hw: pointer to hardware structure
  *
- *  Checks if the LASI temp alarm status was triggered due to overtemp
+ * Checks if the LASI temp alarm status was triggered due to overtemp
  **/
 s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u16 phy_data = 0;
 
+	DEBUGFUNC("ixgbe_tn_check_overtemp");
+
 	if (hw->device_id != IXGBE_DEV_ID_82599_T3_LOM)
-		return 0;
+		goto out;
 
 	/* Check that the LASI temp alarm status was triggered */
 	hw->phy.ops.read_reg(hw, IXGBE_TN_LASI_STATUS_REG,
-			     MDIO_MMD_PMAPMD, &phy_data);
+			     IXGBE_MDIO_PMA_PMD_DEV_TYPE, &phy_data);
 
 	if (!(phy_data & IXGBE_TN_LASI_STATUS_TEMP_ALARM))
-		return 0;
+		goto out;
 
-	return IXGBE_ERR_OVERTEMP;
+	status = IXGBE_ERR_OVERTEMP;
+	ERROR_REPORT1(IXGBE_ERROR_CAUTION, "Device over temperature");
+out:
+	return status;
 }
 
-/** ixgbe_set_copper_phy_power - Control power for copper phy
- *  @hw: pointer to hardware structure
- *  @on: true for on, false for off
- **/
+/**
+ * ixgbe_set_copper_phy_power - Control power for copper phy
+ * @hw: pointer to hardware structure
+ * @on: true for on, false for off
+ */
 s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)
 {
 	u32 status;
 	u16 reg;
 
-	/* Bail if we don't have copper phy */
-	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
-		return 0;
-
 	if (!on && ixgbe_mng_present(hw))
 		return 0;
 
-	status = hw->phy.ops.read_reg(hw, MDIO_CTRL1, MDIO_MMD_VEND1, &reg);
+	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				      &reg);
 	if (status)
 		return status;
 
@@ -2659,6 +2653,8 @@ s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on)
 		reg |= IXGBE_MDIO_PHY_SET_LOW_POWER_MODE;
 	}
 
-	status = hw->phy.ops.write_reg(hw, MDIO_CTRL1, MDIO_MMD_VEND1, reg);
+	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL,
+				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+				       reg);
 	return status;
 }
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
index 6544c4539c0d..acad0c740fda 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_phy.h
@@ -1,12 +1,13 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_PHY_H_
 #define _IXGBE_PHY_H_
 
 #include "ixgbe_type.h"
-#define IXGBE_I2C_EEPROM_DEV_ADDR    0xA0
-#define IXGBE_I2C_EEPROM_DEV_ADDR2   0xA2
+#define IXGBE_I2C_EEPROM_DEV_ADDR	0xA0
+#define IXGBE_I2C_EEPROM_DEV_ADDR2	0xA2
+#define IXGBE_I2C_EEPROM_BANK_LEN	0xFF
 
 /* EEPROM byte offsets */
 #define IXGBE_SFF_IDENTIFIER		0x0
@@ -33,106 +34,112 @@
 #define IXGBE_SFF_QSFP_DEVICE_TECH	0x93
 
 /* Bitmasks */
-#define IXGBE_SFF_DA_PASSIVE_CABLE		0x4
-#define IXGBE_SFF_DA_ACTIVE_CABLE		0x8
+#define IXGBE_SFF_DA_PASSIVE_CABLE	0x4
+#define IXGBE_SFF_DA_ACTIVE_CABLE	0x8
 #define IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING	0x4
-#define IXGBE_SFF_1GBASESX_CAPABLE		0x1
-#define IXGBE_SFF_1GBASELX_CAPABLE		0x2
-#define IXGBE_SFF_1GBASET_CAPABLE		0x8
-#define IXGBE_SFF_10GBASESR_CAPABLE		0x10
-#define IXGBE_SFF_10GBASELR_CAPABLE		0x20
-#define IXGBE_SFF_SOFT_RS_SELECT_MASK		0x8
-#define IXGBE_SFF_SOFT_RS_SELECT_10G		0x8
-#define IXGBE_SFF_SOFT_RS_SELECT_1G		0x0
-#define IXGBE_SFF_ADDRESSING_MODE		0x4
-#define IXGBE_SFF_DDM_IMPLEMENTED		0x40
-#define IXGBE_SFF_QSFP_DA_ACTIVE_CABLE		0x1
-#define IXGBE_SFF_QSFP_DA_PASSIVE_CABLE		0x8
+#define IXGBE_SFF_1GBASESX_CAPABLE	0x1
+#define IXGBE_SFF_1GBASELX_CAPABLE	0x2
+#define IXGBE_SFF_1GBASET_CAPABLE	0x8
+#define IXGBE_SFF_10GBASESR_CAPABLE	0x10
+#define IXGBE_SFF_10GBASELR_CAPABLE	0x20
+#define IXGBE_SFF_SOFT_RS_SELECT_MASK	0x8
+#define IXGBE_SFF_SOFT_RS_SELECT_10G	0x8
+#define IXGBE_SFF_SOFT_RS_SELECT_1G	0x0
+#define IXGBE_SFF_ADDRESSING_MODE	0x4
+#define IXGBE_SFF_QSFP_DA_ACTIVE_CABLE	0x1
+#define IXGBE_SFF_QSFP_DA_PASSIVE_CABLE	0x8
 #define IXGBE_SFF_QSFP_CONNECTOR_NOT_SEPARABLE	0x23
 #define IXGBE_SFF_QSFP_TRANSMITER_850NM_VCSEL	0x0
-#define IXGBE_I2C_EEPROM_READ_MASK		0x100
-#define IXGBE_I2C_EEPROM_STATUS_MASK		0x3
+#define IXGBE_I2C_EEPROM_READ_MASK	0x100
+#define IXGBE_I2C_EEPROM_STATUS_MASK	0x3
 #define IXGBE_I2C_EEPROM_STATUS_NO_OPERATION	0x0
-#define IXGBE_I2C_EEPROM_STATUS_PASS		0x1
-#define IXGBE_I2C_EEPROM_STATUS_FAIL		0x2
+#define IXGBE_I2C_EEPROM_STATUS_PASS	0x1
+#define IXGBE_I2C_EEPROM_STATUS_FAIL	0x2
 #define IXGBE_I2C_EEPROM_STATUS_IN_PROGRESS	0x3
-#define IXGBE_CS4227				0xBE    /* CS4227 address */
-#define IXGBE_CS4227_GLOBAL_ID_LSB		0
-#define IXGBE_CS4227_GLOBAL_ID_MSB		1
-#define IXGBE_CS4227_SCRATCH			2
-#define IXGBE_CS4227_EFUSE_PDF_SKU		0x19F
-#define IXGBE_CS4223_SKU_ID			0x0010  /* Quad port */
-#define IXGBE_CS4227_SKU_ID			0x0014  /* Dual port */
-#define IXGBE_CS4227_RESET_PENDING		0x1357
-#define IXGBE_CS4227_RESET_COMPLETE		0x5AA5
-#define IXGBE_CS4227_RETRIES			15
-#define IXGBE_CS4227_EFUSE_STATUS		0x0181
-#define IXGBE_CS4227_LINE_SPARE22_MSB		0x12AD	/* Reg to set speed */
-#define IXGBE_CS4227_LINE_SPARE24_LSB		0x12B0	/* Reg to set EDC */
-#define IXGBE_CS4227_HOST_SPARE22_MSB		0x1AAD	/* Reg to set speed */
-#define IXGBE_CS4227_HOST_SPARE24_LSB		0x1AB0	/* Reg to program EDC */
-#define IXGBE_CS4227_EEPROM_STATUS		0x5001
-#define IXGBE_CS4227_EEPROM_LOAD_OK		0x0001
-#define IXGBE_CS4227_SPEED_1G			0x8000
-#define IXGBE_CS4227_SPEED_10G			0
-#define IXGBE_CS4227_EDC_MODE_CX1		0x0002
-#define IXGBE_CS4227_EDC_MODE_SR		0x0004
-#define IXGBE_CS4227_EDC_MODE_DIAG		0x0008
-#define IXGBE_CS4227_RESET_HOLD			500	/* microseconds */
-#define IXGBE_CS4227_RESET_DELAY		500	/* milliseconds */
-#define IXGBE_CS4227_CHECK_DELAY		30	/* milliseconds */
-#define IXGBE_PE				0xE0	/* Port expander addr */
-#define IXGBE_PE_OUTPUT				1	/* Output reg offset */
-#define IXGBE_PE_CONFIG				3	/* Config reg offset */
-#define IXGBE_PE_BIT1				BIT(1)
+
+#define IXGBE_CS4227			0xBE	/* CS4227 address */
+#define IXGBE_CS4227_GLOBAL_ID_LSB	0
+#define IXGBE_CS4227_GLOBAL_ID_MSB	1
+#define IXGBE_CS4227_SCRATCH		2
+#define IXGBE_CS4227_GLOBAL_ID_VALUE	0x03E5
+#define IXGBE_CS4227_EFUSE_PDF_SKU	0x19F
+#define IXGBE_CS4223_SKU_ID		0x0010	/* Quad port */
+#define IXGBE_CS4227_SKU_ID		0x0014	/* Dual port */
+#define IXGBE_CS4227_RESET_PENDING	0x1357
+#define IXGBE_CS4227_RESET_COMPLETE	0x5AA5
+#define IXGBE_CS4227_RETRIES		15
+#define IXGBE_CS4227_EFUSE_STATUS	0x0181
+#define IXGBE_CS4227_LINE_SPARE22_MSB	0x12AD	/* Reg to program speed */
+#define IXGBE_CS4227_LINE_SPARE24_LSB	0x12B0	/* Reg to program EDC */
+#define IXGBE_CS4227_HOST_SPARE22_MSB	0x1AAD	/* Reg to program speed */
+#define IXGBE_CS4227_HOST_SPARE24_LSB	0x1AB0	/* Reg to program EDC */
+#define IXGBE_CS4227_EEPROM_STATUS	0x5001
+#define IXGBE_CS4227_EEPROM_LOAD_OK	0x0001
+#define IXGBE_CS4227_SPEED_1G		0x8000
+#define IXGBE_CS4227_SPEED_10G		0
+#define IXGBE_CS4227_EDC_MODE_CX1	0x0002
+#define IXGBE_CS4227_EDC_MODE_SR	0x0004
+#define IXGBE_CS4227_EDC_MODE_DIAG	0x0008
+#define IXGBE_CS4227_RESET_HOLD		500	/* microseconds */
+#define IXGBE_CS4227_RESET_DELAY	450	/* milliseconds */
+#define IXGBE_CS4227_CHECK_DELAY	30	/* milliseconds */
+#define IXGBE_PE			0xE0	/* Port expander address */
+#define IXGBE_PE_OUTPUT			1	/* Output register offset */
+#define IXGBE_PE_CONFIG			3	/* Config register offset */
+#define IXGBE_PE_BIT1			(1 << 1)
 
 /* Flow control defines */
-#define IXGBE_TAF_SYM_PAUSE                  0x400
-#define IXGBE_TAF_ASM_PAUSE                  0x800
+#define IXGBE_TAF_SYM_PAUSE		0x400
+#define IXGBE_TAF_ASM_PAUSE		0x800
 
 /* Bit-shift macros */
-#define IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT    24
-#define IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT    16
-#define IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT    8
+#define IXGBE_SFF_VENDOR_OUI_BYTE0_SHIFT	24
+#define IXGBE_SFF_VENDOR_OUI_BYTE1_SHIFT	16
+#define IXGBE_SFF_VENDOR_OUI_BYTE2_SHIFT	8
 
 /* Vendor OUIs: format of OUI is 0x[byte0][byte1][byte2][00] */
-#define IXGBE_SFF_VENDOR_OUI_TYCO     0x00407600
-#define IXGBE_SFF_VENDOR_OUI_FTL      0x00906500
-#define IXGBE_SFF_VENDOR_OUI_AVAGO    0x00176A00
-#define IXGBE_SFF_VENDOR_OUI_INTEL    0x001B2100
+#define IXGBE_SFF_VENDOR_OUI_TYCO	0x00407600
+#define IXGBE_SFF_VENDOR_OUI_FTL	0x00906500
+#define IXGBE_SFF_VENDOR_OUI_AVAGO	0x00176A00
+#define IXGBE_SFF_VENDOR_OUI_INTEL	0x001B2100
 
 /* I2C SDA and SCL timing parameters for standard mode */
-#define IXGBE_I2C_T_HD_STA  4
-#define IXGBE_I2C_T_LOW     5
-#define IXGBE_I2C_T_HIGH    4
-#define IXGBE_I2C_T_SU_STA  5
-#define IXGBE_I2C_T_HD_DATA 5
-#define IXGBE_I2C_T_SU_DATA 1
-#define IXGBE_I2C_T_RISE    1
-#define IXGBE_I2C_T_FALL    1
-#define IXGBE_I2C_T_SU_STO  4
-#define IXGBE_I2C_T_BUF     5
-
-#define IXGBE_SFP_DETECT_RETRIES	2
+#define IXGBE_I2C_T_HD_STA	4
+#define IXGBE_I2C_T_LOW		5
+#define IXGBE_I2C_T_HIGH	4
+#define IXGBE_I2C_T_SU_STA	5
+#define IXGBE_I2C_T_HD_DATA	5
+#define IXGBE_I2C_T_SU_DATA	1
+#define IXGBE_I2C_T_RISE	1
+#define IXGBE_I2C_T_FALL	1
+#define IXGBE_I2C_T_SU_STO	4
+#define IXGBE_I2C_T_BUF		5
 
-#define IXGBE_TN_LASI_STATUS_REG        0x9005
-#define IXGBE_TN_LASI_STATUS_TEMP_ALARM 0x0008
+#ifndef IXGBE_SFP_DETECT_RETRIES
+#define IXGBE_SFP_DETECT_RETRIES	10
 
-/* SFP+ SFF-8472 Compliance code */
-#define IXGBE_SFF_SFF_8472_UNSUP      0x00
+#endif /* IXGBE_SFP_DETECT_RETRIES */
+#define IXGBE_TN_LASI_STATUS_REG	0x9005
+#define IXGBE_TN_LASI_STATUS_TEMP_ALARM	0x0008
 
-s32 ixgbe_mii_bus_init(struct ixgbe_hw *hw);
+/* SFP+ SFF-8472 Compliance */
+#define IXGBE_SFF_SFF_8472_UNSUP	0x00
 
+s32 ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw);
+bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, u32 phy_addr);
+enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);
+s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);
 s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw);
 s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw);
+void ixgbe_restart_auto_neg(struct ixgbe_hw *hw);
+s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+			   u16 *phy_data);
+s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
+			    u16 phy_data);
 s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 			       u32 device_type, u16 *phy_data);
 s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
 				u32 device_type, u16 phy_data);
-s32 ixgbe_read_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
-			   u32 device_type, u16 *phy_data);
-s32 ixgbe_write_phy_reg_mdi(struct ixgbe_hw *hw, u32 reg_addr,
-			    u32 device_type, u16 phy_data);
 s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw);
 s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
 				       ixgbe_link_speed speed,
@@ -140,18 +147,24 @@ s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
 s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
 					       ixgbe_link_speed *speed,
 					       bool *autoneg);
-bool ixgbe_check_reset_blocked(struct ixgbe_hw *hw);
+s32 ixgbe_check_reset_blocked(struct ixgbe_hw *hw);
 
 /* PHY specific */
 s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw,
 			     ixgbe_link_speed *speed,
 			     bool *link_up);
 s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw);
+s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
+				       u16 *firmware_version);
+s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
+					   u16 *firmware_version);
 
 s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
 s32 ixgbe_set_copper_phy_power(struct ixgbe_hw *hw, bool on);
 s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw);
 s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw);
+u64 ixgbe_get_supported_phy_sfp_layer_generic(struct ixgbe_hw *hw);
+s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
 s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
 					u16 *list_offset,
 					u16 *data_offset);
@@ -166,10 +179,9 @@ s32 ixgbe_write_i2c_byte_generic_unlocked(struct ixgbe_hw *hw, u8 byte_offset,
 					  u8 dev_addr, u8 data);
 s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				  u8 *eeprom_data);
-s32 ixgbe_read_i2c_sff8472_generic(struct ixgbe_hw *hw, u8 byte_offset,
-				   u8 *sff8472_data);
 s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
 				   u8 eeprom_data);
+void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw);
 s32 ixgbe_read_i2c_combined_generic_int(struct ixgbe_hw *, u8 addr, u16 reg,
 					u16 *val, bool lock);
 s32 ixgbe_write_i2c_combined_generic_int(struct ixgbe_hw *, u8 addr, u16 reg,
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_procfs.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_procfs.c
new file mode 100644
index 000000000000..31bf98e7a40f
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_procfs.c
@@ -0,0 +1,917 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#include "ixgbe.h"
+#include "ixgbe_common.h"
+#include "ixgbe_type.h"
+
+#ifdef IXGBE_PROCFS
+#ifndef IXGBE_SYSFS
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+#include <linux/device.h>
+#include <linux/netdevice.h>
+
+static struct proc_dir_entry *ixgbe_top_dir = NULL;
+
+static struct net_device_stats *procfs_get_stats(struct net_device *netdev)
+{
+#ifndef HAVE_NETDEV_STATS_IN_NETDEV
+	struct ixgbe_adapter *adapter;
+#endif
+	if (netdev == NULL)
+		return NULL;
+
+#ifdef HAVE_NETDEV_STATS_IN_NETDEV
+	/* only return the current stats */
+	return &netdev->stats;
+#else
+	adapter = netdev_priv(netdev);
+
+	/* only return the current stats */
+	return &adapter->net_stats;
+#endif /* HAVE_NETDEV_STATS_IN_NETDEV */
+}
+
+bool ixgbe_thermal_present(struct ixgbe_adapter *adapter)
+{
+	s32 status;
+	if (adapter == NULL)
+		return false;
+	status = ixgbe_init_thermal_sensor_thresh_generic(&(adapter->hw));
+	if (status != IXGBE_SUCCESS)
+		return false;
+
+	return true;
+}
+
+static int ixgbe_fwbanner(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%s\n", adapter->eeprom_id);
+}
+
+static int ixgbe_porttype(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	return snprintf(page, count, "%d\n",
+			test_bit(__IXGBE_DOWN, &adapter->state));
+}
+
+static int ixgbe_portspeed(char *page, char __always_unused **start,
+			   off_t __always_unused off, int count,
+			   int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	int speed = 0;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	switch (adapter->link_speed) {
+	case IXGBE_LINK_SPEED_100_FULL:
+		speed = 1;
+		break;
+	case IXGBE_LINK_SPEED_1GB_FULL:
+		speed = 10;
+		break;
+	case IXGBE_LINK_SPEED_10GB_FULL:
+		speed = 100;
+		break;
+	}
+	return snprintf(page, count, "%d\n", speed);
+}
+
+static int ixgbe_wqlflag(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%d\n", adapter->wol);
+}
+
+static int ixgbe_xflowctl(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct ixgbe_hw *hw;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", hw->fc.current_mode);
+}
+
+static int ixgbe_rxdrops(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->rx_dropped);
+}
+
+static int ixgbe_rxerrors(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n", net_stats->rx_errors);
+}
+
+static int ixgbe_rxupacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_TPR));
+}
+
+static int ixgbe_rxmpacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_MPRC));
+}
+
+static int ixgbe_rxbpacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_BPRC));
+}
+
+static int ixgbe_txupacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_TPT));
+}
+
+static int ixgbe_txmpacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_MPTC));
+}
+
+static int ixgbe_txbpacks(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "%d\n", IXGBE_READ_REG(hw, IXGBE_BPTC));
+}
+
+static int ixgbe_txerrors(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->tx_errors);
+}
+
+static int ixgbe_txdrops(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->tx_dropped);
+}
+
+static int ixgbe_rxframes(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->rx_packets);
+}
+
+static int ixgbe_rxbytes(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->rx_bytes);
+}
+
+static int ixgbe_txframes(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->tx_packets);
+}
+
+static int ixgbe_txbytes(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device_stats *net_stats;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	net_stats  = procfs_get_stats(adapter->netdev);
+	if (net_stats == NULL)
+		return snprintf(page, count, "error: no net stats\n");
+
+	return snprintf(page, count, "%lu\n",
+			net_stats->tx_bytes);
+}
+
+static int ixgbe_linkstat(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	int bitmask = 0;
+	u32 link_speed;
+	bool link_up = false;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	if (!test_bit(__IXGBE_DOWN, &adapter->state))
+		bitmask |= 1;
+
+	if (hw->mac.ops.check_link)
+		hw->mac.ops.check_link(hw, &link_speed, &link_up, false);
+	else
+		/* always assume link is up, if no check link function */
+		link_up = true;
+	if (link_up)
+		bitmask |= 2;
+
+	if (adapter->old_lsc != adapter->lsc_int) {
+		bitmask |= 4;
+		adapter->old_lsc = adapter->lsc_int;
+	}
+
+	return snprintf(page, count, "0x%X\n", bitmask);
+}
+
+static int ixgbe_funcid(char *page, char __always_unused **start,
+			off_t __always_unused off, int count,
+			int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct ixgbe_hw *hw;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "0x%X\n", hw->bus.func);
+}
+
+static int ixgbe_funcvers(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void __always_unused *data)
+{
+	return snprintf(page, count, "%s\n", ixgbe_driver_version);
+}
+
+static int ixgbe_macburn(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "0x%02X%02X%02X%02X%02X%02X\n",
+		       (unsigned int)hw->mac.perm_addr[0],
+		       (unsigned int)hw->mac.perm_addr[1],
+		       (unsigned int)hw->mac.perm_addr[2],
+		       (unsigned int)hw->mac.perm_addr[3],
+		       (unsigned int)hw->mac.perm_addr[4],
+		       (unsigned int)hw->mac.perm_addr[5]);
+}
+
+static int ixgbe_macadmn(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_hw *hw;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	return snprintf(page, count, "0x%02X%02X%02X%02X%02X%02X\n",
+		       (unsigned int)hw->mac.addr[0],
+		       (unsigned int)hw->mac.addr[1],
+		       (unsigned int)hw->mac.addr[2],
+		       (unsigned int)hw->mac.addr[3],
+		       (unsigned int)hw->mac.addr[4],
+		       (unsigned int)hw->mac.addr[5]);
+}
+
+static int ixgbe_maclla1(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct ixgbe_hw *hw;
+	int rc;
+	u16 eeprom_buff[6];
+	u16 first_word = 0x37;
+	const u16 word_count = ARRAY_SIZE(eeprom_buff);
+
+	if (!adapter)
+		return snprintf(page, count, "error: no adapter\n");
+
+	hw = &adapter->hw;
+
+	rc = hw->eeprom.ops.read_buffer(hw, first_word, 1, &first_word);
+	if (rc != 0)
+		return snprintf(page, count, "error: reading pointer to the EEPROM\n");
+
+	if (first_word != 0x0000 && first_word != 0xFFFF) {
+		rc = hw->eeprom.ops.read_buffer(hw, first_word, word_count,
+					eeprom_buff);
+		if (rc != 0)
+			return snprintf(page, count, "error: reading buffer\n");
+	} else {
+		memset(eeprom_buff, 0, sizeof(eeprom_buff));
+	}
+
+	switch (hw->bus.func) {
+	case 0:
+		return snprintf(page, count, "0x%04X%04X%04X\n",
+				eeprom_buff[0],
+				eeprom_buff[1],
+				eeprom_buff[2]);
+	case 1:
+		return snprintf(page, count, "0x%04X%04X%04X\n",
+				eeprom_buff[3],
+				eeprom_buff[4],
+				eeprom_buff[5]);
+	}
+	return snprintf(page, count, "unexpected port %d\n", hw->bus.func);
+}
+
+static int ixgbe_mtusize(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device *netdev;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	netdev = adapter->netdev;
+	if (netdev == NULL)
+		return snprintf(page, count, "error: no net device\n");
+
+	return snprintf(page, count, "%d\n", netdev->mtu);
+}
+
+static int ixgbe_featflag(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	int bitmask = 0;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device *netdev;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	netdev = adapter->netdev;
+	if (netdev == NULL)
+		return snprintf(page, count, "error: no net device\n");
+	if (adapter->netdev->features & NETIF_F_RXCSUM)
+		bitmask |= 1;
+	return snprintf(page, count, "%d\n", bitmask);
+}
+
+static int ixgbe_lsominct(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void __always_unused *data)
+{
+	return snprintf(page, count, "%d\n", 1);
+}
+
+static int ixgbe_prommode(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	struct net_device *netdev;
+
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+	netdev = adapter->netdev;
+	if (netdev == NULL)
+		return snprintf(page, count, "error: no net device\n");
+
+	return snprintf(page, count, "%d\n",
+			netdev->flags & IFF_PROMISC);
+}
+
+static int ixgbe_txdscqsz(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%d\n", adapter->tx_ring[0]->count);
+}
+
+static int ixgbe_rxdscqsz(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%d\n", adapter->rx_ring[0]->count);
+}
+
+static int ixgbe_rxqavg(char *page, char __always_unused **start,
+			off_t __always_unused off, int count,
+			int __always_unused *eof, void *data)
+{
+	int index;
+	int diff = 0;
+	u16 ntc;
+	u16 ntu;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	for (index = 0; index < adapter->num_rx_queues; index++) {
+		ntc = adapter->rx_ring[index]->next_to_clean;
+		ntu = adapter->rx_ring[index]->next_to_use;
+
+		if (ntc >= ntu)
+			diff += (ntc - ntu);
+		else
+			diff += (adapter->rx_ring[index]->count - ntu + ntc);
+	}
+	if (adapter->num_rx_queues <= 0)
+		return snprintf(page, count,
+				"can't calculate, number of queues %d\n",
+				adapter->num_rx_queues);
+	return snprintf(page, count, "%d\n", diff/adapter->num_rx_queues);
+}
+
+static int ixgbe_txqavg(char *page, char __always_unused **start,
+			off_t __always_unused off, int count,
+			int __always_unused *eof, void *data)
+{
+	int index;
+	int diff = 0;
+	u16 ntc;
+	u16 ntu;
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	for (index = 0; index < adapter->num_tx_queues; index++) {
+		ntc = adapter->tx_ring[index]->next_to_clean;
+		ntu = adapter->tx_ring[index]->next_to_use;
+
+		if (ntc >= ntu)
+			diff += (ntc - ntu);
+		else
+			diff += (adapter->tx_ring[index]->count - ntu + ntc);
+	}
+	if (adapter->num_tx_queues <= 0)
+		return snprintf(page, count,
+				"can't calculate, number of queues %d\n",
+				adapter->num_tx_queues);
+	return snprintf(page, count, "%d\n",
+			diff/adapter->num_tx_queues);
+}
+
+static int ixgbe_iovotype(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void __always_unused *data)
+{
+	return snprintf(page, count, "2\n");
+}
+
+static int ixgbe_funcnbr(char *page, char __always_unused **start,
+			 off_t __always_unused off, int count,
+			 int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%d\n", adapter->num_vfs);
+}
+
+static int ixgbe_pciebnbr(char *page, char __always_unused **start,
+			  off_t __always_unused off, int count,
+			  int __always_unused *eof, void *data)
+{
+	struct ixgbe_adapter *adapter = (struct ixgbe_adapter *)data;
+	if (adapter == NULL)
+		return snprintf(page, count, "error: no adapter\n");
+
+	return snprintf(page, count, "%d\n", adapter->pdev->bus->number);
+}
+
+static int ixgbe_therm_location(char *page, char __always_unused **start,
+				off_t __always_unused off, int count,
+				int __always_unused *eof, void *data)
+{
+	struct ixgbe_therm_proc_data *therm_data =
+		(struct ixgbe_therm_proc_data *)data;
+
+	if (therm_data == NULL)
+		return snprintf(page, count, "error: no therm_data\n");
+
+	return snprintf(page, count, "%d\n", therm_data->sensor_data->location);
+}
+
+
+static int ixgbe_therm_maxopthresh(char *page, char __always_unused **start,
+				   off_t __always_unused off, int count,
+				   int __always_unused *eof, void *data)
+{
+	struct ixgbe_therm_proc_data *therm_data =
+		(struct ixgbe_therm_proc_data *)data;
+
+	if (therm_data == NULL)
+		return snprintf(page, count, "error: no therm_data\n");
+
+	return snprintf(page, count, "%d\n",
+			therm_data->sensor_data->max_op_thresh);
+}
+
+
+static int ixgbe_therm_cautionthresh(char *page, char __always_unused **start,
+				     off_t __always_unused off, int count,
+				     int __always_unused *eof, void *data)
+{
+	struct ixgbe_therm_proc_data *therm_data =
+		(struct ixgbe_therm_proc_data *)data;
+
+	if (therm_data == NULL)
+		return snprintf(page, count, "error: no therm_data\n");
+
+	return snprintf(page, count, "%d\n",
+			therm_data->sensor_data->caution_thresh);
+}
+
+static int ixgbe_therm_temp(char *page, char __always_unused **start,
+			    off_t __always_unused off, int count,
+			    int __always_unused *eof, void *data)
+{
+	s32 status;
+	struct ixgbe_therm_proc_data *therm_data =
+		(struct ixgbe_therm_proc_data *)data;
+
+	if (therm_data == NULL)
+		return snprintf(page, count, "error: no therm_data\n");
+
+	status = ixgbe_get_thermal_sensor_data_generic(therm_data->hw);
+	if (status != IXGBE_SUCCESS)
+		snprintf(page, count, "error: status %d returned\n", status);
+
+	return snprintf(page, count, "%d\n", therm_data->sensor_data->temp);
+}
+
+
+struct ixgbe_proc_type {
+	char name[32];
+	int (*read)(char*, char**, off_t, int, int*, void*);
+};
+
+struct ixgbe_proc_type ixgbe_proc_entries[] = {
+	{"fwbanner", &ixgbe_fwbanner},
+	{"porttype", &ixgbe_porttype},
+	{"portspeed", &ixgbe_portspeed},
+	{"wqlflag", &ixgbe_wqlflag},
+	{"xflowctl", &ixgbe_xflowctl},
+	{"rxdrops", &ixgbe_rxdrops},
+	{"rxerrors", &ixgbe_rxerrors},
+	{"rxupacks", &ixgbe_rxupacks},
+	{"rxmpacks", &ixgbe_rxmpacks},
+	{"rxbpacks", &ixgbe_rxbpacks},
+	{"txdrops", &ixgbe_txdrops},
+	{"txerrors", &ixgbe_txerrors},
+	{"txupacks", &ixgbe_txupacks},
+	{"txmpacks", &ixgbe_txmpacks},
+	{"txbpacks", &ixgbe_txbpacks},
+	{"rxframes", &ixgbe_rxframes},
+	{"rxbytes", &ixgbe_rxbytes},
+	{"txframes", &ixgbe_txframes},
+	{"txbytes", &ixgbe_txbytes},
+	{"linkstat", &ixgbe_linkstat},
+	{"funcid", &ixgbe_funcid},
+	{"funcvers", &ixgbe_funcvers},
+	{"macburn", &ixgbe_macburn},
+	{"macadmn", &ixgbe_macadmn},
+	{"maclla1", &ixgbe_maclla1},
+	{"mtusize", &ixgbe_mtusize},
+	{"featflag", &ixgbe_featflag},
+	{"lsominct", &ixgbe_lsominct},
+	{"prommode", &ixgbe_prommode},
+	{"txdscqsz", &ixgbe_txdscqsz},
+	{"rxdscqsz", &ixgbe_rxdscqsz},
+	{"txqavg", &ixgbe_txqavg},
+	{"rxqavg", &ixgbe_rxqavg},
+	{"iovotype", &ixgbe_iovotype},
+	{"funcnbr", &ixgbe_funcnbr},
+	{"pciebnbr", &ixgbe_pciebnbr},
+	{"", NULL}
+};
+
+struct ixgbe_proc_type ixgbe_internal_entries[] = {
+	{"location", &ixgbe_therm_location},
+	{"temp", &ixgbe_therm_temp},
+	{"cautionthresh", &ixgbe_therm_cautionthresh},
+	{"maxopthresh", &ixgbe_therm_maxopthresh},
+	{"", NULL}
+};
+
+void ixgbe_del_proc_entries(struct ixgbe_adapter *adapter)
+{
+	int index;
+	int i;
+	char buf[16];	/* much larger than the sensor number will ever be */
+
+	if (ixgbe_top_dir == NULL)
+		return;
+
+	for (i = 0; i < IXGBE_MAX_SENSORS; i++) {
+		if (adapter->therm_dir[i] == NULL)
+			continue;
+
+		for (index = 0; ; index++) {
+			if (ixgbe_internal_entries[index].read == NULL)
+				break;
+
+			 remove_proc_entry(ixgbe_internal_entries[index].name,
+					   adapter->therm_dir[i]);
+		}
+		snprintf(buf, sizeof(buf), "sensor_%d", i);
+		remove_proc_entry(buf, adapter->info_dir);
+	}
+
+	if (adapter->info_dir != NULL) {
+		for (index = 0; ; index++) {
+			if (ixgbe_proc_entries[index].read == NULL)
+				break;
+			remove_proc_entry(ixgbe_proc_entries[index].name,
+					  adapter->info_dir);
+		}
+		remove_proc_entry("info", adapter->eth_dir);
+	}
+
+	if (adapter->eth_dir != NULL)
+		remove_proc_entry(pci_name(adapter->pdev), ixgbe_top_dir);
+}
+
+/* called from ixgbe_main.c */
+void ixgbe_procfs_exit(struct ixgbe_adapter *adapter)
+{
+	ixgbe_del_proc_entries(adapter);
+}
+
+int ixgbe_procfs_topdir_init()
+{
+	ixgbe_top_dir = proc_mkdir("driver/ixgbe", NULL);
+	if (ixgbe_top_dir == NULL)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void ixgbe_procfs_topdir_exit()
+{
+	remove_proc_entry("driver/ixgbe", NULL);
+}
+
+/* called from ixgbe_main.c */
+int ixgbe_procfs_init(struct ixgbe_adapter *adapter)
+{
+	int rc = 0;
+	int index;
+	int i;
+	char buf[16];	/* much larger than the sensor number will ever be */
+
+	adapter->eth_dir = NULL;
+	adapter->info_dir = NULL;
+	for (i = 0; i < IXGBE_MAX_SENSORS; i++)
+		adapter->therm_dir[i] = NULL;
+
+	if (ixgbe_top_dir == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	adapter->eth_dir = proc_mkdir(pci_name(adapter->pdev), ixgbe_top_dir);
+	if (adapter->eth_dir == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+
+	adapter->info_dir = proc_mkdir("info", adapter->eth_dir);
+	if (adapter->info_dir == NULL) {
+		rc = -ENOMEM;
+		goto fail;
+	}
+	for (index = 0; ; index++) {
+		if (ixgbe_proc_entries[index].read == NULL)
+			break;
+		if (!(create_proc_read_entry(ixgbe_proc_entries[index].name,
+					   0444,
+					   adapter->info_dir,
+					   ixgbe_proc_entries[index].read,
+					   adapter))) {
+
+			rc = -ENOMEM;
+			goto fail;
+		}
+	}
+	if (ixgbe_thermal_present(adapter) == false)
+		goto exit;
+
+	for (i = 0; i < IXGBE_MAX_SENSORS; i++) {
+
+		if (adapter->hw.mac.thermal_sensor_data.sensor[i].location ==
+		    0)
+			continue;
+
+		snprintf(buf, sizeof(buf), "sensor_%d", i);
+		adapter->therm_dir[i] = proc_mkdir(buf, adapter->info_dir);
+		if (adapter->therm_dir[i] == NULL) {
+			rc = -ENOMEM;
+			goto fail;
+		}
+		for (index = 0; ; index++) {
+			if (ixgbe_internal_entries[index].read == NULL)
+				break;
+			/*
+			 * therm_data struct contains pointer the read func
+			 * will be needing
+			 */
+			adapter->therm_data[i].hw = &adapter->hw;
+			adapter->therm_data[i].sensor_data =
+				&adapter->hw.mac.thermal_sensor_data.sensor[i];
+
+			if (!(create_proc_read_entry(
+					   ixgbe_internal_entries[index].name,
+					   0444,
+					   adapter->therm_dir[i],
+					   ixgbe_internal_entries[index].read,
+					   &adapter->therm_data[i]))) {
+				rc = -ENOMEM;
+				goto fail;
+			}
+		}
+	}
+	goto exit;
+
+fail:
+	ixgbe_del_proc_entries(adapter);
+exit:
+	return rc;
+}
+
+#endif /* !IXGBE_SYSFS */
+#endif /* IXGBE_PROCFS */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
index 22a874eee2e8..7b3a2dc89819 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_ptp.c
@@ -1,9 +1,8 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #include "ixgbe.h"
 #include <linux/ptp_classify.h>
-#include <linux/clocksource.h>
 
 /*
  * The 82599 and the X540 do not have true 64bit nanosecond scale
@@ -235,9 +234,9 @@ static void ixgbe_ptp_setup_sdp_X540(struct ixgbe_adapter *adapter)
  */
 static void ixgbe_ptp_setup_sdp_X550(struct ixgbe_adapter *adapter)
 {
-	u32 esdp, tsauxc, freqout, trgttiml, trgttimh, rem, tssdp;
 	struct cyclecounter *cc = &adapter->hw_cc;
 	struct ixgbe_hw *hw = &adapter->hw;
+	u32 esdp, tsauxc, freqout, trgttiml, trgttimh, rem, tssdp;
 	u64 ns = 0, clock_edge = 0;
 	struct timespec64 ts;
 	unsigned long flags;
@@ -272,7 +271,7 @@ static void ixgbe_ptp_setup_sdp_X550(struct ixgbe_adapter *adapter)
 	 * cycle counter shift is small enough to avoid overflowing a 32bit
 	 * value.
 	 */
-	freqout = div_u64(NS_PER_HALF_SEC << cc->shift,  cc->mult);
+	freqout = (NS_PER_HALF_SEC << cc->shift) / cc->mult;
 
 	/* Read the current clock time, and save the cycle counter value */
 	spin_lock_irqsave(&adapter->tmreg_lock, flags);
@@ -411,7 +410,7 @@ static void ixgbe_ptp_convert_to_hwtstamp(struct ixgbe_adapter *adapter,
 	 */
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		/* Upper 32 bits represent billions of cycles, lower 32 bits
 		 * represent cycles. However, we use timespec64_to_ns for the
 		 * correct math even though the units haven't been corrected
@@ -495,7 +494,7 @@ static int ixgbe_ptp_adjfreq_82599(struct ptp_clock_info *ptp, s32 ppb)
 static int ixgbe_ptp_adjfreq_X550(struct ptp_clock_info *ptp, s32 ppb)
 {
 	struct ixgbe_adapter *adapter =
-			container_of(ptp, struct ixgbe_adapter, ptp_caps);
+		container_of(ptp, struct ixgbe_adapter, ptp_caps);
 	struct ixgbe_hw *hw = &adapter->hw;
 	int neg_adj = 0;
 	u64 rate = IXGBE_X550_BASE_PERIOD;
@@ -568,7 +567,7 @@ static int ixgbe_ptp_gettimex(struct ptp_clock_info *ptp,
 	switch (adapter->hw.mac.type) {
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		/* Upper 32 bits represent billions of cycles, lower 32 bits
 		 * represent cycles. However, we use timespec64_to_ns for the
 		 * correct math even though the units haven't been corrected
@@ -598,6 +597,20 @@ static int ixgbe_ptp_gettimex(struct ptp_clock_info *ptp,
 	return 0;
 }
 
+/**
+ * ixgbe_ptp_gettime
+ * @ptp: the ptp clock structure
+ * @ts: timespec64 structure to hold the current time value
+ *
+ * read the timecounter and return the correct value on ns,
+ * after converting it into a struct timespec64.
+ */
+static int __maybe_unused ixgbe_ptp_gettime(struct ptp_clock_info *ptp,
+					    struct timespec64 *ts)
+{
+	return ixgbe_ptp_gettimex(ptp, ts, NULL);
+}
+
 /**
  * ixgbe_ptp_settime
  * @ptp: the ptp clock structure
@@ -624,6 +637,31 @@ static int ixgbe_ptp_settime(struct ptp_clock_info *ptp,
 	return 0;
 }
 
+#ifndef HAVE_PTP_CLOCK_INFO_GETTIME64
+static int ixgbe_ptp_gettime32(struct ptp_clock_info *ptp, struct timespec *ts)
+{
+	struct timespec64 ts64;
+	int err;
+
+	err = ixgbe_ptp_gettime(ptp, &ts64);
+	if (err)
+		return err;
+
+	*ts = timespec64_to_timespec(ts64);
+
+	return 0;
+}
+
+static int ixgbe_ptp_settime32(struct ptp_clock_info *ptp,
+			       const struct timespec *ts)
+{
+	struct timespec64 ts64;
+
+	ts64 = timespec_to_timespec64(*ts);
+	return ixgbe_ptp_settime(ptp, &ts64);
+}
+#endif
+
 /**
  * ixgbe_ptp_feature_enable
  * @ptp: the ptp clock structure
@@ -693,12 +731,14 @@ void ixgbe_ptp_check_pps_event(struct ixgbe_adapter *adapter)
  *
  * this watchdog task periodically reads the timecounter
  * in order to prevent missing when the system time registers wrap
- * around. This needs to be run approximately twice a minute.
+ * around. This needs to be run approximately twice a minute for the fastest
+ * overflowing hardware. We run it for all hardware since it shouldn't have a
+ * large impact.
  */
 void ixgbe_ptp_overflow_check(struct ixgbe_adapter *adapter)
 {
 	bool timeout = time_is_before_jiffies(adapter->last_overflow_check +
-					     IXGBE_OVERFLOW_PERIOD);
+					      IXGBE_OVERFLOW_PERIOD);
 	unsigned long flags;
 
 	if (timeout) {
@@ -745,7 +785,7 @@ void ixgbe_ptp_rx_hang(struct ixgbe_adapter *adapter)
 	}
 
 	/* only need to read the high RXSTMP register to clear the lock */
-	if (time_is_before_jiffies(rx_event + 5 * HZ)) {
+	if (time_is_before_jiffies(rx_event + 5*HZ)) {
 		IXGBE_READ_REG(hw, IXGBE_RXSTMPH);
 		adapter->last_rx_ptp_check = jiffies;
 
@@ -863,6 +903,7 @@ static void ixgbe_ptp_tx_hwtstamp_work(struct work_struct *work)
 		return;
 	}
 
+	/* check timeout last in case timestamp event just occurred */
 	if (timeout) {
 		ixgbe_ptp_clear_tx_timestamp(adapter);
 		adapter->tx_hwtstamp_timeouts++;
@@ -929,7 +970,6 @@ void ixgbe_ptp_rx_rgtstamp(struct ixgbe_q_vector *q_vector,
 	/* Read the tsyncrxctl register afterwards in order to prevent taking an
 	 * I/O hit on every packet.
 	 */
-
 	tsyncrxctl = IXGBE_READ_REG(hw, IXGBE_TSYNCRXCTL);
 	if (!(tsyncrxctl & IXGBE_TSYNCRXCTL_VALID))
 		return;
@@ -983,7 +1023,7 @@ int ixgbe_ptp_get_ts_config(struct ixgbe_adapter *adapter, struct ifreq *ifr)
  * mode, if required to support the specifically requested mode.
  */
 static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,
-				 struct hwtstamp_config *config)
+					struct hwtstamp_config *config)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 tsync_tx_ctl = IXGBE_TSYNCTXCTL_ENABLED;
@@ -1040,7 +1080,9 @@ static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,
 				   IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);
 		break;
 	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+#ifdef HAVE_HWTSTAMP_FILTER_NTP_ALL
 	case HWTSTAMP_FILTER_NTP_ALL:
+#endif /* HAVE_HWTSTAMP_FILTER_NTP_ALL */
 	case HWTSTAMP_FILTER_ALL:
 		/* The X550 controller is capable of timestamping all packets,
 		 * which allows it to accept any filter.
@@ -1051,13 +1093,12 @@ static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,
 			adapter->flags |= IXGBE_FLAG_RX_HWTSTAMP_ENABLED;
 			break;
 		}
-		fallthrough;
+		/* fall through */
 	default:
-		/*
-		 * register RXMTRL must be set in order to do V1 packets,
+		/* register RXMTRL must be set in order to do V1 packets,
 		 * therefore it is not possible to time stamp both V1 Sync and
-		 * Delay_Req messages and hardware does not support
-		 * timestamping all packets => return error
+		 * Delay_Req messages unless hardware supports timestamping all
+		 * packets => return error
 		 */
 		adapter->flags &= ~(IXGBE_FLAG_RX_HWTSTAMP_ENABLED |
 				    IXGBE_FLAG_RX_HWTSTAMP_IN_REGISTER);
@@ -1080,7 +1121,7 @@ static int ixgbe_ptp_set_timestamp_mode(struct ixgbe_adapter *adapter,
 	switch (hw->mac.type) {
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		/* enable timestamping all packets only if at least some
 		 * packets were requested. Otherwise, play nice and disable
 		 * timestamping
@@ -1242,8 +1283,8 @@ void ixgbe_ptp_start_cyclecounter(struct ixgbe_adapter *adapter)
 			cc.mult = 3;
 			cc.shift = 2;
 		}
-		fallthrough;
-	case ixgbe_mac_x550em_a:
+		/* fallthrough */
+	case ixgbe_mac_X550EM_a:
 	case ixgbe_mac_X550:
 		cc.read = ixgbe_ptp_read_X550;
 
@@ -1317,7 +1358,7 @@ void ixgbe_ptp_reset(struct ixgbe_adapter *adapter)
 
 	spin_lock_irqsave(&adapter->tmreg_lock, flags);
 	timecounter_init(&adapter->hw_tc, &adapter->hw_cc,
-			 ktime_to_ns(ktime_get_real()));
+			 ktime_get_real_ns());
 	spin_unlock_irqrestore(&adapter->tmreg_lock, flags);
 
 	adapter->last_overflow_check = jiffies;
@@ -1361,8 +1402,17 @@ static long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)
 		adapter->ptp_caps.pps = 1;
 		adapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_82599;
 		adapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;
+#ifdef HAVE_PTP_CLOCK_INFO_GETTIME64
+#ifdef HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL
 		adapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;
+#else
+		adapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;
+#endif /* HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL */
 		adapter->ptp_caps.settime64 = ixgbe_ptp_settime;
+#else /* HAVE_PTP_CLOCK_INFO_GETTIME64 */
+		adapter->ptp_caps.gettime = ixgbe_ptp_gettime32;
+		adapter->ptp_caps.settime = ixgbe_ptp_settime32;
+#endif /* !HAVE_PTP_CLOCK_INFO_GETTIME64 */
 		adapter->ptp_caps.enable = ixgbe_ptp_feature_enable;
 		adapter->ptp_setup_sdp = ixgbe_ptp_setup_sdp_X540;
 		break;
@@ -1378,13 +1428,22 @@ static long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)
 		adapter->ptp_caps.pps = 0;
 		adapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_82599;
 		adapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;
+#ifdef HAVE_PTP_CLOCK_INFO_GETTIME64
+#ifdef HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL
 		adapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;
+#else
+		adapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;
+#endif /* HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL */
 		adapter->ptp_caps.settime64 = ixgbe_ptp_settime;
+#else /* HAVE_PTP_CLOCK_INFO_GETTIME64 */
+		adapter->ptp_caps.gettime = ixgbe_ptp_gettime32;
+		adapter->ptp_caps.settime = ixgbe_ptp_settime32;
+#endif /* !HAVE_PTP_CLOCK_INFO_GETTIME64 */
 		adapter->ptp_caps.enable = ixgbe_ptp_feature_enable;
 		break;
 	case ixgbe_mac_X550:
 	case ixgbe_mac_X550EM_x:
-	case ixgbe_mac_x550em_a:
+	case ixgbe_mac_X550EM_a:
 		snprintf(adapter->ptp_caps.name, 16, "%s", netdev->name);
 		adapter->ptp_caps.owner = THIS_MODULE;
 		adapter->ptp_caps.max_adj = 30000000;
@@ -1394,8 +1453,17 @@ static long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)
 		adapter->ptp_caps.pps = 1;
 		adapter->ptp_caps.adjfreq = ixgbe_ptp_adjfreq_X550;
 		adapter->ptp_caps.adjtime = ixgbe_ptp_adjtime;
+#ifdef HAVE_PTP_CLOCK_INFO_GETTIME64
+#ifdef HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL
 		adapter->ptp_caps.gettimex64 = ixgbe_ptp_gettimex;
+#else
+		adapter->ptp_caps.gettime64 = ixgbe_ptp_gettime;
+#endif /* HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL */
 		adapter->ptp_caps.settime64 = ixgbe_ptp_settime;
+#else /* HAVE_PTP_CLOCK_INFO_GETTIME64 */
+		adapter->ptp_caps.gettime = ixgbe_ptp_gettime32;
+		adapter->ptp_caps.settime = ixgbe_ptp_settime32;
+#endif /* !HAVE_PTP_CLOCK_INFO_GETTIME64 */
 		adapter->ptp_caps.enable = ixgbe_ptp_feature_enable;
 		adapter->ptp_setup_sdp = ixgbe_ptp_setup_sdp_X550;
 		break;
@@ -1406,7 +1474,7 @@ static long ixgbe_ptp_create_clock(struct ixgbe_adapter *adapter)
 	}
 
 	adapter->ptp_clock = ptp_clock_register(&adapter->ptp_caps,
-						&adapter->pdev->dev);
+						pci_dev_to_dev(adapter->pdev));
 	if (IS_ERR(adapter->ptp_clock)) {
 		err = PTR_ERR(adapter->ptp_clock);
 		adapter->ptp_clock = NULL;
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
index 988db46bff0e..8126029ba5b6 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.c
@@ -1,5 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
 
 #include <linux/types.h>
 #include <linux/module.h>
@@ -11,10 +12,6 @@
 #include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/ipv6.h>
-#include <linux/if_bridge.h>
-#ifdef NETIF_F_HW_VLAN_CTAG_TX
-#include <linux/if_vlan.h>
-#endif
 
 #include "ixgbe.h"
 #include "ixgbe_type.h"
@@ -53,14 +50,19 @@ static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter,
 	struct ixgbe_hw *hw = &adapter->hw;
 	int i;
 
+#ifdef HAVE_XDP_SUPPORT
 	if (adapter->xdp_prog) {
 		e_warn(probe, "SRIOV is not supported with XDP\n");
 		return -EINVAL;
 	}
+#endif /* HAVE_XDP_SUPPORT */
+
+	adapter->flags |= IXGBE_FLAG_SRIOV_ENABLED;
 
 	/* Enable VMDq flag so device will be set in VM mode */
-	adapter->flags |= IXGBE_FLAG_SRIOV_ENABLED |
-			  IXGBE_FLAG_VMDQ_ENABLED;
+	adapter->flags |= IXGBE_FLAG_VMDQ_ENABLED;
+	if (!adapter->ring_feature[RING_F_VMDQ].limit)
+		adapter->ring_feature[RING_F_VMDQ].limit = 1;
 
 	/* Allocate memory for per VF control structures */
 	adapter->vfinfo = kcalloc(num_vfs, sizeof(struct vf_data_storage),
@@ -68,42 +70,60 @@ static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter,
 	if (!adapter->vfinfo)
 		return -ENOMEM;
 
+	/* Initialize default switching mode VEB */
+	IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
+
+	/* set adapter->num_vfs only after allocating vfinfo to avoid
+	 * NULL pointer issues when accessing adapter->vfinfo
+	 */
 	adapter->num_vfs = num_vfs;
 
 	ixgbe_alloc_vf_macvlans(adapter, num_vfs);
-	adapter->ring_feature[RING_F_VMDQ].offset = num_vfs;
 
-	/* Initialize default switching mode VEB */
-	IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, IXGBE_PFDTXGSWC_VT_LBEN);
-	adapter->bridge_mode = BRIDGE_MODE_VEB;
+	adapter->ring_feature[RING_F_VMDQ].offset = num_vfs;
 
-	/* limit trafffic classes based on VFs enabled */
-	if ((adapter->hw.mac.type == ixgbe_mac_82599EB) && (num_vfs < 16)) {
-		adapter->dcb_cfg.num_tcs.pg_tcs = MAX_TRAFFIC_CLASS;
-		adapter->dcb_cfg.num_tcs.pfc_tcs = MAX_TRAFFIC_CLASS;
-	} else if (num_vfs < 32) {
+	/* enable L2 switch and replication */
+	adapter->flags |= IXGBE_FLAG_SRIOV_L2SWITCH_ENABLE |
+				IXGBE_FLAG_SRIOV_REPLICATION_ENABLE;
+
+	/* limit traffic classes based on VFs enabled */
+	if ((adapter->hw.mac.type == ixgbe_mac_82599EB) &&
+		(adapter->num_vfs < 16)) {
+		adapter->dcb_cfg.num_tcs.pg_tcs =
+			IXGBE_DCB_MAX_TRAFFIC_CLASS;
+		adapter->dcb_cfg.num_tcs.pfc_tcs =
+			IXGBE_DCB_MAX_TRAFFIC_CLASS;
+	} else if (adapter->num_vfs < 32) {
 		adapter->dcb_cfg.num_tcs.pg_tcs = 4;
 		adapter->dcb_cfg.num_tcs.pfc_tcs = 4;
 	} else {
 		adapter->dcb_cfg.num_tcs.pg_tcs = 1;
 		adapter->dcb_cfg.num_tcs.pfc_tcs = 1;
 	}
+	adapter->dcb_cfg.vt_mode = true;
+
+#ifdef IXGBE_DISABLE_VF_MQ
+	/* We do not support RSS w/ SR-IOV */
+	adapter->ring_feature[RING_F_RSS].limit = 1;
+#endif
 
 	/* Disable RSC when in SR-IOV mode */
 	adapter->flags2 &= ~(IXGBE_FLAG2_RSC_CAPABLE |
-			     IXGBE_FLAG2_RSC_ENABLED);
+				IXGBE_FLAG2_RSC_ENABLED);
 
-	for (i = 0; i < num_vfs; i++) {
+	for (i = 0; i < adapter->num_vfs; i++) {
 		/* enable spoof checking for all VFs */
 		adapter->vfinfo[i].spoofchk_enabled = true;
 
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 		/* We support VF RSS querying only for 82599 and x540
 		 * devices at the moment. These devices share RSS
 		 * indirection table and RSS hash key with PF therefore
 		 * we want to disable the querying by default.
 		 */
-		adapter->vfinfo[i].rss_query_enabled = false;
+		adapter->vfinfo[i].rss_query_enabled = 0;
 
+#endif
 		/* Untrust all VFs */
 		adapter->vfinfo[i].trusted = false;
 
@@ -111,7 +131,10 @@ static int __ixgbe_enable_sriov(struct ixgbe_adapter *adapter,
 		adapter->vfinfo[i].xcast_mode = IXGBEVF_XCAST_MODE_NONE;
 	}
 
-	e_info(probe, "SR-IOV enabled with %d VFs\n", num_vfs);
+	e_dev_info("SR-IOV enabled with %d VFs\n", num_vfs);
+	if (hw->mac.type < ixgbe_mac_X550)
+		e_dev_info("configure port vlans to keep your VFs secure\n");
+
 	return 0;
 }
 
@@ -150,13 +173,13 @@ static void ixgbe_get_vfs(struct ixgbe_adapter *adapter)
 /* Note this function is called when the user wants to enable SR-IOV
  * VFs using the now deprecated module parameter
  */
-void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs)
+void ixgbe_enable_sriov(struct ixgbe_adapter *adapter)
 {
 	int pre_existing_vfs = 0;
 	unsigned int num_vfs;
 
 	pre_existing_vfs = pci_num_vf(adapter->pdev);
-	if (!pre_existing_vfs && !max_vfs)
+	if (!pre_existing_vfs && !adapter->max_vfs)
 		return;
 
 	/* If there are pre-existing VFs then we have to force
@@ -175,10 +198,11 @@ void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs)
 		 * The 82599 supports up to 64 VFs per physical function
 		 * but this implementation limits allocation to 63 so that
 		 * basic networking resources are still available to the
-		 * physical function.  If the user requests greater than
+		 * physical function.  If the user requests greater thn
 		 * 63 VFs then it is an error - reset to default of zero.
 		 */
-		num_vfs = min_t(unsigned int, max_vfs, IXGBE_MAX_VFS_DRV_LIMIT);
+		num_vfs = min_t(unsigned int, adapter->max_vfs,
+				IXGBE_MAX_VFS_DRV_LIMIT);
 
 		err = pci_enable_sriov(adapter->pdev, num_vfs);
 		if (err) {
@@ -195,16 +219,17 @@ void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs)
 	/* If we have gotten to this point then there is no memory available
 	 * to manage the VF devices - print message and bail.
 	 */
-	e_err(probe, "Unable to allocate memory for VF Data Storage - "
-	      "SRIOV disabled\n");
+	e_err(probe, "Unable to allocate memory for VF Data Storage - SRIOV disabled\n");
 	ixgbe_disable_sriov(adapter);
 }
 
-#endif /* #ifdef CONFIG_PCI_IOV */
+#endif /* CONFIG_PCI_IOV */
 int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
 {
 	unsigned int num_vfs = adapter->num_vfs, vf;
-	int rss;
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 gpie;
+	u32 vmdctl;
 
 	/* set num VFs to 0 to prevent access to vfinfo */
 	adapter->num_vfs = 0;
@@ -231,6 +256,11 @@ int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
 	if (!(adapter->flags & IXGBE_FLAG_SRIOV_ENABLED))
 		return 0;
 
+	/* Turn off malicious driver detection */
+	if ((hw->mac.ops.disable_mdd) &&
+		(!(adapter->flags & IXGBE_FLAG_MDD_ENABLED)))
+		hw->mac.ops.disable_mdd(hw);
+
 #ifdef CONFIG_PCI_IOV
 	/*
 	 * If our VFs are assigned we cannot shut down SR-IOV
@@ -244,70 +274,90 @@ int ixgbe_disable_sriov(struct ixgbe_adapter *adapter)
 	/* disable iov and allow time for transactions to clear */
 	pci_disable_sriov(adapter->pdev);
 #endif
+	/* turn off device IOV mode */
+	IXGBE_WRITE_REG(hw, IXGBE_GCR_EXT, 0);
+	gpie = IXGBE_READ_REG(hw, IXGBE_GPIE);
+	gpie &= ~IXGBE_GPIE_VTMODE_MASK;
+	IXGBE_WRITE_REG(hw, IXGBE_GPIE, gpie);
+
+	/* set default pool back to 0 */
+	vmdctl = IXGBE_READ_REG(hw, IXGBE_VT_CTL);
+	vmdctl &= ~IXGBE_VT_CTL_POOL_MASK;
+	IXGBE_WRITE_REG(hw, IXGBE_VT_CTL, vmdctl);
+	IXGBE_WRITE_FLUSH(hw);
 
 	/* Disable VMDq flag so device will be set in VM mode */
-	if (bitmap_weight(adapter->fwd_bitmask, adapter->num_rx_pools) == 1) {
+	if (adapter->ring_feature[RING_F_VMDQ].limit == 1)
 		adapter->flags &= ~IXGBE_FLAG_VMDQ_ENABLED;
-		adapter->flags &= ~IXGBE_FLAG_SRIOV_ENABLED;
-		rss = min_t(int, ixgbe_max_rss_indices(adapter),
-			    num_online_cpus());
-	} else {
-		rss = min_t(int, IXGBE_MAX_L2A_QUEUES, num_online_cpus());
-	}
 
+	adapter->flags &= ~IXGBE_FLAG_SRIOV_ENABLED;
 	adapter->ring_feature[RING_F_VMDQ].offset = 0;
-	adapter->ring_feature[RING_F_RSS].limit = rss;
 
 	/* take a breather then clean up driver data */
 	msleep(100);
 	return 0;
 }
 
-static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
+static int ixgbe_pci_sriov_enable(struct pci_dev __maybe_unused *dev, int __maybe_unused num_vfs)
 {
 #ifdef CONFIG_PCI_IOV
 	struct ixgbe_adapter *adapter = pci_get_drvdata(dev);
 	int pre_existing_vfs = pci_num_vf(dev);
-	int err = 0, num_rx_pools, i, limit;
+	int err = 0, i;
 	u8 num_tc;
 
+	if (!(adapter->flags & IXGBE_FLAG_SRIOV_CAPABLE)) {
+		e_dev_warn("SRIOV not supported on this device\n");
+		return -EOPNOTSUPP;
+	}
+
+	if (adapter->num_vfs == num_vfs)
+		return -EINVAL;
+
 	if (pre_existing_vfs && pre_existing_vfs != num_vfs)
 		err = ixgbe_disable_sriov(adapter);
 	else if (pre_existing_vfs && pre_existing_vfs == num_vfs)
-		return num_vfs;
+		goto out;
 
 	if (err)
-		return err;
+		goto err_out;
 
-	/* While the SR-IOV capability structure reports total VFs to be 64,
-	 * we limit the actual number allocated as below based on two factors.
+	/* While the SR-IOV capability structure reports total VFs to be
+	 * 64 we limit the actual number that can be allocated as below
+	 * so that some transmit/receive resources can be reserved to the
+	 * PF.  The PCI bus driver already checks for other values out of
+	 * range.
 	 *    Num_TCs	MAX_VFs
 	 *	1	  63
 	 *	<=4	  31
 	 *	>4	  15
-	 * First, we reserve some transmit/receive resources for the PF.
-	 * Second, VMDQ also uses the same pools that SR-IOV does. We need to
-	 * account for this, so that we don't accidentally allocate more VFs
-	 * than we have available pools. The PCI bus driver already checks for
-	 * other values out of range.
 	 */
-	num_tc = adapter->hw_tcs;
-	num_rx_pools = bitmap_weight(adapter->fwd_bitmask,
-				     adapter->num_rx_pools);
-	limit = (num_tc > 4) ? IXGBE_MAX_VFS_8TC :
-		(num_tc > 1) ? IXGBE_MAX_VFS_4TC : IXGBE_MAX_VFS_1TC;
-
-	if (num_vfs > (limit - num_rx_pools)) {
-		e_dev_err("Currently configured with %d TCs, and %d offloaded macvlans. Creating more than %d VFs is not allowed\n",
-			  num_tc, num_rx_pools - 1, limit - num_rx_pools);
-		return -EPERM;
+	num_tc = netdev_get_num_tc(adapter->netdev);
+	if (num_tc > 4) {
+		if (num_vfs > IXGBE_MAX_VFS_8TC) {
+			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_8TC);
+			err = -EPERM;
+			goto err_out;
+		}
+	} else if ((num_tc > 1) && (num_tc <= 4)) {
+		if (num_vfs > IXGBE_MAX_VFS_4TC) {
+			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_4TC);
+			err = -EPERM;
+			goto err_out;
+		}
+	} else {
+		if (num_vfs > IXGBE_MAX_VFS_1TC) {
+			e_dev_err("Currently the device is configured with %d TCs, Creating more than %d VFs is not allowed\n", num_tc, IXGBE_MAX_VFS_1TC);
+			err = -EPERM;
+			goto err_out;
+		}
 	}
 
 	err = __ixgbe_enable_sriov(adapter, num_vfs);
 	if (err)
-		return  err;
+		goto err_out;
 
-	for (i = 0; i < num_vfs; i++)
+	for (i = 0; i < adapter->num_vfs; i++)
 		ixgbe_vf_configuration(dev, (i | 0x10000000));
 
 	/* reset before enabling SRIOV to avoid mailbox issues */
@@ -316,14 +366,17 @@ static int ixgbe_pci_sriov_enable(struct pci_dev *dev, int num_vfs)
 	err = pci_enable_sriov(dev, num_vfs);
 	if (err) {
 		e_dev_warn("Failed to enable PCI sriov: %d\n", err);
-		return err;
+		goto err_out;
 	}
 	ixgbe_get_vfs(adapter);
 
+out:
 	return num_vfs;
-#else
-	return 0;
+
+err_out:
+	return err;
 #endif
+	return 0;
 }
 
 static int ixgbe_pci_sriov_disable(struct pci_dev *dev)
@@ -332,15 +385,16 @@ static int ixgbe_pci_sriov_disable(struct pci_dev *dev)
 	int err;
 #ifdef CONFIG_PCI_IOV
 	u32 current_flags = adapter->flags;
-	int prev_num_vf = pci_num_vf(dev);
 #endif
 
+	if (!adapter->num_vfs && !pci_num_vf(dev))
+		return -EINVAL;
+
 	err = ixgbe_disable_sriov(adapter);
 
 	/* Only reinit if no error and state changed */
 #ifdef CONFIG_PCI_IOV
-	if (!err && (current_flags != adapter->flags ||
-		     prev_num_vf != pci_num_vf(dev)))
+	if (!err && current_flags != adapter->flags)
 		ixgbe_sriov_reinit(adapter);
 #endif
 
@@ -364,39 +418,28 @@ static int ixgbe_set_vf_multicasts(struct ixgbe_adapter *adapter,
 	struct vf_data_storage *vfinfo = &adapter->vfinfo[vf];
 	struct ixgbe_hw *hw = &adapter->hw;
 	int i;
-	u32 vector_bit;
-	u32 vector_reg;
-	u32 mta_reg;
 	u32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));
 
 	/* only so many hash values supported */
 	entries = min(entries, IXGBE_MAX_VF_MC_ENTRIES);
 
-	/*
-	 * salt away the number of multi cast addresses assigned
+	/* salt away the number of multi cast addresses assigned
 	 * to this VF for later use to restore when the PF multi cast
 	 * list changes
 	 */
 	vfinfo->num_vf_mc_hashes = entries;
 
-	/*
-	 * VFs are limited to using the MTA hash table for their multicast
-	 * addresses
-	 */
-	for (i = 0; i < entries; i++) {
+	/* VFs are limited to using the MTA hash table for their multicast
+	 * addresses */
+	for (i = 0; i < entries; i++)
 		vfinfo->vf_mc_hashes[i] = hash_list[i];
-	}
 
-	for (i = 0; i < vfinfo->num_vf_mc_hashes; i++) {
-		vector_reg = (vfinfo->vf_mc_hashes[i] >> 5) & 0x7F;
-		vector_bit = vfinfo->vf_mc_hashes[i] & 0x1F;
-		mta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));
-		mta_reg |= BIT(vector_bit);
-		IXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);
-	}
 	vmolr |= IXGBE_VMOLR_ROMPE;
 	IXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);
 
+	/* Sync up the PF and VF in the same MTA table */
+	ixgbe_write_mc_addr_list(adapter->netdev);
+
 	return 0;
 }
 
@@ -408,7 +451,9 @@ void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)
 	int i, j;
 	u32 vector_bit;
 	u32 vector_reg;
-	u32 mta_reg;
+
+	/* Clear mta_shadow */
+	memset(&hw->mac.mta_shadow, 0, sizeof(hw->mac.mta_shadow));
 
 	for (i = 0; i < adapter->num_vfs; i++) {
 		u32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(i));
@@ -417,11 +462,8 @@ void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)
 			hw->addr_ctrl.mta_in_use++;
 			vector_reg = (vfinfo->vf_mc_hashes[j] >> 5) & 0x7F;
 			vector_bit = vfinfo->vf_mc_hashes[j] & 0x1F;
-			mta_reg = IXGBE_READ_REG(hw, IXGBE_MTA(vector_reg));
-			mta_reg |= BIT(vector_bit);
-			IXGBE_WRITE_REG(hw, IXGBE_MTA(vector_reg), mta_reg);
+			hw->mac.mta_shadow[vector_reg] |= (1 << vector_bit);
 		}
-
 		if (vfinfo->num_vf_mc_hashes)
 			vmolr |= IXGBE_VMOLR_ROMPE;
 		else
@@ -432,14 +474,14 @@ void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter)
 	/* Restore any VF macvlans */
 	ixgbe_full_sync_mac_table(adapter);
 }
-#endif
+#endif /* CONFIG_PCI_IOV */
 
-static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid,
-			     u32 vf)
+int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid, u32 vf)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	int err;
 
+#ifndef HAVE_VLAN_RX_REGISTER
 	/* If VLAN overlaps with one the PF is currently monitoring make
 	 * sure that we are able to allocate a VLVF entry.  This may be
 	 * redundant but it guarantees PF will maintain visibility to
@@ -450,8 +492,10 @@ static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid,
 		if (err)
 			return err;
 	}
+#endif
 
 	err = hw->mac.ops.set_vfta(hw, vid, vf, !!add, false);
+#ifndef HAVE_VLAN_RX_REGISTER
 
 	if (add && !err)
 		return err;
@@ -463,14 +507,13 @@ static int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid,
 	if (test_bit(vid, adapter->active_vlans) ||
 	    (adapter->flags2 & IXGBE_FLAG2_VLAN_PROMISC))
 		ixgbe_update_pf_promisc_vlvf(adapter, vid);
+#endif
 
 	return err;
 }
-
-static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
+static int ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 max_frame, u32 vf)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	int max_frame = msgbuf[1];
 	u32 max_frs;
 
 	/*
@@ -481,29 +524,29 @@ static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 	 * account before we can enable the VF for receive
 	 */
 	if (adapter->hw.mac.type == ixgbe_mac_82599EB) {
+
 		struct net_device *dev = adapter->netdev;
 		int pf_max_frame = dev->mtu + ETH_HLEN;
 		u32 reg_offset, vf_shift, vfre;
 		s32 err = 0;
 
-#ifdef CONFIG_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		if (dev->features & NETIF_F_FCOE_MTU)
 			pf_max_frame = max_t(int, pf_max_frame,
 					     IXGBE_FCOE_JUMBO_FRAME_SIZE);
-
 #endif /* CONFIG_FCOE */
+
 		switch (adapter->vfinfo[vf].vf_api) {
 		case ixgbe_mbox_api_11:
 		case ixgbe_mbox_api_12:
 		case ixgbe_mbox_api_13:
-		case ixgbe_mbox_api_14:
 			/* Version 1.1 supports jumbo frames on VFs if PF has
 			 * jumbo frames enabled which means legacy VFs are
 			 * disabled
 			 */
 			if (pf_max_frame > ETH_FRAME_LEN)
 				break;
-			fallthrough;
+			/* fall through */
 		default:
 			/* If the PF or VF are running w/ jumbo frames enabled
 			 * we need to shut down the VF Rx path as we cannot
@@ -522,9 +565,9 @@ static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 		/* enable or disable receive depending on error */
 		vfre = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));
 		if (err)
-			vfre &= ~BIT(vf_shift);
+			vfre &= ~(1 << vf_shift);
 		else
-			vfre |= BIT(vf_shift);
+			vfre |= 1 << vf_shift;
 		IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), vfre);
 
 		if (err) {
@@ -533,12 +576,6 @@ static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 		}
 	}
 
-	/* MTU < 68 is an error and causes problems on some kernels */
-	if (max_frame > IXGBE_MAX_JUMBO_FRAME_SIZE) {
-		e_err(drv, "VF max_frame %d out of range\n", max_frame);
-		return -EINVAL;
-	}
-
 	/* pull current max frame size from hardware */
 	max_frs = IXGBE_READ_REG(hw, IXGBE_MAXFRS);
 	max_frs &= IXGBE_MHADD_MFS_MASK;
@@ -554,10 +591,10 @@ static s32 ixgbe_set_vf_lpe(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 	return 0;
 }
 
-static void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)
+void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)
 {
 	u32 vmolr = IXGBE_READ_REG(hw, IXGBE_VMOLR(vf));
-	vmolr |= IXGBE_VMOLR_BAM;
+	vmolr |=  IXGBE_VMOLR_BAM;
 	if (aupe)
 		vmolr |= IXGBE_VMOLR_AUPE;
 	else
@@ -565,6 +602,15 @@ static void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe)
 	IXGBE_WRITE_REG(hw, IXGBE_VMOLR(vf), vmolr);
 }
 
+static void ixgbe_set_vmvir(struct ixgbe_adapter *adapter,
+			    u16 vid, u16 qos, u32 vf)
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 vmvir = vid | (qos << VLAN_PRIO_SHIFT) | IXGBE_VMVIR_VLANA_DEFAULT;
+
+	IXGBE_WRITE_REG(hw, IXGBE_VMVIR(vf), vmvir);
+}
+
 static void ixgbe_clear_vmvir(struct ixgbe_adapter *adapter, u32 vf)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -578,7 +624,7 @@ static void ixgbe_clear_vf_vlans(struct ixgbe_adapter *adapter, u32 vf)
 	u32 vlvfb_mask, pool_mask, i;
 
 	/* create mask for VF and other pools */
-	pool_mask = ~BIT(VMDQ_P(0) % 32);
+	pool_mask = (u32)~BIT(VMDQ_P(0) % 32);
 	vlvfb_mask = BIT(vf % 32);
 
 	/* post increment loop, covers VLVF_ENTRIES - 1 to 0 */
@@ -596,7 +642,7 @@ static void ixgbe_clear_vf_vlans(struct ixgbe_adapter *adapter, u32 vf)
 		/* clear our bit from vlvfb */
 		vlvfb ^= vlvfb_mask;
 
-		/* create 64b mask to chedk to see if we should clear VLVF */
+		/* create 64b mask to check to see if we should clear VLVF */
 		bits[word % 2] = vlvfb;
 		bits[~word % 2] = IXGBE_READ_REG(hw, IXGBE_VLVFB(word ^ 1));
 
@@ -693,15 +739,16 @@ static int ixgbe_set_vf_macvlan(struct ixgbe_adapter *adapter,
 
 static inline void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)
 {
-	struct ixgbe_hw *hw = &adapter->hw;
 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	struct vf_data_storage *vfinfo = &adapter->vfinfo[vf];
+	u8 num_tcs = netdev_get_num_tc(adapter->netdev);
 	u32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);
-	u8 num_tcs = adapter->hw_tcs;
+	struct ixgbe_hw *hw = &adapter->hw;
 	u32 reg_val;
 	u32 queue;
+	u32 word;
 
-	/* remove VLAN filters beloning to this VF */
+	/* remove VLAN filters belonging to this VF */
 	ixgbe_clear_vf_vlans(adapter, vf);
 
 	/* add back PF assigned VLAN or VLAN 0 */
@@ -720,19 +767,11 @@ static inline void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)
 		else
 			ixgbe_set_vmvir(adapter, vfinfo->pf_vlan,
 					adapter->default_up, vf);
-
-		if (vfinfo->spoofchk_enabled) {
-			hw->mac.ops.set_vlan_anti_spoofing(hw, true, vf);
-			hw->mac.ops.set_mac_anti_spoofing(hw, true, vf);
-		}
 	}
 
 	/* reset multicast table array for vf */
 	adapter->vfinfo[vf].num_vf_mc_hashes = 0;
 
-	/* clear any ipsec table info */
-	ixgbe_ipsec_vf_clear(adapter, vf);
-
 	/* Flush and reset the mta with the new values */
 	ixgbe_set_rx_mode(adapter->netdev);
 
@@ -742,64 +781,68 @@ static inline void ixgbe_vf_reset_event(struct ixgbe_adapter *adapter, u32 vf)
 	/* reset VF api back to unknown */
 	adapter->vfinfo[vf].vf_api = ixgbe_mbox_api_10;
 
-	/* Restart each queue for given VF */
-	for (queue = 0; queue < q_per_pool; queue++) {
-		unsigned int reg_idx = (vf * q_per_pool) + queue;
-
-		reg_val = IXGBE_READ_REG(hw, IXGBE_PVFTXDCTL(reg_idx));
-
-		/* Re-enabling only configured queues */
-		if (reg_val) {
-			reg_val |= IXGBE_TXDCTL_ENABLE;
-			IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx), reg_val);
-			reg_val &= ~IXGBE_TXDCTL_ENABLE;
-			IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx), reg_val);
+	/*
+	 * Toggling VF's TX queues and clearing VF Mailbox Memory after VFLR
+	 * should only affect X550 and above
+	 */
+	if (hw->mac.type >= ixgbe_mac_X550) {
+		/* Restart each queue for given VF */
+		for (queue = 0; queue < q_per_pool; queue++) {
+			unsigned int reg_idx = (vf * q_per_pool) + queue;
+
+			reg_val = IXGBE_READ_REG(hw, IXGBE_PVFTXDCTL(reg_idx));
+
+			/* Re-enabling only configured queues */
+			if (reg_val) {
+				reg_val |= IXGBE_TXDCTL_ENABLE;
+				IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx),
+						reg_val);
+				reg_val &= ~IXGBE_TXDCTL_ENABLE;
+				IXGBE_WRITE_REG(hw, IXGBE_PVFTXDCTL(reg_idx),
+						reg_val);
+			}
 		}
-	}
-
-	IXGBE_WRITE_FLUSH(hw);
-}
-
-static void ixgbe_vf_clear_mbx(struct ixgbe_adapter *adapter, u32 vf)
-{
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 word;
 
-	/* Clear VF's mailbox memory */
-	for (word = 0; word < IXGBE_VFMAILBOX_SIZE; word++)
-		IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf), word, 0);
+		/* Clear VF's mailbox memory */
+		for (word = 0; word < IXGBE_VFMAILBOX_SIZE; word++)
+			IXGBE_WRITE_REG_ARRAY(hw, IXGBE_PFMBMEM(vf), word, 0);
 
-	IXGBE_WRITE_FLUSH(hw);
+		IXGBE_WRITE_FLUSH(hw);
+	}
 }
 
-static int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter,
-			    int vf, unsigned char *mac_addr)
+int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter,
+		     int vf, unsigned char *mac_addr)
 {
-	s32 retval;
+	s32 retval = 0;
 
 	ixgbe_del_mac_filter(adapter, adapter->vfinfo[vf].vf_mac_addresses, vf);
 	retval = ixgbe_add_mac_filter(adapter, mac_addr, vf);
 	if (retval >= 0)
-		memcpy(adapter->vfinfo[vf].vf_mac_addresses, mac_addr,
-		       ETH_ALEN);
+		memcpy(adapter->vfinfo[vf].vf_mac_addresses,
+		       mac_addr, ETH_ALEN);
 	else
-		eth_zero_addr(adapter->vfinfo[vf].vf_mac_addresses);
+		memset(adapter->vfinfo[vf].vf_mac_addresses, 0, ETH_ALEN);
 
 	return retval;
 }
 
+#ifdef CONFIG_PCI_IOV
 int ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask)
 {
+	unsigned char vf_mac_addr[6];
 	struct ixgbe_adapter *adapter = pci_get_drvdata(pdev);
 	unsigned int vfn = (event_mask & 0x3f);
-
 	bool enable = ((event_mask & 0x10000000U) != 0);
 
-	if (enable)
-		eth_zero_addr(adapter->vfinfo[vfn].vf_mac_addresses);
+	if (enable) {
+		memset(vf_mac_addr, 0, ETH_ALEN);
+		memcpy(adapter->vfinfo[vfn].vf_mac_addresses, vf_mac_addr, 6);
+	}
 
 	return 0;
 }
+#endif /* CONFIG_PCI_IOV */
 
 static inline void ixgbe_write_qde(struct ixgbe_adapter *adapter, u32 vf,
 				   u32 qde)
@@ -807,25 +850,25 @@ static inline void ixgbe_write_qde(struct ixgbe_adapter *adapter, u32 vf,
 	struct ixgbe_hw *hw = &adapter->hw;
 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	u32 q_per_pool = __ALIGN_MASK(1, ~vmdq->mask);
+	u32 reg;
 	int i;
 
 	for (i = vf * q_per_pool; i < ((vf + 1) * q_per_pool); i++) {
-		u32 reg;
-
 		/* flush previous write */
 		IXGBE_WRITE_FLUSH(hw);
 
-		/* indicate to hardware that we want to set drop enable */
+		/* drop enable should always be set in SRIOV mode*/
 		reg = IXGBE_QDE_WRITE | qde;
 		reg |= i <<  IXGBE_QDE_IDX_SHIFT;
 		IXGBE_WRITE_REG(hw, IXGBE_QDE, reg);
 	}
+
 }
 
 static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 {
-	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	struct ixgbe_hw *hw = &adapter->hw;
+	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	unsigned char *vf_mac = adapter->vfinfo[vf].vf_mac_addresses;
 	u32 reg, reg_offset, vf_shift;
 	u32 msgbuf[4] = {0, 0, 0, 0};
@@ -838,8 +881,6 @@ static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 	/* reset the filters for the device */
 	ixgbe_vf_reset_event(adapter, vf);
 
-	ixgbe_vf_clear_mbx(adapter, vf);
-
 	/* set vf mac address */
 	if (!is_zero_ether_addr(vf_mac))
 		ixgbe_set_vf_mac(adapter, vf, vf_mac);
@@ -849,7 +890,7 @@ static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 
 	/* enable transmit for vf */
 	reg = IXGBE_READ_REG(hw, IXGBE_VFTE(reg_offset));
-	reg |= BIT(vf_shift);
+	reg |= 1 << vf_shift;
 	IXGBE_WRITE_REG(hw, IXGBE_VFTE(reg_offset), reg);
 
 	/* force drop enable for all VF Rx queues */
@@ -861,7 +902,7 @@ static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 
 	/* enable receive for vf */
 	reg = IXGBE_READ_REG(hw, IXGBE_VFRE(reg_offset));
-	reg |= BIT(vf_shift);
+	reg |= 1 << vf_shift;
 	/*
 	 * The 82599 cannot support a mix of jumbo and non-jumbo PF/VFs.
 	 * For more info take a look at ixgbe_set_vf_lpe
@@ -870,23 +911,22 @@ static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 		struct net_device *dev = adapter->netdev;
 		int pf_max_frame = dev->mtu + ETH_HLEN;
 
-#ifdef CONFIG_FCOE
+#if IS_ENABLED(CONFIG_FCOE)
 		if (dev->features & NETIF_F_FCOE_MTU)
 			pf_max_frame = max_t(int, pf_max_frame,
 					     IXGBE_FCOE_JUMBO_FRAME_SIZE);
-
 #endif /* CONFIG_FCOE */
+
 		if (pf_max_frame > ETH_FRAME_LEN)
-			reg &= ~BIT(vf_shift);
+			reg &= ~(1 << vf_shift);
 	}
 	IXGBE_WRITE_REG(hw, IXGBE_VFRE(reg_offset), reg);
 
 	/* enable VF mailbox for further messages */
 	adapter->vfinfo[vf].clear_to_send = true;
 
-	/* Enable counting of spoofed packets in the SSVPC register */
 	reg = IXGBE_READ_REG(hw, IXGBE_VMECM(reg_offset));
-	reg |= BIT(vf_shift);
+	reg |= (1 << vf_shift);
 	IXGBE_WRITE_REG(hw, IXGBE_VMECM(reg_offset), reg);
 
 	/*
@@ -901,10 +941,10 @@ static int ixgbe_vf_reset_msg(struct ixgbe_adapter *adapter, u32 vf)
 	/* reply to reset with ack and vf mac address */
 	msgbuf[0] = IXGBE_VF_RESET;
 	if (!is_zero_ether_addr(vf_mac) && adapter->vfinfo[vf].pf_set_mac) {
-		msgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;
+		msgbuf[0] |= IXGBE_VT_MSGTYPE_SUCCESS;
 		memcpy(addr, vf_mac, ETH_ALEN);
 	} else {
-		msgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;
+		msgbuf[0] |= IXGBE_VT_MSGTYPE_FAILURE;
 	}
 
 	/*
@@ -928,14 +968,15 @@ static int ixgbe_set_vf_mac_addr(struct ixgbe_adapter *adapter,
 	}
 
 	if (adapter->vfinfo[vf].pf_set_mac && !adapter->vfinfo[vf].trusted &&
-	    !ether_addr_equal(adapter->vfinfo[vf].vf_mac_addresses, new_mac)) {
+	    memcmp(adapter->vfinfo[vf].vf_mac_addresses, new_mac,
+		   ETH_ALEN)) {
+		u8 *pm = adapter->vfinfo[vf].vf_mac_addresses;
 		e_warn(drv,
-		       "VF %d attempted to override administratively set MAC address\n"
-		       "Reload the VF driver to resume operations\n",
-		       vf);
+		       "VF %d attempted to set a new MAC address but it already has an administratively set MAC address %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X\n",
+		       vf, pm[0], pm[1], pm[2], pm[3], pm[4], pm[5]);
+		e_warn(drv, "Check the VF driver and if it is not using the correct MAC address you may need to reload the VF driver\n");
 		return -1;
 	}
-
 	return ixgbe_set_vf_mac(adapter, vf, new_mac) < 0;
 }
 
@@ -944,7 +985,8 @@ static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,
 {
 	u32 add = (msgbuf[0] & IXGBE_VT_MSGINFO_MASK) >> IXGBE_VT_MSGINFO_SHIFT;
 	u32 vid = (msgbuf[1] & IXGBE_VLVF_VLANID_MASK);
-	u8 tcs = adapter->hw_tcs;
+	u8 tcs = netdev_get_num_tc(adapter->netdev);
+	int err = 0;
 
 	if (adapter->vfinfo[vf].pf_vlan || tcs) {
 		e_warn(drv,
@@ -958,7 +1000,63 @@ static int ixgbe_set_vf_vlan_msg(struct ixgbe_adapter *adapter,
 	if (!vid && !add)
 		return 0;
 
-	return ixgbe_set_vf_vlan(adapter, add, vid, vf);
+	err = ixgbe_set_vf_vlan(adapter, add, vid, vf);
+
+	if (err)
+		return err;
+
+#ifdef HAVE_VLAN_RX_REGISTER
+	/* in case of promiscuous mode any VLAN filter set for a VF must
+	 * also have the PF pool added to it.
+	 */
+	if (add && adapter->netdev->flags & IFF_PROMISC) {
+		err = ixgbe_set_vf_vlan(adapter, add, vid, VMDQ_P(0));
+		if (err)
+			return err;
+	}
+
+#ifdef CONFIG_PCI_IOV
+	/* Go through all the checks to see if the VLAN filter should
+	 * be wiped completely.
+	 */
+	if (!add && adapter->netdev->flags & IFF_PROMISC) {
+		struct ixgbe_hw *hw = &adapter->hw;
+		u32 bits, vlvf;
+		s32 reg_ndx;
+
+		reg_ndx = ixgbe_find_vlvf_entry(hw, vid);
+		if (reg_ndx < 0)
+			goto out;
+		vlvf = IXGBE_READ_REG(hw, IXGBE_VLVF(reg_ndx));
+		/* See if any other pools are set for this VLAN filter
+		 * entry other than the PF.
+		 */
+		if (VMDQ_P(0) < 32) {
+			bits = IXGBE_READ_REG(hw, IXGBE_VLVFB(reg_ndx * 2));
+			bits &= ~(1 << VMDQ_P(0));
+			bits |= IXGBE_READ_REG(hw,
+					       IXGBE_VLVFB(reg_ndx * 2) + 1);
+		} else {
+			bits = IXGBE_READ_REG(hw,
+					      IXGBE_VLVFB(reg_ndx * 2) + 1);
+			bits &= ~(1 << (VMDQ_P(0) - 32));
+			bits |= IXGBE_READ_REG(hw, IXGBE_VLVFB(reg_ndx * 2));
+		}
+
+		/* If the filter was removed then ensure PF pool bit
+		 * is cleared if the PF only added itself to the pool
+		 * because the PF is in promiscuous mode.
+		 */
+		if ((vlvf & VLAN_VID_MASK) == vid && !bits)
+			err = ixgbe_set_vf_vlan(adapter, add, vid, VMDQ_P(0));
+	}
+
+out:
+#endif /* CONFIG_PCI_IOV */
+#else /* HAVE_VLAN_RX_REGISTER */
+	return 0;
+#endif /* HAVE_VLAN_RX_REGISTER */
+	return err;
 }
 
 static int ixgbe_set_vf_macvlan_msg(struct ixgbe_adapter *adapter,
@@ -1015,7 +1113,6 @@ static int ixgbe_negotiate_vf_api(struct ixgbe_adapter *adapter,
 	case ixgbe_mbox_api_11:
 	case ixgbe_mbox_api_12:
 	case ixgbe_mbox_api_13:
-	case ixgbe_mbox_api_14:
 		adapter->vfinfo[vf].vf_api = api;
 		return 0;
 	default:
@@ -1033,7 +1130,7 @@ static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter,
 	struct net_device *dev = adapter->netdev;
 	struct ixgbe_ring_feature *vmdq = &adapter->ring_feature[RING_F_VMDQ];
 	unsigned int default_tc = 0;
-	u8 num_tcs = adapter->hw_tcs;
+	u8 num_tcs = netdev_get_num_tc(dev);
 
 	/* verify the PF is supporting the correct APIs */
 	switch (adapter->vfinfo[vf].vf_api) {
@@ -1041,7 +1138,6 @@ static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter,
 	case ixgbe_mbox_api_11:
 	case ixgbe_mbox_api_12:
 	case ixgbe_mbox_api_13:
-	case ixgbe_mbox_api_14:
 		break;
 	default:
 		return -1;
@@ -1069,6 +1165,7 @@ static int ixgbe_get_vf_queues(struct ixgbe_adapter *adapter,
 	return 0;
 }
 
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 static int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 {
 	u32 i, j;
@@ -1082,9 +1179,8 @@ static int ixgbe_get_vf_reta(struct ixgbe_adapter *adapter, u32 *msgbuf, u32 vf)
 
 	/* verify the PF is supporting the correct API */
 	switch (adapter->vfinfo[vf].vf_api) {
-	case ixgbe_mbox_api_14:
-	case ixgbe_mbox_api_13:
 	case ixgbe_mbox_api_12:
+	case ixgbe_mbox_api_13:
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -1115,9 +1211,8 @@ static int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter,
 
 	/* verify the PF is supporting the correct API */
 	switch (adapter->vfinfo[vf].vf_api) {
-	case ixgbe_mbox_api_14:
-	case ixgbe_mbox_api_13:
 	case ixgbe_mbox_api_12:
+	case ixgbe_mbox_api_13:
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -1127,6 +1222,7 @@ static int ixgbe_get_vf_rss_key(struct ixgbe_adapter *adapter,
 
 	return 0;
 }
+#endif /* HAVE_NDO_SET_VF_RSS_QUERY_EN */
 
 static int ixgbe_update_vf_xcast_mode(struct ixgbe_adapter *adapter,
 				      u32 *msgbuf, u32 vf)
@@ -1141,9 +1237,8 @@ static int ixgbe_update_vf_xcast_mode(struct ixgbe_adapter *adapter,
 		/* promisc introduced in 1.3 version */
 		if (xcast_mode == IXGBEVF_XCAST_MODE_PROMISC)
 			return -EOPNOTSUPP;
-		fallthrough;
+		/* Fall threw */
 	case ixgbe_mbox_api_13:
-	case ixgbe_mbox_api_14:
 		break;
 	default:
 		return -EOPNOTSUPP;
@@ -1219,8 +1314,8 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 	}
 
 	/* this is a message we already processed, do nothing */
-	if (msgbuf[0] & (IXGBE_VT_MSGTYPE_ACK | IXGBE_VT_MSGTYPE_NACK))
-		return 0;
+	if (msgbuf[0] & (IXGBE_VT_MSGTYPE_SUCCESS | IXGBE_VT_MSGTYPE_FAILURE))
+		return retval;
 
 	/* flush the ack before we write any messages back */
 	IXGBE_WRITE_FLUSH(hw);
@@ -1232,10 +1327,11 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 	 * until the vf completes a virtual function reset it should not be
 	 * allowed to start any configuration.
 	 */
+
 	if (!adapter->vfinfo[vf].clear_to_send) {
-		msgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;
+		msgbuf[0] |= IXGBE_VT_MSGTYPE_FAILURE;
 		ixgbe_write_mbx(hw, msgbuf, 1, vf);
-		return 0;
+		return retval;
 	}
 
 	switch ((msgbuf[0] & 0xFFFF)) {
@@ -1249,7 +1345,11 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 		retval = ixgbe_set_vf_vlan_msg(adapter, msgbuf, vf);
 		break;
 	case IXGBE_VF_SET_LPE:
-		retval = ixgbe_set_vf_lpe(adapter, msgbuf, vf);
+		if (msgbuf[1] > IXGBE_MAX_JUMBO_FRAME_SIZE) {
+			e_err(drv, "VF max_frame %d out of range\n", msgbuf[1]);
+			return -EINVAL;
+		}
+		retval = ixgbe_set_vf_lpe(adapter, msgbuf[1], vf);
 		break;
 	case IXGBE_VF_SET_MACVLAN:
 		retval = ixgbe_set_vf_macvlan_msg(adapter, msgbuf, vf);
@@ -1260,21 +1360,17 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 	case IXGBE_VF_GET_QUEUES:
 		retval = ixgbe_get_vf_queues(adapter, msgbuf, vf);
 		break;
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 	case IXGBE_VF_GET_RETA:
 		retval = ixgbe_get_vf_reta(adapter, msgbuf, vf);
 		break;
 	case IXGBE_VF_GET_RSS_KEY:
 		retval = ixgbe_get_vf_rss_key(adapter, msgbuf, vf);
 		break;
+#endif /* HAVE_NDO_SET_VF_RSS_QUERY_EN */
 	case IXGBE_VF_UPDATE_XCAST_MODE:
 		retval = ixgbe_update_vf_xcast_mode(adapter, msgbuf, vf);
 		break;
-	case IXGBE_VF_IPSEC_ADD:
-		retval = ixgbe_ipsec_vf_add_sa(adapter, msgbuf, vf);
-		break;
-	case IXGBE_VF_IPSEC_DEL:
-		retval = ixgbe_ipsec_vf_del_sa(adapter, msgbuf, vf);
-		break;
 	default:
 		e_err(drv, "Unhandled Msg %8.8x\n", msgbuf[0]);
 		retval = IXGBE_ERR_MBX;
@@ -1283,9 +1379,9 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 
 	/* notify the VF of the results of what it sent us */
 	if (retval)
-		msgbuf[0] |= IXGBE_VT_MSGTYPE_NACK;
+		msgbuf[0] |= IXGBE_VT_MSGTYPE_FAILURE;
 	else
-		msgbuf[0] |= IXGBE_VT_MSGTYPE_ACK;
+		msgbuf[0] |= IXGBE_VT_MSGTYPE_SUCCESS;
 
 	msgbuf[0] |= IXGBE_VT_MSGTYPE_CTS;
 
@@ -1297,18 +1393,65 @@ static int ixgbe_rcv_msg_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 static void ixgbe_rcv_ack_from_vf(struct ixgbe_adapter *adapter, u32 vf)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
-	u32 msg = IXGBE_VT_MSGTYPE_NACK;
+	u32 msg = IXGBE_VT_MSGTYPE_FAILURE;
 
 	/* if device isn't clear to send it shouldn't be reading either */
 	if (!adapter->vfinfo[vf].clear_to_send)
 		ixgbe_write_mbx(hw, &msg, 1, vf);
 }
 
+#define Q_BITMAP_DEPTH 2
+static void ixgbe_check_mdd_event(struct ixgbe_adapter *adapter)
+{
+	struct ixgbe_hw *hw = &adapter->hw;
+	u32 vf_bitmap[Q_BITMAP_DEPTH] = { 0 };
+	u32 j, i;
+	u32 ping;
+
+	if (!hw->mac.ops.mdd_event)
+		return;
+
+	/* Did we have a malicious event */
+	hw->mac.ops.mdd_event(hw, vf_bitmap);
+
+	/* Log any blocked queues and release lock */
+	for (i = 0; i < Q_BITMAP_DEPTH; i++) {
+		for (j = 0; j < 32 && vf_bitmap[i]; j++) {
+			u32 vf;
+
+			if (!(vf_bitmap[i] & (1 << j)))
+				continue;
+
+			/* The VF that malicious event occurred on */
+			vf = j + (i * 32);
+
+			dev_warn(pci_dev_to_dev(adapter->pdev),
+				"Malicious event on VF %d tx:%x rx:%x\n", vf,
+				IXGBE_READ_REG(hw, IXGBE_LVMMC_TX),
+				IXGBE_READ_REG(hw, IXGBE_LVMMC_RX));
+
+			/* restart the vf */
+			if (hw->mac.ops.restore_mdd_vf) {
+				hw->mac.ops.restore_mdd_vf(hw, vf);
+
+				/* get the VF to rebuild its queues */
+				adapter->vfinfo[vf].clear_to_send = 0;
+				ping = IXGBE_PF_CONTROL_MSG |
+				       IXGBE_VT_MSGTYPE_CTS;
+				ixgbe_write_mbx(hw, &ping, 1, vf);
+			}
+		}
+	}
+}
+
 void ixgbe_msg_task(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	u32 vf;
 
+	if (adapter->flags & IXGBE_FLAG_MDD_ENABLED && adapter->vfinfo)
+		ixgbe_check_mdd_event(adapter);
+
 	for (vf = 0; vf < adapter->num_vfs; vf++) {
 		/* process any reset requests */
 		if (!ixgbe_check_for_rst(hw, vf))
@@ -1336,6 +1479,7 @@ void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter)
 	IXGBE_WRITE_REG(hw, IXGBE_VFRE(1), 0);
 }
 
+#ifdef HAVE_NDO_SET_VF_TRUST
 static inline void ixgbe_ping_vf(struct ixgbe_adapter *adapter, int vf)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -1347,6 +1491,7 @@ static inline void ixgbe_ping_vf(struct ixgbe_adapter *adapter, int vf)
 	ixgbe_write_mbx(hw, &ping, 1, vf);
 }
 
+#endif
 void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
@@ -1361,29 +1506,55 @@ void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter)
 	}
 }
 
+#ifdef HAVE_NDO_SET_VF_TRUST
+int ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)
+{
+	struct ixgbe_adapter *adapter = netdev_priv(netdev);
+
+	if (vf < 0 || vf >= adapter->num_vfs)
+		return -EINVAL;
+
+	/* nothing to do */
+	if (adapter->vfinfo[vf].trusted == setting)
+		return 0;
+
+	adapter->vfinfo[vf].trusted = setting;
+
+	/* reset VF to reconfigure features */
+	adapter->vfinfo[vf].clear_to_send = false;
+	ixgbe_ping_vf(adapter, vf);
+
+	e_info(drv, "VF %u is %strusted\n", vf, setting ? "" : "not ");
+
+	return 0;
+}
+
+#endif
+#ifdef IFLA_VF_MAX
 int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	s32 retval;
+	s32 retval = 0;
 
-	if (vf >= adapter->num_vfs)
+	if (vf < 0 || vf >= adapter->num_vfs)
 		return -EINVAL;
 
 	if (is_valid_ether_addr(mac)) {
-		dev_info(&adapter->pdev->dev, "setting MAC %pM on VF %d\n",
+		dev_info(pci_dev_to_dev(adapter->pdev), "setting MAC %pM on VF %d\n",
 			 mac, vf);
-		dev_info(&adapter->pdev->dev, "Reload the VF driver to make this change effective.");
+		dev_info(pci_dev_to_dev(adapter->pdev), "Reload the VF driver to make this change effective.\n");
 
 		retval = ixgbe_set_vf_mac(adapter, vf, mac);
 		if (retval >= 0) {
+		/* pf_set_mac is used in ESX5.1 and base driver but not in ESX5.5 */
 			adapter->vfinfo[vf].pf_set_mac = true;
 
 			if (test_bit(__IXGBE_DOWN, &adapter->state)) {
-				dev_warn(&adapter->pdev->dev, "The VF MAC address has been set, but the PF device is not up.\n");
-				dev_warn(&adapter->pdev->dev, "Bring the PF device up before attempting to use the VF device.\n");
+				dev_warn(pci_dev_to_dev(adapter->pdev), "The VF MAC address has been set, but the PF device is not up.\n");
+				dev_warn(pci_dev_to_dev(adapter->pdev), "Bring the PF device up before attempting to use the VF device.\n");
 			}
 		} else {
-			dev_warn(&adapter->pdev->dev, "The VF MAC address was NOT set due to invalid or duplicate MAC address.\n");
+			dev_warn(pci_dev_to_dev(adapter->pdev), "The VF MAC address was NOT set due to invalid or duplicate MAC address.\n");
 		}
 	} else if (is_zero_ether_addr(mac)) {
 		unsigned char *vf_mac_addr =
@@ -1393,24 +1564,24 @@ int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)
 		if (is_zero_ether_addr(vf_mac_addr))
 			return 0;
 
-		dev_info(&adapter->pdev->dev, "removing MAC on VF %d\n", vf);
+		dev_info(pci_dev_to_dev(adapter->pdev), "removing MAC on VF %d\n",
+			 vf);
 
 		retval = ixgbe_del_mac_filter(adapter, vf_mac_addr, vf);
 		if (retval >= 0) {
 			adapter->vfinfo[vf].pf_set_mac = false;
 			memcpy(vf_mac_addr, mac, ETH_ALEN);
 		} else {
-			dev_warn(&adapter->pdev->dev, "Could NOT remove the VF MAC address.\n");
+			dev_warn(pci_dev_to_dev(adapter->pdev), "Could NOT remove the VF MAC address.\n");
 		}
 	} else {
 		retval = -EINVAL;
 	}
-
 	return retval;
 }
 
-static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf,
-				  u16 vlan, u8 qos)
+static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter,
+				   int vf, u16 vlan, u8 qos)
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 	int err;
@@ -1429,16 +1600,13 @@ static int ixgbe_enable_port_vlan(struct ixgbe_adapter *adapter, int vf,
 	if (hw->mac.type >= ixgbe_mac_X550)
 		ixgbe_write_qde(adapter, vf, IXGBE_QDE_ENABLE |
 				IXGBE_QDE_HIDE_VLAN);
-
 	adapter->vfinfo[vf].pf_vlan = vlan;
 	adapter->vfinfo[vf].pf_qos = qos;
-	dev_info(&adapter->pdev->dev,
+	dev_info(pci_dev_to_dev(adapter->pdev),
 		 "Setting VLAN %d, QOS 0x%x on VF %d\n", vlan, qos, vf);
 	if (test_bit(__IXGBE_DOWN, &adapter->state)) {
-		dev_warn(&adapter->pdev->dev,
-			 "The VF VLAN has been set, but the PF device is not up.\n");
-		dev_warn(&adapter->pdev->dev,
-			 "Bring the PF device up before attempting to use the VF device.\n");
+		dev_warn(pci_dev_to_dev(adapter->pdev), "The VF VLAN has been set, but the PF device is not up.\n");
+		dev_warn(pci_dev_to_dev(adapter->pdev), "Bring the PF device up before attempting to use the VF device.\n");
 	}
 
 out:
@@ -1467,18 +1635,28 @@ static int ixgbe_disable_port_vlan(struct ixgbe_adapter *adapter, int vf)
 	return err;
 }
 
+#ifdef IFLA_VF_VLAN_INFO_MAX
 int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan,
 			  u8 qos, __be16 vlan_proto)
+#else
+int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan, u8 qos)
+#endif
 {
 	int err = 0;
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 
-	if ((vf >= adapter->num_vfs) || (vlan > 4095) || (qos > 7))
+	/* VLAN IDs accepted range 0-4094 */
+	if (vf < 0 || vf >= adapter->num_vfs ||
+	    vlan > VLAN_VID_MASK - 1 || qos > 7)
 		return -EINVAL;
+
+#ifdef IFLA_VF_VLAN_INFO_MAX
 	if (vlan_proto != htons(ETH_P_8021Q))
 		return -EPROTONOSUPPORT;
+#endif
 	if (vlan || qos) {
-		/* Check if there is already a port VLAN set, if so
+		/*
+		 * Check if there is already a port VLAN set, if so
 		 * we have to delete the old one first before we
 		 * can set the new one.  The usage model had
 		 * previously assumed the user would delete the
@@ -1490,15 +1668,15 @@ int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int vf, u16 vlan,
 		if (err)
 			goto out;
 		err = ixgbe_enable_port_vlan(adapter, vf, vlan, qos);
+
 	} else {
 		err = ixgbe_disable_port_vlan(adapter, vf);
 	}
-
 out:
 	return err;
 }
 
-int ixgbe_link_mbps(struct ixgbe_adapter *adapter)
+static int ixgbe_link_mbps(struct ixgbe_adapter *adapter)
 {
 	switch (adapter->link_speed) {
 	case IXGBE_LINK_SPEED_100_FULL:
@@ -1574,7 +1752,7 @@ void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter)
 
 	if (ixgbe_link_mbps(adapter) != adapter->vf_rate_link_speed) {
 		adapter->vf_rate_link_speed = 0;
-		dev_info(&adapter->pdev->dev,
+		dev_info(pci_dev_to_dev(adapter->pdev),
 			 "Link speed has been changed. VF Transmit rate is disabled\n");
 	}
 
@@ -1586,14 +1764,20 @@ void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter)
 	}
 }
 
-int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,
+#ifdef HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
+int ixgbe_ndo_set_vf_bw(struct net_device *netdev,
+			int vf,
+			int __always_unused min_tx_rate,
 			int max_tx_rate)
+#else
+int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int max_tx_rate)
+#endif /* HAVE_NDO_SET_VF_MIN_MAX_TX_RATE */
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	int link_speed;
 
 	/* verify VF is active */
-	if (vf >= adapter->num_vfs)
+	if (vf < 0 || vf >= adapter->num_vfs)
 		return -EINVAL;
 
 	/* verify link is up */
@@ -1605,9 +1789,6 @@ int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,
 	if (link_speed != 10000)
 		return -EINVAL;
 
-	if (min_tx_rate)
-		return -EINVAL;
-
 	/* rate limit cannot be less than 10Mbs or greater than link speed */
 	if (max_tx_rate && ((max_tx_rate <= 10) || (max_tx_rate > link_speed)))
 		return -EINVAL;
@@ -1622,12 +1803,14 @@ int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,
 	return 0;
 }
 
+#endif /* IFLA_VF_MAX */
+#if IS_ENABLED(CONFIG_PCI_IOV)
 int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_hw *hw = &adapter->hw;
 
-	if (vf >= adapter->num_vfs)
+	if (vf < 0 || vf >= adapter->num_vfs)
 		return -EINVAL;
 
 	adapter->vfinfo[vf].spoofchk_enabled = setting;
@@ -1645,7 +1828,7 @@ int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)
 		IXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_LLDP),
 				(IXGBE_ETQF_FILTER_EN    |
 				 IXGBE_ETQF_TX_ANTISPOOF |
-				 ETH_P_LLDP));
+				 IXGBE_ETH_P_LLDP));
 
 		IXGBE_WRITE_REG(hw, IXGBE_ETQF(IXGBE_ETQF_FILTER_FC),
 				(IXGBE_ETQF_FILTER_EN |
@@ -1654,10 +1837,12 @@ int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting)
 
 		hw->mac.ops.set_ethertype_anti_spoofing(hw, setting, vf);
 	}
-
 	return 0;
 }
 
+#endif /* CONFIG_PCI_IOV */
+#ifdef IFLA_VF_MAX
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,
 				  bool setting)
 {
@@ -1670,7 +1855,7 @@ int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,
 	    adapter->hw.mac.type >= ixgbe_mac_X550)
 		return -EOPNOTSUPP;
 
-	if (vf >= adapter->num_vfs)
+	if (vf < 0 || vf >= adapter->num_vfs)
 		return -EINVAL;
 
 	adapter->vfinfo[vf].rss_query_enabled = setting;
@@ -1678,42 +1863,37 @@ int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,
 	return 0;
 }
 
-int ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting)
-{
-	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-
-	if (vf >= adapter->num_vfs)
-		return -EINVAL;
-
-	/* nothing to do */
-	if (adapter->vfinfo[vf].trusted == setting)
-		return 0;
-
-	adapter->vfinfo[vf].trusted = setting;
-
-	/* reset VF to reconfigure features */
-	adapter->vfinfo[vf].clear_to_send = false;
-	ixgbe_ping_vf(adapter, vf);
-
-	e_info(drv, "VF %u is %strusted\n", vf, setting ? "" : "not ");
-
-	return 0;
-}
-
+#endif
 int ixgbe_ndo_get_vf_config(struct net_device *netdev,
 			    int vf, struct ifla_vf_info *ivi)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	if (vf >= adapter->num_vfs)
+
+	if (vf < 0 || vf >= adapter->num_vfs)
 		return -EINVAL;
+
 	ivi->vf = vf;
 	memcpy(&ivi->mac, adapter->vfinfo[vf].vf_mac_addresses, ETH_ALEN);
+
+#ifdef HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
 	ivi->max_tx_rate = adapter->vfinfo[vf].tx_rate;
 	ivi->min_tx_rate = 0;
+#else
+	ivi->tx_rate = adapter->vfinfo[vf].tx_rate;
+#endif /* HAVE_NDO_SET_VF_MIN_MAX_TX_RATE */
+
 	ivi->vlan = adapter->vfinfo[vf].pf_vlan;
 	ivi->qos = adapter->vfinfo[vf].pf_qos;
+#ifdef HAVE_VF_SPOOFCHK_CONFIGURE
 	ivi->spoofchk = adapter->vfinfo[vf].spoofchk_enabled;
+#endif
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 	ivi->rss_query_en = adapter->vfinfo[vf].rss_query_enabled;
+#endif
+#ifdef HAVE_NDO_SET_VF_TRUST
 	ivi->trusted = adapter->vfinfo[vf].trusted;
+#endif
 	return 0;
 }
+#endif /* IFLA_VF_MAX */
+
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
index 3ec21923c89c..0c727b674ed6 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sriov.h
@@ -1,51 +1,71 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
 
 #ifndef _IXGBE_SRIOV_H_
 #define _IXGBE_SRIOV_H_
 
-/*  ixgbe driver limit the max number of VFs could be enabled to
- *  63 (IXGBE_MAX_VF_FUNCTIONS - 1)
+/* ixgbe driver limit the max number of VFs could be enabled to
+ * 63 (IXGBE_MAX_VF_FUNCTIONS - 1)
  */
 #define IXGBE_MAX_VFS_DRV_LIMIT  (IXGBE_MAX_VF_FUNCTIONS - 1)
-#define IXGBE_MAX_VFS_1TC		IXGBE_MAX_VF_FUNCTIONS
-#define IXGBE_MAX_VFS_4TC		32
-#define IXGBE_MAX_VFS_8TC		16
+#define IXGBE_MAX_VFS_1TC	 IXGBE_MAX_VFS_DRV_LIMIT
+#define IXGBE_MAX_VFS_4TC	 31
+#define IXGBE_MAX_VFS_8TC	 15
 
-#ifdef CONFIG_PCI_IOV
 void ixgbe_restore_vf_multicasts(struct ixgbe_adapter *adapter);
-#endif
+int ixgbe_set_vf_vlan(struct ixgbe_adapter *adapter, int add, int vid, u32 vf);
+void ixgbe_set_vmolr(struct ixgbe_hw *hw, u32 vf, bool aupe);
 void ixgbe_msg_task(struct ixgbe_adapter *adapter);
-int ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask);
+int ixgbe_set_vf_mac(struct ixgbe_adapter *adapter,
+		     int vf, unsigned char *mac_addr);
 void ixgbe_disable_tx_rx(struct ixgbe_adapter *adapter);
 void ixgbe_ping_all_vfs(struct ixgbe_adapter *adapter);
+#ifdef IFLA_VF_MAX
 int ixgbe_ndo_set_vf_mac(struct net_device *netdev, int queue, u8 *mac);
+#ifdef IFLA_VF_VLAN_INFO_MAX
 int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int queue, u16 vlan,
-			   u8 qos, __be16 vlan_proto);
-int ixgbe_link_mbps(struct ixgbe_adapter *adapter);
+			  u8 qos, __be16 vlan_proto);
+#else
+int ixgbe_ndo_set_vf_vlan(struct net_device *netdev, int queue, u16 vlan,
+			  u8 qos);
+#endif
+#ifdef HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
 int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int min_tx_rate,
 			int max_tx_rate);
-int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting);
+#else
+int ixgbe_ndo_set_vf_bw(struct net_device *netdev, int vf, int tx_rate);
+#endif /* HAVE_NDO_SET_VF_MIN_MAX_TX_RATE */
+#ifdef HAVE_NDO_SET_VF_RSS_QUERY_EN
 int ixgbe_ndo_set_vf_rss_query_en(struct net_device *netdev, int vf,
 				  bool setting);
+#endif
+#ifdef HAVE_NDO_SET_VF_TRUST
 int ixgbe_ndo_set_vf_trust(struct net_device *netdev, int vf, bool setting);
+#endif
 int ixgbe_ndo_get_vf_config(struct net_device *netdev,
 			    int vf, struct ifla_vf_info *ivi);
-void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter);
+#endif /* IFLA_VF_MAX */
 int ixgbe_disable_sriov(struct ixgbe_adapter *adapter);
 #ifdef CONFIG_PCI_IOV
-void ixgbe_enable_sriov(struct ixgbe_adapter *adapter, unsigned int max_vfs);
+int ixgbe_vf_configuration(struct pci_dev *pdev, unsigned int event_mask);
+void ixgbe_enable_sriov(struct ixgbe_adapter *adapter);
+int ixgbe_ndo_set_vf_spoofchk(struct net_device *netdev, int vf, bool setting);
 #endif
 int ixgbe_pci_sriov_configure(struct pci_dev *dev, int num_vfs);
+#ifdef IFLA_VF_MAX
+void ixgbe_check_vf_rate_limit(struct ixgbe_adapter *adapter);
+#endif /* IFLA_VF_MAX */
+void ixgbe_dump_registers(struct ixgbe_adapter *adapter);
 
-static inline void ixgbe_set_vmvir(struct ixgbe_adapter *adapter,
-				   u16 vid, u16 qos, u32 vf)
-{
-	struct ixgbe_hw *hw = &adapter->hw;
-	u32 vmvir = vid | (qos << VLAN_PRIO_SHIFT) | IXGBE_VMVIR_VLANA_DEFAULT;
-
-	IXGBE_WRITE_REG(hw, IXGBE_VMVIR(vf), vmvir);
-}
-
+/*
+ * These are defined in ixgbe_type.h on behalf of the VF driver
+ * but we need them here unwrapped for the PF driver.
+ */
+#define IXGBE_DEV_ID_82599_VF			0x10ED
+#define IXGBE_DEV_ID_X540_VF			0x1515
+#define IXGBE_DEV_ID_X550_VF			0x1565
+#define IXGBE_DEV_ID_X550EM_X_VF		0x15A8
+#define IXGBE_DEV_ID_X550EM_A_VF		0x15C5
 #endif /* _IXGBE_SRIOV_H_ */
 
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c
index 204844288c16..576f117b5fde 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_sysfs.c
@@ -1,30 +1,36 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #include "ixgbe.h"
 #include "ixgbe_common.h"
 #include "ixgbe_type.h"
 
+#ifdef IXGBE_SYSFS
+
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/sysfs.h>
 #include <linux/kobject.h>
 #include <linux/device.h>
 #include <linux/netdevice.h>
+#include <linux/time.h>
+#ifdef IXGBE_HWMON
 #include <linux/hwmon.h>
+#endif
 
+#ifdef IXGBE_HWMON
 /* hwmon callback functions */
-static ssize_t ixgbe_hwmon_show_location(struct device *dev,
+static ssize_t ixgbe_hwmon_show_location(struct device __always_unused *dev,
 					 struct device_attribute *attr,
 					 char *buf)
 {
 	struct hwmon_attr *ixgbe_attr = container_of(attr, struct hwmon_attr,
 						     dev_attr);
-	return sprintf(buf, "loc%u\n",
+	return snprintf(buf, PAGE_SIZE, "loc%u\n",
 		       ixgbe_attr->sensor->location);
 }
 
-static ssize_t ixgbe_hwmon_show_temp(struct device *dev,
+static ssize_t ixgbe_hwmon_show_temp(struct device __always_unused *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
@@ -40,10 +46,10 @@ static ssize_t ixgbe_hwmon_show_temp(struct device *dev,
 	/* display millidegree */
 	value *= 1000;
 
-	return sprintf(buf, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%u\n", value);
 }
 
-static ssize_t ixgbe_hwmon_show_cautionthresh(struct device *dev,
+static ssize_t ixgbe_hwmon_show_cautionthresh(struct device __always_unused *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
@@ -54,10 +60,10 @@ static ssize_t ixgbe_hwmon_show_cautionthresh(struct device *dev,
 	/* display millidegree */
 	value *= 1000;
 
-	return sprintf(buf, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%u\n", value);
 }
 
-static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev,
+static ssize_t ixgbe_hwmon_show_maxopthresh(struct device __always_unused *dev,
 				     struct device_attribute *attr,
 				     char *buf)
 {
@@ -68,7 +74,7 @@ static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev,
 	/* display millidegree */
 	value *= 1000;
 
-	return sprintf(buf, "%u\n", value);
+	return snprintf(buf, PAGE_SIZE, "%u\n", value);
 }
 
 /**
@@ -83,12 +89,18 @@ static ssize_t ixgbe_hwmon_show_maxopthresh(struct device *dev,
  */
 static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter,
 				unsigned int offset, int type) {
-	int rc;
 	unsigned int n_attr;
 	struct hwmon_attr *ixgbe_attr;
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 
 	n_attr = adapter->ixgbe_hwmon_buff->n_hwmon;
 	ixgbe_attr = &adapter->ixgbe_hwmon_buff->hwmon_list[n_attr];
+#else
+	int rc;
+
+	n_attr = adapter->ixgbe_hwmon_buff.n_hwmon;
+	ixgbe_attr = &adapter->ixgbe_hwmon_buff.hwmon_list[n_attr];
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
 
 	switch (type) {
 	case IXGBE_HWMON_TYPE_LOC:
@@ -112,8 +124,7 @@ static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter,
 			 "temp%u_crit", offset + 1);
 		break;
 	default:
-		rc = -EPERM;
-		return rc;
+		return -EPERM;
 	}
 
 	/* These always the same regardless of type */
@@ -123,6 +134,8 @@ static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter,
 	ixgbe_attr->dev_attr.store = NULL;
 	ixgbe_attr->dev_attr.attr.mode = 0444;
 	ixgbe_attr->dev_attr.attr.name = ixgbe_attr->name;
+
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	sysfs_attr_init(&ixgbe_attr->dev_attr.attr);
 
 	adapter->ixgbe_hwmon_buff->attrs[n_attr] = &ixgbe_attr->dev_attr.attr;
@@ -130,10 +143,38 @@ static int ixgbe_add_hwmon_attr(struct ixgbe_adapter *adapter,
 	++adapter->ixgbe_hwmon_buff->n_hwmon;
 
 	return 0;
+#else
+	rc = device_create_file(pci_dev_to_dev(adapter->pdev),
+				&ixgbe_attr->dev_attr);
+
+	if (rc == 0)
+		++adapter->ixgbe_hwmon_buff.n_hwmon;
+
+	return rc;
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
 }
+#endif /* IXGBE_HWMON */
 
-static void ixgbe_sysfs_del_adapter(struct ixgbe_adapter *adapter)
+static void ixgbe_sysfs_del_adapter(struct ixgbe_adapter __maybe_unused *adapter)
 {
+#ifdef IXGBE_HWMON
+#ifndef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
+	int i;
+
+	if (adapter == NULL)
+		return;
+
+	for (i = 0; i < adapter->ixgbe_hwmon_buff.n_hwmon; i++) {
+		device_remove_file(pci_dev_to_dev(adapter->pdev),
+			   &adapter->ixgbe_hwmon_buff.hwmon_list[i].dev_attr);
+	}
+
+	kfree(adapter->ixgbe_hwmon_buff.hwmon_list);
+
+	if (adapter->ixgbe_hwmon_buff.device)
+		hwmon_device_unregister(adapter->ixgbe_hwmon_buff.device);
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
+#endif /* IXGBE_HWMON */
 }
 
 /* called from ixgbe_main.c */
@@ -145,27 +186,52 @@ void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter)
 /* called from ixgbe_main.c */
 int ixgbe_sysfs_init(struct ixgbe_adapter *adapter)
 {
+	int rc = 0;
+#ifdef IXGBE_HWMON
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	struct hwmon_buff *ixgbe_hwmon;
 	struct device *hwmon_dev;
+#else
+	struct hwmon_buff *ixgbe_hwmon = &adapter->ixgbe_hwmon_buff;
+	int n_attrs;
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
 	unsigned int i;
-	int rc = 0;
+#endif /* IXGBE_HWMON */
 
+#ifdef IXGBE_HWMON
 	/* If this method isn't defined we don't support thermals */
 	if (adapter->hw.mac.ops.init_thermal_sensor_thresh == NULL) {
-		goto exit;
+		goto no_thermal;
 	}
 
 	/* Don't create thermal hwmon interface if no sensors present */
 	if (adapter->hw.mac.ops.init_thermal_sensor_thresh(&adapter->hw))
-		goto exit;
+		goto no_thermal;
 
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	ixgbe_hwmon = devm_kzalloc(&adapter->pdev->dev, sizeof(*ixgbe_hwmon),
 				   GFP_KERNEL);
-	if (ixgbe_hwmon == NULL) {
+
+	if (!ixgbe_hwmon) {
 		rc = -ENOMEM;
 		goto exit;
 	}
+
 	adapter->ixgbe_hwmon_buff = ixgbe_hwmon;
+#else
+	/*
+	 * Allocation space for max attributs
+	 * max num sensors * values (loc, temp, max, caution)
+	 */
+	n_attrs = IXGBE_MAX_SENSORS * 4;
+	ixgbe_hwmon->hwmon_list = kcalloc(n_attrs, sizeof(struct hwmon_attr),
+					  GFP_KERNEL);
+
+	if (!ixgbe_hwmon->hwmon_list) {
+		rc = -ENOMEM;
+		goto err;
+	}
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
 
 	for (i = 0; i < IXGBE_MAX_SENSORS; i++) {
 		/*
@@ -178,18 +244,19 @@ int ixgbe_sysfs_init(struct ixgbe_adapter *adapter)
 		/* Bail if any hwmon attr struct fails to initialize */
 		rc = ixgbe_add_hwmon_attr(adapter, i, IXGBE_HWMON_TYPE_CAUTION);
 		if (rc)
-			goto exit;
+			goto err;
 		rc = ixgbe_add_hwmon_attr(adapter, i, IXGBE_HWMON_TYPE_LOC);
 		if (rc)
-			goto exit;
+			goto err;
 		rc = ixgbe_add_hwmon_attr(adapter, i, IXGBE_HWMON_TYPE_TEMP);
 		if (rc)
-			goto exit;
+			goto err;
 		rc = ixgbe_add_hwmon_attr(adapter, i, IXGBE_HWMON_TYPE_MAX);
 		if (rc)
-			goto exit;
+			goto err;
 	}
 
+#ifdef HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
 	ixgbe_hwmon->groups[0] = &ixgbe_hwmon->group;
 	ixgbe_hwmon->group.attrs = ixgbe_hwmon->attrs;
 
@@ -197,9 +264,29 @@ int ixgbe_sysfs_init(struct ixgbe_adapter *adapter)
 							   "ixgbe",
 							   ixgbe_hwmon,
 							   ixgbe_hwmon->groups);
-	if (IS_ERR(hwmon_dev))
+
+	if (IS_ERR(hwmon_dev)) {
 		rc = PTR_ERR(hwmon_dev);
+		goto exit;
+	}
+
+#else
+	ixgbe_hwmon->device =
+		hwmon_device_register(pci_dev_to_dev(adapter->pdev));
+
+	if (IS_ERR(ixgbe_hwmon->device)) {
+		rc = PTR_ERR(ixgbe_hwmon->device);
+		goto err;
+	}
+
+#endif /* HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS */
+no_thermal:
+#endif /* IXGBE_HWMON */
+	goto exit;
+
+err:
+	ixgbe_sysfs_del_adapter(adapter);
 exit:
 	return rc;
 }
-
+#endif /* IXGBE_SYSFS */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h
index 2aeec78029bc..96462b46166b 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_txrx_common.h
@@ -1,49 +1,63 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_TXRX_COMMON_H_
 #define _IXGBE_TXRX_COMMON_H_
 
+#define IXGBE_TXD_CMD (IXGBE_TXD_CMD_EOP | \
+		      IXGBE_TXD_CMD_RS)
+
 #define IXGBE_XDP_PASS		0
 #define IXGBE_XDP_CONSUMED	BIT(0)
 #define IXGBE_XDP_TX		BIT(1)
 #define IXGBE_XDP_REDIR		BIT(2)
 
-#define IXGBE_TXD_CMD (IXGBE_TXD_CMD_EOP | \
-		       IXGBE_TXD_CMD_RS)
-
+#ifdef HAVE_XDP_SUPPORT
+#ifdef HAVE_XDP_FRAME_STRUCT
 int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
 			struct xdp_frame *xdpf);
-bool ixgbe_cleanup_headers(struct ixgbe_ring *rx_ring,
-			   union ixgbe_adv_rx_desc *rx_desc,
-			   struct sk_buff *skb);
-void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring,
-			      union ixgbe_adv_rx_desc *rx_desc,
-			      struct sk_buff *skb);
-void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector,
-		  struct sk_buff *skb);
+#else
+int ixgbe_xmit_xdp_ring(struct ixgbe_adapter *adapter,
+			struct xdp_buff *xdp);
+#endif
 void ixgbe_xdp_ring_update_tail(struct ixgbe_ring *ring);
-void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter, u64 qmask);
-
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
 void ixgbe_txrx_ring_disable(struct ixgbe_adapter *adapter, int ring);
 void ixgbe_txrx_ring_enable(struct ixgbe_adapter *adapter, int ring);
 
-struct xsk_buff_pool *ixgbe_xsk_pool(struct ixgbe_adapter *adapter,
-				     struct ixgbe_ring *ring);
-int ixgbe_xsk_pool_setup(struct ixgbe_adapter *adapter,
-			 struct xsk_buff_pool *pool,
+struct xdp_umem *ixgbe_xsk_umem(struct ixgbe_adapter *adapter,
+				struct ixgbe_ring *ring);
+int ixgbe_xsk_umem_setup(struct ixgbe_adapter *adapter, struct xdp_umem *umem,
 			 u16 qid);
 
 void ixgbe_zca_free(struct zero_copy_allocator *alloc, unsigned long handle);
 
-bool ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 cleaned_count);
+void ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 cleaned_count);
 int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 			  struct ixgbe_ring *rx_ring,
 			  const int budget);
 void ixgbe_xsk_clean_rx_ring(struct ixgbe_ring *rx_ring);
 bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector,
 			    struct ixgbe_ring *tx_ring, int napi_budget);
+#ifdef HAVE_NDO_XSK_WAKEUP
 int ixgbe_xsk_wakeup(struct net_device *dev, u32 queue_id, u32 flags);
+#else
+int ixgbe_xsk_async_xmit(struct net_device *dev, u32 queue_id);
+#endif
 void ixgbe_xsk_clean_tx_ring(struct ixgbe_ring *tx_ring);
+#endif
+#endif /* HAVE_XDP_SUPPORT */
 
-#endif /* #define _IXGBE_TXRX_COMMON_H_ */
+bool ixgbe_cleanup_headers(struct ixgbe_ring __maybe_unused *rx_ring,
+			   union ixgbe_adv_rx_desc *rx_desc,
+			   struct sk_buff *skb);
+void ixgbe_process_skb_fields(struct ixgbe_ring *rx_ring,
+			      union ixgbe_adv_rx_desc *rx_desc,
+			      struct sk_buff *skb);
+void ixgbe_rx_skb(struct ixgbe_q_vector *q_vector,
+		  struct ixgbe_ring *rx_ring,
+		  union ixgbe_adv_rx_desc *rx_desc,
+		  struct sk_buff *skb);
+
+void ixgbe_irq_rearm_queues(struct ixgbe_adapter *adapter, u64 qmask);
+#endif /* _IXGBE_TXRX_COMMON_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
index 2be1c4c72435..02a633c189c7 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_type.h
@@ -1,192 +1,250 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
 #ifndef _IXGBE_TYPE_H_
 #define _IXGBE_TYPE_H_
 
-#include <linux/types.h>
-#include <linux/mdio.h>
-#include <linux/netdevice.h>
+/*
+ * The following is a brief description of the error categories used by the
+ * ERROR_REPORT* macros.
+ *
+ * - IXGBE_ERROR_INVALID_STATE
+ * This category is for errors which represent a serious failure state that is
+ * unexpected, and could be potentially harmful to device operation. It should
+ * not be used for errors relating to issues that can be worked around or
+ * ignored.
+ *
+ * - IXGBE_ERROR_POLLING
+ * This category is for errors related to polling/timeout issues and should be
+ * used in any case where the timeout occurred, or a failure to obtain a lock, or
+ * failure to receive data within the time limit.
+ *
+ * - IXGBE_ERROR_CAUTION
+ * This category should be used for reporting issues that may be the cause of
+ * other errors, such as temperature warnings. It should indicate an event which
+ * could be serious, but hasn't necessarily caused problems yet.
+ *
+ * - IXGBE_ERROR_SOFTWARE
+ * This category is intended for errors due to software state preventing
+ * something. The category is not intended for errors due to bad arguments, or
+ * due to unsupported features. It should be used when a state occurs which
+ * prevents action but is not a serious issue.
+ *
+ * - IXGBE_ERROR_ARGUMENT
+ * This category is for when a bad or invalid argument is passed. It should be
+ * used whenever a function is called and error checking has detected the
+ * argument is wrong or incorrect.
+ *
+ * - IXGBE_ERROR_UNSUPPORTED
+ * This category is for errors which are due to unsupported circumstances or
+ * configuration issues. It should not be used when the issue is due to an
+ * invalid argument, but for when something has occurred that is unsupported
+ * (Ex: Flow control autonegotiation or an unsupported SFP+ module.)
+ */
+
+#include "ixgbe_osdep.h"
+
+/* Override this by setting IOMEM in your ixgbe_osdep.h header */
+#ifndef IOMEM
+#define IOMEM
+#endif
+
+/* Vendor ID */
+#define IXGBE_INTEL_VENDOR_ID			0x8086
 
 /* Device IDs */
-#define IXGBE_DEV_ID_82598               0x10B6
-#define IXGBE_DEV_ID_82598_BX            0x1508
-#define IXGBE_DEV_ID_82598AF_DUAL_PORT   0x10C6
-#define IXGBE_DEV_ID_82598AF_SINGLE_PORT 0x10C7
-#define IXGBE_DEV_ID_82598EB_SFP_LOM     0x10DB
-#define IXGBE_DEV_ID_82598AT             0x10C8
-#define IXGBE_DEV_ID_82598AT2            0x150B
-#define IXGBE_DEV_ID_82598EB_CX4         0x10DD
-#define IXGBE_DEV_ID_82598_CX4_DUAL_PORT 0x10EC
-#define IXGBE_DEV_ID_82598_DA_DUAL_PORT  0x10F1
-#define IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM      0x10E1
-#define IXGBE_DEV_ID_82598EB_XF_LR       0x10F4
-#define IXGBE_DEV_ID_82599_KX4           0x10F7
-#define IXGBE_DEV_ID_82599_KX4_MEZZ      0x1514
-#define IXGBE_DEV_ID_82599_KR            0x1517
-#define IXGBE_DEV_ID_82599_T3_LOM        0x151C
-#define IXGBE_DEV_ID_82599_CX4           0x10F9
-#define IXGBE_DEV_ID_82599_SFP           0x10FB
-#define IXGBE_DEV_ID_82599_BACKPLANE_FCOE       0x152a
-#define IXGBE_DEV_ID_82599_SFP_FCOE      0x1529
-#define IXGBE_SUBDEV_ID_82599_SFP        0x11A9
-#define IXGBE_SUBDEV_ID_82599_SFP_WOL0   0x1071
-#define IXGBE_SUBDEV_ID_82599_RNDC       0x1F72
-#define IXGBE_SUBDEV_ID_82599_560FLR     0x17D0
-#define IXGBE_SUBDEV_ID_82599_SP_560FLR  0x211B
+#define IXGBE_DEV_ID_82598			0x10B6
+#define IXGBE_DEV_ID_82598_BX			0x1508
+#define IXGBE_DEV_ID_82598AF_DUAL_PORT		0x10C6
+#define IXGBE_DEV_ID_82598AF_SINGLE_PORT	0x10C7
+#define IXGBE_DEV_ID_82598AT			0x10C8
+#define IXGBE_DEV_ID_82598AT2			0x150B
+#define IXGBE_DEV_ID_82598EB_SFP_LOM		0x10DB
+#define IXGBE_DEV_ID_82598EB_CX4		0x10DD
+#define IXGBE_DEV_ID_82598_CX4_DUAL_PORT	0x10EC
+#define IXGBE_DEV_ID_82598_DA_DUAL_PORT		0x10F1
+#define IXGBE_DEV_ID_82598_SR_DUAL_PORT_EM	0x10E1
+#define IXGBE_DEV_ID_82598EB_XF_LR		0x10F4
+#define IXGBE_DEV_ID_82599_KX4			0x10F7
+#define IXGBE_DEV_ID_82599_KX4_MEZZ		0x1514
+#define IXGBE_DEV_ID_82599_KR			0x1517
+#define IXGBE_DEV_ID_82599_COMBO_BACKPLANE	0x10F8
+#define IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ	0x000C
+#define IXGBE_DEV_ID_82599_CX4			0x10F9
+#define IXGBE_DEV_ID_82599_SFP			0x10FB
+#define IXGBE_SUBDEV_ID_82599_SFP		0x11A9
+#define IXGBE_SUBDEV_ID_82599_SFP_WOL0		0x1071
+#define IXGBE_SUBDEV_ID_82599_RNDC		0x1F72
+#define IXGBE_SUBDEV_ID_82599_560FLR		0x17D0
+#define IXGBE_SUBDEV_ID_82599_ECNA_DP		0x0470
+#define IXGBE_SUBDEV_ID_82599_SP_560FLR		0x211B
 #define IXGBE_SUBDEV_ID_82599_LOM_SNAP6		0x2159
 #define IXGBE_SUBDEV_ID_82599_SFP_1OCP		0x000D
 #define IXGBE_SUBDEV_ID_82599_SFP_2OCP		0x0008
 #define IXGBE_SUBDEV_ID_82599_SFP_LOM_OEM1	0x8976
 #define IXGBE_SUBDEV_ID_82599_SFP_LOM_OEM2	0x06EE
-#define IXGBE_SUBDEV_ID_82599_ECNA_DP    0x0470
-#define IXGBE_DEV_ID_82599_SFP_EM        0x1507
-#define IXGBE_DEV_ID_82599_SFP_SF2       0x154D
-#define IXGBE_DEV_ID_82599EN_SFP         0x1557
-#define IXGBE_SUBDEV_ID_82599EN_SFP_OCP1 0x0001
-#define IXGBE_DEV_ID_82599_XAUI_LOM      0x10FC
-#define IXGBE_DEV_ID_82599_COMBO_BACKPLANE 0x10F8
-#define IXGBE_SUBDEV_ID_82599_KX4_KR_MEZZ  0x000C
-#define IXGBE_DEV_ID_82599_LS            0x154F
-#define IXGBE_DEV_ID_X540T               0x1528
-#define IXGBE_DEV_ID_82599_SFP_SF_QP     0x154A
-#define IXGBE_DEV_ID_82599_QSFP_SF_QP    0x1558
-#define IXGBE_DEV_ID_X540T1              0x1560
-
-#define IXGBE_DEV_ID_X550T		0x1563
-#define IXGBE_DEV_ID_X550T1		0x15D1
-#define IXGBE_DEV_ID_X550EM_X_KX4	0x15AA
-#define IXGBE_DEV_ID_X550EM_X_KR	0x15AB
-#define IXGBE_DEV_ID_X550EM_X_SFP	0x15AC
-#define IXGBE_DEV_ID_X550EM_X_10G_T	0x15AD
-#define IXGBE_DEV_ID_X550EM_X_1G_T	0x15AE
-#define IXGBE_DEV_ID_X550EM_X_XFI	0x15B0
-#define IXGBE_DEV_ID_X550EM_A_KR	0x15C2
-#define IXGBE_DEV_ID_X550EM_A_KR_L	0x15C3
-#define IXGBE_DEV_ID_X550EM_A_SFP_N	0x15C4
-#define IXGBE_DEV_ID_X550EM_A_SGMII	0x15C6
-#define IXGBE_DEV_ID_X550EM_A_SGMII_L	0x15C7
-#define IXGBE_DEV_ID_X550EM_A_10G_T	0x15C8
-#define IXGBE_DEV_ID_X550EM_A_SFP	0x15CE
-#define IXGBE_DEV_ID_X550EM_A_1G_T	0x15E4
-#define IXGBE_DEV_ID_X550EM_A_1G_T_L	0x15E5
-
-/* VF Device IDs */
-#define IXGBE_DEV_ID_82599_VF		0x10ED
-#define IXGBE_DEV_ID_X540_VF		0x1515
-#define IXGBE_DEV_ID_X550_VF		0x1565
-#define IXGBE_DEV_ID_X550EM_X_VF	0x15A8
-#define IXGBE_DEV_ID_X550EM_A_VF	0x15C5
-
-#define IXGBE_CAT(r, m)	IXGBE_##r##_##m
-
-#define IXGBE_BY_MAC(_hw, r)	((_hw)->mvals[IXGBE_CAT(r, IDX)])
+#define IXGBE_DEV_ID_82599_BACKPLANE_FCOE	0x152A
+#define IXGBE_DEV_ID_82599_SFP_FCOE		0x1529
+#define IXGBE_DEV_ID_82599_SFP_EM		0x1507
+#define IXGBE_DEV_ID_82599_SFP_SF2		0x154D
+#define IXGBE_DEV_ID_82599_SFP_SF_QP		0x154A
+#define IXGBE_DEV_ID_82599_QSFP_SF_QP		0x1558
+#define IXGBE_DEV_ID_82599EN_SFP		0x1557
+#define IXGBE_SUBDEV_ID_82599EN_SFP_OCP1	0x0001
+#define IXGBE_DEV_ID_82599_XAUI_LOM		0x10FC
+#define IXGBE_DEV_ID_82599_T3_LOM		0x151C
+#define IXGBE_DEV_ID_X540T			0x1528
+#define IXGBE_DEV_ID_X540T1			0x1560
+#define IXGBE_DEV_ID_X550T			0x1563
+#define IXGBE_DEV_ID_X550T1			0x15D1
+/* Placeholder value, pending official value. */
+#define IXGBE_DEV_ID_X550EM_A_KR		0x15C2
+#define IXGBE_DEV_ID_X550EM_A_KR_L		0x15C3
+#define IXGBE_DEV_ID_X550EM_A_SFP_N		0x15C4
+#define IXGBE_DEV_ID_X550EM_A_SGMII		0x15C6
+#define IXGBE_DEV_ID_X550EM_A_SGMII_L		0x15C7
+#define IXGBE_DEV_ID_X550EM_A_10G_T		0x15C8
+#define IXGBE_DEV_ID_X550EM_A_QSFP		0x15CA
+#define IXGBE_DEV_ID_X550EM_A_QSFP_N		0x15CC
+#define IXGBE_DEV_ID_X550EM_A_SFP		0x15CE
+#define IXGBE_DEV_ID_X550EM_A_1G_T		0x15E4
+#define IXGBE_DEV_ID_X550EM_A_1G_T_L		0x15E5
+#define IXGBE_DEV_ID_X550EM_X_KX4		0x15AA
+#define IXGBE_DEV_ID_X550EM_X_KR		0x15AB
+#define IXGBE_DEV_ID_X550EM_X_SFP		0x15AC
+#define IXGBE_DEV_ID_X550EM_X_10G_T		0x15AD
+#define IXGBE_DEV_ID_X550EM_X_1G_T		0x15AE
+#define IXGBE_DEV_ID_X550EM_X_XFI		0x15B0
+
+#define IXGBE_CAT(r,m) IXGBE_##r##m
+
+#define IXGBE_BY_MAC(_hw, r) ((_hw)->mvals[IXGBE_CAT(r, _IDX)])
 
 /* General Registers */
-#define IXGBE_CTRL      0x00000
-#define IXGBE_STATUS    0x00008
-#define IXGBE_CTRL_EXT  0x00018
-#define IXGBE_ESDP      0x00020
-#define IXGBE_EODSDP    0x00028
-
-#define IXGBE_I2CCTL_8259X	0x00028
-#define IXGBE_I2CCTL_X540	IXGBE_I2CCTL_8259X
+#define IXGBE_CTRL		0x00000
+#define IXGBE_STATUS		0x00008
+#define IXGBE_CTRL_EXT		0x00018
+#define IXGBE_ESDP		0x00020
+#define IXGBE_EODSDP		0x00028
+#define IXGBE_I2CCTL_82599	0x00028
+#define IXGBE_I2CCTL		IXGBE_I2CCTL_82599
+#define IXGBE_I2CCTL_X540	IXGBE_I2CCTL_82599
 #define IXGBE_I2CCTL_X550	0x15F5C
 #define IXGBE_I2CCTL_X550EM_x	IXGBE_I2CCTL_X550
 #define IXGBE_I2CCTL_X550EM_a	IXGBE_I2CCTL_X550
-#define IXGBE_I2CCTL(_hw)	IXGBE_BY_MAC((_hw), I2CCTL)
-
-#define IXGBE_LEDCTL    0x00200
-#define IXGBE_FRTIMER   0x00048
-#define IXGBE_TCPTIMER  0x0004C
-#define IXGBE_CORESPARE 0x00600
-#define IXGBE_EXVET     0x05078
+#define IXGBE_I2CCTL_BY_MAC(_hw) IXGBE_BY_MAC((_hw), I2CCTL)
+#define IXGBE_PHY_GPIO		0x00028
+#define IXGBE_MAC_GPIO		0x00030
+#define IXGBE_PHYINT_STATUS0	0x00100
+#define IXGBE_PHYINT_STATUS1	0x00104
+#define IXGBE_PHYINT_STATUS2	0x00108
+#define IXGBE_LEDCTL		0x00200
+#define IXGBE_FRTIMER		0x00048
+#define IXGBE_TCPTIMER		0x0004C
+#define IXGBE_CORESPARE		0x00600
+#define IXGBE_EXVET		0x05078
 
 /* NVM Registers */
-#define IXGBE_EEC_8259X		0x10010
-#define IXGBE_EEC_X540		IXGBE_EEC_8259X
-#define IXGBE_EEC_X550		IXGBE_EEC_8259X
-#define IXGBE_EEC_X550EM_x	IXGBE_EEC_8259X
+#define IXGBE_EEC		0x10010
+#define IXGBE_EEC_X540		IXGBE_EEC
+#define IXGBE_EEC_X550		IXGBE_EEC
+#define IXGBE_EEC_X550EM_x	IXGBE_EEC
 #define IXGBE_EEC_X550EM_a	0x15FF8
-#define IXGBE_EEC(_hw)		IXGBE_BY_MAC((_hw), EEC)
-#define IXGBE_EERD      0x10014
-#define IXGBE_EEWR      0x10018
-#define IXGBE_FLA_8259X		0x1001C
-#define IXGBE_FLA_X540		IXGBE_FLA_8259X
-#define IXGBE_FLA_X550		IXGBE_FLA_8259X
-#define IXGBE_FLA_X550EM_x	IXGBE_FLA_8259X
+#define IXGBE_EEC_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), EEC)
+
+#define IXGBE_EERD		0x10014
+#define IXGBE_EEWR		0x10018
+
+#define IXGBE_FLA		0x1001C
+#define IXGBE_FLA_X540		IXGBE_FLA
+#define IXGBE_FLA_X550		IXGBE_FLA
+#define IXGBE_FLA_X550EM_x	IXGBE_FLA
 #define IXGBE_FLA_X550EM_a	0x15F68
-#define IXGBE_FLA(_hw)		IXGBE_BY_MAC((_hw), FLA)
-#define IXGBE_EEMNGCTL  0x10110
-#define IXGBE_EEMNGDATA 0x10114
-#define IXGBE_FLMNGCTL  0x10118
-#define IXGBE_FLMNGDATA 0x1011C
-#define IXGBE_FLMNGCNT  0x10120
-#define IXGBE_FLOP      0x1013C
-#define IXGBE_GRC_8259X		0x10200
-#define IXGBE_GRC_X540		IXGBE_GRC_8259X
-#define IXGBE_GRC_X550		IXGBE_GRC_8259X
-#define IXGBE_GRC_X550EM_x	IXGBE_GRC_8259X
+#define IXGBE_FLA_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), FLA)
+#define IXGBE_FLA_FL_SIZE_SHIFT_X540	17
+#define IXGBE_FLA_FL_SIZE_SHIFT_X550	12
+#define IXGBE_FLA_FL_SIZE_MASK_X540	(0x7 << IXGBE_FLA_FL_SIZE_SHIFT_X540)
+#define IXGBE_FLA_FL_SIZE_MASK_X550	(0x7 << IXGBE_FLA_FL_SIZE_SHIFT_X550)
+
+#define IXGBE_EEMNGCTL	0x10110
+#define IXGBE_EEMNGDATA	0x10114
+#define IXGBE_FLMNGCTL	0x10118
+#define IXGBE_FLMNGDATA	0x1011C
+#define IXGBE_FLMNGCNT	0x10120
+#define IXGBE_FLOP	0x1013C
+
+#define IXGBE_GRC		0x10200
+#define IXGBE_GRC_X540		IXGBE_GRC
+#define IXGBE_GRC_X550		IXGBE_GRC
+#define IXGBE_GRC_X550EM_x	IXGBE_GRC
 #define IXGBE_GRC_X550EM_a	0x15F64
-#define IXGBE_GRC(_hw)		IXGBE_BY_MAC((_hw), GRC)
+#define IXGBE_GRC_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), GRC)
+
+#define IXGBE_SRAMREL		0x10210
+#define IXGBE_SRAMREL_X540	IXGBE_SRAMREL
+#define IXGBE_SRAMREL_X550	IXGBE_SRAMREL
+#define IXGBE_SRAMREL_X550EM_x	IXGBE_SRAMREL
+#define IXGBE_SRAMREL_X550EM_a	0x15F6C
+#define IXGBE_SRAMREL_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SRAMREL)
+
+#define IXGBE_PHYDBG	0x10218
 
 /* General Receive Control */
-#define IXGBE_GRC_MNG  0x00000001 /* Manageability Enable */
-#define IXGBE_GRC_APME 0x00000002 /* APM enabled in EEPROM */
+#define IXGBE_GRC_MNG	0x00000001 /* Manageability Enable */
+#define IXGBE_GRC_APME	0x00000002 /* APM enabled in EEPROM */
 
-#define IXGBE_VPDDIAG0  0x10204
-#define IXGBE_VPDDIAG1  0x10208
+#define IXGBE_VPDDIAG0	0x10204
+#define IXGBE_VPDDIAG1	0x10208
 
 /* I2CCTL Bit Masks */
-#define IXGBE_I2C_CLK_IN_8259X		0x00000001
-#define IXGBE_I2C_CLK_IN_X540		IXGBE_I2C_CLK_IN_8259X
+#define IXGBE_I2C_CLK_IN		0x00000001
+#define IXGBE_I2C_CLK_IN_X540		IXGBE_I2C_CLK_IN
 #define IXGBE_I2C_CLK_IN_X550		0x00004000
 #define IXGBE_I2C_CLK_IN_X550EM_x	IXGBE_I2C_CLK_IN_X550
 #define IXGBE_I2C_CLK_IN_X550EM_a	IXGBE_I2C_CLK_IN_X550
-#define IXGBE_I2C_CLK_IN(_hw)		IXGBE_BY_MAC((_hw), I2C_CLK_IN)
+#define IXGBE_I2C_CLK_IN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), I2C_CLK_IN)
 
-#define IXGBE_I2C_CLK_OUT_8259X		0x00000002
-#define IXGBE_I2C_CLK_OUT_X540		IXGBE_I2C_CLK_OUT_8259X
+#define IXGBE_I2C_CLK_OUT		0x00000002
+#define IXGBE_I2C_CLK_OUT_X540		IXGBE_I2C_CLK_OUT
 #define IXGBE_I2C_CLK_OUT_X550		0x00000200
 #define IXGBE_I2C_CLK_OUT_X550EM_x	IXGBE_I2C_CLK_OUT_X550
 #define IXGBE_I2C_CLK_OUT_X550EM_a	IXGBE_I2C_CLK_OUT_X550
-#define IXGBE_I2C_CLK_OUT(_hw)		IXGBE_BY_MAC((_hw), I2C_CLK_OUT)
+#define IXGBE_I2C_CLK_OUT_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), I2C_CLK_OUT)
 
-#define IXGBE_I2C_DATA_IN_8259X		0x00000004
-#define IXGBE_I2C_DATA_IN_X540		IXGBE_I2C_DATA_IN_8259X
+#define IXGBE_I2C_DATA_IN		0x00000004
+#define IXGBE_I2C_DATA_IN_X540		IXGBE_I2C_DATA_IN
 #define IXGBE_I2C_DATA_IN_X550		0x00001000
 #define IXGBE_I2C_DATA_IN_X550EM_x	IXGBE_I2C_DATA_IN_X550
 #define IXGBE_I2C_DATA_IN_X550EM_a	IXGBE_I2C_DATA_IN_X550
-#define IXGBE_I2C_DATA_IN(_hw)		IXGBE_BY_MAC((_hw), I2C_DATA_IN)
+#define IXGBE_I2C_DATA_IN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), I2C_DATA_IN)
 
-#define IXGBE_I2C_DATA_OUT_8259X	0x00000008
-#define IXGBE_I2C_DATA_OUT_X540		IXGBE_I2C_DATA_OUT_8259X
+#define IXGBE_I2C_DATA_OUT		0x00000008
+#define IXGBE_I2C_DATA_OUT_X540		IXGBE_I2C_DATA_OUT
 #define IXGBE_I2C_DATA_OUT_X550		0x00000400
 #define IXGBE_I2C_DATA_OUT_X550EM_x	IXGBE_I2C_DATA_OUT_X550
 #define IXGBE_I2C_DATA_OUT_X550EM_a	IXGBE_I2C_DATA_OUT_X550
-#define IXGBE_I2C_DATA_OUT(_hw)		IXGBE_BY_MAC((_hw), I2C_DATA_OUT)
+#define IXGBE_I2C_DATA_OUT_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), I2C_DATA_OUT)
 
-#define IXGBE_I2C_DATA_OE_N_EN_8259X	0
-#define IXGBE_I2C_DATA_OE_N_EN_X540	IXGBE_I2C_DATA_OE_N_EN_8259X
+#define IXGBE_I2C_DATA_OE_N_EN		0
+#define IXGBE_I2C_DATA_OE_N_EN_X540	IXGBE_I2C_DATA_OE_N_EN
 #define IXGBE_I2C_DATA_OE_N_EN_X550	0x00000800
 #define IXGBE_I2C_DATA_OE_N_EN_X550EM_x	IXGBE_I2C_DATA_OE_N_EN_X550
 #define IXGBE_I2C_DATA_OE_N_EN_X550EM_a	IXGBE_I2C_DATA_OE_N_EN_X550
-#define IXGBE_I2C_DATA_OE_N_EN(_hw)	IXGBE_BY_MAC((_hw), I2C_DATA_OE_N_EN)
+#define IXGBE_I2C_DATA_OE_N_EN_BY_MAC(_hw) IXGBE_BY_MAC((_hw), I2C_DATA_OE_N_EN)
 
-#define IXGBE_I2C_BB_EN_8259X		0
-#define IXGBE_I2C_BB_EN_X540		IXGBE_I2C_BB_EN_8259X
+#define IXGBE_I2C_BB_EN			0
+#define IXGBE_I2C_BB_EN_X540		IXGBE_I2C_BB_EN
 #define IXGBE_I2C_BB_EN_X550		0x00000100
 #define IXGBE_I2C_BB_EN_X550EM_x	IXGBE_I2C_BB_EN_X550
 #define IXGBE_I2C_BB_EN_X550EM_a	IXGBE_I2C_BB_EN_X550
-#define IXGBE_I2C_BB_EN(_hw)		IXGBE_BY_MAC((_hw), I2C_BB_EN)
+#define IXGBE_I2C_BB_EN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), I2C_BB_EN)
 
-#define IXGBE_I2C_CLK_OE_N_EN_8259X	0
-#define IXGBE_I2C_CLK_OE_N_EN_X540	IXGBE_I2C_CLK_OE_N_EN_8259X
+#define IXGBE_I2C_CLK_OE_N_EN		0
+#define IXGBE_I2C_CLK_OE_N_EN_X540	IXGBE_I2C_CLK_OE_N_EN
 #define IXGBE_I2C_CLK_OE_N_EN_X550	0x00002000
 #define IXGBE_I2C_CLK_OE_N_EN_X550EM_x	IXGBE_I2C_CLK_OE_N_EN_X550
 #define IXGBE_I2C_CLK_OE_N_EN_X550EM_a	IXGBE_I2C_CLK_OE_N_EN_X550
-#define IXGBE_I2C_CLK_OE_N_EN(_hw)	 IXGBE_BY_MAC((_hw), I2C_CLK_OE_N_EN)
-
+#define IXGBE_I2C_CLK_OE_N_EN_BY_MAC(_hw) IXGBE_BY_MAC((_hw), I2C_CLK_OE_N_EN)
 #define IXGBE_I2C_CLOCK_STRETCHING_TIMEOUT	500
 
 #define IXGBE_I2C_THERMAL_SENSOR_ADDR	0xF8
@@ -216,21 +274,21 @@ struct ixgbe_thermal_sensor_data {
 #define NVM_OROM_PATCH_MASK	0xFF
 #define NVM_OROM_SHIFT		8
 
-#define NVM_VER_MASK		0x00FF	/* version mask */
-#define NVM_VER_SHIFT		8	/* version bit shift */
-#define NVM_OEM_PROD_VER_PTR	0x1B /* OEM Product version block pointer */
-#define NVM_OEM_PROD_VER_CAP_OFF 0x1 /* OEM Product version format offset */
-#define NVM_OEM_PROD_VER_OFF_L	0x2  /* OEM Product version offset low */
-#define NVM_OEM_PROD_VER_OFF_H	0x3  /* OEM Product version offset high */
+#define NVM_VER_MASK		0x00FF /* version mask */
+#define NVM_VER_SHIFT		8     /* version bit shift */
+#define NVM_OEM_PROD_VER_PTR	0x1B  /* OEM Product version block pointer */
+#define NVM_OEM_PROD_VER_CAP_OFF 0x1  /* OEM Product version format offset */
+#define NVM_OEM_PROD_VER_OFF_L	0x2   /* OEM Product version offset low */
+#define NVM_OEM_PROD_VER_OFF_H	0x3   /* OEM Product version offset high */
 #define NVM_OEM_PROD_VER_CAP_MASK 0xF /* OEM Product version cap mask */
-#define NVM_OEM_PROD_VER_MOD_LEN 0x3 /* OEM Product version module length */
-#define NVM_ETK_OFF_LOW		0x2D /* version low order word */
-#define NVM_ETK_OFF_HI		0x2E /* version high order word */
-#define NVM_ETK_SHIFT		16   /* high version word shift */
+#define NVM_OEM_PROD_VER_MOD_LEN 0x3  /* OEM Product version module length */
+#define NVM_ETK_OFF_LOW		0x2D  /* version low order word */
+#define NVM_ETK_OFF_HI		0x2E  /* version high order word */
+#define NVM_ETK_SHIFT		16    /* high version word shift */
 #define NVM_VER_INVALID		0xFFFF
 #define NVM_ETK_VALID		0x8000
 #define NVM_INVALID_PTR		0xFFFF
-#define NVM_VER_SIZE		32   /* version sting size */
+#define NVM_VER_SIZE		32    /* version sting size */
 
 struct ixgbe_nvm_version {
 	u32 etk_id;
@@ -247,165 +305,180 @@ struct ixgbe_nvm_version {
 	u8  or_major;
 	u16 or_build;
 	u8  or_patch;
+
 };
 
 /* Interrupt Registers */
-#define IXGBE_EICR      0x00800
-#define IXGBE_EICS      0x00808
-#define IXGBE_EIMS      0x00880
-#define IXGBE_EIMC      0x00888
-#define IXGBE_EIAC      0x00810
-#define IXGBE_EIAM      0x00890
-#define IXGBE_EICS_EX(_i)   (0x00A90 + (_i) * 4)
-#define IXGBE_EIMS_EX(_i)   (0x00AA0 + (_i) * 4)
-#define IXGBE_EIMC_EX(_i)   (0x00AB0 + (_i) * 4)
-#define IXGBE_EIAM_EX(_i)   (0x00AD0 + (_i) * 4)
+#define IXGBE_EICR		0x00800
+#define IXGBE_EICS		0x00808
+#define IXGBE_EIMS		0x00880
+#define IXGBE_EIMC		0x00888
+#define IXGBE_EIAC		0x00810
+#define IXGBE_EIAM		0x00890
+#define IXGBE_EICS_EX(_i)	(0x00A90 + (_i) * 4)
+#define IXGBE_EIMS_EX(_i)	(0x00AA0 + (_i) * 4)
+#define IXGBE_EIMC_EX(_i)	(0x00AB0 + (_i) * 4)
+#define IXGBE_EIAM_EX(_i)	(0x00AD0 + (_i) * 4)
+/* 82599 EITR is only 12 bits, with the lower 3 always zero */
 /*
  * 82598 EITR is 16 bits but set the limits based on the max
- * supported by all ixgbe hardware.  82599 EITR is only 12 bits,
- * with the lower 3 always zero.
+ * supported by all ixgbe hardware
  */
-#define IXGBE_MAX_INT_RATE 488281
-#define IXGBE_MIN_INT_RATE 956
-#define IXGBE_MAX_EITR     0x00000FF8
-#define IXGBE_MIN_EITR     8
-#define IXGBE_EITR(_i)  (((_i) <= 23) ? (0x00820 + ((_i) * 4)) : \
-			 (0x012300 + (((_i) - 24) * 4)))
-#define IXGBE_EITR_ITR_INT_MASK 0x00000FF8
-#define IXGBE_EITR_LLI_MOD      0x00008000
-#define IXGBE_EITR_CNT_WDIS     0x80000000
-#define IXGBE_IVAR(_i)  (0x00900 + ((_i) * 4)) /* 24 at 0x900-0x960 */
-#define IXGBE_IVAR_MISC 0x00A00 /* misc MSI-X interrupt causes */
-#define IXGBE_EITRSEL   0x00894
-#define IXGBE_MSIXT     0x00000 /* MSI-X Table. 0x0000 - 0x01C */
-#define IXGBE_MSIXPBA   0x02000 /* MSI-X Pending bit array */
-#define IXGBE_PBACL(_i) (((_i) == 0) ? (0x11068) : (0x110C0 + ((_i) * 4)))
-#define IXGBE_GPIE      0x00898
+#define IXGBE_MAX_INT_RATE	488281
+#define IXGBE_MIN_INT_RATE	956
+#define IXGBE_MAX_EITR		0x00000FF8
+#define IXGBE_MIN_EITR		8
+#define IXGBE_EITR(_i)		(((_i) <= 23) ? (0x00820 + ((_i) * 4)) : \
+				 (0x012300 + (((_i) - 24) * 4)))
+#define IXGBE_EITR_ITR_INT_MASK	0x00000FF8
+#define IXGBE_EITR_LLI_MOD	0x00008000
+#define IXGBE_EITR_CNT_WDIS	0x80000000
+#define IXGBE_IVAR(_i)		(0x00900 + ((_i) * 4)) /* 24 at 0x900-0x960 */
+#define IXGBE_IVAR_MISC		0x00A00 /* misc MSI-X interrupt causes */
+#define IXGBE_EITRSEL		0x00894
+#define IXGBE_MSIXT		0x00000 /* MSI-X Table. 0x0000 - 0x01C */
+#define IXGBE_MSIXPBA		0x02000 /* MSI-X Pending bit array */
+#define IXGBE_PBACL(_i)	(((_i) == 0) ? (0x11068) : (0x110C0 + ((_i) * 4)))
+#define IXGBE_GPIE		0x00898
 
 /* Flow Control Registers */
-#define IXGBE_FCADBUL   0x03210
-#define IXGBE_FCADBUH   0x03214
-#define IXGBE_FCAMACL   0x04328
-#define IXGBE_FCAMACH   0x0432C
-#define IXGBE_FCRTH_82599(_i) (0x03260 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_FCRTL_82599(_i) (0x03220 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_PFCTOP    0x03008
-#define IXGBE_FCTTV(_i) (0x03200 + ((_i) * 4)) /* 4 of these (0-3) */
-#define IXGBE_FCRTL(_i) (0x03220 + ((_i) * 8)) /* 8 of these (0-7) */
-#define IXGBE_FCRTH(_i) (0x03260 + ((_i) * 8)) /* 8 of these (0-7) */
-#define IXGBE_FCRTV     0x032A0
-#define IXGBE_FCCFG     0x03D00
-#define IXGBE_TFCS      0x0CE00
+#define IXGBE_FCADBUL		0x03210
+#define IXGBE_FCADBUH		0x03214
+#define IXGBE_FCAMACL		0x04328
+#define IXGBE_FCAMACH		0x0432C
+#define IXGBE_FCRTH_82599(_i)	(0x03260 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_FCRTL_82599(_i)	(0x03220 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_PFCTOP		0x03008
+#define IXGBE_FCTTV(_i)		(0x03200 + ((_i) * 4)) /* 4 of these (0-3) */
+#define IXGBE_FCRTL(_i)		(0x03220 + ((_i) * 8)) /* 8 of these (0-7) */
+#define IXGBE_FCRTH(_i)		(0x03260 + ((_i) * 8)) /* 8 of these (0-7) */
+#define IXGBE_FCRTV		0x032A0
+#define IXGBE_FCCFG		0x03D00
+#define IXGBE_TFCS		0x0CE00
 
 /* Receive DMA Registers */
-#define IXGBE_RDBAL(_i) (((_i) < 64) ? (0x01000 + ((_i) * 0x40)) : \
+#define IXGBE_RDBAL(_i)	(((_i) < 64) ? (0x01000 + ((_i) * 0x40)) : \
 			 (0x0D000 + (((_i) - 64) * 0x40)))
-#define IXGBE_RDBAH(_i) (((_i) < 64) ? (0x01004 + ((_i) * 0x40)) : \
+#define IXGBE_RDBAH(_i)	(((_i) < 64) ? (0x01004 + ((_i) * 0x40)) : \
 			 (0x0D004 + (((_i) - 64) * 0x40)))
-#define IXGBE_RDLEN(_i) (((_i) < 64) ? (0x01008 + ((_i) * 0x40)) : \
+#define IXGBE_RDLEN(_i)	(((_i) < 64) ? (0x01008 + ((_i) * 0x40)) : \
 			 (0x0D008 + (((_i) - 64) * 0x40)))
-#define IXGBE_RDH(_i)   (((_i) < 64) ? (0x01010 + ((_i) * 0x40)) : \
+#define IXGBE_RDH(_i)	(((_i) < 64) ? (0x01010 + ((_i) * 0x40)) : \
 			 (0x0D010 + (((_i) - 64) * 0x40)))
-#define IXGBE_RDT(_i)   (((_i) < 64) ? (0x01018 + ((_i) * 0x40)) : \
+#define IXGBE_RDT(_i)	(((_i) < 64) ? (0x01018 + ((_i) * 0x40)) : \
 			 (0x0D018 + (((_i) - 64) * 0x40)))
-#define IXGBE_RXDCTL(_i) (((_i) < 64) ? (0x01028 + ((_i) * 0x40)) : \
-			 (0x0D028 + (((_i) - 64) * 0x40)))
-#define IXGBE_RSCCTL(_i) (((_i) < 64) ? (0x0102C + ((_i) * 0x40)) : \
-			 (0x0D02C + (((_i) - 64) * 0x40)))
-#define IXGBE_RSCDBU     0x03028
-#define IXGBE_RDDCC      0x02F20
-#define IXGBE_RXMEMWRAP  0x03190
-#define IXGBE_STARCTRL   0x03024
+#define IXGBE_RXDCTL(_i)	(((_i) < 64) ? (0x01028 + ((_i) * 0x40)) : \
+				 (0x0D028 + (((_i) - 64) * 0x40)))
+#define IXGBE_RSCCTL(_i)	(((_i) < 64) ? (0x0102C + ((_i) * 0x40)) : \
+				 (0x0D02C + (((_i) - 64) * 0x40)))
+#define IXGBE_RSCDBU	0x03028
+#define IXGBE_RDDCC	0x02F20
+#define IXGBE_RXMEMWRAP	0x03190
+#define IXGBE_STARCTRL	0x03024
 /*
  * Split and Replication Receive Control Registers
  * 00-15 : 0x02100 + n*4
  * 16-64 : 0x01014 + n*0x40
  * 64-127: 0x0D014 + (n-64)*0x40
  */
-#define IXGBE_SRRCTL(_i) (((_i) <= 15) ? (0x02100 + ((_i) * 4)) : \
-			  (((_i) < 64) ? (0x01014 + ((_i) * 0x40)) : \
-			  (0x0D014 + (((_i) - 64) * 0x40))))
+#define IXGBE_SRRCTL(_i)	(((_i) <= 15) ? (0x02100 + ((_i) * 4)) : \
+				 (((_i) < 64) ? (0x01014 + ((_i) * 0x40)) : \
+				 (0x0D014 + (((_i) - 64) * 0x40))))
 /*
  * Rx DCA Control Register:
  * 00-15 : 0x02200 + n*4
  * 16-64 : 0x0100C + n*0x40
  * 64-127: 0x0D00C + (n-64)*0x40
  */
-#define IXGBE_DCA_RXCTRL(_i)    (((_i) <= 15) ? (0x02200 + ((_i) * 4)) : \
+#define IXGBE_DCA_RXCTRL(_i)	(((_i) <= 15) ? (0x02200 + ((_i) * 4)) : \
 				 (((_i) < 64) ? (0x0100C + ((_i) * 0x40)) : \
 				 (0x0D00C + (((_i) - 64) * 0x40))))
-#define IXGBE_RDRXCTL           0x02F00
-#define IXGBE_RXPBSIZE(_i)      (0x03C00 + ((_i) * 4))
-					     /* 8 of these 0x03C00 - 0x03C1C */
-#define IXGBE_RXCTRL    0x03000
-#define IXGBE_DROPEN    0x03D04
-#define IXGBE_RXPBSIZE_SHIFT 10
+#define IXGBE_RDRXCTL		0x02F00
+/* 8 of these 0x03C00 - 0x03C1C */
+#define IXGBE_RXPBSIZE(_i)	(0x03C00 + ((_i) * 4))
+#define IXGBE_RXCTRL		0x03000
+#define IXGBE_DROPEN		0x03D04
+#define IXGBE_RXPBSIZE_SHIFT	10
+#define IXGBE_RXPBSIZE_MASK	0x000FFC00
 
 /* Receive Registers */
-#define IXGBE_RXCSUM    0x05000
-#define IXGBE_RFCTL     0x05008
-#define IXGBE_DRECCCTL  0x02F08
-#define IXGBE_DRECCCTL_DISABLE 0
+#define IXGBE_RXCSUM		0x05000
+#define IXGBE_RFCTL		0x05008
+#define IXGBE_DRECCCTL		0x02F08
+#define IXGBE_DRECCCTL_DISABLE	0
+#define IXGBE_DRECCCTL2		0x02F8C
+
 /* Multicast Table Array - 128 entries */
-#define IXGBE_MTA(_i)   (0x05200 + ((_i) * 4))
-#define IXGBE_RAL(_i)   (((_i) <= 15) ? (0x05400 + ((_i) * 8)) : \
-			 (0x0A200 + ((_i) * 8)))
-#define IXGBE_RAH(_i)   (((_i) <= 15) ? (0x05404 + ((_i) * 8)) : \
-			 (0x0A204 + ((_i) * 8)))
-#define IXGBE_MPSAR_LO(_i) (0x0A600 + ((_i) * 8))
-#define IXGBE_MPSAR_HI(_i) (0x0A604 + ((_i) * 8))
+#define IXGBE_MTA(_i)		(0x05200 + ((_i) * 4))
+#define IXGBE_RAL(_i)		(((_i) <= 15) ? (0x05400 + ((_i) * 8)) : \
+				 (0x0A200 + ((_i) * 8)))
+#define IXGBE_RAH(_i)		(((_i) <= 15) ? (0x05404 + ((_i) * 8)) : \
+				 (0x0A204 + ((_i) * 8)))
+#define IXGBE_MPSAR_LO(_i)	(0x0A600 + ((_i) * 8))
+#define IXGBE_MPSAR_HI(_i)	(0x0A604 + ((_i) * 8))
 /* Packet split receive type */
-#define IXGBE_PSRTYPE(_i)    (((_i) <= 15) ? (0x05480 + ((_i) * 4)) : \
-			      (0x0EA00 + ((_i) * 4)))
+#define IXGBE_PSRTYPE(_i)	(((_i) <= 15) ? (0x05480 + ((_i) * 4)) : \
+				 (0x0EA00 + ((_i) * 4)))
 /* array of 4096 1-bit vlan filters */
-#define IXGBE_VFTA(_i)  (0x0A000 + ((_i) * 4))
+#define IXGBE_VFTA(_i)		(0x0A000 + ((_i) * 4))
 /*array of 4096 4-bit vlan vmdq indices */
-#define IXGBE_VFTAVIND(_j, _i)  (0x0A200 + ((_j) * 0x200) + ((_i) * 4))
-#define IXGBE_FCTRL     0x05080
-#define IXGBE_VLNCTRL   0x05088
-#define IXGBE_MCSTCTRL  0x05090
-#define IXGBE_MRQC      0x05818
-#define IXGBE_SAQF(_i)  (0x0E000 + ((_i) * 4)) /* Source Address Queue Filter */
-#define IXGBE_DAQF(_i)  (0x0E200 + ((_i) * 4)) /* Dest. Address Queue Filter */
-#define IXGBE_SDPQF(_i) (0x0E400 + ((_i) * 4)) /* Src Dest. Addr Queue Filter */
-#define IXGBE_FTQF(_i)  (0x0E600 + ((_i) * 4)) /* Five Tuple Queue Filter */
-#define IXGBE_ETQF(_i)  (0x05128 + ((_i) * 4)) /* EType Queue Filter */
-#define IXGBE_ETQS(_i)  (0x0EC00 + ((_i) * 4)) /* EType Queue Select */
-#define IXGBE_SYNQF     0x0EC30 /* SYN Packet Queue Filter */
-#define IXGBE_RQTC      0x0EC70
-#define IXGBE_MTQC      0x08120
-#define IXGBE_VLVF(_i)  (0x0F100 + ((_i) * 4))  /* 64 of these (0-63) */
-#define IXGBE_VLVFB(_i) (0x0F200 + ((_i) * 4))  /* 128 of these (0-127) */
-#define IXGBE_VMVIR(_i) (0x08000 + ((_i) * 4))  /* 64 of these (0-63) */
-#define IXGBE_PFFLPL	0x050B0
-#define IXGBE_PFFLPH	0x050B4
-#define IXGBE_VT_CTL         0x051B0
-#define IXGBE_PFMAILBOX(_i)  (0x04B00 + (4 * (_i))) /* 64 total */
-#define IXGBE_PFMBMEM(_i)    (0x13000 + (64 * (_i))) /* 64 Mailboxes, 16 DW each */
-#define IXGBE_PFMBICR(_i)    (0x00710 + (4 * (_i))) /* 4 total */
-#define IXGBE_PFMBIMR(_i)    (0x00720 + (4 * (_i))) /* 4 total */
-#define IXGBE_VFRE(_i)       (0x051E0 + ((_i) * 4))
-#define IXGBE_VFTE(_i)       (0x08110 + ((_i) * 4))
-#define IXGBE_VMECM(_i)      (0x08790 + ((_i) * 4))
-#define IXGBE_QDE            0x2F04
-#define IXGBE_VMTXSW(_i)     (0x05180 + ((_i) * 4)) /* 2 total */
-#define IXGBE_VMOLR(_i)      (0x0F000 + ((_i) * 4)) /* 64 total */
-#define IXGBE_UTA(_i)        (0x0F400 + ((_i) * 4))
-#define IXGBE_MRCTL(_i)      (0x0F600 + ((_i) * 4))
-#define IXGBE_VMRVLAN(_i)    (0x0F610 + ((_i) * 4))
-#define IXGBE_VMRVM(_i)      (0x0F630 + ((_i) * 4))
-#define IXGBE_WQBR_RX(_i)    (0x2FB0 + ((_i) * 4)) /* 4 total */
-#define IXGBE_WQBR_TX(_i)    (0x8130 + ((_i) * 4)) /* 4 total */
-#define IXGBE_L34T_IMIR(_i)  (0x0E800 + ((_i) * 4)) /*128 of these (0-127)*/
-#define IXGBE_RXFECCERR0         0x051B8
-#define IXGBE_LLITHRESH 0x0EC90
-#define IXGBE_IMIR(_i)  (0x05A80 + ((_i) * 4))  /* 8 of these (0-7) */
-#define IXGBE_IMIREXT(_i)       (0x05AA0 + ((_i) * 4))  /* 8 of these (0-7) */
-#define IXGBE_IMIRVP    0x05AC0
-#define IXGBE_VMD_CTL   0x0581C
-#define IXGBE_RETA(_i)  (0x05C00 + ((_i) * 4))  /* 32 of these (0-31) */
-#define IXGBE_ERETA(_i)	(0x0EE80 + ((_i) * 4))  /* 96 of these (0-95) */
-#define IXGBE_RSSRK(_i) (0x05C80 + ((_i) * 4))  /* 10 of these (0-9) */
+#define IXGBE_VFTAVIND(_j, _i)	(0x0A200 + ((_j) * 0x200) + ((_i) * 4))
+#define IXGBE_FCTRL		0x05080
+#define IXGBE_VLNCTRL		0x05088
+#define IXGBE_MCSTCTRL		0x05090
+#define IXGBE_MRQC		0x05818
+#define IXGBE_SAQF(_i)	(0x0E000 + ((_i) * 4)) /* Source Address Queue Filter */
+#define IXGBE_DAQF(_i)	(0x0E200 + ((_i) * 4)) /* Dest. Address Queue Filter */
+#define IXGBE_SDPQF(_i)	(0x0E400 + ((_i) * 4)) /* Src Dest. Addr Queue Filter */
+#define IXGBE_FTQF(_i)	(0x0E600 + ((_i) * 4)) /* Five Tuple Queue Filter */
+#define IXGBE_ETQF(_i)	(0x05128 + ((_i) * 4)) /* EType Queue Filter */
+#define IXGBE_ETQS(_i)	(0x0EC00 + ((_i) * 4)) /* EType Queue Select */
+#define IXGBE_SYNQF	0x0EC30 /* SYN Packet Queue Filter */
+#define IXGBE_RQTC	0x0EC70
+#define IXGBE_MTQC	0x08120
+#define IXGBE_VLVF(_i)	(0x0F100 + ((_i) * 4))  /* 64 of these (0-63) */
+#define IXGBE_VLVFB(_i)	(0x0F200 + ((_i) * 4))  /* 128 of these (0-127) */
+#define IXGBE_VMVIR(_i)	(0x08000 + ((_i) * 4))  /* 64 of these (0-63) */
+#define IXGBE_PFFLPL		0x050B0
+#define IXGBE_PFFLPH		0x050B4
+#define IXGBE_VT_CTL		0x051B0
+#define IXGBE_PFMAILBOX(_i)	(0x04B00 + (4 * (_i))) /* 64 total */
+/* 64 Mailboxes, 16 DW each */
+#define IXGBE_PFMBMEM(_i)	(0x13000 + (64 * (_i)))
+#define IXGBE_PFMBICR_INDEX(_i)	((_i) >> 4)
+#define IXGBE_PFMBICR_SHIFT(_i)	((_i) % 16)
+#define IXGBE_PFMBICR(_i)	(0x00710 + (4 * (_i))) /* 4 total */
+#define IXGBE_PFMBIMR(_i)	(0x00720 + (4 * (_i))) /* 4 total */
+#define IXGBE_PFVFLRE(_i)	((((_i) & 1) ? 0x001C0 : 0x00600))
+#define IXGBE_PFVFLREC(_i)	(0x00700 + ((_i) * 4))
+#define IXGBE_PFVFLRE_INDEX(_i)	((_i) >> 5)
+#define IXGBE_PFVFLRE_SHIFT(_i)	((_i) % 32)
+#define IXGBE_VFRE(_i)		(0x051E0 + ((_i) * 4))
+#define IXGBE_VFTE(_i)		(0x08110 + ((_i) * 4))
+#define IXGBE_VMECM(_i)		(0x08790 + ((_i) * 4))
+#define IXGBE_QDE		0x2F04
+#define IXGBE_VMTXSW(_i)	(0x05180 + ((_i) * 4)) /* 2 total */
+#define IXGBE_VMOLR(_i)		(0x0F000 + ((_i) * 4)) /* 64 total */
+#define IXGBE_UTA(_i)		(0x0F400 + ((_i) * 4))
+#define IXGBE_MRCTL(_i)		(0x0F600 + ((_i) * 4))
+#define IXGBE_VMRVLAN(_i)	(0x0F610 + ((_i) * 4))
+#define IXGBE_VMRVM(_i)		(0x0F630 + ((_i) * 4))
+#define IXGBE_LVMMC_RX		0x2FA8
+#define IXGBE_LVMMC_TX		0x8108
+#define IXGBE_LMVM_RX		0x2FA4
+#define IXGBE_LMVM_TX		0x8124
+#define IXGBE_WQBR_RX(_i)	(0x2FB0 + ((_i) * 4)) /* 4 total */
+#define IXGBE_WQBR_TX(_i)	(0x8130 + ((_i) * 4)) /* 4 total */
+#define IXGBE_L34T_IMIR(_i)	(0x0E800 + ((_i) * 4)) /*128 of these (0-127)*/
+#define IXGBE_RXFECCERR0	0x051B8
+#define IXGBE_LLITHRESH		0x0EC90
+#define IXGBE_IMIR(_i)		(0x05A80 + ((_i) * 4))  /* 8 of these (0-7) */
+#define IXGBE_IMIREXT(_i)	(0x05AA0 + ((_i) * 4))  /* 8 of these (0-7) */
+#define IXGBE_IMIRVP		0x05AC0
+#define IXGBE_VMD_CTL		0x0581C
+#define IXGBE_RETA(_i)		(0x05C00 + ((_i) * 4))  /* 32 of these (0-31) */
+#define IXGBE_ERETA(_i)		(0x0EE80 + ((_i) * 4))  /* 96 of these (0-95) */
+#define IXGBE_RSSRK(_i)		(0x05C80 + ((_i) * 4))  /* 10 of these (0-9) */
 
 /* Registers for setting up RSS on X550 with SRIOV
  * _p - pool number (0..63)
@@ -416,950 +489,1095 @@ struct ixgbe_nvm_version {
 #define IXGBE_PFVFRETA(_i, _p)	(0x019000 + ((_i) * 4) + ((_p) * 0x40))
 
 /* Flow Director registers */
-#define IXGBE_FDIRCTRL  0x0EE00
-#define IXGBE_FDIRHKEY  0x0EE68
-#define IXGBE_FDIRSKEY  0x0EE6C
-#define IXGBE_FDIRDIP4M 0x0EE3C
-#define IXGBE_FDIRSIP4M 0x0EE40
-#define IXGBE_FDIRTCPM  0x0EE44
-#define IXGBE_FDIRUDPM  0x0EE48
+#define IXGBE_FDIRCTRL	0x0EE00
+#define IXGBE_FDIRHKEY	0x0EE68
+#define IXGBE_FDIRSKEY	0x0EE6C
+#define IXGBE_FDIRDIP4M	0x0EE3C
+#define IXGBE_FDIRSIP4M	0x0EE40
+#define IXGBE_FDIRTCPM	0x0EE44
+#define IXGBE_FDIRUDPM	0x0EE48
 #define IXGBE_FDIRSCTPM	0x0EE78
-#define IXGBE_FDIRIP6M  0x0EE74
-#define IXGBE_FDIRM     0x0EE70
+#define IXGBE_FDIRIP6M	0x0EE74
+#define IXGBE_FDIRM	0x0EE70
 
 /* Flow Director Stats registers */
-#define IXGBE_FDIRFREE  0x0EE38
-#define IXGBE_FDIRLEN   0x0EE4C
-#define IXGBE_FDIRUSTAT 0x0EE50
-#define IXGBE_FDIRFSTAT 0x0EE54
-#define IXGBE_FDIRMATCH 0x0EE58
-#define IXGBE_FDIRMISS  0x0EE5C
+#define IXGBE_FDIRFREE	0x0EE38
+#define IXGBE_FDIRLEN	0x0EE4C
+#define IXGBE_FDIRUSTAT	0x0EE50
+#define IXGBE_FDIRFSTAT	0x0EE54
+#define IXGBE_FDIRMATCH	0x0EE58
+#define IXGBE_FDIRMISS	0x0EE5C
 
 /* Flow Director Programming registers */
 #define IXGBE_FDIRSIPv6(_i) (0x0EE0C + ((_i) * 4)) /* 3 of these (0-2) */
-#define IXGBE_FDIRIPSA      0x0EE18
-#define IXGBE_FDIRIPDA      0x0EE1C
-#define IXGBE_FDIRPORT      0x0EE20
-#define IXGBE_FDIRVLAN      0x0EE24
-#define IXGBE_FDIRHASH      0x0EE28
-#define IXGBE_FDIRCMD       0x0EE2C
+#define IXGBE_FDIRIPSA	0x0EE18
+#define IXGBE_FDIRIPDA	0x0EE1C
+#define IXGBE_FDIRPORT	0x0EE20
+#define IXGBE_FDIRVLAN	0x0EE24
+#define IXGBE_FDIRHASH	0x0EE28
+#define IXGBE_FDIRCMD	0x0EE2C
 
 /* Transmit DMA registers */
-#define IXGBE_TDBAL(_i) (0x06000 + ((_i) * 0x40)) /* 32 of these (0-31)*/
-#define IXGBE_TDBAH(_i) (0x06004 + ((_i) * 0x40))
-#define IXGBE_TDLEN(_i) (0x06008 + ((_i) * 0x40))
-#define IXGBE_TDH(_i)   (0x06010 + ((_i) * 0x40))
-#define IXGBE_TDT(_i)   (0x06018 + ((_i) * 0x40))
-#define IXGBE_TXDCTL(_i) (0x06028 + ((_i) * 0x40))
-#define IXGBE_TDWBAL(_i) (0x06038 + ((_i) * 0x40))
-#define IXGBE_TDWBAH(_i) (0x0603C + ((_i) * 0x40))
-#define IXGBE_DTXCTL    0x07E00
-
-#define IXGBE_DMATXCTL      0x04A80
-#define IXGBE_PFVFSPOOF(_i) (0x08200 + ((_i) * 4)) /* 8 of these 0 - 7 */
-#define IXGBE_PFDTXGSWC     0x08220
-#define IXGBE_DTXMXSZRQ     0x08100
-#define IXGBE_DTXTCPFLGL    0x04A88
-#define IXGBE_DTXTCPFLGH    0x04A8C
-#define IXGBE_LBDRPEN       0x0CA00
-#define IXGBE_TXPBTHRESH(_i) (0x04950 + ((_i) * 4)) /* 8 of these 0 - 7 */
-
-#define IXGBE_DMATXCTL_TE       0x1 /* Transmit Enable */
-#define IXGBE_DMATXCTL_NS       0x2 /* No Snoop LSO hdr buffer */
-#define IXGBE_DMATXCTL_GDV      0x8 /* Global Double VLAN */
-#define IXGBE_DMATXCTL_MDP_EN   0x20 /* Bit 5 */
-#define IXGBE_DMATXCTL_MBINTEN  0x40 /* Bit 6 */
-#define IXGBE_DMATXCTL_VT_SHIFT 16  /* VLAN EtherType */
-
-#define IXGBE_PFDTXGSWC_VT_LBEN 0x1 /* Local L2 VT switch enable */
+#define IXGBE_TDBAL(_i)		(0x06000 + ((_i) * 0x40)) /* 32 of them (0-31)*/
+#define IXGBE_TDBAH(_i)		(0x06004 + ((_i) * 0x40))
+#define IXGBE_TDLEN(_i)		(0x06008 + ((_i) * 0x40))
+#define IXGBE_TDH(_i)		(0x06010 + ((_i) * 0x40))
+#define IXGBE_TDT(_i)		(0x06018 + ((_i) * 0x40))
+#define IXGBE_TXDCTL(_i)	(0x06028 + ((_i) * 0x40))
+#define IXGBE_TDWBAL(_i)	(0x06038 + ((_i) * 0x40))
+#define IXGBE_TDWBAH(_i)	(0x0603C + ((_i) * 0x40))
+#define IXGBE_DTXCTL		0x07E00
+
+#define IXGBE_DMATXCTL		0x04A80
+#define IXGBE_PFVFSPOOF(_i)	(0x08200 + ((_i) * 4)) /* 8 of these 0 - 7 */
+#define IXGBE_PFDTXGSWC		0x08220
+#define IXGBE_DTXMXSZRQ		0x08100
+#define IXGBE_DTXTCPFLGL	0x04A88
+#define IXGBE_DTXTCPFLGH	0x04A8C
+#define IXGBE_LBDRPEN		0x0CA00
+#define IXGBE_TXPBTHRESH(_i)	(0x04950 + ((_i) * 4)) /* 8 of these 0 - 7 */
+
+#define IXGBE_DMATXCTL_TE	0x1 /* Transmit Enable */
+#define IXGBE_DMATXCTL_NS	0x2 /* No Snoop LSO hdr buffer */
+#define IXGBE_DMATXCTL_GDV	0x8 /* Global Double VLAN */
+#define IXGBE_DMATXCTL_MDP_EN	0x20 /* Bit 5 */
+#define IXGBE_DMATXCTL_MBINTEN	0x40 /* Bit 6 */
+#define IXGBE_DMATXCTL_VT_SHIFT	16  /* VLAN EtherType */
+
+#define IXGBE_PFDTXGSWC_VT_LBEN	0x1 /* Local L2 VT switch enable */
 
 /* Anti-spoofing defines */
-#define IXGBE_SPOOF_MACAS_MASK          0xFF
-#define IXGBE_SPOOF_VLANAS_MASK         0xFF00
-#define IXGBE_SPOOF_VLANAS_SHIFT        8
+#define IXGBE_SPOOF_MACAS_MASK		0xFF
+#define IXGBE_SPOOF_VLANAS_MASK		0xFF00
+#define IXGBE_SPOOF_VLANAS_SHIFT	8
 #define IXGBE_SPOOF_ETHERTYPEAS		0xFF000000
 #define IXGBE_SPOOF_ETHERTYPEAS_SHIFT	16
-#define IXGBE_PFVFSPOOF_REG_COUNT       8
-
-#define IXGBE_DCA_TXCTRL(_i)    (0x07200 + ((_i) * 4)) /* 16 of these (0-15) */
+#define IXGBE_PFVFSPOOF_REG_COUNT	8
+/* 16 of these (0-15) */
+#define IXGBE_DCA_TXCTRL(_i)		(0x07200 + ((_i) * 4))
 /* Tx DCA Control register : 128 of these (0-127) */
-#define IXGBE_DCA_TXCTRL_82599(_i)  (0x0600C + ((_i) * 0x40))
-#define IXGBE_TIPG      0x0CB00
-#define IXGBE_TXPBSIZE(_i)      (0x0CC00 + ((_i) * 4)) /* 8 of these */
-#define IXGBE_MNGTXMAP  0x0CD10
-#define IXGBE_TIPG_FIBER_DEFAULT 3
-#define IXGBE_TXPBSIZE_SHIFT    10
+#define IXGBE_DCA_TXCTRL_82599(_i)	(0x0600C + ((_i) * 0x40))
+#define IXGBE_TIPG			0x0CB00
+#define IXGBE_TXPBSIZE(_i)		(0x0CC00 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_MNGTXMAP			0x0CD10
+#define IXGBE_TIPG_FIBER_DEFAULT	3
+#define IXGBE_TXPBSIZE_SHIFT		10
 
 /* Wake up registers */
-#define IXGBE_WUC       0x05800
-#define IXGBE_WUFC      0x05808
-#define IXGBE_WUS       0x05810
-#define IXGBE_IPAV      0x05838
-#define IXGBE_IP4AT     0x05840 /* IPv4 table 0x5840-0x5858 */
-#define IXGBE_IP6AT     0x05880 /* IPv6 table 0x5880-0x588F */
-
-#define IXGBE_WUPL      0x05900
-#define IXGBE_WUPM      0x05A00 /* wake up pkt memory 0x5A00-0x5A7C */
+#define IXGBE_WUC	0x05800
+#define IXGBE_WUFC	0x05808
+#define IXGBE_WUS	0x05810
+#define IXGBE_IPAV	0x05838
+#define IXGBE_IP4AT	0x05840 /* IPv4 table 0x5840-0x5858 */
+#define IXGBE_IP6AT	0x05880 /* IPv6 table 0x5880-0x588F */
+
+#define IXGBE_WUPL	0x05900
+#define IXGBE_WUPM	0x05A00 /* wake up pkt memory 0x5A00-0x5A7C */
+#define IXGBE_PROXYS	0x05F60 /* Proxying Status Register */
+#define IXGBE_PROXYFC	0x05F64 /* Proxying Filter Control Register */
 #define IXGBE_VXLANCTRL	0x0000507C /* Rx filter VXLAN UDPPORT Register */
-#define IXGBE_FHFT(_n)	(0x09000 + ((_n) * 0x100)) /* Flex host filter table */
-#define IXGBE_FHFT_EXT(_n)	(0x09800 + ((_n) * 0x100)) /* Ext Flexible Host
-							    * Filter Table */
 
 /* masks for accessing VXLAN and GENEVE UDP ports */
-#define IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK     0x0000ffff /* VXLAN port */
-#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK    0xffff0000 /* GENEVE port */
-#define IXGBE_VXLANCTRL_ALL_UDPPORT_MASK       0xffffffff /* GENEVE/VXLAN */
-
-#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT   16
+#define IXGBE_VXLANCTRL_VXLAN_UDPPORT_MASK	0x0000ffff /* VXLAN port */
+#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_MASK	0xffff0000 /* GENEVE port */
+#define IXGBE_VXLANCTRL_ALL_UDPPORT_MASK	0xffffffff /* GENEVE/VXLAN */
+#define IXGBE_VXLANCTRL_GENEVE_UDPPORT_SHIFT	16
 
-#define IXGBE_FLEXIBLE_FILTER_COUNT_MAX         4
-#define IXGBE_EXT_FLEXIBLE_FILTER_COUNT_MAX     2
+#define IXGBE_FHFT(_n)	(0x09000 + ((_n) * 0x100)) /* Flex host filter table */
+/* Ext Flexible Host Filter Table */
+#define IXGBE_FHFT_EXT(_n)	(0x09800 + ((_n) * 0x100))
+#define IXGBE_FHFT_EXT_X550(_n)	(0x09600 + ((_n) * 0x100))
+
+/* Four Flexible Filters are supported */
+#define IXGBE_FLEXIBLE_FILTER_COUNT_MAX		4
+/* Six Flexible Filters are supported */
+#define IXGBE_FLEXIBLE_FILTER_COUNT_MAX_6	6
+/* Eight Flexible Filters are supported */
+#define IXGBE_FLEXIBLE_FILTER_COUNT_MAX_8	8
+#define IXGBE_EXT_FLEXIBLE_FILTER_COUNT_MAX	2
 
 /* Each Flexible Filter is at most 128 (0x80) bytes in length */
-#define IXGBE_FLEXIBLE_FILTER_SIZE_MAX  128
-#define IXGBE_FHFT_LENGTH_OFFSET        0xFC  /* Length byte in FHFT */
-#define IXGBE_FHFT_LENGTH_MASK          0x0FF /* Length in lower byte */
+#define IXGBE_FLEXIBLE_FILTER_SIZE_MAX		128
+#define IXGBE_FHFT_LENGTH_OFFSET		0xFC  /* Length byte in FHFT */
+#define IXGBE_FHFT_LENGTH_MASK			0x0FF /* Length in lower byte */
 
 /* Definitions for power management and wakeup registers */
 /* Wake Up Control */
-#define IXGBE_WUC_PME_EN     0x00000002 /* PME Enable */
-#define IXGBE_WUC_PME_STATUS 0x00000004 /* PME Status */
-#define IXGBE_WUC_WKEN       0x00000010 /* Enable PE_WAKE_N pin assertion  */
+#define IXGBE_WUC_PME_EN	0x00000002 /* PME Enable */
+#define IXGBE_WUC_PME_STATUS	0x00000004 /* PME Status */
+#define IXGBE_WUC_WKEN		0x00000010 /* Enable PE_WAKE_N pin assertion  */
 
 /* Wake Up Filter Control */
-#define IXGBE_WUFC_LNKC 0x00000001 /* Link Status Change Wakeup Enable */
-#define IXGBE_WUFC_MAG  0x00000002 /* Magic Packet Wakeup Enable */
-#define IXGBE_WUFC_EX   0x00000004 /* Directed Exact Wakeup Enable */
-#define IXGBE_WUFC_MC   0x00000008 /* Directed Multicast Wakeup Enable */
-#define IXGBE_WUFC_BC   0x00000010 /* Broadcast Wakeup Enable */
-#define IXGBE_WUFC_ARP  0x00000020 /* ARP Request Packet Wakeup Enable */
-#define IXGBE_WUFC_IPV4 0x00000040 /* Directed IPv4 Packet Wakeup Enable */
-#define IXGBE_WUFC_IPV6 0x00000080 /* Directed IPv6 Packet Wakeup Enable */
-#define IXGBE_WUFC_MNG  0x00000100 /* Directed Mgmt Packet Wakeup Enable */
-
-#define IXGBE_WUFC_IGNORE_TCO   0x00008000 /* Ignore WakeOn TCO packets */
-#define IXGBE_WUFC_FLX0 0x00010000 /* Flexible Filter 0 Enable */
-#define IXGBE_WUFC_FLX1 0x00020000 /* Flexible Filter 1 Enable */
-#define IXGBE_WUFC_FLX2 0x00040000 /* Flexible Filter 2 Enable */
-#define IXGBE_WUFC_FLX3 0x00080000 /* Flexible Filter 3 Enable */
-#define IXGBE_WUFC_FLX4 0x00100000 /* Flexible Filter 4 Enable */
-#define IXGBE_WUFC_FLX5 0x00200000 /* Flexible Filter 5 Enable */
-#define IXGBE_WUFC_FLX_FILTERS     0x000F0000 /* Mask for 4 flex filters */
-#define IXGBE_WUFC_EXT_FLX_FILTERS 0x00300000 /* Mask for Ext. flex filters */
-#define IXGBE_WUFC_ALL_FILTERS     0x003F00FF /* Mask for all wakeup filters */
-#define IXGBE_WUFC_FLX_OFFSET      16 /* Offset to the Flexible Filters bits */
+#define IXGBE_WUFC_LNKC	0x00000001 /* Link Status Change Wakeup Enable */
+#define IXGBE_WUFC_MAG	0x00000002 /* Magic Packet Wakeup Enable */
+#define IXGBE_WUFC_EX	0x00000004 /* Directed Exact Wakeup Enable */
+#define IXGBE_WUFC_MC	0x00000008 /* Directed Multicast Wakeup Enable */
+#define IXGBE_WUFC_BC	0x00000010 /* Broadcast Wakeup Enable */
+#define IXGBE_WUFC_ARP	0x00000020 /* ARP Request Packet Wakeup Enable */
+#define IXGBE_WUFC_IPV4	0x00000040 /* Directed IPv4 Packet Wakeup Enable */
+#define IXGBE_WUFC_IPV6	0x00000080 /* Directed IPv6 Packet Wakeup Enable */
+#define IXGBE_WUFC_MNG	0x00000100 /* Directed Mgmt Packet Wakeup Enable */
+
+#define IXGBE_WUFC_IGNORE_TCO	0x00008000 /* Ignore WakeOn TCO packets */
+#define IXGBE_WUFC_FLX0	0x00010000 /* Flexible Filter 0 Enable */
+#define IXGBE_WUFC_FLX1	0x00020000 /* Flexible Filter 1 Enable */
+#define IXGBE_WUFC_FLX2	0x00040000 /* Flexible Filter 2 Enable */
+#define IXGBE_WUFC_FLX3	0x00080000 /* Flexible Filter 3 Enable */
+#define IXGBE_WUFC_FLX4	0x00100000 /* Flexible Filter 4 Enable */
+#define IXGBE_WUFC_FLX5	0x00200000 /* Flexible Filter 5 Enable */
+#define IXGBE_WUFC_FLX_FILTERS		0x000F0000 /* Mask for 4 flex filters */
+#define IXGBE_WUFC_FLX_FILTERS_6	0x003F0000 /* Mask for 6 flex filters */
+#define IXGBE_WUFC_FLX_FILTERS_8	0x00FF0000 /* Mask for 8 flex filters */
+#define IXGBE_WUFC_FW_RST_WK	0x80000000 /* Ena wake on FW reset assertion */
+/* Mask for Ext. flex filters */
+#define IXGBE_WUFC_EXT_FLX_FILTERS	0x00300000
+#define IXGBE_WUFC_ALL_FILTERS		0x000F00FF /* Mask all 4 flex filters */
+#define IXGBE_WUFC_ALL_FILTERS_6	0x003F00FF /* Mask all 6 flex filters */
+#define IXGBE_WUFC_ALL_FILTERS_8	0x00FF00FF /* Mask all 8 flex filters */
+#define IXGBE_WUFC_FLX_OFFSET	16 /* Offset to the Flexible Filters bits */
 
 /* Wake Up Status */
-#define IXGBE_WUS_LNKC  IXGBE_WUFC_LNKC
-#define IXGBE_WUS_MAG   IXGBE_WUFC_MAG
-#define IXGBE_WUS_EX    IXGBE_WUFC_EX
-#define IXGBE_WUS_MC    IXGBE_WUFC_MC
-#define IXGBE_WUS_BC    IXGBE_WUFC_BC
-#define IXGBE_WUS_ARP   IXGBE_WUFC_ARP
-#define IXGBE_WUS_IPV4  IXGBE_WUFC_IPV4
-#define IXGBE_WUS_IPV6  IXGBE_WUFC_IPV6
-#define IXGBE_WUS_MNG   IXGBE_WUFC_MNG
-#define IXGBE_WUS_FLX0  IXGBE_WUFC_FLX0
-#define IXGBE_WUS_FLX1  IXGBE_WUFC_FLX1
-#define IXGBE_WUS_FLX2  IXGBE_WUFC_FLX2
-#define IXGBE_WUS_FLX3  IXGBE_WUFC_FLX3
-#define IXGBE_WUS_FLX4  IXGBE_WUFC_FLX4
-#define IXGBE_WUS_FLX5  IXGBE_WUFC_FLX5
-#define IXGBE_WUS_FLX_FILTERS  IXGBE_WUFC_FLX_FILTERS
-
-/* Wake Up Packet Length */
-#define IXGBE_WUPL_LENGTH_MASK 0xFFFF
+#define IXGBE_WUS_LNKC		IXGBE_WUFC_LNKC
+#define IXGBE_WUS_MAG		IXGBE_WUFC_MAG
+#define IXGBE_WUS_EX		IXGBE_WUFC_EX
+#define IXGBE_WUS_MC		IXGBE_WUFC_MC
+#define IXGBE_WUS_BC		IXGBE_WUFC_BC
+#define IXGBE_WUS_ARP		IXGBE_WUFC_ARP
+#define IXGBE_WUS_IPV4		IXGBE_WUFC_IPV4
+#define IXGBE_WUS_IPV6		IXGBE_WUFC_IPV6
+#define IXGBE_WUS_MNG		IXGBE_WUFC_MNG
+#define IXGBE_WUS_FLX0		IXGBE_WUFC_FLX0
+#define IXGBE_WUS_FLX1		IXGBE_WUFC_FLX1
+#define IXGBE_WUS_FLX2		IXGBE_WUFC_FLX2
+#define IXGBE_WUS_FLX3		IXGBE_WUFC_FLX3
+#define IXGBE_WUS_FLX4		IXGBE_WUFC_FLX4
+#define IXGBE_WUS_FLX5		IXGBE_WUFC_FLX5
+#define IXGBE_WUS_FLX_FILTERS	IXGBE_WUFC_FLX_FILTERS
+#define IXGBE_WUS_FW_RST_WK	IXGBE_WUFC_FW_RST_WK
+/* Proxy Status */
+#define IXGBE_PROXYS_EX		0x00000004 /* Exact packet received */
+#define IXGBE_PROXYS_ARP_DIR	0x00000020 /* ARP w/filter match received */
+#define IXGBE_PROXYS_NS		0x00000200 /* IPV6 NS received */
+#define IXGBE_PROXYS_NS_DIR	0x00000400 /* IPV6 NS w/DA match received */
+#define IXGBE_PROXYS_ARP	0x00000800 /* ARP request packet received */
+#define IXGBE_PROXYS_MLD	0x00001000 /* IPv6 MLD packet received */
+
+/* Proxying Filter Control */
+#define IXGBE_PROXYFC_ENABLE	0x00000001 /* Port Proxying Enable */
+#define IXGBE_PROXYFC_EX	0x00000004 /* Directed Exact Proxy Enable */
+#define IXGBE_PROXYFC_ARP_DIR	0x00000020 /* Directed ARP Proxy Enable */
+#define IXGBE_PROXYFC_NS	0x00000200 /* IPv6 Neighbor Solicitation */
+#define IXGBE_PROXYFC_ARP	0x00000800 /* ARP Request Proxy Enable */
+#define IXGBE_PROXYFC_MLD	0x00000800 /* IPv6 MLD Proxy Enable */
+#define IXGBE_PROXYFC_NO_TCO	0x00008000 /* Ignore TCO packets */
+
+#define IXGBE_WUPL_LENGTH_MASK	0xFFFF
 
 /* DCB registers */
-#define MAX_TRAFFIC_CLASS        8
-#define X540_TRAFFIC_CLASS       4
-#define DEF_TRAFFIC_CLASS        1
-#define IXGBE_RMCS      0x03D00
-#define IXGBE_DPMCS     0x07F40
-#define IXGBE_PDPMCS    0x0CD00
-#define IXGBE_RUPPBMR   0x050A0
-#define IXGBE_RT2CR(_i) (0x03C20 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RT2SR(_i) (0x03C40 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_TDTQ2TCCR(_i)     (0x0602C + ((_i) * 0x40)) /* 8 of these (0-7) */
-#define IXGBE_TDTQ2TCSR(_i)     (0x0622C + ((_i) * 0x40)) /* 8 of these (0-7) */
-#define IXGBE_TDPT2TCCR(_i)     (0x0CD20 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_TDPT2TCSR(_i)     (0x0CD40 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_DCB_MAX_TRAFFIC_CLASS	8
+#define IXGBE_RMCS		0x03D00
+#define IXGBE_DPMCS		0x07F40
+#define IXGBE_PDPMCS		0x0CD00
+#define IXGBE_RUPPBMR		0x050A0
+#define IXGBE_RT2CR(_i)		(0x03C20 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RT2SR(_i)		(0x03C40 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_TDTQ2TCCR(_i)	(0x0602C + ((_i) * 0x40)) /* 8 of these (0-7) */
+#define IXGBE_TDTQ2TCSR(_i)	(0x0622C + ((_i) * 0x40)) /* 8 of these (0-7) */
+#define IXGBE_TDPT2TCCR(_i)	(0x0CD20 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_TDPT2TCSR(_i)	(0x0CD40 + ((_i) * 4)) /* 8 of these (0-7) */
+
+/* Power Management */
+/* DMA Coalescing configuration */
+struct ixgbe_dmac_config {
+	u16	watchdog_timer; /* usec units */
+	bool	fcoe_en;
+	u32	link_speed;
+	u8	fcoe_tc;
+	u8	num_tcs;
+};
+
+/*
+ * DMA Coalescing threshold Rx PB TC[n] value in Kilobyte by link speed.
+ * DMACRXT = 10Gbps = 10,000 bits / usec = 1250 bytes / usec 70 * 1250 ==
+ * 87500 bytes [85KB]
+ */
+#define IXGBE_DMACRXT_10G		0x55
+#define IXGBE_DMACRXT_1G		0x09
+#define IXGBE_DMACRXT_100M		0x01
+
+/* DMA Coalescing registers */
+#define IXGBE_DMCMNGTH			0x15F20 /* Management Threshold */
+#define IXGBE_DMACR			0x02400 /* Control register */
+#define IXGBE_DMCTH(_i)			(0x03300 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_DMCTLX			0x02404 /* Time to Lx request */
+/* DMA Coalescing register fields */
+#define IXGBE_DMCMNGTH_DMCMNGTH_MASK	0x000FFFF0 /* Mng Threshold mask */
+#define IXGBE_DMCMNGTH_DMCMNGTH_SHIFT	4 /* Management Threshold shift */
+#define IXGBE_DMACR_DMACWT_MASK		0x0000FFFF /* Watchdog Timer mask */
+#define IXGBE_DMACR_HIGH_PRI_TC_MASK	0x00FF0000
+#define IXGBE_DMACR_HIGH_PRI_TC_SHIFT	16
+#define IXGBE_DMACR_EN_MNG_IND		0x10000000 /* Enable Mng Indications */
+#define IXGBE_DMACR_LX_COAL_IND		0x40000000 /* Lx Coalescing indicate */
+#define IXGBE_DMACR_DMAC_EN		0x80000000 /* DMA Coalescing Enable */
+#define IXGBE_DMCTH_DMACRXT_MASK	0x000001FF /* Receive Threshold mask */
+#define IXGBE_DMCTLX_TTLX_MASK		0x00000FFF /* Time to Lx request mask */
+
+/* EEE registers */
+#define IXGBE_EEER			0x043A0 /* EEE register */
+#define IXGBE_EEE_STAT			0x04398 /* EEE Status */
+#define IXGBE_EEE_SU			0x04380 /* EEE Set up */
+#define IXGBE_EEE_SU_TEEE_DLY_SHIFT	26
+#define IXGBE_TLPIC			0x041F4 /* EEE Tx LPI count */
+#define IXGBE_RLPIC			0x041F8 /* EEE Rx LPI count */
+
+/* EEE register fields */
+#define IXGBE_EEER_TX_LPI_EN		0x00010000 /* Enable EEE LPI TX path */
+#define IXGBE_EEER_RX_LPI_EN		0x00020000 /* Enable EEE LPI RX path */
+#define IXGBE_EEE_STAT_NEG		0x20000000 /* EEE support neg on link */
+#define IXGBE_EEE_RX_LPI_STATUS		0x40000000 /* RX Link in LPI status */
+#define IXGBE_EEE_TX_LPI_STATUS		0x80000000 /* TX Link in LPI status */
 
 /* Security Control Registers */
-#define IXGBE_SECTXCTRL         0x08800
-#define IXGBE_SECTXSTAT         0x08804
-#define IXGBE_SECTXBUFFAF       0x08808
-#define IXGBE_SECTXMINIFG       0x08810
-#define IXGBE_SECRXCTRL         0x08D00
-#define IXGBE_SECRXSTAT         0x08D04
+#define IXGBE_SECTXCTRL		0x08800
+#define IXGBE_SECTXSTAT		0x08804
+#define IXGBE_SECTXBUFFAF	0x08808
+#define IXGBE_SECTXMINIFG	0x08810
+#define IXGBE_SECRXCTRL		0x08D00
+#define IXGBE_SECRXSTAT		0x08D04
 
 /* Security Bit Fields and Masks */
-#define IXGBE_SECTXCTRL_SECTX_DIS       0x00000001
-#define IXGBE_SECTXCTRL_TX_DIS          0x00000002
-#define IXGBE_SECTXCTRL_STORE_FORWARD   0x00000004
+#define IXGBE_SECTXCTRL_SECTX_DIS	0x00000001
+#define IXGBE_SECTXCTRL_TX_DIS		0x00000002
+#define IXGBE_SECTXCTRL_STORE_FORWARD	0x00000004
 
-#define IXGBE_SECTXSTAT_SECTX_RDY       0x00000001
-#define IXGBE_SECTXSTAT_SECTX_OFF_DIS   0x00000002
-#define IXGBE_SECTXSTAT_ECC_TXERR       0x00000004
+#define IXGBE_SECTXSTAT_SECTX_RDY	0x00000001
+#define IXGBE_SECTXSTAT_ECC_TXERR	0x00000002
 
-#define IXGBE_SECRXCTRL_SECRX_DIS       0x00000001
-#define IXGBE_SECRXCTRL_RX_DIS          0x00000002
+#define IXGBE_SECRXCTRL_SECRX_DIS	0x00000001
+#define IXGBE_SECRXCTRL_RX_DIS		0x00000002
 
-#define IXGBE_SECRXSTAT_SECRX_RDY       0x00000001
-#define IXGBE_SECRXSTAT_SECRX_OFF_DIS   0x00000002
-#define IXGBE_SECRXSTAT_ECC_RXERR       0x00000004
+#define IXGBE_SECRXSTAT_SECRX_RDY	0x00000001
+#define IXGBE_SECRXSTAT_ECC_RXERR	0x00000002
 
 /* LinkSec (MacSec) Registers */
-#define IXGBE_LSECTXCAP         0x08A00
-#define IXGBE_LSECRXCAP         0x08F00
-#define IXGBE_LSECTXCTRL        0x08A04
-#define IXGBE_LSECTXSCL         0x08A08 /* SCI Low */
-#define IXGBE_LSECTXSCH         0x08A0C /* SCI High */
-#define IXGBE_LSECTXSA          0x08A10
-#define IXGBE_LSECTXPN0         0x08A14
-#define IXGBE_LSECTXPN1         0x08A18
-#define IXGBE_LSECTXKEY0(_n)    (0x08A1C + (4 * (_n))) /* 4 of these (0-3) */
-#define IXGBE_LSECTXKEY1(_n)    (0x08A2C + (4 * (_n))) /* 4 of these (0-3) */
-#define IXGBE_LSECRXCTRL        0x08F04
-#define IXGBE_LSECRXSCL         0x08F08
-#define IXGBE_LSECRXSCH         0x08F0C
-#define IXGBE_LSECRXSA(_i)      (0x08F10 + (4 * (_i))) /* 2 of these (0-1) */
-#define IXGBE_LSECRXPN(_i)      (0x08F18 + (4 * (_i))) /* 2 of these (0-1) */
-#define IXGBE_LSECRXKEY(_n, _m) (0x08F20 + ((0x10 * (_n)) + (4 * (_m))))
-#define IXGBE_LSECTXUT          0x08A3C /* OutPktsUntagged */
-#define IXGBE_LSECTXPKTE        0x08A40 /* OutPktsEncrypted */
-#define IXGBE_LSECTXPKTP        0x08A44 /* OutPktsProtected */
-#define IXGBE_LSECTXOCTE        0x08A48 /* OutOctetsEncrypted */
-#define IXGBE_LSECTXOCTP        0x08A4C /* OutOctetsProtected */
-#define IXGBE_LSECRXUT          0x08F40 /* InPktsUntagged/InPktsNoTag */
-#define IXGBE_LSECRXOCTD        0x08F44 /* InOctetsDecrypted */
-#define IXGBE_LSECRXOCTV        0x08F48 /* InOctetsValidated */
-#define IXGBE_LSECRXBAD         0x08F4C /* InPktsBadTag */
-#define IXGBE_LSECRXNOSCI       0x08F50 /* InPktsNoSci */
-#define IXGBE_LSECRXUNSCI       0x08F54 /* InPktsUnknownSci */
-#define IXGBE_LSECRXUNCH        0x08F58 /* InPktsUnchecked */
-#define IXGBE_LSECRXDELAY       0x08F5C /* InPktsDelayed */
-#define IXGBE_LSECRXLATE        0x08F60 /* InPktsLate */
-#define IXGBE_LSECRXOK(_n)      (0x08F64 + (0x04 * (_n))) /* InPktsOk */
-#define IXGBE_LSECRXINV(_n)     (0x08F6C + (0x04 * (_n))) /* InPktsInvalid */
-#define IXGBE_LSECRXNV(_n)      (0x08F74 + (0x04 * (_n))) /* InPktsNotValid */
-#define IXGBE_LSECRXUNSA        0x08F7C /* InPktsUnusedSa */
-#define IXGBE_LSECRXNUSA        0x08F80 /* InPktsNotUsingSa */
+#define IXGBE_LSECTXCAP		0x08A00
+#define IXGBE_LSECRXCAP		0x08F00
+#define IXGBE_LSECTXCTRL	0x08A04
+#define IXGBE_LSECTXSCL		0x08A08 /* SCI Low */
+#define IXGBE_LSECTXSCH		0x08A0C /* SCI High */
+#define IXGBE_LSECTXSA		0x08A10
+#define IXGBE_LSECTXPN0		0x08A14
+#define IXGBE_LSECTXPN1		0x08A18
+#define IXGBE_LSECTXKEY0(_n)	(0x08A1C + (4 * (_n))) /* 4 of these (0-3) */
+#define IXGBE_LSECTXKEY1(_n)	(0x08A2C + (4 * (_n))) /* 4 of these (0-3) */
+#define IXGBE_LSECRXCTRL	0x08F04
+#define IXGBE_LSECRXSCL		0x08F08
+#define IXGBE_LSECRXSCH		0x08F0C
+#define IXGBE_LSECRXSA(_i)	(0x08F10 + (4 * (_i))) /* 2 of these (0-1) */
+#define IXGBE_LSECRXPN(_i)	(0x08F18 + (4 * (_i))) /* 2 of these (0-1) */
+#define IXGBE_LSECRXKEY(_n, _m)	(0x08F20 + ((0x10 * (_n)) + (4 * (_m))))
+#define IXGBE_LSECTXUT		0x08A3C /* OutPktsUntagged */
+#define IXGBE_LSECTXPKTE	0x08A40 /* OutPktsEncrypted */
+#define IXGBE_LSECTXPKTP	0x08A44 /* OutPktsProtected */
+#define IXGBE_LSECTXOCTE	0x08A48 /* OutOctetsEncrypted */
+#define IXGBE_LSECTXOCTP	0x08A4C /* OutOctetsProtected */
+#define IXGBE_LSECRXUT		0x08F40 /* InPktsUntagged/InPktsNoTag */
+#define IXGBE_LSECRXOCTD	0x08F44 /* InOctetsDecrypted */
+#define IXGBE_LSECRXOCTV	0x08F48 /* InOctetsValidated */
+#define IXGBE_LSECRXBAD		0x08F4C /* InPktsBadTag */
+#define IXGBE_LSECRXNOSCI	0x08F50 /* InPktsNoSci */
+#define IXGBE_LSECRXUNSCI	0x08F54 /* InPktsUnknownSci */
+#define IXGBE_LSECRXUNCH	0x08F58 /* InPktsUnchecked */
+#define IXGBE_LSECRXDELAY	0x08F5C /* InPktsDelayed */
+#define IXGBE_LSECRXLATE	0x08F60 /* InPktsLate */
+#define IXGBE_LSECRXOK(_n)	(0x08F64 + (0x04 * (_n))) /* InPktsOk */
+#define IXGBE_LSECRXINV(_n)	(0x08F6C + (0x04 * (_n))) /* InPktsInvalid */
+#define IXGBE_LSECRXNV(_n)	(0x08F74 + (0x04 * (_n))) /* InPktsNotValid */
+#define IXGBE_LSECRXUNSA	0x08F7C /* InPktsUnusedSa */
+#define IXGBE_LSECRXNUSA	0x08F80 /* InPktsNotUsingSa */
 
 /* LinkSec (MacSec) Bit Fields and Masks */
-#define IXGBE_LSECTXCAP_SUM_MASK        0x00FF0000
-#define IXGBE_LSECTXCAP_SUM_SHIFT       16
-#define IXGBE_LSECRXCAP_SUM_MASK        0x00FF0000
-#define IXGBE_LSECRXCAP_SUM_SHIFT       16
-
-#define IXGBE_LSECTXCTRL_EN_MASK        0x00000003
-#define IXGBE_LSECTXCTRL_DISABLE        0x0
-#define IXGBE_LSECTXCTRL_AUTH           0x1
-#define IXGBE_LSECTXCTRL_AUTH_ENCRYPT   0x2
-#define IXGBE_LSECTXCTRL_AISCI          0x00000020
-#define IXGBE_LSECTXCTRL_PNTHRSH_MASK   0xFFFFFF00
-#define IXGBE_LSECTXCTRL_RSV_MASK       0x000000D8
-
-#define IXGBE_LSECRXCTRL_EN_MASK        0x0000000C
-#define IXGBE_LSECRXCTRL_EN_SHIFT       2
-#define IXGBE_LSECRXCTRL_DISABLE        0x0
-#define IXGBE_LSECRXCTRL_CHECK          0x1
-#define IXGBE_LSECRXCTRL_STRICT         0x2
-#define IXGBE_LSECRXCTRL_DROP           0x3
-#define IXGBE_LSECRXCTRL_PLSH           0x00000040
-#define IXGBE_LSECRXCTRL_RP             0x00000080
-#define IXGBE_LSECRXCTRL_RSV_MASK       0xFFFFFF33
+#define IXGBE_LSECTXCAP_SUM_MASK	0x00FF0000
+#define IXGBE_LSECTXCAP_SUM_SHIFT	16
+#define IXGBE_LSECRXCAP_SUM_MASK	0x00FF0000
+#define IXGBE_LSECRXCAP_SUM_SHIFT	16
+
+#define IXGBE_LSECTXCTRL_EN_MASK	0x00000003
+#define IXGBE_LSECTXCTRL_DISABLE	0x0
+#define IXGBE_LSECTXCTRL_AUTH		0x1
+#define IXGBE_LSECTXCTRL_AUTH_ENCRYPT	0x2
+#define IXGBE_LSECTXCTRL_AISCI		0x00000020
+#define IXGBE_LSECTXCTRL_PNTHRSH_MASK	0xFFFFFF00
+#define IXGBE_LSECTXCTRL_RSV_MASK	0x000000D8
+
+#define IXGBE_LSECRXCTRL_EN_MASK	0x0000000C
+#define IXGBE_LSECRXCTRL_EN_SHIFT	2
+#define IXGBE_LSECRXCTRL_DISABLE	0x0
+#define IXGBE_LSECRXCTRL_CHECK		0x1
+#define IXGBE_LSECRXCTRL_STRICT		0x2
+#define IXGBE_LSECRXCTRL_DROP		0x3
+#define IXGBE_LSECRXCTRL_PLSH		0x00000040
+#define IXGBE_LSECRXCTRL_RP		0x00000080
+#define IXGBE_LSECRXCTRL_RSV_MASK	0xFFFFFF33
 
 /* IpSec Registers */
-#define IXGBE_IPSTXIDX          0x08900
-#define IXGBE_IPSTXSALT         0x08904
-#define IXGBE_IPSTXKEY(_i)      (0x08908 + (4 * (_i))) /* 4 of these (0-3) */
-#define IXGBE_IPSRXIDX          0x08E00
-#define IXGBE_IPSRXIPADDR(_i)   (0x08E04 + (4 * (_i))) /* 4 of these (0-3) */
-#define IXGBE_IPSRXSPI          0x08E14
-#define IXGBE_IPSRXIPIDX        0x08E18
-#define IXGBE_IPSRXKEY(_i)      (0x08E1C + (4 * (_i))) /* 4 of these (0-3) */
-#define IXGBE_IPSRXSALT         0x08E2C
-#define IXGBE_IPSRXMOD          0x08E30
-
-#define IXGBE_SECTXCTRL_STORE_FORWARD_ENABLE    0x4
+#define IXGBE_IPSTXIDX		0x08900
+#define IXGBE_IPSTXSALT		0x08904
+#define IXGBE_IPSTXKEY(_i)	(0x08908 + (4 * (_i))) /* 4 of these (0-3) */
+#define IXGBE_IPSRXIDX		0x08E00
+#define IXGBE_IPSRXIPADDR(_i)	(0x08E04 + (4 * (_i))) /* 4 of these (0-3) */
+#define IXGBE_IPSRXSPI		0x08E14
+#define IXGBE_IPSRXIPIDX	0x08E18
+#define IXGBE_IPSRXKEY(_i)	(0x08E1C + (4 * (_i))) /* 4 of these (0-3) */
+#define IXGBE_IPSRXSALT		0x08E2C
+#define IXGBE_IPSRXMOD		0x08E30
+
+#define IXGBE_SECTXCTRL_STORE_FORWARD_ENABLE	0x4
 
 /* DCB registers */
-#define IXGBE_RTRPCS      0x02430
-#define IXGBE_RTTDCS      0x04900
-#define IXGBE_RTTDCS_ARBDIS     0x00000040 /* DCB arbiter disable */
-#define IXGBE_RTTPCS      0x0CD00
-#define IXGBE_RTRUP2TC    0x03020
-#define IXGBE_RTTUP2TC    0x0C800
-#define IXGBE_RTRPT4C(_i) (0x02140 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_TXLLQ(_i)   (0x082E0 + ((_i) * 4)) /* 4 of these (0-3) */
-#define IXGBE_RTRPT4S(_i) (0x02160 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RTTDT2C(_i) (0x04910 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RTTDT2S(_i) (0x04930 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RTTPT2C(_i) (0x0CD20 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RTTPT2S(_i) (0x0CD40 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_RTTDQSEL    0x04904
-#define IXGBE_RTTDT1C     0x04908
-#define IXGBE_RTTDT1S     0x0490C
-#define IXGBE_RTTQCNCR    0x08B00
-#define IXGBE_RTTQCNTG    0x04A90
-#define IXGBE_RTTBCNRD    0x0498C
-#define IXGBE_RTTQCNRR    0x0498C
-#define IXGBE_RTTDTECC    0x04990
-#define IXGBE_RTTDTECC_NO_BCN   0x00000100
-#define IXGBE_RTTBCNRC    0x04984
-#define IXGBE_RTTBCNRC_RS_ENA	0x80000000
+#define IXGBE_RTRPCS		0x02430
+#define IXGBE_RTTDCS		0x04900
+#define IXGBE_RTTDCS_ARBDIS	0x00000040 /* DCB arbiter disable */
+#define IXGBE_RTTPCS		0x0CD00
+#define IXGBE_RTRUP2TC		0x03020
+#define IXGBE_RTTUP2TC		0x0C800
+#define IXGBE_RTRPT4C(_i)	(0x02140 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_TXLLQ(_i)		(0x082E0 + ((_i) * 4)) /* 4 of these (0-3) */
+#define IXGBE_RTRPT4S(_i)	(0x02160 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RTTDT2C(_i)	(0x04910 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RTTDT2S(_i)	(0x04930 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RTTPT2C(_i)	(0x0CD20 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RTTPT2S(_i)	(0x0CD40 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_RTTDQSEL		0x04904
+#define IXGBE_RTTDT1C		0x04908
+#define IXGBE_RTTDT1S		0x0490C
+#define IXGBE_RTTQCNCR		0x08B00
+#define IXGBE_RTTQCNTG		0x04A90
+#define IXGBE_RTTBCNRD		0x0498C
+#define IXGBE_RTTQCNRR		0x0498C
+#define IXGBE_RTTDTECC		0x04990
+#define IXGBE_RTTDTECC_NO_BCN	0x00000100
+
+#define IXGBE_RTTBCNRC			0x04984
+#define IXGBE_RTTBCNRC_RS_ENA		0x80000000
 #define IXGBE_RTTBCNRC_RF_DEC_MASK	0x00003FFF
 #define IXGBE_RTTBCNRC_RF_INT_SHIFT	14
-#define IXGBE_RTTBCNRC_RF_INT_MASK	\
+#define IXGBE_RTTBCNRC_RF_INT_MASK \
 	(IXGBE_RTTBCNRC_RF_DEC_MASK << IXGBE_RTTBCNRC_RF_INT_SHIFT)
-#define IXGBE_RTTBCNRM    0x04980
-#define IXGBE_RTTQCNRM    0x04980
+#define IXGBE_RTTBCNRM	0x04980
+#define IXGBE_RTTQCNRM	0x04980
 
+/* FCoE DMA Context Registers */
 /* FCoE Direct DMA Context */
 #define IXGBE_FCDDC(_i, _j)	(0x20000 + ((_i) * 0x4) + ((_j) * 0x10))
-/* FCoE DMA Context Registers */
-#define IXGBE_FCPTRL    0x02410 /* FC User Desc. PTR Low */
-#define IXGBE_FCPTRH    0x02414 /* FC USer Desc. PTR High */
-#define IXGBE_FCBUFF    0x02418 /* FC Buffer Control */
-#define IXGBE_FCDMARW   0x02420 /* FC Receive DMA RW */
-#define IXGBE_FCINVST0  0x03FC0 /* FC Invalid DMA Context Status Reg 0 */
-#define IXGBE_FCINVST(_i)       (IXGBE_FCINVST0 + ((_i) * 4))
-#define IXGBE_FCBUFF_VALID      BIT(0)    /* DMA Context Valid */
-#define IXGBE_FCBUFF_BUFFSIZE   (3u << 3) /* User Buffer Size */
-#define IXGBE_FCBUFF_WRCONTX    BIT(7)    /* 0: Initiator, 1: Target */
-#define IXGBE_FCBUFF_BUFFCNT    0x0000ff00 /* Number of User Buffers */
-#define IXGBE_FCBUFF_OFFSET     0xffff0000 /* User Buffer Offset */
-#define IXGBE_FCBUFF_BUFFSIZE_SHIFT  3
-#define IXGBE_FCBUFF_BUFFCNT_SHIFT   8
-#define IXGBE_FCBUFF_OFFSET_SHIFT    16
-#define IXGBE_FCDMARW_WE        BIT(14)   /* Write enable */
-#define IXGBE_FCDMARW_RE        BIT(15)   /* Read enable */
-#define IXGBE_FCDMARW_FCOESEL   0x000001ff  /* FC X_ID: 11 bits */
-#define IXGBE_FCDMARW_LASTSIZE  0xffff0000  /* Last User Buffer Size */
-#define IXGBE_FCDMARW_LASTSIZE_SHIFT 16
-
+#define IXGBE_FCPTRL		0x02410 /* FC User Desc. PTR Low */
+#define IXGBE_FCPTRH		0x02414 /* FC USer Desc. PTR High */
+#define IXGBE_FCBUFF		0x02418 /* FC Buffer Control */
+#define IXGBE_FCDMARW		0x02420 /* FC Receive DMA RW */
+#define IXGBE_FCBUFF_VALID	(1 << 0)   /* DMA Context Valid */
+#define IXGBE_FCBUFF_BUFFSIZE	(3 << 3)   /* User Buffer Size */
+#define IXGBE_FCBUFF_WRCONTX	(1 << 7)   /* 0: Initiator, 1: Target */
+#define IXGBE_FCBUFF_BUFFCNT	0x0000ff00 /* Number of User Buffers */
+#define IXGBE_FCBUFF_OFFSET	0xffff0000 /* User Buffer Offset */
+#define IXGBE_FCBUFF_BUFFSIZE_SHIFT	3
+#define IXGBE_FCBUFF_BUFFCNT_SHIFT	8
+#define IXGBE_FCBUFF_OFFSET_SHIFT	16
+#define IXGBE_FCDMARW_WE		(1 << 14)   /* Write enable */
+#define IXGBE_FCDMARW_RE		(1 << 15)   /* Read enable */
+#define IXGBE_FCDMARW_FCOESEL		0x000001ff  /* FC X_ID: 11 bits */
+#define IXGBE_FCDMARW_LASTSIZE		0xffff0000  /* Last User Buffer Size */
+#define IXGBE_FCDMARW_LASTSIZE_SHIFT	16
 /* FCoE SOF/EOF */
-#define IXGBE_TEOFF     0x04A94 /* Tx FC EOF */
-#define IXGBE_TSOFF     0x04A98 /* Tx FC SOF */
-#define IXGBE_REOFF     0x05158 /* Rx FC EOF */
-#define IXGBE_RSOFF     0x051F8 /* Rx FC SOF */
+#define IXGBE_TEOFF		0x04A94 /* Tx FC EOF */
+#define IXGBE_TSOFF		0x04A98 /* Tx FC SOF */
+#define IXGBE_REOFF		0x05158 /* Rx FC EOF */
+#define IXGBE_RSOFF		0x051F8 /* Rx FC SOF */
+/* FCoE Filter Context Registers */
+#define IXGBE_FCD_ID		0x05114 /* FCoE D_ID */
+#define IXGBE_FCSMAC		0x0510C /* FCoE Source MAC */
+#define IXGBE_FCFLTRW_SMAC_HIGH_SHIFT	16
 /* FCoE Direct Filter Context */
 #define IXGBE_FCDFC(_i, _j)	(0x28000 + ((_i) * 0x4) + ((_j) * 0x10))
 #define IXGBE_FCDFCD(_i)	(0x30000 + ((_i) * 0x4))
-/* FCoE Filter Context Registers */
-#define IXGBE_FCFLT     0x05108 /* FC FLT Context */
-#define IXGBE_FCFLTRW   0x05110 /* FC Filter RW Control */
-#define IXGBE_FCPARAM   0x051d8 /* FC Offset Parameter */
-#define IXGBE_FCFLT_VALID       BIT(0)   /* Filter Context Valid */
-#define IXGBE_FCFLT_FIRST       BIT(1)   /* Filter First */
-#define IXGBE_FCFLT_SEQID       0x00ff0000 /* Sequence ID */
-#define IXGBE_FCFLT_SEQCNT      0xff000000 /* Sequence Count */
-#define IXGBE_FCFLTRW_RVALDT    BIT(13)  /* Fast Re-Validation */
-#define IXGBE_FCFLTRW_WE        BIT(14)  /* Write Enable */
-#define IXGBE_FCFLTRW_RE        BIT(15)  /* Read Enable */
+#define IXGBE_FCFLT		0x05108 /* FC FLT Context */
+#define IXGBE_FCFLTRW		0x05110 /* FC Filter RW Control */
+#define IXGBE_FCPARAM		0x051d8 /* FC Offset Parameter */
+#define IXGBE_FCFLT_VALID	(1 << 0)   /* Filter Context Valid */
+#define IXGBE_FCFLT_FIRST	(1 << 1)   /* Filter First */
+#define IXGBE_FCFLT_SEQID	0x00ff0000 /* Sequence ID */
+#define IXGBE_FCFLT_SEQCNT	0xff000000 /* Sequence Count */
+#define IXGBE_FCFLTRW_RVALDT	(1 << 13)  /* Fast Re-Validation */
+#define IXGBE_FCFLTRW_WE	(1 << 14)  /* Write Enable */
+#define IXGBE_FCFLTRW_RE	(1 << 15)  /* Read Enable */
 /* FCoE Receive Control */
-#define IXGBE_FCRXCTRL  0x05100 /* FC Receive Control */
-#define IXGBE_FCRXCTRL_FCOELLI  BIT(0)   /* Low latency interrupt */
-#define IXGBE_FCRXCTRL_SAVBAD   BIT(1)   /* Save Bad Frames */
-#define IXGBE_FCRXCTRL_FRSTRDH  BIT(2)   /* EN 1st Read Header */
-#define IXGBE_FCRXCTRL_LASTSEQH BIT(3)   /* EN Last Header in Seq */
-#define IXGBE_FCRXCTRL_ALLH     BIT(4)   /* EN All Headers */
-#define IXGBE_FCRXCTRL_FRSTSEQH BIT(5)   /* EN 1st Seq. Header */
-#define IXGBE_FCRXCTRL_ICRC     BIT(6)   /* Ignore Bad FC CRC */
-#define IXGBE_FCRXCTRL_FCCRCBO  BIT(7)   /* FC CRC Byte Ordering */
-#define IXGBE_FCRXCTRL_FCOEVER  0x00000f00 /* FCoE Version: 4 bits */
-#define IXGBE_FCRXCTRL_FCOEVER_SHIFT 8
+#define IXGBE_FCRXCTRL		0x05100 /* FC Receive Control */
+#define IXGBE_FCRXCTRL_FCOELLI	(1 << 0)   /* Low latency interrupt */
+#define IXGBE_FCRXCTRL_SAVBAD	(1 << 1)   /* Save Bad Frames */
+#define IXGBE_FCRXCTRL_FRSTRDH	(1 << 2)   /* EN 1st Read Header */
+#define IXGBE_FCRXCTRL_LASTSEQH	(1 << 3)   /* EN Last Header in Seq */
+#define IXGBE_FCRXCTRL_ALLH	(1 << 4)   /* EN All Headers */
+#define IXGBE_FCRXCTRL_FRSTSEQH	(1 << 5)   /* EN 1st Seq. Header */
+#define IXGBE_FCRXCTRL_ICRC	(1 << 6)   /* Ignore Bad FC CRC */
+#define IXGBE_FCRXCTRL_FCCRCBO	(1 << 7)   /* FC CRC Byte Ordering */
+#define IXGBE_FCRXCTRL_FCOEVER	0x00000f00 /* FCoE Version: 4 bits */
+#define IXGBE_FCRXCTRL_FCOEVER_SHIFT	8
 /* FCoE Redirection */
-#define IXGBE_FCRECTL   0x0ED00 /* FC Redirection Control */
-#define IXGBE_FCRETA0   0x0ED10 /* FC Redirection Table 0 */
-#define IXGBE_FCRETA(_i)        (IXGBE_FCRETA0 + ((_i) * 4)) /* FCoE Redir */
-#define IXGBE_FCRECTL_ENA       0x1        /* FCoE Redir Table Enable */
-#define IXGBE_FCRETA_SIZE       8          /* Max entries in FCRETA */
-#define IXGBE_FCRETA_ENTRY_MASK 0x0000007f /* 7 bits for the queue index */
+#define IXGBE_FCRECTL		0x0ED00 /* FC Redirection Control */
+#define IXGBE_FCRETA0		0x0ED10 /* FC Redirection Table 0 */
+#define IXGBE_FCRETA(_i)	(IXGBE_FCRETA0 + ((_i) * 4)) /* FCoE Redir */
+#define IXGBE_FCRECTL_ENA	0x1 /* FCoE Redir Table Enable */
+#define IXGBE_FCRETASEL_ENA	0x2 /* FCoE FCRETASEL bit */
+#define IXGBE_FCRETA_SIZE	8 /* Max entries in FCRETA */
+#define IXGBE_FCRETA_ENTRY_MASK	0x0000007f /* 7 bits for the queue index */
 #define IXGBE_FCRETA_SIZE_X550	32 /* Max entries in FCRETA */
 /* Higher 7 bits for the queue index */
 #define IXGBE_FCRETA_ENTRY_HIGH_MASK	0x007F0000
 #define IXGBE_FCRETA_ENTRY_HIGH_SHIFT	16
 
 /* Stats registers */
-#define IXGBE_CRCERRS   0x04000
-#define IXGBE_ILLERRC   0x04004
-#define IXGBE_ERRBC     0x04008
-#define IXGBE_MSPDC     0x04010
-#define IXGBE_MPC(_i)   (0x03FA0 + ((_i) * 4)) /* 8 of these 3FA0-3FBC*/
-#define IXGBE_MLFC      0x04034
-#define IXGBE_MRFC      0x04038
-#define IXGBE_RLEC      0x04040
-#define IXGBE_LXONTXC   0x03F60
-#define IXGBE_LXONRXC   0x0CF60
-#define IXGBE_LXOFFTXC  0x03F68
-#define IXGBE_LXOFFRXC  0x0CF68
-#define IXGBE_LXONRXCNT 0x041A4
-#define IXGBE_LXOFFRXCNT 0x041A8
-#define IXGBE_PXONRXCNT(_i)     (0x04140 + ((_i) * 4)) /* 8 of these */
-#define IXGBE_PXOFFRXCNT(_i)    (0x04160 + ((_i) * 4)) /* 8 of these */
-#define IXGBE_PXON2OFFCNT(_i)   (0x03240 + ((_i) * 4)) /* 8 of these */
-#define IXGBE_PXONTXC(_i)       (0x03F00 + ((_i) * 4)) /* 8 of these 3F00-3F1C*/
-#define IXGBE_PXONRXC(_i)       (0x0CF00 + ((_i) * 4)) /* 8 of these CF00-CF1C*/
-#define IXGBE_PXOFFTXC(_i)      (0x03F20 + ((_i) * 4)) /* 8 of these 3F20-3F3C*/
-#define IXGBE_PXOFFRXC(_i)      (0x0CF20 + ((_i) * 4)) /* 8 of these CF20-CF3C*/
-#define IXGBE_PRC64     0x0405C
-#define IXGBE_PRC127    0x04060
-#define IXGBE_PRC255    0x04064
-#define IXGBE_PRC511    0x04068
-#define IXGBE_PRC1023   0x0406C
-#define IXGBE_PRC1522   0x04070
-#define IXGBE_GPRC      0x04074
-#define IXGBE_BPRC      0x04078
-#define IXGBE_MPRC      0x0407C
-#define IXGBE_GPTC      0x04080
-#define IXGBE_GORCL     0x04088
-#define IXGBE_GORCH     0x0408C
-#define IXGBE_GOTCL     0x04090
-#define IXGBE_GOTCH     0x04094
-#define IXGBE_RNBC(_i)  (0x03FC0 + ((_i) * 4)) /* 8 of these 3FC0-3FDC*/
-#define IXGBE_RUC       0x040A4
-#define IXGBE_RFC       0x040A8
-#define IXGBE_ROC       0x040AC
-#define IXGBE_RJC       0x040B0
-#define IXGBE_MNGPRC    0x040B4
-#define IXGBE_MNGPDC    0x040B8
-#define IXGBE_MNGPTC    0x0CF90
-#define IXGBE_TORL      0x040C0
-#define IXGBE_TORH      0x040C4
-#define IXGBE_TPR       0x040D0
-#define IXGBE_TPT       0x040D4
-#define IXGBE_PTC64     0x040D8
-#define IXGBE_PTC127    0x040DC
-#define IXGBE_PTC255    0x040E0
-#define IXGBE_PTC511    0x040E4
-#define IXGBE_PTC1023   0x040E8
-#define IXGBE_PTC1522   0x040EC
-#define IXGBE_MPTC      0x040F0
-#define IXGBE_BPTC      0x040F4
-#define IXGBE_XEC       0x04120
-#define IXGBE_SSVPC     0x08780
-
-#define IXGBE_RQSMR(_i) (0x02300 + ((_i) * 4))
-#define IXGBE_TQSMR(_i) (((_i) <= 7) ? (0x07300 + ((_i) * 4)) : \
+#define IXGBE_CRCERRS	0x04000
+#define IXGBE_ILLERRC	0x04004
+#define IXGBE_ERRBC	0x04008
+#define IXGBE_MSPDC	0x04010
+#define IXGBE_MPC(_i)	(0x03FA0 + ((_i) * 4)) /* 8 of these 3FA0-3FBC*/
+#define IXGBE_MLFC	0x04034
+#define IXGBE_MRFC	0x04038
+#define IXGBE_RLEC	0x04040
+#define IXGBE_LXONTXC	0x03F60
+#define IXGBE_LXONRXC	0x0CF60
+#define IXGBE_LXOFFTXC	0x03F68
+#define IXGBE_LXOFFRXC	0x0CF68
+#define IXGBE_LXONRXCNT		0x041A4
+#define IXGBE_LXOFFRXCNT	0x041A8
+#define IXGBE_PXONRXCNT(_i)	(0x04140 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_PXOFFRXCNT(_i)	(0x04160 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_PXON2OFFCNT(_i)	(0x03240 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_PXONTXC(_i)	(0x03F00 + ((_i) * 4)) /* 8 of these 3F00-3F1C*/
+#define IXGBE_PXONRXC(_i)	(0x0CF00 + ((_i) * 4)) /* 8 of these CF00-CF1C*/
+#define IXGBE_PXOFFTXC(_i)	(0x03F20 + ((_i) * 4)) /* 8 of these 3F20-3F3C*/
+#define IXGBE_PXOFFRXC(_i)	(0x0CF20 + ((_i) * 4)) /* 8 of these CF20-CF3C*/
+#define IXGBE_PRC64		0x0405C
+#define IXGBE_PRC127		0x04060
+#define IXGBE_PRC255		0x04064
+#define IXGBE_PRC511		0x04068
+#define IXGBE_PRC1023		0x0406C
+#define IXGBE_PRC1522		0x04070
+#define IXGBE_GPRC		0x04074
+#define IXGBE_BPRC		0x04078
+#define IXGBE_MPRC		0x0407C
+#define IXGBE_GPTC		0x04080
+#define IXGBE_GORCL		0x04088
+#define IXGBE_GORCH		0x0408C
+#define IXGBE_GOTCL		0x04090
+#define IXGBE_GOTCH		0x04094
+#define IXGBE_RNBC(_i)		(0x03FC0 + ((_i) * 4)) /* 8 of these 3FC0-3FDC*/
+#define IXGBE_RUC		0x040A4
+#define IXGBE_RFC		0x040A8
+#define IXGBE_ROC		0x040AC
+#define IXGBE_RJC		0x040B0
+#define IXGBE_MNGPRC		0x040B4
+#define IXGBE_MNGPDC		0x040B8
+#define IXGBE_MNGPTC		0x0CF90
+#define IXGBE_TORL		0x040C0
+#define IXGBE_TORH		0x040C4
+#define IXGBE_TPR		0x040D0
+#define IXGBE_TPT		0x040D4
+#define IXGBE_PTC64		0x040D8
+#define IXGBE_PTC127		0x040DC
+#define IXGBE_PTC255		0x040E0
+#define IXGBE_PTC511		0x040E4
+#define IXGBE_PTC1023		0x040E8
+#define IXGBE_PTC1522		0x040EC
+#define IXGBE_MPTC		0x040F0
+#define IXGBE_BPTC		0x040F4
+#define IXGBE_XEC		0x04120
+#define IXGBE_SSVPC		0x08780
+
+#define IXGBE_RQSMR(_i)	(0x02300 + ((_i) * 4))
+#define IXGBE_TQSMR(_i)	(((_i) <= 7) ? (0x07300 + ((_i) * 4)) : \
 			 (0x08600 + ((_i) * 4)))
-#define IXGBE_TQSM(_i)  (0x08600 + ((_i) * 4))
-
-#define IXGBE_QPRC(_i) (0x01030 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QPTC(_i) (0x06030 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QBRC(_i) (0x01034 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QBTC(_i) (0x06034 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QBRC_L(_i) (0x01034 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QBRC_H(_i) (0x01038 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QPRDC(_i) (0x01430 + ((_i) * 0x40)) /* 16 of these */
-#define IXGBE_QBTC_L(_i) (0x08700 + ((_i) * 0x8)) /* 16 of these */
-#define IXGBE_QBTC_H(_i) (0x08704 + ((_i) * 0x8)) /* 16 of these */
-#define IXGBE_FCCRC     0x05118 /* Count of Good Eth CRC w/ Bad FC CRC */
-#define IXGBE_FCOERPDC  0x0241C /* FCoE Rx Packets Dropped Count */
-#define IXGBE_FCLAST    0x02424 /* FCoE Last Error Count */
-#define IXGBE_FCOEPRC   0x02428 /* Number of FCoE Packets Received */
-#define IXGBE_FCOEDWRC  0x0242C /* Number of FCoE DWords Received */
-#define IXGBE_FCOEPTC   0x08784 /* Number of FCoE Packets Transmitted */
-#define IXGBE_FCOEDWTC  0x08788 /* Number of FCoE DWords Transmitted */
-#define IXGBE_O2BGPTC   0x041C4
-#define IXGBE_O2BSPC    0x087B0
-#define IXGBE_B2OSPC    0x041C0
-#define IXGBE_B2OGPRC   0x02F90
-#define IXGBE_PCRC8ECL  0x0E810
-#define IXGBE_PCRC8ECH  0x0E811
-#define IXGBE_PCRC8ECH_MASK     0x1F
-#define IXGBE_LDPCECL   0x0E820
-#define IXGBE_LDPCECH   0x0E821
-
-/* MII clause 22/28 definitions */
-#define IXGBE_MDIO_PHY_LOW_POWER_MODE	0x0800
-
-#define IXGBE_MDIO_XENPAK_LASI_STATUS	0x9005 /* XENPAK LASI Status register */
-#define IXGBE_XENPAK_LASI_LINK_STATUS_ALARM 0x1 /* Link Status Alarm change */
-
-#define IXGBE_MDIO_AUTO_NEG_LINK_STATUS	0x4 /* Indicates if link is up */
-
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK	0x7 /* Speed/Duplex Mask */
-#define IXGBE_MDIO_AUTO_NEG_VEN_STAT_SPEED_MASK	0x6 /* Speed Mask */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10M_HALF 0x0 /* 10Mb/s Half Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10M_FULL 0x1 /* 10Mb/s Full Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_100M_HALF 0x2 /* 100Mb/s H Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_100M_FULL 0x3 /* 100Mb/s F Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_HALF 0x4 /* 1Gb/s Half Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL 0x5 /* 1Gb/s Full Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_HALF 0x6 /* 10Gb/s Half Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL 0x7 /* 10Gb/s Full Duplex */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB	0x4 /* 1Gb/s */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB	0x6 /* 10Gb/s */
-
-#define IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG 0xC400	/* 1G Provisioning 1 */
-#define IXGBE_MII_AUTONEG_XNP_TX_REG		0x17	/* 1G XNP Transmit */
-#define IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX	0x4000	/* full duplex, bit:14*/
-#define IXGBE_MII_1GBASE_T_ADVERTISE		0x8000	/* full duplex, bit:15*/
-#define IXGBE_MII_2_5GBASE_T_ADVERTISE		0x0400
-#define IXGBE_MII_5GBASE_T_ADVERTISE		0x0800
-#define IXGBE_MII_RESTART			0x200
-#define IXGBE_MII_AUTONEG_LINK_UP		0x04
-#define IXGBE_MII_AUTONEG_REG			0x0
+#define IXGBE_TQSM(_i)	(0x08600 + ((_i) * 4))
+
+#define IXGBE_QPRC(_i)	(0x01030 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QPTC(_i)	(0x06030 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QBRC(_i)	(0x01034 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QBTC(_i)	(0x06034 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QBRC_L(_i)	(0x01034 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QBRC_H(_i)	(0x01038 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QPRDC(_i)		(0x01430 + ((_i) * 0x40)) /* 16 of these */
+#define IXGBE_QBTC_L(_i)	(0x08700 + ((_i) * 0x8)) /* 16 of these */
+#define IXGBE_QBTC_H(_i)	(0x08704 + ((_i) * 0x8)) /* 16 of these */
+#define IXGBE_FCCRC		0x05118 /* Num of Good Eth CRC w/ Bad FC CRC */
+#define IXGBE_FCOERPDC		0x0241C /* FCoE Rx Packets Dropped Count */
+#define IXGBE_FCLAST		0x02424 /* FCoE Last Error Count */
+#define IXGBE_FCOEPRC		0x02428 /* Number of FCoE Packets Received */
+#define IXGBE_FCOEDWRC		0x0242C /* Number of FCoE DWords Received */
+#define IXGBE_FCOEPTC		0x08784 /* Number of FCoE Packets Transmitted */
+#define IXGBE_FCOEDWTC		0x08788 /* Number of FCoE DWords Transmitted */
+#define IXGBE_FCCRC_CNT_MASK	0x0000FFFF /* CRC_CNT: bit 0 - 15 */
+#define IXGBE_FCLAST_CNT_MASK	0x0000FFFF /* Last_CNT: bit 0 - 15 */
+#define IXGBE_O2BGPTC		0x041C4
+#define IXGBE_O2BSPC		0x087B0
+#define IXGBE_B2OSPC		0x041C0
+#define IXGBE_B2OGPRC		0x02F90
+#define IXGBE_BUPRC		0x04180
+#define IXGBE_BMPRC		0x04184
+#define IXGBE_BBPRC		0x04188
+#define IXGBE_BUPTC		0x0418C
+#define IXGBE_BMPTC		0x04190
+#define IXGBE_BBPTC		0x04194
+#define IXGBE_BCRCERRS		0x04198
+#define IXGBE_BXONRXC		0x0419C
+#define IXGBE_BXOFFRXC		0x041E0
+#define IXGBE_BXONTXC		0x041E4
+#define IXGBE_BXOFFTXC		0x041E8
 
 /* Management */
-#define IXGBE_MAVTV(_i) (0x05010 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_MFUTP(_i) (0x05030 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_MANC      0x05820
-#define IXGBE_MFVAL     0x05824
-#define IXGBE_MANC2H    0x05860
-#define IXGBE_MDEF(_i)  (0x05890 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_MIPAF     0x058B0
-#define IXGBE_MMAL(_i)  (0x05910 + ((_i) * 8)) /* 4 of these (0-3) */
-#define IXGBE_MMAH(_i)  (0x05914 + ((_i) * 8)) /* 4 of these (0-3) */
-#define IXGBE_FTFT      0x09400 /* 0x9400-0x97FC */
-#define IXGBE_METF(_i)  (0x05190 + ((_i) * 4)) /* 4 of these (0-3) */
-#define IXGBE_MDEF_EXT(_i) (0x05160 + ((_i) * 4)) /* 8 of these (0-7) */
-#define IXGBE_LSWFW     0x15014
+#define IXGBE_MAVTV(_i)		(0x05010 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_MFUTP(_i)		(0x05030 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_MANC		0x05820
+#define IXGBE_MFVAL		0x05824
+#define IXGBE_MANC2H		0x05860
+#define IXGBE_MDEF(_i)		(0x05890 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_MIPAF		0x058B0
+#define IXGBE_MMAL(_i)		(0x05910 + ((_i) * 8)) /* 4 of these (0-3) */
+#define IXGBE_MMAH(_i)		(0x05914 + ((_i) * 8)) /* 4 of these (0-3) */
+#define IXGBE_FTFT		0x09400 /* 0x9400-0x97FC */
+#define IXGBE_METF(_i)		(0x05190 + ((_i) * 4)) /* 4 of these (0-3) */
+#define IXGBE_MDEF_EXT(_i)	(0x05160 + ((_i) * 4)) /* 8 of these (0-7) */
+#define IXGBE_LSWFW		0x15F14
+#define IXGBE_BMCIP(_i)		(0x05050 + ((_i) * 4)) /* 0x5050-0x505C */
+#define IXGBE_BMCIPVAL		0x05060
+#define IXGBE_BMCIP_IPADDR_TYPE	0x00000001
+#define IXGBE_BMCIP_IPADDR_VALID	0x00000002
 
 /* Management Bit Fields and Masks */
+#define IXGBE_MANC_MPROXYE	0x40000000 /* Management Proxy Enable */
 #define IXGBE_MANC_RCV_TCO_EN	0x00020000 /* Rcv TCO packet enable */
+#define IXGBE_MANC_EN_BMC2OS	0x10000000 /* Ena BMC2OS and OS2BMC traffic */
+#define IXGBE_MANC_EN_BMC2OS_SHIFT	28
 
 /* Firmware Semaphore Register */
 #define IXGBE_FWSM_MODE_MASK	0xE
+#define IXGBE_FWSM_TS_ENABLED	0x1
 #define IXGBE_FWSM_FW_MODE_PT	0x4
-#define IXGBE_FWSM_FW_NVM_RECOVERY_MODE	BIT(5)
-#define IXGBE_FWSM_EXT_ERR_IND_MASK	0x01F80000
-#define IXGBE_FWSM_FW_VAL_BIT	BIT(15)
+#define IXGBE_FWSM_FW_NVM_RECOVERY_MODE (1 << 5)
+#define IXGBE_FWSM_EXT_ERR_IND_MASK 0x01F80000
+#define IXGBE_FWSM_FW_VAL_BIT	(1 << 15)
 
 /* ARC Subsystem registers */
-#define IXGBE_HICR      0x15F00
-#define IXGBE_FWSTS     0x15F0C
-#define IXGBE_HSMC0R    0x15F04
-#define IXGBE_HSMC1R    0x15F08
-#define IXGBE_SWSR      0x15F10
-#define IXGBE_HFDR      0x15FE8
-#define IXGBE_FLEX_MNG  0x15800 /* 0x15800 - 0x15EFC */
-
-#define IXGBE_HICR_EN              0x01  /* Enable bit - RO */
+#define IXGBE_HICR		0x15F00
+#define IXGBE_FWSTS		0x15F0C
+#define IXGBE_HSMC0R		0x15F04
+#define IXGBE_HSMC1R		0x15F08
+#define IXGBE_SWSR		0x15F10
+#define IXGBE_FWRESETCNT	0x15F40
+#define IXGBE_HFDR		0x15FE8
+#define IXGBE_FLEX_MNG		0x15800 /* 0x15800 - 0x15EFC */
+#define IXGBE_FLEX_MNG_PTR(_i)	(IXGBE_FLEX_MNG + ((_i) * 4))
+
+#define IXGBE_HICR_EN		0x01  /* Enable bit - RO */
 /* Driver sets this bit when done to put command in RAM */
-#define IXGBE_HICR_C               0x02
-#define IXGBE_HICR_SV              0x04  /* Status Validity */
-#define IXGBE_HICR_FW_RESET_ENABLE 0x40
-#define IXGBE_HICR_FW_RESET        0x80
+#define IXGBE_HICR_C		0x02
+#define IXGBE_HICR_SV		0x04  /* Status Validity */
+#define IXGBE_HICR_FW_RESET_ENABLE	0x40
+#define IXGBE_HICR_FW_RESET	0x80
 
 /* PCI-E registers */
-#define IXGBE_GCR       0x11000
-#define IXGBE_GTV       0x11004
-#define IXGBE_FUNCTAG   0x11008
-#define IXGBE_GLT       0x1100C
-#define IXGBE_GSCL_1    0x11010
-#define IXGBE_GSCL_2    0x11014
-#define IXGBE_GSCL_3    0x11018
-#define IXGBE_GSCL_4    0x1101C
-#define IXGBE_GSCN_0    0x11020
-#define IXGBE_GSCN_1    0x11024
-#define IXGBE_GSCN_2    0x11028
-#define IXGBE_GSCN_3    0x1102C
-#define IXGBE_FACTPS_8259X	0x10150
-#define IXGBE_FACTPS_X540	IXGBE_FACTPS_8259X
-#define IXGBE_FACTPS_X550	IXGBE_FACTPS_8259X
-#define IXGBE_FACTPS_X550EM_x	IXGBE_FACTPS_8259X
+#define IXGBE_GCR		0x11000
+#define IXGBE_GTV		0x11004
+#define IXGBE_FUNCTAG		0x11008
+#define IXGBE_GLT		0x1100C
+#define IXGBE_PCIEPIPEADR	0x11004
+#define IXGBE_PCIEPIPEDAT	0x11008
+#define IXGBE_GSCL_1		0x11010
+#define IXGBE_GSCL_2		0x11014
+#define IXGBE_GSCL_1_X540	IXGBE_GSCL_1
+#define IXGBE_GSCL_2_X540	IXGBE_GSCL_2
+#define IXGBE_GSCL_3		0x11018
+#define IXGBE_GSCL_4		0x1101C
+#define IXGBE_GSCN_0		0x11020
+#define IXGBE_GSCN_1		0x11024
+#define IXGBE_GSCN_2		0x11028
+#define IXGBE_GSCN_3		0x1102C
+#define IXGBE_GSCN_0_X540	IXGBE_GSCN_0
+#define IXGBE_GSCN_1_X540	IXGBE_GSCN_1
+#define IXGBE_GSCN_2_X540	IXGBE_GSCN_2
+#define IXGBE_GSCN_3_X540	IXGBE_GSCN_3
+#define IXGBE_FACTPS		0x10150
+#define IXGBE_FACTPS_X540	IXGBE_FACTPS
+#define IXGBE_GSCL_1_X550	0x11800
+#define IXGBE_GSCL_2_X550	0x11804
+#define IXGBE_GSCL_1_X550EM_x	IXGBE_GSCL_1_X550
+#define IXGBE_GSCL_2_X550EM_x	IXGBE_GSCL_2_X550
+#define IXGBE_GSCN_0_X550	0x11820
+#define IXGBE_GSCN_1_X550	0x11824
+#define IXGBE_GSCN_2_X550	0x11828
+#define IXGBE_GSCN_3_X550	0x1182C
+#define IXGBE_GSCN_0_X550EM_x	IXGBE_GSCN_0_X550
+#define IXGBE_GSCN_1_X550EM_x	IXGBE_GSCN_1_X550
+#define IXGBE_GSCN_2_X550EM_x	IXGBE_GSCN_2_X550
+#define IXGBE_GSCN_3_X550EM_x	IXGBE_GSCN_3_X550
+#define IXGBE_FACTPS_X550	IXGBE_FACTPS
+#define IXGBE_FACTPS_X550EM_x	IXGBE_FACTPS
+#define IXGBE_GSCL_1_X550EM_a	IXGBE_GSCL_1_X550
+#define IXGBE_GSCL_2_X550EM_a	IXGBE_GSCL_2_X550
+#define IXGBE_GSCN_0_X550EM_a	IXGBE_GSCN_0_X550
+#define IXGBE_GSCN_1_X550EM_a	IXGBE_GSCN_1_X550
+#define IXGBE_GSCN_2_X550EM_a	IXGBE_GSCN_2_X550
+#define IXGBE_GSCN_3_X550EM_a	IXGBE_GSCN_3_X550
 #define IXGBE_FACTPS_X550EM_a	0x15FEC
-#define IXGBE_FACTPS(_hw)	IXGBE_BY_MAC((_hw), FACTPS)
+#define IXGBE_FACTPS_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), FACTPS)
 
-#define IXGBE_PCIEANACTL  0x11040
-#define IXGBE_SWSM_8259X	0x10140
-#define IXGBE_SWSM_X540		IXGBE_SWSM_8259X
-#define IXGBE_SWSM_X550		IXGBE_SWSM_8259X
-#define IXGBE_SWSM_X550EM_x	IXGBE_SWSM_8259X
+#define IXGBE_PCIEANACTL	0x11040
+#define IXGBE_SWSM		0x10140
+#define IXGBE_SWSM_X540		IXGBE_SWSM
+#define IXGBE_SWSM_X550		IXGBE_SWSM
+#define IXGBE_SWSM_X550EM_x	IXGBE_SWSM
 #define IXGBE_SWSM_X550EM_a	0x15F70
-#define IXGBE_SWSM(_hw)		IXGBE_BY_MAC((_hw), SWSM)
-#define IXGBE_FWSM_8259X	0x10148
-#define IXGBE_FWSM_X540		IXGBE_FWSM_8259X
-#define IXGBE_FWSM_X550		IXGBE_FWSM_8259X
-#define IXGBE_FWSM_X550EM_x	IXGBE_FWSM_8259X
+#define IXGBE_SWSM_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SWSM)
+
+#define IXGBE_FWSM		0x10148
+#define IXGBE_FWSM_X540		IXGBE_FWSM
+#define IXGBE_FWSM_X550		IXGBE_FWSM
+#define IXGBE_FWSM_X550EM_x	IXGBE_FWSM
 #define IXGBE_FWSM_X550EM_a	0x15F74
-#define IXGBE_FWSM(_hw)		IXGBE_BY_MAC((_hw), FWSM)
-#define IXGBE_GSSR      0x10160
-#define IXGBE_MREVID    0x11064
-#define IXGBE_DCA_ID    0x11070
-#define IXGBE_DCA_CTRL  0x11074
-#define IXGBE_SWFW_SYNC_8259X		IXGBE_GSSR
-#define IXGBE_SWFW_SYNC_X540		IXGBE_SWFW_SYNC_8259X
-#define IXGBE_SWFW_SYNC_X550		IXGBE_SWFW_SYNC_8259X
-#define IXGBE_SWFW_SYNC_X550EM_x	IXGBE_SWFW_SYNC_8259X
+#define IXGBE_FWSM_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), FWSM)
+
+#define IXGBE_SWFW_SYNC		IXGBE_GSSR
+#define IXGBE_SWFW_SYNC_X540	IXGBE_SWFW_SYNC
+#define IXGBE_SWFW_SYNC_X550	IXGBE_SWFW_SYNC
+#define IXGBE_SWFW_SYNC_X550EM_x	IXGBE_SWFW_SYNC
 #define IXGBE_SWFW_SYNC_X550EM_a	0x15F78
-#define IXGBE_SWFW_SYNC(_hw)		IXGBE_BY_MAC((_hw), SWFW_SYNC)
-
-/* PCIe registers 82599-specific */
-#define IXGBE_GCR_EXT           0x11050
-#define IXGBE_GSCL_5_82599      0x11030
-#define IXGBE_GSCL_6_82599      0x11034
-#define IXGBE_GSCL_7_82599      0x11038
-#define IXGBE_GSCL_8_82599      0x1103C
-#define IXGBE_PHYADR_82599      0x11040
-#define IXGBE_PHYDAT_82599      0x11044
-#define IXGBE_PHYCTL_82599      0x11048
-#define IXGBE_PBACLR_82599      0x11068
-
-#define IXGBE_CIAA_8259X	0x11088
-#define IXGBE_CIAA_X540		IXGBE_CIAA_8259X
+#define IXGBE_SWFW_SYNC_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SWFW_SYNC)
+
+#define IXGBE_GSSR		0x10160
+#define IXGBE_MREVID		0x11064
+#define IXGBE_DCA_ID		0x11070
+#define IXGBE_DCA_CTRL		0x11074
+
+/* PCI-E registers 82599-Specific */
+#define IXGBE_GCR_EXT		0x11050
+#define IXGBE_GSCL_5_82599	0x11030
+#define IXGBE_GSCL_6_82599	0x11034
+#define IXGBE_GSCL_7_82599	0x11038
+#define IXGBE_GSCL_8_82599	0x1103C
+#define IXGBE_GSCL_5_X540	IXGBE_GSCL_5_82599
+#define IXGBE_GSCL_6_X540	IXGBE_GSCL_6_82599
+#define IXGBE_GSCL_7_X540	IXGBE_GSCL_7_82599
+#define IXGBE_GSCL_8_X540	IXGBE_GSCL_8_82599
+#define IXGBE_PHYADR_82599	0x11040
+#define IXGBE_PHYDAT_82599	0x11044
+#define IXGBE_PHYCTL_82599	0x11048
+#define IXGBE_PBACLR_82599	0x11068
+#define IXGBE_CIAA		0x11088
+#define IXGBE_CIAD		0x1108C
+#define IXGBE_CIAA_82599	IXGBE_CIAA
+#define IXGBE_CIAD_82599	IXGBE_CIAD
+#define IXGBE_CIAA_X540		IXGBE_CIAA
+#define IXGBE_CIAD_X540		IXGBE_CIAD
+#define IXGBE_GSCL_5_X550	0x11810
+#define IXGBE_GSCL_6_X550	0x11814
+#define IXGBE_GSCL_7_X550	0x11818
+#define IXGBE_GSCL_8_X550	0x1181C
+#define IXGBE_GSCL_5_X550EM_x	IXGBE_GSCL_5_X550
+#define IXGBE_GSCL_6_X550EM_x	IXGBE_GSCL_6_X550
+#define IXGBE_GSCL_7_X550EM_x	IXGBE_GSCL_7_X550
+#define IXGBE_GSCL_8_X550EM_x	IXGBE_GSCL_8_X550
 #define IXGBE_CIAA_X550		0x11508
-#define IXGBE_CIAA_X550EM_x	IXGBE_CIAA_X550
-#define IXGBE_CIAA_X550EM_a	IXGBE_CIAA_X550
-#define IXGBE_CIAA(_hw)		IXGBE_BY_MAC((_hw), CIAA)
-
-#define IXGBE_CIAD_8259X	0x1108C
-#define IXGBE_CIAD_X540		IXGBE_CIAD_8259X
 #define IXGBE_CIAD_X550		0x11510
+#define IXGBE_CIAA_X550EM_x	IXGBE_CIAA_X550
 #define IXGBE_CIAD_X550EM_x	IXGBE_CIAD_X550
+#define IXGBE_GSCL_5_X550EM_a	IXGBE_GSCL_5_X550
+#define IXGBE_GSCL_6_X550EM_a	IXGBE_GSCL_6_X550
+#define IXGBE_GSCL_7_X550EM_a	IXGBE_GSCL_7_X550
+#define IXGBE_GSCL_8_X550EM_a	IXGBE_GSCL_8_X550
+#define IXGBE_CIAA_X550EM_a	IXGBE_CIAA_X550
 #define IXGBE_CIAD_X550EM_a	IXGBE_CIAD_X550
-#define IXGBE_CIAD(_hw)		IXGBE_BY_MAC((_hw), CIAD)
-
-#define IXGBE_PICAUSE           0x110B0
-#define IXGBE_PIENA             0x110B8
-#define IXGBE_CDQ_MBR_82599     0x110B4
-#define IXGBE_PCIESPARE         0x110BC
-#define IXGBE_MISC_REG_82599    0x110F0
-#define IXGBE_ECC_CTRL_0_82599  0x11100
-#define IXGBE_ECC_CTRL_1_82599  0x11104
-#define IXGBE_ECC_STATUS_82599  0x110E0
-#define IXGBE_BAR_CTRL_82599    0x110F4
+#define IXGBE_CIAA_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), CIAA)
+#define IXGBE_CIAD_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), CIAD)
+#define IXGBE_PICAUSE		0x110B0
+#define IXGBE_PIENA		0x110B8
+#define IXGBE_CDQ_MBR_82599	0x110B4
+#define IXGBE_PCIESPARE		0x110BC
+#define IXGBE_MISC_REG_82599	0x110F0
+#define IXGBE_ECC_CTRL_0_82599	0x11100
+#define IXGBE_ECC_CTRL_1_82599	0x11104
+#define IXGBE_ECC_STATUS_82599	0x110E0
+#define IXGBE_BAR_CTRL_82599	0x110F4
 
 /* PCI Express Control */
-#define IXGBE_GCR_CMPL_TMOUT_MASK       0x0000F000
-#define IXGBE_GCR_CMPL_TMOUT_10ms       0x00001000
-#define IXGBE_GCR_CMPL_TMOUT_RESEND     0x00010000
-#define IXGBE_GCR_CAP_VER2              0x00040000
-
-#define IXGBE_GCR_EXT_MSIX_EN           0x80000000
-#define IXGBE_GCR_EXT_BUFFERS_CLEAR     0x40000000
-#define IXGBE_GCR_EXT_VT_MODE_16        0x00000001
-#define IXGBE_GCR_EXT_VT_MODE_32        0x00000002
-#define IXGBE_GCR_EXT_VT_MODE_64        0x00000003
-#define IXGBE_GCR_EXT_SRIOV             (IXGBE_GCR_EXT_MSIX_EN | \
+#define IXGBE_GCR_CMPL_TMOUT_MASK	0x0000F000
+#define IXGBE_GCR_CMPL_TMOUT_10ms	0x00001000
+#define IXGBE_GCR_CMPL_TMOUT_RESEND	0x00010000
+#define IXGBE_GCR_CAP_VER2		0x00040000
+
+#define IXGBE_GCR_EXT_MSIX_EN		0x80000000
+#define IXGBE_GCR_EXT_BUFFERS_CLEAR	0x40000000
+#define IXGBE_GCR_EXT_VT_MODE_16	0x00000001
+#define IXGBE_GCR_EXT_VT_MODE_32	0x00000002
+#define IXGBE_GCR_EXT_VT_MODE_64	0x00000003
+#define IXGBE_GCR_EXT_SRIOV		(IXGBE_GCR_EXT_MSIX_EN | \
 					 IXGBE_GCR_EXT_VT_MODE_64)
-
+#define IXGBE_GCR_EXT_VT_MODE_MASK	0x00000003
 /* Time Sync Registers */
-#define IXGBE_TSYNCRXCTL 0x05188 /* Rx Time Sync Control register - RW */
-#define IXGBE_TSYNCTXCTL 0x08C00 /* Tx Time Sync Control register - RW */
-#define IXGBE_RXSTMPL    0x051E8 /* Rx timestamp Low - RO */
-#define IXGBE_RXSTMPH    0x051A4 /* Rx timestamp High - RO */
-#define IXGBE_RXSATRL    0x051A0 /* Rx timestamp attribute low - RO */
-#define IXGBE_RXSATRH    0x051A8 /* Rx timestamp attribute high - RO */
-#define IXGBE_RXMTRL     0x05120 /* RX message type register low - RW */
-#define IXGBE_TXSTMPL    0x08C04 /* Tx timestamp value Low - RO */
-#define IXGBE_TXSTMPH    0x08C08 /* Tx timestamp value High - RO */
-#define IXGBE_SYSTIML    0x08C0C /* System time register Low - RO */
-#define IXGBE_SYSTIMH    0x08C10 /* System time register High - RO */
-#define IXGBE_SYSTIMR    0x08C58 /* System time register Residue - RO */
-#define IXGBE_TIMINCA    0x08C14 /* Increment attributes register - RW */
-#define IXGBE_TIMADJL    0x08C18 /* Time Adjustment Offset register Low - RW */
-#define IXGBE_TIMADJH    0x08C1C /* Time Adjustment Offset register High - RW */
-#define IXGBE_TSAUXC     0x08C20 /* TimeSync Auxiliary Control register - RW */
-#define IXGBE_TRGTTIML0  0x08C24 /* Target Time Register 0 Low - RW */
-#define IXGBE_TRGTTIMH0  0x08C28 /* Target Time Register 0 High - RW */
-#define IXGBE_TRGTTIML1  0x08C2C /* Target Time Register 1 Low - RW */
-#define IXGBE_TRGTTIMH1  0x08C30 /* Target Time Register 1 High - RW */
-#define IXGBE_CLKTIML    0x08C34 /* Clock Out Time Register Low - RW */
-#define IXGBE_CLKTIMH    0x08C38 /* Clock Out Time Register High - RW */
-#define IXGBE_FREQOUT0   0x08C34 /* Frequency Out 0 Control register - RW */
-#define IXGBE_FREQOUT1   0x08C38 /* Frequency Out 1 Control register - RW */
-#define IXGBE_AUXSTMPL0  0x08C3C /* Auxiliary Time Stamp 0 register Low - RO */
-#define IXGBE_AUXSTMPH0  0x08C40 /* Auxiliary Time Stamp 0 register High - RO */
-#define IXGBE_AUXSTMPL1  0x08C44 /* Auxiliary Time Stamp 1 register Low - RO */
-#define IXGBE_AUXSTMPH1  0x08C48 /* Auxiliary Time Stamp 1 register High - RO */
-#define IXGBE_TSIM       0x08C68 /* TimeSync Interrupt Mask Register - RW */
-#define IXGBE_TSSDP      0x0003C /* TimeSync SDP Configuration Register - RW */
+#define IXGBE_TSYNCRXCTL	0x05188 /* Rx Time Sync Control register - RW */
+#define IXGBE_TSYNCTXCTL	0x08C00 /* Tx Time Sync Control register - RW */
+#define IXGBE_RXSTMPL	0x051E8 /* Rx timestamp Low - RO */
+#define IXGBE_RXSTMPH	0x051A4 /* Rx timestamp High - RO */
+#define IXGBE_RXSATRL	0x051A0 /* Rx timestamp attribute low - RO */
+#define IXGBE_RXSATRH	0x051A8 /* Rx timestamp attribute high - RO */
+#define IXGBE_RXMTRL	0x05120 /* RX message type register low - RW */
+#define IXGBE_TXSTMPL	0x08C04 /* Tx timestamp value Low - RO */
+#define IXGBE_TXSTMPH	0x08C08 /* Tx timestamp value High - RO */
+#define IXGBE_SYSTIML	0x08C0C /* System time register Low - RO */
+#define IXGBE_SYSTIMH	0x08C10 /* System time register High - RO */
+#define IXGBE_SYSTIMR	0x08C58 /* System time register Residue - RO */
+#define IXGBE_TIMINCA	0x08C14 /* Increment attributes register - RW */
+#define IXGBE_TIMADJL	0x08C18 /* Time Adjustment Offset register Low - RW */
+#define IXGBE_TIMADJH	0x08C1C /* Time Adjustment Offset register High - RW */
+#define IXGBE_TSAUXC	0x08C20 /* TimeSync Auxiliary Control register - RW */
+#define IXGBE_TRGTTIML0	0x08C24 /* Target Time Register 0 Low - RW */
+#define IXGBE_TRGTTIMH0	0x08C28 /* Target Time Register 0 High - RW */
+#define IXGBE_TRGTTIML1	0x08C2C /* Target Time Register 1 Low - RW */
+#define IXGBE_TRGTTIMH1	0x08C30 /* Target Time Register 1 High - RW */
+#define IXGBE_CLKTIML	0x08C34 /* Clock Out Time Register Low - RW */
+#define IXGBE_CLKTIMH	0x08C38 /* Clock Out Time Register High - RW */
+#define IXGBE_FREQOUT0	0x08C34 /* Frequency Out 0 Control register - RW */
+#define IXGBE_FREQOUT1	0x08C38 /* Frequency Out 1 Control register - RW */
+#define IXGBE_AUXSTMPL0	0x08C3C /* Auxiliary Time Stamp 0 register Low - RO */
+#define IXGBE_AUXSTMPH0	0x08C40 /* Auxiliary Time Stamp 0 register High - RO */
+#define IXGBE_AUXSTMPL1	0x08C44 /* Auxiliary Time Stamp 1 register Low - RO */
+#define IXGBE_AUXSTMPH1	0x08C48 /* Auxiliary Time Stamp 1 register High - RO */
+#define IXGBE_TSIM	0x08C68 /* TimeSync Interrupt Mask Register - RW */
+#define IXGBE_TSICR	0x08C60 /* TimeSync Interrupt Cause Register - WO */
+#define IXGBE_TSSDP	0x0003C /* TimeSync SDP Configuration Register - RW */
 
 /* Diagnostic Registers */
-#define IXGBE_RDSTATCTL   0x02C20
-#define IXGBE_RDSTAT(_i)  (0x02C00 + ((_i) * 4)) /* 0x02C00-0x02C1C */
-#define IXGBE_RDHMPN      0x02F08
-#define IXGBE_RIC_DW(_i)  (0x02F10 + ((_i) * 4))
-#define IXGBE_RDPROBE     0x02F20
-#define IXGBE_RDMAM       0x02F30
-#define IXGBE_RDMAD       0x02F34
-#define IXGBE_TDSTATCTL   0x07C20
-#define IXGBE_TDSTAT(_i)  (0x07C00 + ((_i) * 4)) /* 0x07C00 - 0x07C1C */
-#define IXGBE_TDHMPN      0x07F08
-#define IXGBE_TDHMPN2     0x082FC
-#define IXGBE_TXDESCIC    0x082CC
-#define IXGBE_TIC_DW(_i)  (0x07F10 + ((_i) * 4))
-#define IXGBE_TIC_DW2(_i) (0x082B0 + ((_i) * 4))
-#define IXGBE_TDPROBE     0x07F20
-#define IXGBE_TXBUFCTRL   0x0C600
-#define IXGBE_TXBUFDATA(_i) (0x0C610 + ((_i) * 4)) /* 4 of these (0-3) */
-#define IXGBE_RXBUFCTRL   0x03600
-#define IXGBE_RXBUFDATA(_i) (0x03610 + ((_i) * 4)) /* 4 of these (0-3) */
-#define IXGBE_PCIE_DIAG(_i)     (0x11090 + ((_i) * 4)) /* 8 of these */
-#define IXGBE_RFVAL     0x050A4
-#define IXGBE_MDFTC1    0x042B8
-#define IXGBE_MDFTC2    0x042C0
-#define IXGBE_MDFTFIFO1 0x042C4
-#define IXGBE_MDFTFIFO2 0x042C8
-#define IXGBE_MDFTS     0x042CC
-#define IXGBE_RXDATAWRPTR(_i)   (0x03700 + ((_i) * 4)) /* 8 of these 3700-370C*/
-#define IXGBE_RXDESCWRPTR(_i)   (0x03710 + ((_i) * 4)) /* 8 of these 3710-371C*/
-#define IXGBE_RXDATARDPTR(_i)   (0x03720 + ((_i) * 4)) /* 8 of these 3720-372C*/
-#define IXGBE_RXDESCRDPTR(_i)   (0x03730 + ((_i) * 4)) /* 8 of these 3730-373C*/
-#define IXGBE_TXDATAWRPTR(_i)   (0x0C700 + ((_i) * 4)) /* 8 of these C700-C70C*/
-#define IXGBE_TXDESCWRPTR(_i)   (0x0C710 + ((_i) * 4)) /* 8 of these C710-C71C*/
-#define IXGBE_TXDATARDPTR(_i)   (0x0C720 + ((_i) * 4)) /* 8 of these C720-C72C*/
-#define IXGBE_TXDESCRDPTR(_i)   (0x0C730 + ((_i) * 4)) /* 8 of these C730-C73C*/
-#define IXGBE_PCIEECCCTL 0x1106C
-#define IXGBE_RXWRPTR(_i)       (0x03100 + ((_i) * 4)) /* 8 of these 3100-310C*/
-#define IXGBE_RXUSED(_i)        (0x03120 + ((_i) * 4)) /* 8 of these 3120-312C*/
-#define IXGBE_RXRDPTR(_i)       (0x03140 + ((_i) * 4)) /* 8 of these 3140-314C*/
-#define IXGBE_RXRDWRPTR(_i)     (0x03160 + ((_i) * 4)) /* 8 of these 3160-310C*/
-#define IXGBE_TXWRPTR(_i)       (0x0C100 + ((_i) * 4)) /* 8 of these C100-C10C*/
-#define IXGBE_TXUSED(_i)        (0x0C120 + ((_i) * 4)) /* 8 of these C120-C12C*/
-#define IXGBE_TXRDPTR(_i)       (0x0C140 + ((_i) * 4)) /* 8 of these C140-C14C*/
-#define IXGBE_TXRDWRPTR(_i)     (0x0C160 + ((_i) * 4)) /* 8 of these C160-C10C*/
-#define IXGBE_PCIEECCCTL0 0x11100
-#define IXGBE_PCIEECCCTL1 0x11104
-#define IXGBE_RXDBUECC  0x03F70
-#define IXGBE_TXDBUECC  0x0CF70
-#define IXGBE_RXDBUEST 0x03F74
-#define IXGBE_TXDBUEST 0x0CF74
-#define IXGBE_PBTXECC   0x0C300
-#define IXGBE_PBRXECC   0x03300
-#define IXGBE_GHECCR    0x110B0
+#define IXGBE_RDSTATCTL		0x02C20
+#define IXGBE_RDSTAT(_i)	(0x02C00 + ((_i) * 4)) /* 0x02C00-0x02C1C */
+#define IXGBE_RDHMPN		0x02F08
+#define IXGBE_RIC_DW(_i)	(0x02F10 + ((_i) * 4))
+#define IXGBE_RDPROBE		0x02F20
+#define IXGBE_RDMAM		0x02F30
+#define IXGBE_RDMAD		0x02F34
+#define IXGBE_TDHMPN		0x07F08
+#define IXGBE_TDHMPN2		0x082FC
+#define IXGBE_TXDESCIC		0x082CC
+#define IXGBE_TIC_DW(_i)	(0x07F10 + ((_i) * 4))
+#define IXGBE_TIC_DW2(_i)	(0x082B0 + ((_i) * 4))
+#define IXGBE_TDPROBE		0x07F20
+#define IXGBE_TXBUFCTRL		0x0C600
+#define IXGBE_TXBUFDATA0	0x0C610
+#define IXGBE_TXBUFDATA1	0x0C614
+#define IXGBE_TXBUFDATA2	0x0C618
+#define IXGBE_TXBUFDATA3	0x0C61C
+#define IXGBE_RXBUFCTRL		0x03600
+#define IXGBE_RXBUFDATA0	0x03610
+#define IXGBE_RXBUFDATA1	0x03614
+#define IXGBE_RXBUFDATA2	0x03618
+#define IXGBE_RXBUFDATA3	0x0361C
+#define IXGBE_PCIE_DIAG(_i)	(0x11090 + ((_i) * 4)) /* 8 of these */
+#define IXGBE_RFVAL		0x050A4
+#define IXGBE_MDFTC1		0x042B8
+#define IXGBE_MDFTC2		0x042C0
+#define IXGBE_MDFTFIFO1		0x042C4
+#define IXGBE_MDFTFIFO2		0x042C8
+#define IXGBE_MDFTS		0x042CC
+#define IXGBE_RXDATAWRPTR(_i)	(0x03700 + ((_i) * 4)) /* 8 of these 3700-370C*/
+#define IXGBE_RXDESCWRPTR(_i)	(0x03710 + ((_i) * 4)) /* 8 of these 3710-371C*/
+#define IXGBE_RXDATARDPTR(_i)	(0x03720 + ((_i) * 4)) /* 8 of these 3720-372C*/
+#define IXGBE_RXDESCRDPTR(_i)	(0x03730 + ((_i) * 4)) /* 8 of these 3730-373C*/
+#define IXGBE_TXDATAWRPTR(_i)	(0x0C700 + ((_i) * 4)) /* 8 of these C700-C70C*/
+#define IXGBE_TXDESCWRPTR(_i)	(0x0C710 + ((_i) * 4)) /* 8 of these C710-C71C*/
+#define IXGBE_TXDATARDPTR(_i)	(0x0C720 + ((_i) * 4)) /* 8 of these C720-C72C*/
+#define IXGBE_TXDESCRDPTR(_i)	(0x0C730 + ((_i) * 4)) /* 8 of these C730-C73C*/
+#define IXGBE_PCIEECCCTL	0x1106C
+#define IXGBE_RXWRPTR(_i)	(0x03100 + ((_i) * 4)) /* 8 of these 3100-310C*/
+#define IXGBE_RXUSED(_i)	(0x03120 + ((_i) * 4)) /* 8 of these 3120-312C*/
+#define IXGBE_RXRDPTR(_i)	(0x03140 + ((_i) * 4)) /* 8 of these 3140-314C*/
+#define IXGBE_RXRDWRPTR(_i)	(0x03160 + ((_i) * 4)) /* 8 of these 3160-310C*/
+#define IXGBE_TXWRPTR(_i)	(0x0C100 + ((_i) * 4)) /* 8 of these C100-C10C*/
+#define IXGBE_TXUSED(_i)	(0x0C120 + ((_i) * 4)) /* 8 of these C120-C12C*/
+#define IXGBE_TXRDPTR(_i)	(0x0C140 + ((_i) * 4)) /* 8 of these C140-C14C*/
+#define IXGBE_TXRDWRPTR(_i)	(0x0C160 + ((_i) * 4)) /* 8 of these C160-C10C*/
+#define IXGBE_PCIEECCCTL0	0x11100
+#define IXGBE_PCIEECCCTL1	0x11104
+#define IXGBE_RXDBUECC		0x03F70
+#define IXGBE_TXDBUECC		0x0CF70
+#define IXGBE_RXDBUEST		0x03F74
+#define IXGBE_TXDBUEST		0x0CF74
+#define IXGBE_PBTXECC		0x0C300
+#define IXGBE_PBRXECC		0x03300
+#define IXGBE_GHECCR		0x110B0
 
 /* MAC Registers */
-#define IXGBE_PCS1GCFIG 0x04200
-#define IXGBE_PCS1GLCTL 0x04208
-#define IXGBE_PCS1GLSTA 0x0420C
-#define IXGBE_PCS1GDBG0 0x04210
-#define IXGBE_PCS1GDBG1 0x04214
-#define IXGBE_PCS1GANA  0x04218
-#define IXGBE_PCS1GANLP 0x0421C
-#define IXGBE_PCS1GANNP 0x04220
-#define IXGBE_PCS1GANLPNP 0x04224
-#define IXGBE_HLREG0    0x04240
-#define IXGBE_HLREG1    0x04244
-#define IXGBE_PAP       0x04248
-#define IXGBE_MACA      0x0424C
-#define IXGBE_APAE      0x04250
-#define IXGBE_ARD       0x04254
-#define IXGBE_AIS       0x04258
-#define IXGBE_MSCA      0x0425C
-#define IXGBE_MSRWD     0x04260
-#define IXGBE_MLADD     0x04264
-#define IXGBE_MHADD     0x04268
-#define IXGBE_MAXFRS    0x04268
-#define IXGBE_TREG      0x0426C
-#define IXGBE_PCSS1     0x04288
-#define IXGBE_PCSS2     0x0428C
-#define IXGBE_XPCSS     0x04290
-#define IXGBE_MFLCN     0x04294
-#define IXGBE_SERDESC   0x04298
-#define IXGBE_MAC_SGMII_BUSY 0x04298
-#define IXGBE_MACS      0x0429C
-#define IXGBE_AUTOC     0x042A0
-#define IXGBE_LINKS     0x042A4
-#define IXGBE_LINKS2    0x04324
-#define IXGBE_AUTOC2    0x042A8
-#define IXGBE_AUTOC3    0x042AC
-#define IXGBE_ANLP1     0x042B0
-#define IXGBE_ANLP2     0x042B4
-#define IXGBE_MACC      0x04330
-#define IXGBE_ATLASCTL  0x04800
-#define IXGBE_MMNGC     0x042D0
-#define IXGBE_ANLPNP1   0x042D4
-#define IXGBE_ANLPNP2   0x042D8
-#define IXGBE_KRPCSFC   0x042E0
-#define IXGBE_KRPCSS    0x042E4
-#define IXGBE_FECS1     0x042E8
-#define IXGBE_FECS2     0x042EC
-#define IXGBE_SMADARCTL 0x14F10
-#define IXGBE_MPVC      0x04318
-#define IXGBE_SGMIIC    0x04314
+#define IXGBE_PCS1GCFIG		0x04200
+#define IXGBE_PCS1GLCTL		0x04208
+#define IXGBE_PCS1GLSTA		0x0420C
+#define IXGBE_PCS1GDBG0		0x04210
+#define IXGBE_PCS1GDBG1		0x04214
+#define IXGBE_PCS1GANA		0x04218
+#define IXGBE_PCS1GANLP		0x0421C
+#define IXGBE_PCS1GANNP		0x04220
+#define IXGBE_PCS1GANLPNP	0x04224
+#define IXGBE_HLREG0		0x04240
+#define IXGBE_HLREG1		0x04244
+#define IXGBE_PAP		0x04248
+#define IXGBE_MACA		0x0424C
+#define IXGBE_APAE		0x04250
+#define IXGBE_ARD		0x04254
+#define IXGBE_AIS		0x04258
+#define IXGBE_MSCA		0x0425C
+#define IXGBE_MSRWD		0x04260
+#define IXGBE_MLADD		0x04264
+#define IXGBE_MHADD		0x04268
+#define IXGBE_MAXFRS		0x04268
+#define IXGBE_TREG		0x0426C
+#define IXGBE_PCSS1		0x04288
+#define IXGBE_PCSS2		0x0428C
+#define IXGBE_XPCSS		0x04290
+#define IXGBE_MFLCN		0x04294
+#define IXGBE_SERDESC		0x04298
+#define IXGBE_MAC_SGMII_BUSY	0x04298
+#define IXGBE_MACS		0x0429C
+#define IXGBE_AUTOC		0x042A0
+#define IXGBE_LINKS		0x042A4
+#define IXGBE_LINKS2		0x04324
+#define IXGBE_AUTOC2		0x042A8
+#define IXGBE_AUTOC3		0x042AC
+#define IXGBE_ANLP1		0x042B0
+#define IXGBE_ANLP2		0x042B4
+#define IXGBE_MACC		0x04330
+#define IXGBE_ATLASCTL		0x04800
+#define IXGBE_MMNGC		0x042D0
+#define IXGBE_ANLPNP1		0x042D4
+#define IXGBE_ANLPNP2		0x042D8
+#define IXGBE_KRPCSFC		0x042E0
+#define IXGBE_KRPCSS		0x042E4
+#define IXGBE_FECS1		0x042E8
+#define IXGBE_FECS2		0x042EC
+#define IXGBE_SMADARCTL		0x14F10
+#define IXGBE_MPVC		0x04318
+#define IXGBE_SGMIIC		0x04314
 
 /* Statistics Registers */
-#define IXGBE_RXNFGPC      0x041B0
-#define IXGBE_RXNFGBCL     0x041B4
-#define IXGBE_RXNFGBCH     0x041B8
-#define IXGBE_RXDGPC       0x02F50
-#define IXGBE_RXDGBCL      0x02F54
-#define IXGBE_RXDGBCH      0x02F58
-#define IXGBE_RXDDGPC      0x02F5C
-#define IXGBE_RXDDGBCL     0x02F60
-#define IXGBE_RXDDGBCH     0x02F64
-#define IXGBE_RXLPBKGPC    0x02F68
-#define IXGBE_RXLPBKGBCL   0x02F6C
-#define IXGBE_RXLPBKGBCH   0x02F70
-#define IXGBE_RXDLPBKGPC   0x02F74
-#define IXGBE_RXDLPBKGBCL  0x02F78
-#define IXGBE_RXDLPBKGBCH  0x02F7C
-#define IXGBE_TXDGPC       0x087A0
-#define IXGBE_TXDGBCL      0x087A4
-#define IXGBE_TXDGBCH      0x087A8
-
-#define IXGBE_RXDSTATCTRL 0x02F40
+#define IXGBE_RXNFGPC		0x041B0
+#define IXGBE_RXNFGBCL		0x041B4
+#define IXGBE_RXNFGBCH		0x041B8
+#define IXGBE_RXDGPC		0x02F50
+#define IXGBE_RXDGBCL		0x02F54
+#define IXGBE_RXDGBCH		0x02F58
+#define IXGBE_RXDDGPC		0x02F5C
+#define IXGBE_RXDDGBCL		0x02F60
+#define IXGBE_RXDDGBCH		0x02F64
+#define IXGBE_RXLPBKGPC		0x02F68
+#define IXGBE_RXLPBKGBCL	0x02F6C
+#define IXGBE_RXLPBKGBCH	0x02F70
+#define IXGBE_RXDLPBKGPC	0x02F74
+#define IXGBE_RXDLPBKGBCL	0x02F78
+#define IXGBE_RXDLPBKGBCH	0x02F7C
+#define IXGBE_TXDGPC		0x087A0
+#define IXGBE_TXDGBCL		0x087A4
+#define IXGBE_TXDGBCH		0x087A8
+
+#define IXGBE_RXDSTATCTRL	0x02F40
 
 /* Copper Pond 2 link timeout */
 #define IXGBE_VALIDATE_LINK_READY_TIMEOUT 50
 
 /* Omer CORECTL */
-#define IXGBE_CORECTL           0x014F00
+#define IXGBE_CORECTL			0x014F00
 /* BARCTRL */
-#define IXGBE_BARCTRL               0x110F4
-#define IXGBE_BARCTRL_FLSIZE        0x0700
-#define IXGBE_BARCTRL_FLSIZE_SHIFT  8
-#define IXGBE_BARCTRL_CSRSIZE       0x2000
+#define IXGBE_BARCTRL			0x110F4
+#define IXGBE_BARCTRL_FLSIZE		0x0700
+#define IXGBE_BARCTRL_FLSIZE_SHIFT	8
+#define IXGBE_BARCTRL_CSRSIZE		0x2000
+#define IXGBE_BARCTRL_CSRSIZE_SHIFT	13
 
 /* RSCCTL Bit Masks */
-#define IXGBE_RSCCTL_RSCEN          0x01
-#define IXGBE_RSCCTL_MAXDESC_1      0x00
-#define IXGBE_RSCCTL_MAXDESC_4      0x04
-#define IXGBE_RSCCTL_MAXDESC_8      0x08
-#define IXGBE_RSCCTL_MAXDESC_16     0x0C
+#define IXGBE_RSCCTL_RSCEN	0x01
+#define IXGBE_RSCCTL_MAXDESC_1	0x00
+#define IXGBE_RSCCTL_MAXDESC_4	0x04
+#define IXGBE_RSCCTL_MAXDESC_8	0x08
+#define IXGBE_RSCCTL_MAXDESC_16	0x0C
+#define IXGBE_RSCCTL_TS_DIS	0x02
 
 /* RSCDBU Bit Masks */
-#define IXGBE_RSCDBU_RSCSMALDIS_MASK    0x0000007F
-#define IXGBE_RSCDBU_RSCACKDIS          0x00000080
+#define IXGBE_RSCDBU_RSCSMALDIS_MASK	0x0000007F
+#define IXGBE_RSCDBU_RSCACKDIS		0x00000080
 
 /* RDRXCTL Bit Masks */
-#define IXGBE_RDRXCTL_RDMTS_1_2     0x00000000 /* Rx Desc Min Threshold Size */
-#define IXGBE_RDRXCTL_CRCSTRIP      0x00000002 /* CRC Strip */
-#define IXGBE_RDRXCTL_PSP           0x00000004 /* Pad small packet */
-#define IXGBE_RDRXCTL_MVMEN         0x00000020
-#define IXGBE_RDRXCTL_DMAIDONE      0x00000008 /* DMA init cycle done */
-#define IXGBE_RDRXCTL_AGGDIS        0x00010000 /* Aggregation disable */
-#define IXGBE_RDRXCTL_RSCFRSTSIZE   0x003E0000 /* RSC First packet size */
-#define IXGBE_RDRXCTL_RSCLLIDIS     0x00800000 /* Disable RSC compl on LLI */
-#define IXGBE_RDRXCTL_RSCACKC       0x02000000 /* must set 1 when RSC enabled */
-#define IXGBE_RDRXCTL_FCOE_WRFIX    0x04000000 /* must set 1 when RSC enabled */
-#define IXGBE_RDRXCTL_MBINTEN       0x10000000
-#define IXGBE_RDRXCTL_MDP_EN        0x20000000
+#define IXGBE_RDRXCTL_RDMTS_1_2		0x00000000 /* Rx Desc Min THLD Size */
+#define IXGBE_RDRXCTL_CRCSTRIP		0x00000002 /* CRC Strip */
+#define IXGBE_RDRXCTL_PSP		0x00000004 /* Pad Small Packet */
+#define IXGBE_RDRXCTL_MVMEN		0x00000020
+#define IXGBE_RDRXCTL_RSC_PUSH_DIS	0x00000020
+#define IXGBE_RDRXCTL_DMAIDONE		0x00000008 /* DMA init cycle done */
+#define IXGBE_RDRXCTL_RSC_PUSH		0x00000080
+#define IXGBE_RDRXCTL_AGGDIS		0x00010000 /* Aggregation disable */
+#define IXGBE_RDRXCTL_RSCFRSTSIZE	0x003E0000 /* RSC First packet size */
+#define IXGBE_RDRXCTL_RSCLLIDIS		0x00800000 /* Disable RSC compl on LLI*/
+#define IXGBE_RDRXCTL_RSCACKC		0x02000000 /* must set 1 when RSC ena */
+#define IXGBE_RDRXCTL_FCOE_WRFIX	0x04000000 /* must set 1 when RSC ena */
+#define IXGBE_RDRXCTL_MBINTEN		0x10000000
+#define IXGBE_RDRXCTL_MDP_EN		0x20000000
 
 /* RQTC Bit Masks and Shifts */
-#define IXGBE_RQTC_SHIFT_TC(_i)     ((_i) * 4)
-#define IXGBE_RQTC_TC0_MASK         (0x7 << 0)
-#define IXGBE_RQTC_TC1_MASK         (0x7 << 4)
-#define IXGBE_RQTC_TC2_MASK         (0x7 << 8)
-#define IXGBE_RQTC_TC3_MASK         (0x7 << 12)
-#define IXGBE_RQTC_TC4_MASK         (0x7 << 16)
-#define IXGBE_RQTC_TC5_MASK         (0x7 << 20)
-#define IXGBE_RQTC_TC6_MASK         (0x7 << 24)
-#define IXGBE_RQTC_TC7_MASK         (0x7 << 28)
+#define IXGBE_RQTC_SHIFT_TC(_i)	((_i) * 4)
+#define IXGBE_RQTC_TC0_MASK	(0x7 << 0)
+#define IXGBE_RQTC_TC1_MASK	(0x7 << 4)
+#define IXGBE_RQTC_TC2_MASK	(0x7 << 8)
+#define IXGBE_RQTC_TC3_MASK	(0x7 << 12)
+#define IXGBE_RQTC_TC4_MASK	(0x7 << 16)
+#define IXGBE_RQTC_TC5_MASK	(0x7 << 20)
+#define IXGBE_RQTC_TC6_MASK	(0x7 << 24)
+#define IXGBE_RQTC_TC7_MASK	(0x7 << 28)
 
 /* PSRTYPE.RQPL Bit masks and shift */
-#define IXGBE_PSRTYPE_RQPL_MASK     0x7
-#define IXGBE_PSRTYPE_RQPL_SHIFT    29
+#define IXGBE_PSRTYPE_RQPL_MASK		0x7
+#define IXGBE_PSRTYPE_RQPL_SHIFT	29
 
 /* CTRL Bit Masks */
-#define IXGBE_CTRL_GIO_DIS      0x00000004 /* Global IO Master Disable bit */
-#define IXGBE_CTRL_LNK_RST      0x00000008 /* Link Reset. Resets everything. */
-#define IXGBE_CTRL_RST          0x04000000 /* Reset (SW) */
-#define IXGBE_CTRL_RST_MASK     (IXGBE_CTRL_LNK_RST | IXGBE_CTRL_RST)
+#define IXGBE_CTRL_GIO_DIS	0x00000004 /* Global IO Master Disable bit */
+#define IXGBE_CTRL_LNK_RST	0x00000008 /* Link Reset. Resets everything. */
+#define IXGBE_CTRL_RST		0x04000000 /* Reset (SW) */
+#define IXGBE_CTRL_RST_MASK	(IXGBE_CTRL_LNK_RST | IXGBE_CTRL_RST)
 
 /* FACTPS */
-#define IXGBE_FACTPS_MNGCG      0x20000000 /* Manageblility Clock Gated */
-#define IXGBE_FACTPS_LFS        0x40000000 /* LAN Function Select */
+#define IXGBE_FACTPS_MNGCG	0x20000000 /* Manageblility Clock Gated */
+#define IXGBE_FACTPS_LFS	0x40000000 /* LAN Function Select */
 
 /* MHADD Bit Masks */
-#define IXGBE_MHADD_MFS_MASK    0xFFFF0000
-#define IXGBE_MHADD_MFS_SHIFT   16
+#define IXGBE_MHADD_MFS_MASK	0xFFFF0000
+#define IXGBE_MHADD_MFS_SHIFT	16
 
 /* Extended Device Control */
-#define IXGBE_CTRL_EXT_PFRSTD   0x00004000 /* Physical Function Reset Done */
-#define IXGBE_CTRL_EXT_NS_DIS   0x00010000 /* No Snoop disable */
-#define IXGBE_CTRL_EXT_RO_DIS   0x00020000 /* Relaxed Ordering disable */
-#define IXGBE_CTRL_EXT_DRV_LOAD 0x10000000 /* Driver loaded bit for FW */
+#define IXGBE_CTRL_EXT_PFRSTD	0x00004000 /* Physical Function Reset Done */
+#define IXGBE_CTRL_EXT_NS_DIS	0x00010000 /* No Snoop disable */
+#define IXGBE_CTRL_EXT_RO_DIS	0x00020000 /* Relaxed Ordering disable */
+#define IXGBE_CTRL_EXT_DRV_LOAD	0x10000000 /* Driver loaded bit for FW */
 
 /* Direct Cache Access (DCA) definitions */
-#define IXGBE_DCA_CTRL_DCA_ENABLE  0x00000000 /* DCA Enable */
-#define IXGBE_DCA_CTRL_DCA_DISABLE 0x00000001 /* DCA Disable */
-
-#define IXGBE_DCA_CTRL_DCA_MODE_CB1 0x00 /* DCA Mode CB1 */
-#define IXGBE_DCA_CTRL_DCA_MODE_CB2 0x02 /* DCA Mode CB2 */
-
-#define IXGBE_DCA_RXCTRL_CPUID_MASK 0x0000001F /* Rx CPUID Mask */
-#define IXGBE_DCA_RXCTRL_CPUID_MASK_82599  0xFF000000 /* Rx CPUID Mask */
-#define IXGBE_DCA_RXCTRL_CPUID_SHIFT_82599 24 /* Rx CPUID Shift */
-#define IXGBE_DCA_RXCTRL_DESC_DCA_EN BIT(5) /* DCA Rx Desc enable */
-#define IXGBE_DCA_RXCTRL_HEAD_DCA_EN BIT(6) /* DCA Rx Desc header enable */
-#define IXGBE_DCA_RXCTRL_DATA_DCA_EN BIT(7) /* DCA Rx Desc payload enable */
-#define IXGBE_DCA_RXCTRL_DESC_RRO_EN BIT(9) /* DCA Rx rd Desc Relax Order */
-#define IXGBE_DCA_RXCTRL_DATA_WRO_EN BIT(13) /* Rx wr data Relax Order */
-#define IXGBE_DCA_RXCTRL_HEAD_WRO_EN BIT(15) /* Rx wr header RO */
-
-#define IXGBE_DCA_TXCTRL_CPUID_MASK 0x0000001F /* Tx CPUID Mask */
-#define IXGBE_DCA_TXCTRL_CPUID_MASK_82599  0xFF000000 /* Tx CPUID Mask */
-#define IXGBE_DCA_TXCTRL_CPUID_SHIFT_82599 24 /* Tx CPUID Shift */
-#define IXGBE_DCA_TXCTRL_DESC_DCA_EN BIT(5) /* DCA Tx Desc enable */
-#define IXGBE_DCA_TXCTRL_DESC_RRO_EN BIT(9) /* Tx rd Desc Relax Order */
-#define IXGBE_DCA_TXCTRL_DESC_WRO_EN BIT(11) /* Tx Desc writeback RO bit */
-#define IXGBE_DCA_TXCTRL_DATA_RRO_EN BIT(13) /* Tx rd data Relax Order */
-#define IXGBE_DCA_MAX_QUEUES_82598   16 /* DCA regs only on 16 queues */
+#define IXGBE_DCA_CTRL_DCA_ENABLE	0x00000000 /* DCA Enable */
+#define IXGBE_DCA_CTRL_DCA_DISABLE	0x00000001 /* DCA Disable */
+
+#define IXGBE_DCA_CTRL_DCA_MODE_CB1	0x00 /* DCA Mode CB1 */
+#define IXGBE_DCA_CTRL_DCA_MODE_CB2	0x02 /* DCA Mode CB2 */
+
+#define IXGBE_DCA_RXCTRL_CPUID_MASK	0x0000001F /* Rx CPUID Mask */
+#define IXGBE_DCA_RXCTRL_CPUID_MASK_82599	0xFF000000 /* Rx CPUID Mask */
+#define IXGBE_DCA_RXCTRL_CPUID_SHIFT_82599	24 /* Rx CPUID Shift */
+#define IXGBE_DCA_RXCTRL_DESC_DCA_EN	(1 << 5) /* Rx Desc enable */
+#define IXGBE_DCA_RXCTRL_HEAD_DCA_EN	(1 << 6) /* Rx Desc header ena */
+#define IXGBE_DCA_RXCTRL_DATA_DCA_EN	(1 << 7) /* Rx Desc payload ena */
+#define IXGBE_DCA_RXCTRL_DESC_RRO_EN	(1 << 9) /* Rx rd Desc Relax Order */
+#define IXGBE_DCA_RXCTRL_DATA_WRO_EN	(1 << 13) /* Rx wr data Relax Order */
+#define IXGBE_DCA_RXCTRL_HEAD_WRO_EN	(1 << 15) /* Rx wr header RO */
+
+#define IXGBE_DCA_TXCTRL_CPUID_MASK	0x0000001F /* Tx CPUID Mask */
+#define IXGBE_DCA_TXCTRL_CPUID_MASK_82599	0xFF000000 /* Tx CPUID Mask */
+#define IXGBE_DCA_TXCTRL_CPUID_SHIFT_82599	24 /* Tx CPUID Shift */
+#define IXGBE_DCA_TXCTRL_DESC_DCA_EN	(1 << 5) /* DCA Tx Desc enable */
+#define IXGBE_DCA_TXCTRL_DESC_RRO_EN	(1 << 9) /* Tx rd Desc Relax Order */
+#define IXGBE_DCA_TXCTRL_DESC_WRO_EN	(1 << 11) /* Tx Desc writeback RO bit */
+#define IXGBE_DCA_TXCTRL_DATA_RRO_EN	(1 << 13) /* Tx rd data Relax Order */
+#define IXGBE_DCA_MAX_QUEUES_82598	16 /* DCA regs only on 16 queues */
 
 /* MSCA Bit Masks */
-#define IXGBE_MSCA_NP_ADDR_MASK      0x0000FFFF /* MDI Address (new protocol) */
-#define IXGBE_MSCA_NP_ADDR_SHIFT     0
-#define IXGBE_MSCA_DEV_TYPE_MASK     0x001F0000 /* Device Type (new protocol) */
-#define IXGBE_MSCA_DEV_TYPE_SHIFT    16 /* Register Address (old protocol */
-#define IXGBE_MSCA_PHY_ADDR_MASK     0x03E00000 /* PHY Address mask */
-#define IXGBE_MSCA_PHY_ADDR_SHIFT    21 /* PHY Address shift*/
-#define IXGBE_MSCA_OP_CODE_MASK      0x0C000000 /* OP CODE mask */
-#define IXGBE_MSCA_OP_CODE_SHIFT     26 /* OP CODE shift */
-#define IXGBE_MSCA_ADDR_CYCLE        0x00000000 /* OP CODE 00 (addr cycle) */
-#define IXGBE_MSCA_WRITE             0x04000000 /* OP CODE 01 (write) */
-#define IXGBE_MSCA_READ              0x0C000000 /* OP CODE 11 (read) */
-#define IXGBE_MSCA_READ_AUTOINC      0x08000000 /* OP CODE 10 (read, auto inc)*/
-#define IXGBE_MSCA_ST_CODE_MASK      0x30000000 /* ST Code mask */
-#define IXGBE_MSCA_ST_CODE_SHIFT     28 /* ST Code shift */
-#define IXGBE_MSCA_NEW_PROTOCOL      0x00000000 /* ST CODE 00 (new protocol) */
-#define IXGBE_MSCA_OLD_PROTOCOL      0x10000000 /* ST CODE 01 (old protocol) */
-#define IXGBE_MSCA_MDI_COMMAND       0x40000000 /* Initiate MDI command */
-#define IXGBE_MSCA_MDI_IN_PROG_EN    0x80000000 /* MDI in progress enable */
+#define IXGBE_MSCA_NP_ADDR_MASK		0x0000FFFF /* MDI Addr (new prot) */
+#define IXGBE_MSCA_NP_ADDR_SHIFT	0
+#define IXGBE_MSCA_DEV_TYPE_MASK	0x001F0000 /* Dev Type (new prot) */
+#define IXGBE_MSCA_DEV_TYPE_SHIFT	16 /* Register Address (old prot */
+#define IXGBE_MSCA_PHY_ADDR_MASK	0x03E00000 /* PHY Address mask */
+#define IXGBE_MSCA_PHY_ADDR_SHIFT	21 /* PHY Address shift*/
+#define IXGBE_MSCA_OP_CODE_MASK		0x0C000000 /* OP CODE mask */
+#define IXGBE_MSCA_OP_CODE_SHIFT	26 /* OP CODE shift */
+#define IXGBE_MSCA_ADDR_CYCLE		0x00000000 /* OP CODE 00 (addr cycle) */
+#define IXGBE_MSCA_WRITE		0x04000000 /* OP CODE 01 (wr) */
+#define IXGBE_MSCA_READ			0x0C000000 /* OP CODE 11 (rd) */
+#define IXGBE_MSCA_READ_AUTOINC		0x08000000 /* OP CODE 10 (rd auto inc)*/
+#define IXGBE_MSCA_ST_CODE_MASK		0x30000000 /* ST Code mask */
+#define IXGBE_MSCA_ST_CODE_SHIFT	28 /* ST Code shift */
+#define IXGBE_MSCA_NEW_PROTOCOL		0x00000000 /* ST CODE 00 (new prot) */
+#define IXGBE_MSCA_OLD_PROTOCOL		0x10000000 /* ST CODE 01 (old prot) */
+#define IXGBE_MSCA_MDI_COMMAND		0x40000000 /* Initiate MDI command */
+#define IXGBE_MSCA_MDI_IN_PROG_EN	0x80000000 /* MDI in progress ena */
 
 /* MSRWD bit masks */
-#define IXGBE_MSRWD_WRITE_DATA_MASK     0x0000FFFF
-#define IXGBE_MSRWD_WRITE_DATA_SHIFT    0
-#define IXGBE_MSRWD_READ_DATA_MASK      0xFFFF0000
-#define IXGBE_MSRWD_READ_DATA_SHIFT     16
+#define IXGBE_MSRWD_WRITE_DATA_MASK	0x0000FFFF
+#define IXGBE_MSRWD_WRITE_DATA_SHIFT	0
+#define IXGBE_MSRWD_READ_DATA_MASK	0xFFFF0000
+#define IXGBE_MSRWD_READ_DATA_SHIFT	16
 
 /* Atlas registers */
-#define IXGBE_ATLAS_PDN_LPBK    0x24
-#define IXGBE_ATLAS_PDN_10G     0xB
-#define IXGBE_ATLAS_PDN_1G      0xC
-#define IXGBE_ATLAS_PDN_AN      0xD
+#define IXGBE_ATLAS_PDN_LPBK		0x24
+#define IXGBE_ATLAS_PDN_10G		0xB
+#define IXGBE_ATLAS_PDN_1G		0xC
+#define IXGBE_ATLAS_PDN_AN		0xD
 
 /* Atlas bit masks */
-#define IXGBE_ATLASCTL_WRITE_CMD        0x00010000
-#define IXGBE_ATLAS_PDN_TX_REG_EN       0x10
-#define IXGBE_ATLAS_PDN_TX_10G_QL_ALL   0xF0
-#define IXGBE_ATLAS_PDN_TX_1G_QL_ALL    0xF0
-#define IXGBE_ATLAS_PDN_TX_AN_QL_ALL    0xF0
+#define IXGBE_ATLASCTL_WRITE_CMD	0x00010000
+#define IXGBE_ATLAS_PDN_TX_REG_EN	0x10
+#define IXGBE_ATLAS_PDN_TX_10G_QL_ALL	0xF0
+#define IXGBE_ATLAS_PDN_TX_1G_QL_ALL	0xF0
+#define IXGBE_ATLAS_PDN_TX_AN_QL_ALL	0xF0
 
 /* Omer bit masks */
-#define IXGBE_CORECTL_WRITE_CMD         0x00010000
-
-/* MDIO definitions */
+#define IXGBE_CORECTL_WRITE_CMD		0x00010000
 
+/* Device Type definitions for new protocol MDIO commands */
 #define IXGBE_MDIO_ZERO_DEV_TYPE		0x0
-#define IXGBE_MDIO_PCS_DEV_TYPE		0x3
+#define IXGBE_MDIO_PMA_PMD_DEV_TYPE		0x1
+#define IXGBE_MDIO_PCS_DEV_TYPE			0x3
+#define IXGBE_MDIO_PHY_XS_DEV_TYPE		0x4
+#define IXGBE_MDIO_AUTO_NEG_DEV_TYPE		0x7
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE	0x1E   /* Device 30 */
 #define IXGBE_TWINAX_DEV			1
 
-#define IXGBE_MDIO_COMMAND_TIMEOUT     100 /* PHY Timeout for 1 GB mode */
+#define IXGBE_MDIO_COMMAND_TIMEOUT	100 /* PHY Timeout for 1 GB mode */
 
-#define IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS  0x0008 /* 1 = Link Up */
-#define IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS 0x0010 /* 0 - 10G, 1 - 1G */
-#define IXGBE_MDIO_VENDOR_SPECIFIC_1_10G_SPEED    0x0018
-#define IXGBE_MDIO_VENDOR_SPECIFIC_1_1G_SPEED     0x0010
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_CONTROL		0x0 /* VS1 Ctrl Reg */
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_STATUS		0x1 /* VS1 Status Reg */
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_LINK_STATUS	0x0008 /* 1 = Link Up */
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_SPEED_STATUS	0x0010 /* 0-10G, 1-1G */
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_10G_SPEED		0x0018
+#define IXGBE_MDIO_VENDOR_SPECIFIC_1_1G_SPEED		0x0010
 
+#define IXGBE_MDIO_AUTO_NEG_CONTROL	0x0 /* AUTO_NEG Control Reg */
+#define IXGBE_MDIO_AUTO_NEG_STATUS	0x1 /* AUTO_NEG Status Reg */
 #define IXGBE_MDIO_AUTO_NEG_VENDOR_STAT	0xC800 /* AUTO_NEG Vendor Status Reg */
-#define IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM  0xCC00 /* AUTO_NEG Vendor TX Reg */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM 0xCC00 /* AUTO_NEG Vendor TX Reg */
 #define IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2 0xCC01 /* AUTO_NEG Vendor Tx Reg */
 #define IXGBE_MDIO_AUTO_NEG_VEN_LSC	0x1 /* AUTO_NEG Vendor Tx LSC */
+#define IXGBE_MDIO_AUTO_NEG_ADVT	0x10 /* AUTO_NEG Advt Reg */
+#define IXGBE_MDIO_AUTO_NEG_LP		0x13 /* AUTO_NEG LP Status Reg */
 #define IXGBE_MDIO_AUTO_NEG_EEE_ADVT	0x3C /* AUTO_NEG EEE Advt Reg */
-
-#define IXGBE_MDIO_PHY_SET_LOW_POWER_MODE	 0x0800 /* Set low power mode */
+#define IXGBE_AUTO_NEG_10GBASE_EEE_ADVT	0x8  /* AUTO NEG EEE 10GBaseT Advt */
+#define IXGBE_AUTO_NEG_1000BASE_EEE_ADVT 0x4  /* AUTO NEG EEE 1000BaseT Advt */
+#define IXGBE_AUTO_NEG_100BASE_EEE_ADVT	0x2  /* AUTO NEG EEE 100BaseT Advt */
+#define IXGBE_MDIO_PHY_XS_CONTROL	0x0 /* PHY_XS Control Reg */
+#define IXGBE_MDIO_PHY_XS_RESET		0x8000 /* PHY_XS Reset */
+#define IXGBE_MDIO_PHY_ID_HIGH		0x2 /* PHY ID High Reg*/
+#define IXGBE_MDIO_PHY_ID_LOW		0x3 /* PHY ID Low Reg*/
+#define IXGBE_MDIO_PHY_SPEED_ABILITY	0x4 /* Speed Ability Reg */
+#define IXGBE_MDIO_PHY_SPEED_10G	0x0001 /* 10G capable */
+#define IXGBE_MDIO_PHY_SPEED_1G		0x0010 /* 1G capable */
+#define IXGBE_MDIO_PHY_SPEED_100M	0x0020 /* 100M capable */
+#define IXGBE_MDIO_PHY_EXT_ABILITY	0xB /* Ext Ability Reg */
+#define IXGBE_MDIO_PHY_10GBASET_ABILITY		0x0004 /* 10GBaseT capable */
+#define IXGBE_MDIO_PHY_1000BASET_ABILITY	0x0020 /* 1000BaseT capable */
+#define IXGBE_MDIO_PHY_100BASETX_ABILITY	0x0080 /* 100BaseTX capable */
+#define IXGBE_MDIO_PHY_SET_LOW_POWER_MODE	0x0800 /* Set low power mode */
 #define IXGBE_AUTO_NEG_LP_STATUS	0xE820 /* AUTO NEG Rx LP Status Reg */
-#define IXGBE_AUTO_NEG_LP_1000BASE_CAP	0x8000 /* AUTO NEG Rx LP 1000BaseT */
-#define IXGBE_MDIO_TX_VENDOR_ALARMS_3	0xCC02 /* Vendor Alarms 3 Reg */
-#define IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK 0x3 /* PHY Reset Complete Mask */
+#define IXGBE_AUTO_NEG_LP_1000BASE_CAP	0x8000 /* AUTO NEG Rx LP 1000BaseT Cap */
+#define IXGBE_AUTO_NEG_LP_10GBASE_CAP	0x0800 /* AUTO NEG Rx LP 10GBaseT Cap */
+#define IXGBE_AUTO_NEG_10GBASET_STAT	0x0021 /* AUTO NEG 10G BaseT Stat */
+
+#define IXGBE_MDIO_TX_VENDOR_ALARMS_3		0xCC02 /* Vendor Alarms 3 Reg */
+#define IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK	0x3 /* PHY Reset Complete Mask */
 #define IXGBE_MDIO_GLOBAL_RES_PR_10 0xC479 /* Global Resv Provisioning 10 Reg */
-#define IXGBE_MDIO_POWER_UP_STALL	0x8000 /* Power Up Stall */
+#define IXGBE_MDIO_POWER_UP_STALL		0x8000 /* Power Up Stall */
 #define IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK	0xFF00 /* int std mask */
 #define IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG	0xFC00 /* chip std int flag */
 #define IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK	0xFF01 /* int chip-wide mask */
@@ -1367,248 +1585,301 @@ struct ixgbe_nvm_version {
 #define IXGBE_MDIO_GLOBAL_ALARM_1		0xCC00 /* Global alarm 1 */
 #define IXGBE_MDIO_GLOBAL_ALM_1_DEV_FAULT	0x0010 /* device fault */
 #define IXGBE_MDIO_GLOBAL_ALM_1_HI_TMP_FAIL	0x4000 /* high temp failure */
-#define IXGBE_MDIO_GLOBAL_FAULT_MSG		0xC850 /* global fault msg */
+#define IXGBE_MDIO_GLOBAL_FAULT_MSG	0xC850 /* Global Fault Message */
 #define IXGBE_MDIO_GLOBAL_FAULT_MSG_HI_TMP	0x8007 /* high temp failure */
 #define IXGBE_MDIO_GLOBAL_INT_MASK		0xD400 /* Global int mask */
-/* autoneg vendor alarm int enable */
-#define IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN	0x1000
+#define IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN	0x1000 /* autoneg vendor alarm int enable */
 #define IXGBE_MDIO_GLOBAL_ALARM_1_INT		0x4 /* int in Global alarm 1 */
 #define IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN	0x1 /* vendor alarm int enable */
 #define IXGBE_MDIO_GLOBAL_STD_ALM2_INT		0x200 /* vendor alarm2 int mask */
 #define IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN	0x4000 /* int high temp enable */
-#define IXGBE_MDIO_GLOBAL_INT_DEV_FAULT_EN	0x0010 /*int dev fault enable */
-
+#define IXGBE_MDIO_GLOBAL_INT_DEV_FAULT_EN 0x0010 /* int dev fault enable */
+#define IXGBE_MDIO_PMA_PMD_CONTROL_ADDR	0x0000 /* PMA/PMD Control Reg */
 #define IXGBE_MDIO_PMA_PMD_SDA_SCL_ADDR	0xC30A /* PHY_XS SDA/SCL Addr Reg */
 #define IXGBE_MDIO_PMA_PMD_SDA_SCL_DATA	0xC30B /* PHY_XS SDA/SCL Data Reg */
-#define IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT	0xC30C /* PHY_XS SDA/SCL Stat Reg */
-#define IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK	0xD401 /* PHY TX Vendor LASI */
-#define IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN	0x1 /* PHY TX Vendor LASI enable */
-#define IXGBE_MDIO_PMD_STD_TX_DISABLE_CNTR	0x9 /* Standard Tx Dis Reg */
-#define IXGBE_MDIO_PMD_GLOBAL_TX_DISABLE	0x0001 /* PMD Global Tx Dis */
+#define IXGBE_MDIO_PMA_PMD_SDA_SCL_STAT	0xC30C /* PHY_XS SDA/SCL Status Reg */
+#define IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK 0xD401 /* PHY TX Vendor LASI */
+#define IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN   0x1 /* PHY TX Vendor LASI enable */
+#define IXGBE_MDIO_PMD_STD_TX_DISABLE_CNTR 0x9 /* Standard Transmit Dis Reg */
+#define IXGBE_MDIO_PMD_GLOBAL_TX_DISABLE 0x0001 /* PMD Global Transmit Dis */
+
+#define IXGBE_PCRC8ECL		0x0E810 /* PCR CRC-8 Error Count Lo */
+#define IXGBE_PCRC8ECH		0x0E811 /* PCR CRC-8 Error Count Hi */
+#define IXGBE_PCRC8ECH_MASK	0x1F
+#define IXGBE_LDPCECL		0x0E820 /* PCR Uncorrected Error Count Lo */
+#define IXGBE_LDPCECH		0x0E821 /* PCR Uncorrected Error Count Hi */
 
 /* MII clause 22/28 definitions */
+#define IXGBE_MDIO_PHY_LOW_POWER_MODE	0x0800
+
+#define IXGBE_MDIO_XENPAK_LASI_STATUS		0x9005 /* XENPAK LASI Status register*/
+#define IXGBE_XENPAK_LASI_LINK_STATUS_ALARM	0x1 /* Link Status Alarm change */
+
+#define IXGBE_MDIO_AUTO_NEG_LINK_STATUS		0x4 /* Indicates if link is up */
+
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK	0x7 /* Speed/Duplex Mask */
+#define IXGBE_MDIO_AUTO_NEG_VEN_STAT_SPEED_MASK		0x6 /* Speed Mask */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10M_HALF	0x0 /* 10Mb/s Half Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10M_FULL	0x1 /* 10Mb/s Full Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_100M_HALF	0x2 /* 100Mb/s Half Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_100M_FULL	0x3 /* 100Mb/s Full Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_HALF	0x4 /* 1Gb/s Half Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL	0x5 /* 1Gb/s Full Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_HALF	0x6 /* 10Gb/s Half Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL	0x7 /* 10Gb/s Full Duplex */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB		0x4 /* 1Gb/s */
+#define IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB		0x6 /* 10Gb/s */
+
+#define IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG	0x20   /* 10G Control Reg */
 #define IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG 0xC400 /* 1G Provisioning 1 */
-#define IXGBE_MII_AUTONEG_XNP_TX_REG             0x17   /* 1G XNP Transmit */
-#define IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX      0x4000 /* full duplex, bit:14*/
-#define IXGBE_MII_1GBASE_T_ADVERTISE             0x8000 /* full duplex, bit:15*/
-#define IXGBE_MII_AUTONEG_REG                    0x0
+#define IXGBE_MII_AUTONEG_XNP_TX_REG		0x17   /* 1G XNP Transmit */
+#define IXGBE_MII_AUTONEG_ADVERTISE_REG		0x10   /* 100M Advertisement */
+#define IXGBE_MII_10GBASE_T_ADVERTISE		0x1000 /* full duplex, bit:12*/
+#define IXGBE_MII_1GBASE_T_ADVERTISE_XNP_TX	0x4000 /* full duplex, bit:14*/
+#define IXGBE_MII_1GBASE_T_ADVERTISE		0x8000 /* full duplex, bit:15*/
+#define IXGBE_MII_2_5GBASE_T_ADVERTISE		0x0400
+#define IXGBE_MII_5GBASE_T_ADVERTISE		0x0800
+#define IXGBE_MII_100BASE_T_ADVERTISE		0x0100 /* full duplex, bit:8 */
+#define IXGBE_MII_100BASE_T_ADVERTISE_HALF	0x0080 /* half duplex, bit:7 */
+#define IXGBE_MII_RESTART			0x200
+#define IXGBE_MII_AUTONEG_COMPLETE		0x20
+#define IXGBE_MII_AUTONEG_LINK_UP		0x04
+#define IXGBE_MII_AUTONEG_REG			0x0
 
-#define IXGBE_PHY_REVISION_MASK        0xFFFFFFF0
-#define IXGBE_MAX_PHY_ADDR             32
+#define IXGBE_PHY_REVISION_MASK		0xFFFFFFF0
+#define IXGBE_MAX_PHY_ADDR		32
 
 /* PHY IDs*/
-#define TN1010_PHY_ID    0x00A19410
-#define TNX_FW_REV       0xB
-#define X540_PHY_ID      0x01540200
+#define TN1010_PHY_ID	0x00A19410
+#define TNX_FW_REV	0xB
+#define X540_PHY_ID	0x01540200
+#define X550_PHY_ID	0x01540220
 #define X550_PHY_ID2	0x01540223
 #define X550_PHY_ID3	0x01540221
-#define X557_PHY_ID      0x01540240
+#define X557_PHY_ID	0x01540240
 #define X557_PHY_ID2	0x01540250
-#define QT2022_PHY_ID    0x0043A400
-#define ATH_PHY_ID       0x03429050
-#define AQ_FW_REV        0x20
+#define AQ_FW_REV	0x20
+#define QT2022_PHY_ID	0x0043A400
+#define ATH_PHY_ID	0x03429050
+
+/* PHY Types */
+#define IXGBE_M88E1500_E_PHY_ID	0x01410DD0
+#define IXGBE_M88E1543_E_PHY_ID	0x01410EA0
 
 /* Special PHY Init Routine */
-#define IXGBE_PHY_INIT_OFFSET_NL 0x002B
-#define IXGBE_PHY_INIT_END_NL    0xFFFF
-#define IXGBE_CONTROL_MASK_NL    0xF000
-#define IXGBE_DATA_MASK_NL       0x0FFF
-#define IXGBE_CONTROL_SHIFT_NL   12
-#define IXGBE_DELAY_NL           0
-#define IXGBE_DATA_NL            1
-#define IXGBE_CONTROL_NL         0x000F
-#define IXGBE_CONTROL_EOL_NL     0x0FFF
-#define IXGBE_CONTROL_SOL_NL     0x0000
+#define IXGBE_PHY_INIT_OFFSET_NL	0x002B
+#define IXGBE_PHY_INIT_END_NL		0xFFFF
+#define IXGBE_CONTROL_MASK_NL		0xF000
+#define IXGBE_DATA_MASK_NL		0x0FFF
+#define IXGBE_CONTROL_SHIFT_NL		12
+#define IXGBE_DELAY_NL			0
+#define IXGBE_DATA_NL			1
+#define IXGBE_CONTROL_NL		0x000F
+#define IXGBE_CONTROL_EOL_NL		0x0FFF
+#define IXGBE_CONTROL_SOL_NL		0x0000
 
 /* General purpose Interrupt Enable */
-#define IXGBE_SDP0_GPIEN_8259X		0x00000001 /* SDP0 */
-#define IXGBE_SDP1_GPIEN_8259X		0x00000002 /* SDP1 */
-#define IXGBE_SDP2_GPIEN_8259X		0x00000004 /* SDP2 */
-#define IXGBE_SDP0_GPIEN_X540		0x00000002 /* SDP0 on X540 and X550 */
-#define IXGBE_SDP1_GPIEN_X540		0x00000004 /* SDP1 on X540 and X550 */
-#define IXGBE_SDP2_GPIEN_X540		0x00000008 /* SDP2 on X540 and X550 */
-#define IXGBE_SDP0_GPIEN_X550		IXGBE_SDP0_GPIEN_X540
-#define IXGBE_SDP1_GPIEN_X550		IXGBE_SDP1_GPIEN_X540
-#define IXGBE_SDP2_GPIEN_X550		IXGBE_SDP2_GPIEN_X540
+#define IXGBE_SDP0_GPIEN	0x00000001 /* SDP0 */
+#define IXGBE_SDP1_GPIEN	0x00000002 /* SDP1 */
+#define IXGBE_SDP2_GPIEN	0x00000004 /* SDP2 */
+#define IXGBE_SDP0_GPIEN_X540	0x00000002 /* SDP0 on X540 and X550 */
+#define IXGBE_SDP1_GPIEN_X540	0x00000004 /* SDP1 on X540 and X550 */
+#define IXGBE_SDP2_GPIEN_X540	0x00000008 /* SDP2 on X540 and X550 */
+#define IXGBE_SDP0_GPIEN_X550	IXGBE_SDP0_GPIEN_X540
+#define IXGBE_SDP1_GPIEN_X550	IXGBE_SDP1_GPIEN_X540
+#define IXGBE_SDP2_GPIEN_X550	IXGBE_SDP2_GPIEN_X540
 #define IXGBE_SDP0_GPIEN_X550EM_x	IXGBE_SDP0_GPIEN_X540
 #define IXGBE_SDP1_GPIEN_X550EM_x	IXGBE_SDP1_GPIEN_X540
 #define IXGBE_SDP2_GPIEN_X550EM_x	IXGBE_SDP2_GPIEN_X540
 #define IXGBE_SDP0_GPIEN_X550EM_a	IXGBE_SDP0_GPIEN_X540
 #define IXGBE_SDP1_GPIEN_X550EM_a	IXGBE_SDP1_GPIEN_X540
 #define IXGBE_SDP2_GPIEN_X550EM_a	IXGBE_SDP2_GPIEN_X540
-#define IXGBE_SDP0_GPIEN(_hw)		IXGBE_BY_MAC((_hw), SDP0_GPIEN)
-#define IXGBE_SDP1_GPIEN(_hw)		IXGBE_BY_MAC((_hw), SDP1_GPIEN)
-#define IXGBE_SDP2_GPIEN(_hw)		IXGBE_BY_MAC((_hw), SDP2_GPIEN)
-
-#define IXGBE_GPIE_MSIX_MODE     0x00000010 /* MSI-X mode */
-#define IXGBE_GPIE_OCD           0x00000020 /* Other Clear Disable */
-#define IXGBE_GPIE_EIMEN         0x00000040 /* Immediate Interrupt Enable */
-#define IXGBE_GPIE_EIAME         0x40000000
-#define IXGBE_GPIE_PBA_SUPPORT   0x80000000
-#define IXGBE_GPIE_RSC_DELAY_SHIFT 11
-#define IXGBE_GPIE_VTMODE_MASK   0x0000C000 /* VT Mode Mask */
-#define IXGBE_GPIE_VTMODE_16     0x00004000 /* 16 VFs 8 queues per VF */
-#define IXGBE_GPIE_VTMODE_32     0x00008000 /* 32 VFs 4 queues per VF */
-#define IXGBE_GPIE_VTMODE_64     0x0000C000 /* 64 VFs 2 queues per VF */
+#define IXGBE_SDP0_GPIEN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SDP0_GPIEN)
+#define IXGBE_SDP1_GPIEN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SDP1_GPIEN)
+#define IXGBE_SDP2_GPIEN_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), SDP2_GPIEN)
+
+#define IXGBE_GPIE_MSIX_MODE	0x00000010 /* MSI-X mode */
+#define IXGBE_GPIE_OCD		0x00000020 /* Other Clear Disable */
+#define IXGBE_GPIE_EIMEN	0x00000040 /* Immediate Interrupt Enable */
+#define IXGBE_GPIE_EIAME	0x40000000
+#define IXGBE_GPIE_PBA_SUPPORT	0x80000000
+#define IXGBE_GPIE_RSC_DELAY_SHIFT	11
+#define IXGBE_GPIE_VTMODE_MASK	0x0000C000 /* VT Mode Mask */
+#define IXGBE_GPIE_VTMODE_16	0x00004000 /* 16 VFs 8 queues per VF */
+#define IXGBE_GPIE_VTMODE_32	0x00008000 /* 32 VFs 4 queues per VF */
+#define IXGBE_GPIE_VTMODE_64	0x0000C000 /* 64 VFs 2 queues per VF */
 
 /* Packet Buffer Initialization */
-#define IXGBE_TXPBSIZE_20KB     0x00005000 /* 20KB Packet Buffer */
-#define IXGBE_TXPBSIZE_40KB     0x0000A000 /* 40KB Packet Buffer */
-#define IXGBE_RXPBSIZE_48KB     0x0000C000 /* 48KB Packet Buffer */
-#define IXGBE_RXPBSIZE_64KB     0x00010000 /* 64KB Packet Buffer */
-#define IXGBE_RXPBSIZE_80KB     0x00014000 /* 80KB Packet Buffer */
-#define IXGBE_RXPBSIZE_128KB    0x00020000 /* 128KB Packet Buffer */
-#define IXGBE_RXPBSIZE_MAX      0x00080000 /* 512KB Packet Buffer*/
-#define IXGBE_TXPBSIZE_MAX      0x00028000 /* 160KB Packet Buffer*/
-
-#define IXGBE_TXPKT_SIZE_MAX    0xA        /* Max Tx Packet size  */
+#define IXGBE_MAX_PACKET_BUFFERS	8
+
+#define IXGBE_TXPBSIZE_20KB	0x00005000 /* 20KB Packet Buffer */
+#define IXGBE_TXPBSIZE_40KB	0x0000A000 /* 40KB Packet Buffer */
+#define IXGBE_RXPBSIZE_48KB	0x0000C000 /* 48KB Packet Buffer */
+#define IXGBE_RXPBSIZE_64KB	0x00010000 /* 64KB Packet Buffer */
+#define IXGBE_RXPBSIZE_80KB	0x00014000 /* 80KB Packet Buffer */
+#define IXGBE_RXPBSIZE_128KB	0x00020000 /* 128KB Packet Buffer */
+#define IXGBE_RXPBSIZE_MAX	0x00080000 /* 512KB Packet Buffer */
+#define IXGBE_TXPBSIZE_MAX	0x00028000 /* 160KB Packet Buffer */
+
+#define IXGBE_TXPKT_SIZE_MAX	0xA /* Max Tx Packet size */
 #define IXGBE_MAX_PB		8
 
 /* Packet buffer allocation strategies */
 enum {
-	PBA_STRATEGY_EQUAL	= 0,	/* Distribute PB space equally */
+	PBA_STRATEGY_EQUAL	= 0, /* Distribute PB space equally */
 #define PBA_STRATEGY_EQUAL	PBA_STRATEGY_EQUAL
-	PBA_STRATEGY_WEIGHTED	= 1,	/* Weight front half of TCs */
+	PBA_STRATEGY_WEIGHTED	= 1, /* Weight front half of TCs */
 #define PBA_STRATEGY_WEIGHTED	PBA_STRATEGY_WEIGHTED
 };
 
 /* Transmit Flow Control status */
-#define IXGBE_TFCS_TXOFF         0x00000001
-#define IXGBE_TFCS_TXOFF0        0x00000100
-#define IXGBE_TFCS_TXOFF1        0x00000200
-#define IXGBE_TFCS_TXOFF2        0x00000400
-#define IXGBE_TFCS_TXOFF3        0x00000800
-#define IXGBE_TFCS_TXOFF4        0x00001000
-#define IXGBE_TFCS_TXOFF5        0x00002000
-#define IXGBE_TFCS_TXOFF6        0x00004000
-#define IXGBE_TFCS_TXOFF7        0x00008000
+#define IXGBE_TFCS_TXOFF	0x00000001
+#define IXGBE_TFCS_TXOFF0	0x00000100
+#define IXGBE_TFCS_TXOFF1	0x00000200
+#define IXGBE_TFCS_TXOFF2	0x00000400
+#define IXGBE_TFCS_TXOFF3	0x00000800
+#define IXGBE_TFCS_TXOFF4	0x00001000
+#define IXGBE_TFCS_TXOFF5	0x00002000
+#define IXGBE_TFCS_TXOFF6	0x00004000
+#define IXGBE_TFCS_TXOFF7	0x00008000
 
 /* TCP Timer */
-#define IXGBE_TCPTIMER_KS            0x00000100
-#define IXGBE_TCPTIMER_COUNT_ENABLE  0x00000200
-#define IXGBE_TCPTIMER_COUNT_FINISH  0x00000400
-#define IXGBE_TCPTIMER_LOOP          0x00000800
-#define IXGBE_TCPTIMER_DURATION_MASK 0x000000FF
+#define IXGBE_TCPTIMER_KS		0x00000100
+#define IXGBE_TCPTIMER_COUNT_ENABLE	0x00000200
+#define IXGBE_TCPTIMER_COUNT_FINISH	0x00000400
+#define IXGBE_TCPTIMER_LOOP		0x00000800
+#define IXGBE_TCPTIMER_DURATION_MASK	0x000000FF
 
 /* HLREG0 Bit Masks */
-#define IXGBE_HLREG0_TXCRCEN      0x00000001   /* bit  0 */
-#define IXGBE_HLREG0_RXCRCSTRP    0x00000002   /* bit  1 */
-#define IXGBE_HLREG0_JUMBOEN      0x00000004   /* bit  2 */
-#define IXGBE_HLREG0_TXPADEN      0x00000400   /* bit 10 */
-#define IXGBE_HLREG0_TXPAUSEEN    0x00001000   /* bit 12 */
-#define IXGBE_HLREG0_RXPAUSEEN    0x00004000   /* bit 14 */
-#define IXGBE_HLREG0_LPBK         0x00008000   /* bit 15 */
-#define IXGBE_HLREG0_MDCSPD       0x00010000   /* bit 16 */
-#define IXGBE_HLREG0_CONTMDC      0x00020000   /* bit 17 */
-#define IXGBE_HLREG0_CTRLFLTR     0x00040000   /* bit 18 */
-#define IXGBE_HLREG0_PREPEND      0x00F00000   /* bits 20-23 */
-#define IXGBE_HLREG0_PRIPAUSEEN   0x01000000   /* bit 24 */
-#define IXGBE_HLREG0_RXPAUSERECDA 0x06000000   /* bits 25-26 */
-#define IXGBE_HLREG0_RXLNGTHERREN 0x08000000   /* bit 27 */
-#define IXGBE_HLREG0_RXPADSTRIPEN 0x10000000   /* bit 28 */
+#define IXGBE_HLREG0_TXCRCEN		0x00000001 /* bit  0 */
+#define IXGBE_HLREG0_RXCRCSTRP		0x00000002 /* bit  1 */
+#define IXGBE_HLREG0_JUMBOEN		0x00000004 /* bit  2 */
+#define IXGBE_HLREG0_TXPADEN		0x00000400 /* bit 10 */
+#define IXGBE_HLREG0_TXPAUSEEN		0x00001000 /* bit 12 */
+#define IXGBE_HLREG0_RXPAUSEEN		0x00004000 /* bit 14 */
+#define IXGBE_HLREG0_LPBK		0x00008000 /* bit 15 */
+#define IXGBE_HLREG0_MDCSPD		0x00010000 /* bit 16 */
+#define IXGBE_HLREG0_CONTMDC		0x00020000 /* bit 17 */
+#define IXGBE_HLREG0_CTRLFLTR		0x00040000 /* bit 18 */
+#define IXGBE_HLREG0_PREPEND		0x00F00000 /* bits 20-23 */
+#define IXGBE_HLREG0_PRIPAUSEEN		0x01000000 /* bit 24 */
+#define IXGBE_HLREG0_RXPAUSERECDA	0x06000000 /* bits 25-26 */
+#define IXGBE_HLREG0_RXLNGTHERREN	0x08000000 /* bit 27 */
+#define IXGBE_HLREG0_RXPADSTRIPEN	0x10000000 /* bit 28 */
 
 /* VMD_CTL bitmasks */
-#define IXGBE_VMD_CTL_VMDQ_EN     0x00000001
-#define IXGBE_VMD_CTL_VMDQ_FILTER 0x00000002
+#define IXGBE_VMD_CTL_VMDQ_EN		0x00000001
+#define IXGBE_VMD_CTL_VMDQ_FILTER	0x00000002
 
 /* VT_CTL bitmasks */
-#define IXGBE_VT_CTL_DIS_DEFPL  0x20000000 /* disable default pool */
-#define IXGBE_VT_CTL_REPLEN     0x40000000 /* replication enabled */
-#define IXGBE_VT_CTL_VT_ENABLE  0x00000001  /* Enable VT Mode */
-#define IXGBE_VT_CTL_POOL_SHIFT 7
-#define IXGBE_VT_CTL_POOL_MASK  (0x3F << IXGBE_VT_CTL_POOL_SHIFT)
+#define IXGBE_VT_CTL_DIS_DEFPL		0x20000000 /* disable default pool */
+#define IXGBE_VT_CTL_REPLEN		0x40000000 /* replication enabled */
+#define IXGBE_VT_CTL_VT_ENABLE		0x00000001  /* Enable VT Mode */
+#define IXGBE_VT_CTL_POOL_SHIFT		7
+#define IXGBE_VT_CTL_POOL_MASK		(0x3F << IXGBE_VT_CTL_POOL_SHIFT)
 
 /* VMOLR bitmasks */
 #define IXGBE_VMOLR_UPE		0x00400000 /* unicast promiscuous */
 #define IXGBE_VMOLR_VPE		0x00800000 /* VLAN promiscuous */
-#define IXGBE_VMOLR_AUPE        0x01000000 /* accept untagged packets */
-#define IXGBE_VMOLR_ROMPE       0x02000000 /* accept packets in MTA tbl */
-#define IXGBE_VMOLR_ROPE        0x04000000 /* accept packets in UC tbl */
-#define IXGBE_VMOLR_BAM         0x08000000 /* accept broadcast packets */
-#define IXGBE_VMOLR_MPE         0x10000000 /* multicast promiscuous */
+#define IXGBE_VMOLR_AUPE	0x01000000 /* accept untagged packets */
+#define IXGBE_VMOLR_ROMPE	0x02000000 /* accept packets in MTA tbl */
+#define IXGBE_VMOLR_ROPE	0x04000000 /* accept packets in UC tbl */
+#define IXGBE_VMOLR_BAM		0x08000000 /* accept broadcast packets */
+#define IXGBE_VMOLR_MPE		0x10000000 /* multicast promiscuous */
 
 /* VFRE bitmask */
-#define IXGBE_VFRE_ENABLE_ALL   0xFFFFFFFF
+#define IXGBE_VFRE_ENABLE_ALL	0xFFFFFFFF
 
-#define IXGBE_VF_INIT_TIMEOUT   200 /* Number of retries to clear RSTI */
+#define IXGBE_VF_INIT_TIMEOUT	200 /* Number of retries to clear RSTI */
 
 /* RDHMPN and TDHMPN bitmasks */
-#define IXGBE_RDHMPN_RDICADDR       0x007FF800
-#define IXGBE_RDHMPN_RDICRDREQ      0x00800000
-#define IXGBE_RDHMPN_RDICADDR_SHIFT 11
-#define IXGBE_TDHMPN_TDICADDR       0x003FF800
-#define IXGBE_TDHMPN_TDICRDREQ      0x00800000
-#define IXGBE_TDHMPN_TDICADDR_SHIFT 11
-
-#define IXGBE_RDMAM_MEM_SEL_SHIFT   13
-#define IXGBE_RDMAM_DWORD_SHIFT     9
-#define IXGBE_RDMAM_DESC_COMP_FIFO  1
-#define IXGBE_RDMAM_DFC_CMD_FIFO    2
-#define IXGBE_RDMAM_TCN_STATUS_RAM  4
-#define IXGBE_RDMAM_WB_COLL_FIFO    5
-#define IXGBE_RDMAM_QSC_CNT_RAM     6
-#define IXGBE_RDMAM_QSC_QUEUE_CNT   8
-#define IXGBE_RDMAM_QSC_QUEUE_RAM   0xA
-#define IXGBE_RDMAM_DESC_COM_FIFO_RANGE     135
-#define IXGBE_RDMAM_DESC_COM_FIFO_COUNT     4
-#define IXGBE_RDMAM_DFC_CMD_FIFO_RANGE      48
-#define IXGBE_RDMAM_DFC_CMD_FIFO_COUNT      7
-#define IXGBE_RDMAM_TCN_STATUS_RAM_RANGE    256
-#define IXGBE_RDMAM_TCN_STATUS_RAM_COUNT    9
-#define IXGBE_RDMAM_WB_COLL_FIFO_RANGE      8
-#define IXGBE_RDMAM_WB_COLL_FIFO_COUNT      4
-#define IXGBE_RDMAM_QSC_CNT_RAM_RANGE       64
-#define IXGBE_RDMAM_QSC_CNT_RAM_COUNT       4
-#define IXGBE_RDMAM_QSC_QUEUE_CNT_RANGE     32
-#define IXGBE_RDMAM_QSC_QUEUE_CNT_COUNT     4
-#define IXGBE_RDMAM_QSC_QUEUE_RAM_RANGE     128
-#define IXGBE_RDMAM_QSC_QUEUE_RAM_COUNT     8
-
-#define IXGBE_TXDESCIC_READY        0x80000000
+#define IXGBE_RDHMPN_RDICADDR		0x007FF800
+#define IXGBE_RDHMPN_RDICRDREQ		0x00800000
+#define IXGBE_RDHMPN_RDICADDR_SHIFT	11
+#define IXGBE_TDHMPN_TDICADDR		0x003FF800
+#define IXGBE_TDHMPN_TDICRDREQ		0x00800000
+#define IXGBE_TDHMPN_TDICADDR_SHIFT	11
+
+#define IXGBE_RDMAM_MEM_SEL_SHIFT		13
+#define IXGBE_RDMAM_DWORD_SHIFT			9
+#define IXGBE_RDMAM_DESC_COMP_FIFO		1
+#define IXGBE_RDMAM_DFC_CMD_FIFO		2
+#define IXGBE_RDMAM_RSC_HEADER_ADDR		3
+#define IXGBE_RDMAM_TCN_STATUS_RAM		4
+#define IXGBE_RDMAM_WB_COLL_FIFO		5
+#define IXGBE_RDMAM_QSC_CNT_RAM			6
+#define IXGBE_RDMAM_QSC_FCOE_RAM		7
+#define IXGBE_RDMAM_QSC_QUEUE_CNT		8
+#define IXGBE_RDMAM_QSC_QUEUE_RAM		0xA
+#define IXGBE_RDMAM_QSC_RSC_RAM			0xB
+#define IXGBE_RDMAM_DESC_COM_FIFO_RANGE		135
+#define IXGBE_RDMAM_DESC_COM_FIFO_COUNT		4
+#define IXGBE_RDMAM_DFC_CMD_FIFO_RANGE		48
+#define IXGBE_RDMAM_DFC_CMD_FIFO_COUNT		7
+#define IXGBE_RDMAM_RSC_HEADER_ADDR_RANGE	32
+#define IXGBE_RDMAM_RSC_HEADER_ADDR_COUNT	4
+#define IXGBE_RDMAM_TCN_STATUS_RAM_RANGE	256
+#define IXGBE_RDMAM_TCN_STATUS_RAM_COUNT	9
+#define IXGBE_RDMAM_WB_COLL_FIFO_RANGE		8
+#define IXGBE_RDMAM_WB_COLL_FIFO_COUNT		4
+#define IXGBE_RDMAM_QSC_CNT_RAM_RANGE		64
+#define IXGBE_RDMAM_QSC_CNT_RAM_COUNT		4
+#define IXGBE_RDMAM_QSC_FCOE_RAM_RANGE		512
+#define IXGBE_RDMAM_QSC_FCOE_RAM_COUNT		5
+#define IXGBE_RDMAM_QSC_QUEUE_CNT_RANGE		32
+#define IXGBE_RDMAM_QSC_QUEUE_CNT_COUNT		4
+#define IXGBE_RDMAM_QSC_QUEUE_RAM_RANGE		128
+#define IXGBE_RDMAM_QSC_QUEUE_RAM_COUNT		8
+#define IXGBE_RDMAM_QSC_RSC_RAM_RANGE		32
+#define IXGBE_RDMAM_QSC_RSC_RAM_COUNT		8
+
+#define IXGBE_TXDESCIC_READY	0x80000000
 
 /* Receive Checksum Control */
-#define IXGBE_RXCSUM_IPPCSE     0x00001000   /* IP payload checksum enable */
-#define IXGBE_RXCSUM_PCSD       0x00002000   /* packet checksum disabled */
+#define IXGBE_RXCSUM_IPPCSE	0x00001000 /* IP payload checksum enable */
+#define IXGBE_RXCSUM_PCSD	0x00002000 /* packet checksum disabled */
 
 /* FCRTL Bit Masks */
-#define IXGBE_FCRTL_XONE        0x80000000  /* XON enable */
-#define IXGBE_FCRTH_FCEN        0x80000000  /* Packet buffer fc enable */
+#define IXGBE_FCRTL_XONE	0x80000000 /* XON enable */
+#define IXGBE_FCRTH_FCEN	0x80000000 /* Packet buffer fc enable */
 
 /* PAP bit masks*/
-#define IXGBE_PAP_TXPAUSECNT_MASK   0x0000FFFF /* Pause counter mask */
+#define IXGBE_PAP_TXPAUSECNT_MASK	0x0000FFFF /* Pause counter mask */
 
 /* RMCS Bit Masks */
-#define IXGBE_RMCS_RRM          0x00000002 /* Receive Recycle Mode enable */
+#define IXGBE_RMCS_RRM			0x00000002 /* Rx Recycle Mode enable */
 /* Receive Arbitration Control: 0 Round Robin, 1 DFP */
-#define IXGBE_RMCS_RAC          0x00000004
-#define IXGBE_RMCS_DFP          IXGBE_RMCS_RAC /* Deficit Fixed Priority ena */
-#define IXGBE_RMCS_TFCE_802_3X         0x00000008 /* Tx Priority FC ena */
-#define IXGBE_RMCS_TFCE_PRIORITY       0x00000010 /* Tx Priority FC ena */
-#define IXGBE_RMCS_ARBDIS       0x00000040 /* Arbitration disable bit */
+#define IXGBE_RMCS_RAC			0x00000004
+/* Deficit Fixed Prio ena */
+#define IXGBE_RMCS_DFP			IXGBE_RMCS_RAC
+#define IXGBE_RMCS_TFCE_802_3X		0x00000008 /* Tx Priority FC ena */
+#define IXGBE_RMCS_TFCE_PRIORITY	0x00000010 /* Tx Priority FC ena */
+#define IXGBE_RMCS_ARBDIS		0x00000040 /* Arbitration disable bit */
 
 /* FCCFG Bit Masks */
-#define IXGBE_FCCFG_TFCE_802_3X         0x00000008 /* Tx link FC enable */
-#define IXGBE_FCCFG_TFCE_PRIORITY       0x00000010 /* Tx priority FC enable */
+#define IXGBE_FCCFG_TFCE_802_3X		0x00000008 /* Tx link FC enable */
+#define IXGBE_FCCFG_TFCE_PRIORITY	0x00000010 /* Tx priority FC enable */
 
 /* Interrupt register bitmasks */
 
 /* Extended Interrupt Cause Read */
-#define IXGBE_EICR_RTX_QUEUE    0x0000FFFF /* RTx Queue Interrupt */
-#define IXGBE_EICR_FLOW_DIR     0x00010000 /* FDir Exception */
-#define IXGBE_EICR_RX_MISS      0x00020000 /* Packet Buffer Overrun */
-#define IXGBE_EICR_PCI          0x00040000 /* PCI Exception */
-#define IXGBE_EICR_MAILBOX      0x00080000 /* VF to PF Mailbox Interrupt */
-#define IXGBE_EICR_LSC          0x00100000 /* Link Status Change */
-#define IXGBE_EICR_LINKSEC      0x00200000 /* PN Threshold */
-#define IXGBE_EICR_MNG          0x00400000 /* Manageability Event Interrupt */
-#define IXGBE_EICR_TS           0x00800000 /* Thermal Sensor Event */
-#define IXGBE_EICR_TIMESYNC     0x01000000 /* Timesync Event */
-#define IXGBE_EICR_GPI_SDP0_8259X	0x01000000 /* Gen Purpose INT on SDP0 */
-#define IXGBE_EICR_GPI_SDP1_8259X	0x02000000 /* Gen Purpose INT on SDP1 */
-#define IXGBE_EICR_GPI_SDP2_8259X	0x04000000 /* Gen Purpose INT on SDP2 */
-#define IXGBE_EICR_GPI_SDP0_X540	0x02000000
-#define IXGBE_EICR_GPI_SDP1_X540	0x04000000
-#define IXGBE_EICR_GPI_SDP2_X540	0x08000000
+#define IXGBE_EICR_RTX_QUEUE	0x0000FFFF /* RTx Queue Interrupt */
+#define IXGBE_EICR_FLOW_DIR	0x00010000 /* FDir Exception */
+#define IXGBE_EICR_RX_MISS	0x00020000 /* Packet Buffer Overrun */
+#define IXGBE_EICR_PCI		0x00040000 /* PCI Exception */
+#define IXGBE_EICR_MAILBOX	0x00080000 /* VF to PF Mailbox Interrupt */
+#define IXGBE_EICR_LSC		0x00100000 /* Link Status Change */
+#define IXGBE_EICR_LINKSEC	0x00200000 /* PN Threshold */
+#define IXGBE_EICR_MNG		0x00400000 /* Manageability Event Interrupt */
+#define IXGBE_EICR_TS		0x00800000 /* Thermal Sensor Event */
+#define IXGBE_EICR_TIMESYNC	0x01000000 /* Timesync Event */
+#define IXGBE_EICR_GPI_SDP0	0x01000000 /* Gen Purpose Interrupt on SDP0 */
+#define IXGBE_EICR_GPI_SDP1	0x02000000 /* Gen Purpose Interrupt on SDP1 */
+#define IXGBE_EICR_GPI_SDP2	0x04000000 /* Gen Purpose Interrupt on SDP2 */
+#define IXGBE_EICR_ECC		0x10000000 /* ECC Error */
+#define IXGBE_EICR_GPI_SDP0_X540 0x02000000 /* Gen Purpose Interrupt on SDP0 */
+#define IXGBE_EICR_GPI_SDP1_X540 0x04000000 /* Gen Purpose Interrupt on SDP1 */
+#define IXGBE_EICR_GPI_SDP2_X540 0x08000000 /* Gen Purpose Interrupt on SDP2 */
 #define IXGBE_EICR_GPI_SDP0_X550	IXGBE_EICR_GPI_SDP0_X540
 #define IXGBE_EICR_GPI_SDP1_X550	IXGBE_EICR_GPI_SDP1_X540
 #define IXGBE_EICR_GPI_SDP2_X550	IXGBE_EICR_GPI_SDP2_X540
@@ -1618,361 +1889,373 @@ enum {
 #define IXGBE_EICR_GPI_SDP0_X550EM_a	IXGBE_EICR_GPI_SDP0_X540
 #define IXGBE_EICR_GPI_SDP1_X550EM_a	IXGBE_EICR_GPI_SDP1_X540
 #define IXGBE_EICR_GPI_SDP2_X550EM_a	IXGBE_EICR_GPI_SDP2_X540
-#define IXGBE_EICR_GPI_SDP0(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP0)
-#define IXGBE_EICR_GPI_SDP1(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP1)
-#define IXGBE_EICR_GPI_SDP2(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP2)
+#define IXGBE_EICR_GPI_SDP0_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP0)
+#define IXGBE_EICR_GPI_SDP1_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP1)
+#define IXGBE_EICR_GPI_SDP2_BY_MAC(_hw)	IXGBE_BY_MAC((_hw), EICR_GPI_SDP2)
 
-#define IXGBE_EICR_ECC          0x10000000 /* ECC Error */
-#define IXGBE_EICR_PBUR         0x10000000 /* Packet Buffer Handler Error */
-#define IXGBE_EICR_DHER         0x20000000 /* Descriptor Handler Error */
-#define IXGBE_EICR_TCP_TIMER    0x40000000 /* TCP Timer */
-#define IXGBE_EICR_OTHER        0x80000000 /* Interrupt Cause Active */
+#define IXGBE_EICR_PBUR		0x10000000 /* Packet Buffer Handler Error */
+#define IXGBE_EICR_DHER		0x20000000 /* Descriptor Handler Error */
+#define IXGBE_EICR_TCP_TIMER	0x40000000 /* TCP Timer */
+#define IXGBE_EICR_OTHER	0x80000000 /* Interrupt Cause Active */
 
 /* Extended Interrupt Cause Set */
-#define IXGBE_EICS_RTX_QUEUE    IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
-#define IXGBE_EICS_FLOW_DIR     IXGBE_EICR_FLOW_DIR  /* FDir Exception */
-#define IXGBE_EICS_RX_MISS      IXGBE_EICR_RX_MISS   /* Pkt Buffer Overrun */
-#define IXGBE_EICS_PCI          IXGBE_EICR_PCI       /* PCI Exception */
-#define IXGBE_EICS_MAILBOX      IXGBE_EICR_MAILBOX   /* VF to PF Mailbox Int */
-#define IXGBE_EICS_LSC          IXGBE_EICR_LSC       /* Link Status Change */
-#define IXGBE_EICS_MNG          IXGBE_EICR_MNG       /* MNG Event Interrupt */
-#define IXGBE_EICS_TIMESYNC     IXGBE_EICR_TIMESYNC  /* Timesync Event */
-#define IXGBE_EICS_GPI_SDP0(_hw)	IXGBE_EICR_GPI_SDP0(_hw)
-#define IXGBE_EICS_GPI_SDP1(_hw)	IXGBE_EICR_GPI_SDP1(_hw)
-#define IXGBE_EICS_GPI_SDP2(_hw)	IXGBE_EICR_GPI_SDP2(_hw)
-#define IXGBE_EICS_ECC          IXGBE_EICR_ECC       /* ECC Error */
-#define IXGBE_EICS_PBUR         IXGBE_EICR_PBUR      /* Pkt Buf Handler Err */
-#define IXGBE_EICS_DHER         IXGBE_EICR_DHER      /* Desc Handler Error */
-#define IXGBE_EICS_TCP_TIMER    IXGBE_EICR_TCP_TIMER /* TCP Timer */
-#define IXGBE_EICS_OTHER        IXGBE_EICR_OTHER     /* INT Cause Active */
+#define IXGBE_EICS_RTX_QUEUE	IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
+#define IXGBE_EICS_FLOW_DIR	IXGBE_EICR_FLOW_DIR  /* FDir Exception */
+#define IXGBE_EICS_RX_MISS	IXGBE_EICR_RX_MISS   /* Pkt Buffer Overrun */
+#define IXGBE_EICS_PCI		IXGBE_EICR_PCI /* PCI Exception */
+#define IXGBE_EICS_MAILBOX	IXGBE_EICR_MAILBOX   /* VF to PF Mailbox Int */
+#define IXGBE_EICS_LSC		IXGBE_EICR_LSC /* Link Status Change */
+#define IXGBE_EICS_MNG		IXGBE_EICR_MNG /* MNG Event Interrupt */
+#define IXGBE_EICS_TIMESYNC	IXGBE_EICR_TIMESYNC /* Timesync Event */
+#define IXGBE_EICS_GPI_SDP0	IXGBE_EICR_GPI_SDP0 /* SDP0 Gen Purpose Int */
+#define IXGBE_EICS_GPI_SDP1	IXGBE_EICR_GPI_SDP1 /* SDP1 Gen Purpose Int */
+#define IXGBE_EICS_GPI_SDP2	IXGBE_EICR_GPI_SDP2 /* SDP2 Gen Purpose Int */
+#define IXGBE_EICS_ECC		IXGBE_EICR_ECC /* ECC Error */
+#define IXGBE_EICS_GPI_SDP0_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP0_BY_MAC(_hw)
+#define IXGBE_EICS_GPI_SDP1_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP1_BY_MAC(_hw)
+#define IXGBE_EICS_GPI_SDP2_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP2_BY_MAC(_hw)
+#define IXGBE_EICS_PBUR		IXGBE_EICR_PBUR /* Pkt Buf Handler Err */
+#define IXGBE_EICS_DHER		IXGBE_EICR_DHER /* Desc Handler Error */
+#define IXGBE_EICS_TCP_TIMER	IXGBE_EICR_TCP_TIMER /* TCP Timer */
+#define IXGBE_EICS_OTHER	IXGBE_EICR_OTHER /* INT Cause Active */
 
 /* Extended Interrupt Mask Set */
-#define IXGBE_EIMS_RTX_QUEUE    IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
-#define IXGBE_EIMS_FLOW_DIR     IXGBE_EICR_FLOW_DIR  /* FDir Exception */
-#define IXGBE_EIMS_RX_MISS      IXGBE_EICR_RX_MISS   /* Packet Buffer Overrun */
-#define IXGBE_EIMS_PCI          IXGBE_EICR_PCI       /* PCI Exception */
-#define IXGBE_EIMS_MAILBOX      IXGBE_EICR_MAILBOX   /* VF to PF Mailbox Int */
-#define IXGBE_EIMS_LSC          IXGBE_EICR_LSC       /* Link Status Change */
-#define IXGBE_EIMS_MNG          IXGBE_EICR_MNG       /* MNG Event Interrupt */
-#define IXGBE_EIMS_TS           IXGBE_EICR_TS        /* Thermel Sensor Event */
-#define IXGBE_EIMS_TIMESYNC     IXGBE_EICR_TIMESYNC  /* Timesync Event */
-#define IXGBE_EIMS_GPI_SDP0(_hw)	IXGBE_EICR_GPI_SDP0(_hw)
-#define IXGBE_EIMS_GPI_SDP1(_hw)	IXGBE_EICR_GPI_SDP1(_hw)
-#define IXGBE_EIMS_GPI_SDP2(_hw)	IXGBE_EICR_GPI_SDP2(_hw)
-#define IXGBE_EIMS_ECC          IXGBE_EICR_ECC       /* ECC Error */
-#define IXGBE_EIMS_PBUR         IXGBE_EICR_PBUR      /* Pkt Buf Handler Err */
-#define IXGBE_EIMS_DHER         IXGBE_EICR_DHER      /* Descr Handler Error */
-#define IXGBE_EIMS_TCP_TIMER    IXGBE_EICR_TCP_TIMER /* TCP Timer */
-#define IXGBE_EIMS_OTHER        IXGBE_EICR_OTHER     /* INT Cause Active */
+#define IXGBE_EIMS_RTX_QUEUE	IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
+#define IXGBE_EIMS_FLOW_DIR	IXGBE_EICR_FLOW_DIR /* FDir Exception */
+#define IXGBE_EIMS_RX_MISS	IXGBE_EICR_RX_MISS /* Packet Buffer Overrun */
+#define IXGBE_EIMS_PCI		IXGBE_EICR_PCI /* PCI Exception */
+#define IXGBE_EIMS_MAILBOX	IXGBE_EICR_MAILBOX   /* VF to PF Mailbox Int */
+#define IXGBE_EIMS_LSC		IXGBE_EICR_LSC /* Link Status Change */
+#define IXGBE_EIMS_MNG		IXGBE_EICR_MNG /* MNG Event Interrupt */
+#define IXGBE_EIMS_TS		IXGBE_EICR_TS /* Thermal Sensor Event */
+#define IXGBE_EIMS_TIMESYNC	IXGBE_EICR_TIMESYNC /* Timesync Event */
+#define IXGBE_EIMS_GPI_SDP0	IXGBE_EICR_GPI_SDP0 /* SDP0 Gen Purpose Int */
+#define IXGBE_EIMS_GPI_SDP1	IXGBE_EICR_GPI_SDP1 /* SDP1 Gen Purpose Int */
+#define IXGBE_EIMS_GPI_SDP2	IXGBE_EICR_GPI_SDP2 /* SDP2 Gen Purpose Int */
+#define IXGBE_EIMS_ECC		IXGBE_EICR_ECC /* ECC Error */
+#define IXGBE_EIMS_GPI_SDP0_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP0_BY_MAC(_hw)
+#define IXGBE_EIMS_GPI_SDP1_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP1_BY_MAC(_hw)
+#define IXGBE_EIMS_GPI_SDP2_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP2_BY_MAC(_hw)
+#define IXGBE_EIMS_PBUR		IXGBE_EICR_PBUR /* Pkt Buf Handler Err */
+#define IXGBE_EIMS_DHER		IXGBE_EICR_DHER /* Descr Handler Error */
+#define IXGBE_EIMS_TCP_TIMER	IXGBE_EICR_TCP_TIMER /* TCP Timer */
+#define IXGBE_EIMS_OTHER	IXGBE_EICR_OTHER /* INT Cause Active */
 
 /* Extended Interrupt Mask Clear */
-#define IXGBE_EIMC_RTX_QUEUE    IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
-#define IXGBE_EIMC_FLOW_DIR     IXGBE_EICR_FLOW_DIR  /* FDir Exception */
-#define IXGBE_EIMC_RX_MISS      IXGBE_EICR_RX_MISS   /* Packet Buffer Overrun */
-#define IXGBE_EIMC_PCI          IXGBE_EICR_PCI       /* PCI Exception */
-#define IXGBE_EIMC_MAILBOX      IXGBE_EICR_MAILBOX   /* VF to PF Mailbox Int */
-#define IXGBE_EIMC_LSC          IXGBE_EICR_LSC       /* Link Status Change */
-#define IXGBE_EIMC_MNG          IXGBE_EICR_MNG       /* MNG Event Interrupt */
-#define IXGBE_EIMC_TIMESYNC     IXGBE_EICR_TIMESYNC  /* Timesync Event */
-#define IXGBE_EIMC_GPI_SDP0(_hw)	IXGBE_EICR_GPI_SDP0(_hw)
-#define IXGBE_EIMC_GPI_SDP1(_hw)	IXGBE_EICR_GPI_SDP1(_hw)
-#define IXGBE_EIMC_GPI_SDP2(_hw)	IXGBE_EICR_GPI_SDP2(_hw)
-#define IXGBE_EIMC_ECC          IXGBE_EICR_ECC       /* ECC Error */
-#define IXGBE_EIMC_PBUR         IXGBE_EICR_PBUR      /* Pkt Buf Handler Err */
-#define IXGBE_EIMC_DHER         IXGBE_EICR_DHER      /* Desc Handler Err */
-#define IXGBE_EIMC_TCP_TIMER    IXGBE_EICR_TCP_TIMER /* TCP Timer */
-#define IXGBE_EIMC_OTHER        IXGBE_EICR_OTHER     /* INT Cause Active */
+#define IXGBE_EIMC_RTX_QUEUE	IXGBE_EICR_RTX_QUEUE /* RTx Queue Interrupt */
+#define IXGBE_EIMC_FLOW_DIR	IXGBE_EICR_FLOW_DIR /* FDir Exception */
+#define IXGBE_EIMC_RX_MISS	IXGBE_EICR_RX_MISS /* Packet Buffer Overrun */
+#define IXGBE_EIMC_PCI		IXGBE_EICR_PCI /* PCI Exception */
+#define IXGBE_EIMC_MAILBOX	IXGBE_EICR_MAILBOX /* VF to PF Mailbox Int */
+#define IXGBE_EIMC_LSC		IXGBE_EICR_LSC /* Link Status Change */
+#define IXGBE_EIMC_MNG		IXGBE_EICR_MNG /* MNG Event Interrupt */
+#define IXGBE_EIMC_TIMESYNC	IXGBE_EICR_TIMESYNC /* Timesync Event */
+#define IXGBE_EIMC_GPI_SDP0	IXGBE_EICR_GPI_SDP0 /* SDP0 Gen Purpose Int */
+#define IXGBE_EIMC_GPI_SDP1	IXGBE_EICR_GPI_SDP1 /* SDP1 Gen Purpose Int */
+#define IXGBE_EIMC_GPI_SDP2	IXGBE_EICR_GPI_SDP2  /* SDP2 Gen Purpose Int */
+#define IXGBE_EIMC_ECC		IXGBE_EICR_ECC /* ECC Error */
+#define IXGBE_EIMC_GPI_SDP0_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP0_BY_MAC(_hw)
+#define IXGBE_EIMC_GPI_SDP1_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP1_BY_MAC(_hw)
+#define IXGBE_EIMC_GPI_SDP2_BY_MAC(_hw)	IXGBE_EICR_GPI_SDP2_BY_MAC(_hw)
+#define IXGBE_EIMC_PBUR		IXGBE_EICR_PBUR /* Pkt Buf Handler Err */
+#define IXGBE_EIMC_DHER		IXGBE_EICR_DHER /* Desc Handler Err */
+#define IXGBE_EIMC_TCP_TIMER	IXGBE_EICR_TCP_TIMER /* TCP Timer */
+#define IXGBE_EIMC_OTHER	IXGBE_EICR_OTHER /* INT Cause Active */
 
 #define IXGBE_EIMS_ENABLE_MASK ( \
-				IXGBE_EIMS_RTX_QUEUE       | \
-				IXGBE_EIMS_LSC             | \
-				IXGBE_EIMS_TCP_TIMER       | \
+				IXGBE_EIMS_RTX_QUEUE	| \
+				IXGBE_EIMS_LSC		| \
+				IXGBE_EIMS_TCP_TIMER	| \
 				IXGBE_EIMS_OTHER)
 
 /* Immediate Interrupt Rx (A.K.A. Low Latency Interrupt) */
-#define IXGBE_IMIR_PORT_IM_EN     0x00010000  /* TCP port enable */
-#define IXGBE_IMIR_PORT_BP        0x00020000  /* TCP port check bypass */
-#define IXGBE_IMIREXT_SIZE_BP     0x00001000  /* Packet size bypass */
-#define IXGBE_IMIREXT_CTRL_URG    0x00002000  /* Check URG bit in header */
-#define IXGBE_IMIREXT_CTRL_ACK    0x00004000  /* Check ACK bit in header */
-#define IXGBE_IMIREXT_CTRL_PSH    0x00008000  /* Check PSH bit in header */
-#define IXGBE_IMIREXT_CTRL_RST    0x00010000  /* Check RST bit in header */
-#define IXGBE_IMIREXT_CTRL_SYN    0x00020000  /* Check SYN bit in header */
-#define IXGBE_IMIREXT_CTRL_FIN    0x00040000  /* Check FIN bit in header */
-#define IXGBE_IMIREXT_CTRL_BP     0x00080000  /* Bypass check of control bits */
-#define IXGBE_IMIR_SIZE_BP_82599  0x00001000 /* Packet size bypass */
-#define IXGBE_IMIR_CTRL_URG_82599 0x00002000 /* Check URG bit in header */
-#define IXGBE_IMIR_CTRL_ACK_82599 0x00004000 /* Check ACK bit in header */
-#define IXGBE_IMIR_CTRL_PSH_82599 0x00008000 /* Check PSH bit in header */
-#define IXGBE_IMIR_CTRL_RST_82599 0x00010000 /* Check RST bit in header */
-#define IXGBE_IMIR_CTRL_SYN_82599 0x00020000 /* Check SYN bit in header */
-#define IXGBE_IMIR_CTRL_FIN_82599 0x00040000 /* Check FIN bit in header */
-#define IXGBE_IMIR_CTRL_BP_82599  0x00080000 /* Bypass check of control bits */
-#define IXGBE_IMIR_LLI_EN_82599   0x00100000 /* Enables low latency Int */
-#define IXGBE_IMIR_RX_QUEUE_MASK_82599  0x0000007F /* Rx Queue Mask */
-#define IXGBE_IMIR_RX_QUEUE_SHIFT_82599 21 /* Rx Queue Shift */
-#define IXGBE_IMIRVP_PRIORITY_MASK      0x00000007 /* VLAN priority mask */
-#define IXGBE_IMIRVP_PRIORITY_EN        0x00000008 /* VLAN priority enable */
-
-#define IXGBE_MAX_FTQF_FILTERS          128
-#define IXGBE_FTQF_PROTOCOL_MASK        0x00000003
-#define IXGBE_FTQF_PROTOCOL_TCP         0x00000000
-#define IXGBE_FTQF_PROTOCOL_UDP         0x00000001
-#define IXGBE_FTQF_PROTOCOL_SCTP        2
-#define IXGBE_FTQF_PRIORITY_MASK        0x00000007
-#define IXGBE_FTQF_PRIORITY_SHIFT       2
-#define IXGBE_FTQF_POOL_MASK            0x0000003F
-#define IXGBE_FTQF_POOL_SHIFT           8
-#define IXGBE_FTQF_5TUPLE_MASK_MASK     0x0000001F
-#define IXGBE_FTQF_5TUPLE_MASK_SHIFT    25
-#define IXGBE_FTQF_SOURCE_ADDR_MASK     0x1E
-#define IXGBE_FTQF_DEST_ADDR_MASK       0x1D
-#define IXGBE_FTQF_SOURCE_PORT_MASK     0x1B
-#define IXGBE_FTQF_DEST_PORT_MASK       0x17
-#define IXGBE_FTQF_PROTOCOL_COMP_MASK   0x0F
-#define IXGBE_FTQF_POOL_MASK_EN         0x40000000
-#define IXGBE_FTQF_QUEUE_ENABLE         0x80000000
+#define IXGBE_IMIR_PORT_IM_EN	0x00010000  /* TCP port enable */
+#define IXGBE_IMIR_PORT_BP	0x00020000  /* TCP port check bypass */
+#define IXGBE_IMIREXT_SIZE_BP	0x00001000  /* Packet size bypass */
+#define IXGBE_IMIREXT_CTRL_URG	0x00002000  /* Check URG bit in header */
+#define IXGBE_IMIREXT_CTRL_ACK	0x00004000  /* Check ACK bit in header */
+#define IXGBE_IMIREXT_CTRL_PSH	0x00008000  /* Check PSH bit in header */
+#define IXGBE_IMIREXT_CTRL_RST	0x00010000  /* Check RST bit in header */
+#define IXGBE_IMIREXT_CTRL_SYN	0x00020000  /* Check SYN bit in header */
+#define IXGBE_IMIREXT_CTRL_FIN	0x00040000  /* Check FIN bit in header */
+#define IXGBE_IMIREXT_CTRL_BP	0x00080000  /* Bypass check of control bits */
+#define IXGBE_IMIR_SIZE_BP_82599	0x00001000 /* Packet size bypass */
+#define IXGBE_IMIR_CTRL_URG_82599	0x00002000 /* Check URG bit in header */
+#define IXGBE_IMIR_CTRL_ACK_82599	0x00004000 /* Check ACK bit in header */
+#define IXGBE_IMIR_CTRL_PSH_82599	0x00008000 /* Check PSH bit in header */
+#define IXGBE_IMIR_CTRL_RST_82599	0x00010000 /* Check RST bit in header */
+#define IXGBE_IMIR_CTRL_SYN_82599	0x00020000 /* Check SYN bit in header */
+#define IXGBE_IMIR_CTRL_FIN_82599	0x00040000 /* Check FIN bit in header */
+#define IXGBE_IMIR_CTRL_BP_82599	0x00080000 /* Bypass chk of ctrl bits */
+#define IXGBE_IMIR_LLI_EN_82599		0x00100000 /* Enables low latency Int */
+#define IXGBE_IMIR_RX_QUEUE_MASK_82599	0x0000007F /* Rx Queue Mask */
+#define IXGBE_IMIR_RX_QUEUE_SHIFT_82599	21 /* Rx Queue Shift */
+#define IXGBE_IMIRVP_PRIORITY_MASK	0x00000007 /* VLAN priority mask */
+#define IXGBE_IMIRVP_PRIORITY_EN	0x00000008 /* VLAN priority enable */
+
+#define IXGBE_MAX_FTQF_FILTERS		128
+#define IXGBE_FTQF_PROTOCOL_MASK	0x00000003
+#define IXGBE_FTQF_PROTOCOL_TCP		0x00000000
+#define IXGBE_FTQF_PROTOCOL_UDP		0x00000001
+#define IXGBE_FTQF_PROTOCOL_SCTP	2
+#define IXGBE_FTQF_PRIORITY_MASK	0x00000007
+#define IXGBE_FTQF_PRIORITY_SHIFT	2
+#define IXGBE_FTQF_POOL_MASK		0x0000003F
+#define IXGBE_FTQF_POOL_SHIFT		8
+#define IXGBE_FTQF_5TUPLE_MASK_MASK	0x0000001F
+#define IXGBE_FTQF_5TUPLE_MASK_SHIFT	25
+#define IXGBE_FTQF_SOURCE_ADDR_MASK	0x1E
+#define IXGBE_FTQF_DEST_ADDR_MASK	0x1D
+#define IXGBE_FTQF_SOURCE_PORT_MASK	0x1B
+#define IXGBE_FTQF_DEST_PORT_MASK	0x17
+#define IXGBE_FTQF_PROTOCOL_COMP_MASK	0x0F
+#define IXGBE_FTQF_POOL_MASK_EN		0x40000000
+#define IXGBE_FTQF_QUEUE_ENABLE		0x80000000
 
 /* Interrupt clear mask */
-#define IXGBE_IRQ_CLEAR_MASK    0xFFFFFFFF
+#define IXGBE_IRQ_CLEAR_MASK	0xFFFFFFFF
 
 /* Interrupt Vector Allocation Registers */
-#define IXGBE_IVAR_REG_NUM      25
-#define IXGBE_IVAR_REG_NUM_82599       64
-#define IXGBE_IVAR_TXRX_ENTRY   96
-#define IXGBE_IVAR_RX_ENTRY     64
-#define IXGBE_IVAR_RX_QUEUE(_i)    (0 + (_i))
-#define IXGBE_IVAR_TX_QUEUE(_i)    (64 + (_i))
-#define IXGBE_IVAR_TX_ENTRY     32
+#define IXGBE_IVAR_REG_NUM		25
+#define IXGBE_IVAR_REG_NUM_82599	64
+#define IXGBE_IVAR_TXRX_ENTRY		96
+#define IXGBE_IVAR_RX_ENTRY		64
+#define IXGBE_IVAR_RX_QUEUE(_i)		(0 + (_i))
+#define IXGBE_IVAR_TX_QUEUE(_i)		(64 + (_i))
+#define IXGBE_IVAR_TX_ENTRY		32
 
-#define IXGBE_IVAR_TCP_TIMER_INDEX       96 /* 0 based index */
-#define IXGBE_IVAR_OTHER_CAUSES_INDEX    97 /* 0 based index */
+#define IXGBE_IVAR_TCP_TIMER_INDEX	96 /* 0 based index */
+#define IXGBE_IVAR_OTHER_CAUSES_INDEX	97 /* 0 based index */
 
-#define IXGBE_MSIX_VECTOR(_i)   (0 + (_i))
+#define IXGBE_MSIX_VECTOR(_i)		(0 + (_i))
 
-#define IXGBE_IVAR_ALLOC_VAL    0x80 /* Interrupt Allocation valid */
+#define IXGBE_IVAR_ALLOC_VAL		0x80 /* Interrupt Allocation valid */
 
 /* ETYPE Queue Filter/Select Bit Masks */
-#define IXGBE_MAX_ETQF_FILTERS  8
-#define IXGBE_ETQF_FCOE         0x08000000 /* bit 27 */
-#define IXGBE_ETQF_BCN          0x10000000 /* bit 28 */
-#define IXGBE_ETQF_TX_ANTISPOOF	0x20000000 /* bit 29 */
-#define IXGBE_ETQF_1588         0x40000000 /* bit 30 */
-#define IXGBE_ETQF_FILTER_EN    0x80000000 /* bit 31 */
-#define IXGBE_ETQF_POOL_ENABLE   BIT(26) /* bit 26 */
+#define IXGBE_MAX_ETQF_FILTERS		8
+#define IXGBE_ETQF_FCOE			0x08000000 /* bit 27 */
+#define IXGBE_ETQF_BCN			0x10000000 /* bit 28 */
+#define IXGBE_ETQF_TX_ANTISPOOF		0x20000000 /* bit 29 */
+#define IXGBE_ETQF_1588			0x40000000 /* bit 30 */
+#define IXGBE_ETQF_FILTER_EN		0x80000000 /* bit 31 */
+#define IXGBE_ETQF_POOL_ENABLE		(1 << 26) /* bit 26 */
 #define IXGBE_ETQF_POOL_SHIFT		20
 
-#define IXGBE_ETQS_RX_QUEUE     0x007F0000 /* bits 22:16 */
-#define IXGBE_ETQS_RX_QUEUE_SHIFT       16
-#define IXGBE_ETQS_LLI          0x20000000 /* bit 29 */
-#define IXGBE_ETQS_QUEUE_EN     0x80000000 /* bit 31 */
+#define IXGBE_ETQS_RX_QUEUE		0x007F0000 /* bits 22:16 */
+#define IXGBE_ETQS_RX_QUEUE_SHIFT	16
+#define IXGBE_ETQS_LLI			0x20000000 /* bit 29 */
+#define IXGBE_ETQS_QUEUE_EN		0x80000000 /* bit 31 */
 
 /*
  * ETQF filter list: one static filter per filter consumer. This is
- *                   to avoid filter collisions later. Add new filters
- *                   here!!
+ *		   to avoid filter collisions later. Add new filters
+ *		   here!!
  *
  * Current filters:
- *    EAPOL 802.1x (0x888e): Filter 0
- *    FCoE (0x8906):         Filter 2
- *    1588 (0x88f7):         Filter 3
- *    FIP  (0x8914):         Filter 4
- *    LLDP (0x88CC):         Filter 5
- *    LACP (0x8809):         Filter 6
- *    FC   (0x8808):         Filter 7
+ *	EAPOL 802.1x (0x888e): Filter 0
+ *	FCoE (0x8906):	 Filter 2
+ *	1588 (0x88f7):	 Filter 3
+ *	FIP  (0x8914):	 Filter 4
+ *	LLDP (0x88CC):	 Filter 5
+ *	LACP (0x8809):	 Filter 6
+ *	FC   (0x8808):	 Filter 7
  */
-#define IXGBE_ETQF_FILTER_EAPOL          0
-#define IXGBE_ETQF_FILTER_FCOE           2
-#define IXGBE_ETQF_FILTER_1588           3
-#define IXGBE_ETQF_FILTER_FIP            4
-#define IXGBE_ETQF_FILTER_LLDP		 5
-#define IXGBE_ETQF_FILTER_LACP		 6
-#define IXGBE_ETQF_FILTER_FC		 7
-
+#define IXGBE_ETQF_FILTER_EAPOL		0
+#define IXGBE_ETQF_FILTER_FCOE		2
+#define IXGBE_ETQF_FILTER_1588		3
+#define IXGBE_ETQF_FILTER_FIP		4
+#define IXGBE_ETQF_FILTER_LLDP		5
+#define IXGBE_ETQF_FILTER_LACP		6
+#define IXGBE_ETQF_FILTER_FC		7
 /* VLAN Control Bit Masks */
-#define IXGBE_VLNCTRL_VET       0x0000FFFF  /* bits 0-15 */
-#define IXGBE_VLNCTRL_CFI       0x10000000  /* bit 28 */
-#define IXGBE_VLNCTRL_CFIEN     0x20000000  /* bit 29 */
-#define IXGBE_VLNCTRL_VFE       0x40000000  /* bit 30 */
-#define IXGBE_VLNCTRL_VME       0x80000000  /* bit 31 */
+#define IXGBE_VLNCTRL_VET		0x0000FFFF  /* bits 0-15 */
+#define IXGBE_VLNCTRL_CFI		0x10000000  /* bit 28 */
+#define IXGBE_VLNCTRL_CFIEN		0x20000000  /* bit 29 */
+#define IXGBE_VLNCTRL_VFE		0x40000000  /* bit 30 */
+#define IXGBE_VLNCTRL_VME		0x80000000  /* bit 31 */
 
 /* VLAN pool filtering masks */
-#define IXGBE_VLVF_VIEN         0x80000000  /* filter is valid */
-#define IXGBE_VLVF_ENTRIES      64
-#define IXGBE_VLVF_VLANID_MASK  0x00000FFF
-
+#define IXGBE_VLVF_VIEN			0x80000000  /* filter is valid */
+#define IXGBE_VLVF_ENTRIES		64
+#define IXGBE_VLVF_VLANID_MASK		0x00000FFF
 /* Per VF Port VLAN insertion rules */
-#define IXGBE_VMVIR_VLANA_DEFAULT 0x40000000 /* Always use default VLAN */
-#define IXGBE_VMVIR_VLANA_NEVER   0x80000000 /* Never insert VLAN tag */
+#define IXGBE_VMVIR_VLANA_DEFAULT	0x40000000 /* Always use default VLAN */
+#define IXGBE_VMVIR_VLANA_NEVER		0x80000000 /* Never insert VLAN tag */
 
-#define IXGBE_ETHERNET_IEEE_VLAN_TYPE 0x8100  /* 802.1q protocol */
+#define IXGBE_ETHERNET_IEEE_VLAN_TYPE	0x8100  /* 802.1q protocol */
 
 /* STATUS Bit Masks */
-#define IXGBE_STATUS_LAN_ID         0x0000000C /* LAN ID */
-#define IXGBE_STATUS_LAN_ID_SHIFT   2          /* LAN ID Shift*/
-#define IXGBE_STATUS_GIO            0x00080000 /* GIO Master Enable Status */
+#define IXGBE_STATUS_LAN_ID		0x0000000C /* LAN ID */
+#define IXGBE_STATUS_LAN_ID_SHIFT	2 /* LAN ID Shift*/
+#define IXGBE_STATUS_GIO		0x00080000 /* GIO Master Ena Status */
 
-#define IXGBE_STATUS_LAN_ID_0   0x00000000 /* LAN ID 0 */
-#define IXGBE_STATUS_LAN_ID_1   0x00000004 /* LAN ID 1 */
+#define IXGBE_STATUS_LAN_ID_0	0x00000000 /* LAN ID 0 */
+#define IXGBE_STATUS_LAN_ID_1	0x00000004 /* LAN ID 1 */
 
 /* ESDP Bit Masks */
-#define IXGBE_ESDP_SDP0 0x00000001 /* SDP0 Data Value */
-#define IXGBE_ESDP_SDP1 0x00000002 /* SDP1 Data Value */
-#define IXGBE_ESDP_SDP2 0x00000004 /* SDP2 Data Value */
-#define IXGBE_ESDP_SDP3 0x00000008 /* SDP3 Data Value */
-#define IXGBE_ESDP_SDP4 0x00000010 /* SDP4 Data Value */
-#define IXGBE_ESDP_SDP5 0x00000020 /* SDP5 Data Value */
-#define IXGBE_ESDP_SDP6 0x00000040 /* SDP6 Data Value */
-#define IXGBE_ESDP_SDP0_DIR     0x00000100 /* SDP0 IO direction */
-#define IXGBE_ESDP_SDP1_DIR     0x00000200 /* SDP1 IO direction */
-#define IXGBE_ESDP_SDP4_DIR     0x00000004 /* SDP4 IO direction */
-#define IXGBE_ESDP_SDP5_DIR     0x00002000 /* SDP5 IO direction */
-#define IXGBE_ESDP_SDP0_NATIVE  0x00010000 /* SDP0 Native Function */
-#define IXGBE_ESDP_SDP1_NATIVE  0x00020000 /* SDP1 IO mode */
+#define IXGBE_ESDP_SDP0		0x00000001 /* SDP0 Data Value */
+#define IXGBE_ESDP_SDP1		0x00000002 /* SDP1 Data Value */
+#define IXGBE_ESDP_SDP2		0x00000004 /* SDP2 Data Value */
+#define IXGBE_ESDP_SDP3		0x00000008 /* SDP3 Data Value */
+#define IXGBE_ESDP_SDP4		0x00000010 /* SDP4 Data Value */
+#define IXGBE_ESDP_SDP5		0x00000020 /* SDP5 Data Value */
+#define IXGBE_ESDP_SDP6		0x00000040 /* SDP6 Data Value */
+#define IXGBE_ESDP_SDP7		0x00000080 /* SDP7 Data Value */
+#define IXGBE_ESDP_SDP0_DIR	0x00000100 /* SDP0 IO direction */
+#define IXGBE_ESDP_SDP1_DIR	0x00000200 /* SDP1 IO direction */
+#define IXGBE_ESDP_SDP2_DIR	0x00000400 /* SDP1 IO direction */
+#define IXGBE_ESDP_SDP3_DIR	0x00000800 /* SDP3 IO direction */
+#define IXGBE_ESDP_SDP4_DIR	0x00001000 /* SDP4 IO direction */
+#define IXGBE_ESDP_SDP5_DIR	0x00002000 /* SDP5 IO direction */
+#define IXGBE_ESDP_SDP6_DIR	0x00004000 /* SDP6 IO direction */
+#define IXGBE_ESDP_SDP7_DIR	0x00008000 /* SDP7 IO direction */
+#define IXGBE_ESDP_SDP0_NATIVE	0x00010000 /* SDP0 IO mode */
+#define IXGBE_ESDP_SDP1_NATIVE	0x00020000 /* SDP1 IO mode */
+
 
 /* LEDCTL Bit Masks */
-#define IXGBE_LED_IVRT_BASE      0x00000040
-#define IXGBE_LED_BLINK_BASE     0x00000080
-#define IXGBE_LED_MODE_MASK_BASE 0x0000000F
-#define IXGBE_LED_OFFSET(_base, _i) (_base << (8 * (_i)))
-#define IXGBE_LED_MODE_SHIFT(_i) (8 * (_i))
-#define IXGBE_LED_IVRT(_i)       IXGBE_LED_OFFSET(IXGBE_LED_IVRT_BASE, _i)
-#define IXGBE_LED_BLINK(_i)      IXGBE_LED_OFFSET(IXGBE_LED_BLINK_BASE, _i)
-#define IXGBE_LED_MODE_MASK(_i)  IXGBE_LED_OFFSET(IXGBE_LED_MODE_MASK_BASE, _i)
-#define IXGBE_X557_LED_MANUAL_SET_MASK	BIT(8)
+#define IXGBE_LED_IVRT_BASE		0x00000040
+#define IXGBE_LED_BLINK_BASE		0x00000080
+#define IXGBE_LED_MODE_MASK_BASE	0x0000000F
+#define IXGBE_LED_OFFSET(_base, _i)	(_base << (8 * (_i)))
+#define IXGBE_LED_MODE_SHIFT(_i)	(8*(_i))
+#define IXGBE_LED_IVRT(_i)	IXGBE_LED_OFFSET(IXGBE_LED_IVRT_BASE, _i)
+#define IXGBE_LED_BLINK(_i)	IXGBE_LED_OFFSET(IXGBE_LED_BLINK_BASE, _i)
+#define IXGBE_LED_MODE_MASK(_i)	IXGBE_LED_OFFSET(IXGBE_LED_MODE_MASK_BASE, _i)
+#define IXGBE_X557_LED_MANUAL_SET_MASK	(1 << 8)
 #define IXGBE_X557_MAX_LED_INDEX	3
 #define IXGBE_X557_LED_PROVISIONING	0xC430
 
 /* LED modes */
-#define IXGBE_LED_LINK_UP       0x0
-#define IXGBE_LED_LINK_10G      0x1
-#define IXGBE_LED_MAC           0x2
-#define IXGBE_LED_FILTER        0x3
-#define IXGBE_LED_LINK_ACTIVE   0x4
-#define IXGBE_LED_LINK_1G       0x5
-#define IXGBE_LED_ON            0xE
-#define IXGBE_LED_OFF           0xF
+#define IXGBE_LED_LINK_UP	0x0
+#define IXGBE_LED_LINK_10G	0x1
+#define IXGBE_LED_MAC		0x2
+#define IXGBE_LED_FILTER	0x3
+#define IXGBE_LED_LINK_ACTIVE	0x4
+#define IXGBE_LED_LINK_1G	0x5
+#define IXGBE_LED_ON		0xE
+#define IXGBE_LED_OFF		0xF
 
 /* AUTOC Bit Masks */
 #define IXGBE_AUTOC_KX4_KX_SUPP_MASK 0xC0000000
-#define IXGBE_AUTOC_KX4_SUPP    0x80000000
-#define IXGBE_AUTOC_KX_SUPP     0x40000000
-#define IXGBE_AUTOC_PAUSE       0x30000000
-#define IXGBE_AUTOC_ASM_PAUSE   0x20000000
-#define IXGBE_AUTOC_SYM_PAUSE   0x10000000
-#define IXGBE_AUTOC_RF          0x08000000
-#define IXGBE_AUTOC_PD_TMR      0x06000000
-#define IXGBE_AUTOC_AN_RX_LOOSE 0x01000000
-#define IXGBE_AUTOC_AN_RX_DRIFT 0x00800000
-#define IXGBE_AUTOC_AN_RX_ALIGN 0x007C0000
-#define IXGBE_AUTOC_FECA        0x00040000
-#define IXGBE_AUTOC_FECR        0x00020000
-#define IXGBE_AUTOC_KR_SUPP     0x00010000
-#define IXGBE_AUTOC_AN_RESTART  0x00001000
-#define IXGBE_AUTOC_FLU         0x00000001
-#define IXGBE_AUTOC_LMS_SHIFT   13
-#define IXGBE_AUTOC_LMS_10G_SERIAL      (0x3 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_KX4_KX_KR       (0x4 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_SGMII_1G_100M   (0x5 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN (0x6 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII (0x7 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_MASK            (0x7 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_1G_LINK_NO_AN   (0x0 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_10G_LINK_NO_AN  (0x1 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_1G_AN           (0x2 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_KX4_AN          (0x4 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_KX4_AN_1G_AN    (0x6 << IXGBE_AUTOC_LMS_SHIFT)
-#define IXGBE_AUTOC_LMS_ATTACH_TYPE     (0x7 << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
-
-#define IXGBE_AUTOC_1G_PMA_PMD_MASK    0x00000200
-#define IXGBE_AUTOC_1G_PMA_PMD_SHIFT   9
-#define IXGBE_AUTOC_10G_PMA_PMD_MASK   0x00000180
-#define IXGBE_AUTOC_10G_PMA_PMD_SHIFT  7
-#define IXGBE_AUTOC_10G_XAUI   (0u << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_10G_KX4    (1u << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_10G_CX4    (2u << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_1G_BX      (0u << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_1G_KX      (1u << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_1G_SFI     (0u << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC_1G_KX_BX   (1u << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
-
-#define IXGBE_AUTOC2_UPPER_MASK  0xFFFF0000
-#define IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK  0x00030000
-#define IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT 16
-#define IXGBE_AUTOC2_10G_KR  (0u << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC2_10G_XFI (1u << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC2_10G_SFI (2u << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
-#define IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK  0x50000000
-#define IXGBE_AUTOC2_LINK_DISABLE_MASK        0x70000000
-
-#define IXGBE_MACC_FLU       0x00000001
-#define IXGBE_MACC_FSV_10G   0x00030000
-#define IXGBE_MACC_FS        0x00040000
-#define IXGBE_MAC_RX2TX_LPBK 0x00000002
-
-/* Veto Bit definition */
-#define IXGBE_MMNGC_MNG_VETO  0x00000001
+#define IXGBE_AUTOC_KX4_SUPP	0x80000000
+#define IXGBE_AUTOC_KX_SUPP	0x40000000
+#define IXGBE_AUTOC_PAUSE	0x30000000
+#define IXGBE_AUTOC_ASM_PAUSE	0x20000000
+#define IXGBE_AUTOC_SYM_PAUSE	0x10000000
+#define IXGBE_AUTOC_RF		0x08000000
+#define IXGBE_AUTOC_PD_TMR	0x06000000
+#define IXGBE_AUTOC_AN_RX_LOOSE	0x01000000
+#define IXGBE_AUTOC_AN_RX_DRIFT	0x00800000
+#define IXGBE_AUTOC_AN_RX_ALIGN	0x007C0000
+#define IXGBE_AUTOC_FECA	0x00040000
+#define IXGBE_AUTOC_FECR	0x00020000
+#define IXGBE_AUTOC_KR_SUPP	0x00010000
+#define IXGBE_AUTOC_AN_RESTART	0x00001000
+#define IXGBE_AUTOC_FLU		0x00000001
+#define IXGBE_AUTOC_LMS_SHIFT	13
+#define IXGBE_AUTOC_LMS_10G_SERIAL	(0x3 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_KX4_KX_KR	(0x4 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_SGMII_1G_100M	(0x5 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_KX4_KX_KR_1G_AN	(0x6 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_KX4_KX_KR_SGMII	(0x7 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_MASK		(0x7 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_1G_LINK_NO_AN	(0x0 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_10G_LINK_NO_AN	(0x1 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_1G_AN		(0x2 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_KX4_AN		(0x4 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_KX4_AN_1G_AN	(0x6 << IXGBE_AUTOC_LMS_SHIFT)
+#define IXGBE_AUTOC_LMS_ATTACH_TYPE	(0x7 << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
+
+#define IXGBE_AUTOC_1G_PMA_PMD_MASK	0x00000200
+#define IXGBE_AUTOC_1G_PMA_PMD_SHIFT	9
+#define IXGBE_AUTOC_10G_PMA_PMD_MASK	0x00000180
+#define IXGBE_AUTOC_10G_PMA_PMD_SHIFT	7
+#define IXGBE_AUTOC_10G_XAUI	(0x0 << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_10G_KX4	(0x1 << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_10G_CX4	(0x2 << IXGBE_AUTOC_10G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_1G_BX	(0x0 << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_1G_KX	(0x1 << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_1G_SFI	(0x0 << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC_1G_KX_BX	(0x1 << IXGBE_AUTOC_1G_PMA_PMD_SHIFT)
+
+#define IXGBE_AUTOC2_UPPER_MASK	0xFFFF0000
+#define IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_MASK	0x00030000
+#define IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT	16
+#define IXGBE_AUTOC2_10G_KR	(0x0 << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC2_10G_XFI	(0x1 << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC2_10G_SFI	(0x2 << IXGBE_AUTOC2_10G_SERIAL_PMA_PMD_SHIFT)
+#define IXGBE_AUTOC2_LINK_DISABLE_ON_D3_MASK	0x50000000
+#define IXGBE_AUTOC2_LINK_DISABLE_MASK		0x70000000
+
+#define IXGBE_MACC_FLU		0x00000001
+#define IXGBE_MACC_FSV_10G	0x00030000
+#define IXGBE_MACC_FS		0x00040000
+#define IXGBE_MAC_RX2TX_LPBK	0x00000002
+
+/* Veto Bit definiton */
+#define IXGBE_MMNGC_MNG_VETO	0x00000001
 
 /* LINKS Bit Masks */
-#define IXGBE_LINKS_KX_AN_COMP  0x80000000
-#define IXGBE_LINKS_UP          0x40000000
-#define IXGBE_LINKS_SPEED       0x20000000
-#define IXGBE_LINKS_MODE        0x18000000
-#define IXGBE_LINKS_RX_MODE     0x06000000
-#define IXGBE_LINKS_TX_MODE     0x01800000
-#define IXGBE_LINKS_XGXS_EN     0x00400000
-#define IXGBE_LINKS_SGMII_EN    0x02000000
-#define IXGBE_LINKS_PCS_1G_EN   0x00200000
-#define IXGBE_LINKS_1G_AN_EN    0x00100000
-#define IXGBE_LINKS_KX_AN_IDLE  0x00080000
-#define IXGBE_LINKS_1G_SYNC     0x00040000
-#define IXGBE_LINKS_10G_ALIGN   0x00020000
-#define IXGBE_LINKS_10G_LANE_SYNC 0x00017000
-#define IXGBE_LINKS_TL_FAULT    0x00001000
-#define IXGBE_LINKS_SIGNAL      0x00000F00
-
-#define IXGBE_LINKS_SPEED_NON_STD   0x08000000
-#define IXGBE_LINKS_SPEED_82599     0x30000000
-#define IXGBE_LINKS_SPEED_10G_82599 0x30000000
-#define IXGBE_LINKS_SPEED_1G_82599  0x20000000
-#define IXGBE_LINKS_SPEED_100_82599 0x10000000
-#define IXGBE_LINKS_SPEED_10_X550EM_A 0
-#define IXGBE_LINK_UP_TIME      90 /* 9.0 Seconds */
-#define IXGBE_AUTO_NEG_TIME     45 /* 4.5 Seconds */
-
-#define IXGBE_LINKS2_AN_SUPPORTED   0x00000040
+#define IXGBE_LINKS_KX_AN_COMP	0x80000000
+#define IXGBE_LINKS_UP		0x40000000
+#define IXGBE_LINKS_SPEED	0x20000000
+#define IXGBE_LINKS_MODE	0x18000000
+#define IXGBE_LINKS_RX_MODE	0x06000000
+#define IXGBE_LINKS_TX_MODE	0x01800000
+#define IXGBE_LINKS_XGXS_EN	0x00400000
+#define IXGBE_LINKS_SGMII_EN	0x02000000
+#define IXGBE_LINKS_PCS_1G_EN	0x00200000
+#define IXGBE_LINKS_1G_AN_EN	0x00100000
+#define IXGBE_LINKS_KX_AN_IDLE	0x00080000
+#define IXGBE_LINKS_1G_SYNC	0x00040000
+#define IXGBE_LINKS_10G_ALIGN	0x00020000
+#define IXGBE_LINKS_10G_LANE_SYNC	0x00017000
+#define IXGBE_LINKS_TL_FAULT		0x00001000
+#define IXGBE_LINKS_SIGNAL		0x00000F00
+
+#define IXGBE_LINKS_SPEED_NON_STD	0x08000000
+#define IXGBE_LINKS_SPEED_82599		0x30000000
+#define IXGBE_LINKS_SPEED_10G_82599	0x30000000
+#define IXGBE_LINKS_SPEED_1G_82599	0x20000000
+#define IXGBE_LINKS_SPEED_100_82599	0x10000000
+#define IXGBE_LINKS_SPEED_10_X550EM_A	0x00000000
+#define IXGBE_LINK_UP_TIME		90 /* 9.0 Seconds */
+#define IXGBE_AUTO_NEG_TIME		45 /* 4.5 Seconds */
+
+#define IXGBE_LINKS2_AN_SUPPORTED	0x00000040
 
 /* PCS1GLSTA Bit Masks */
-#define IXGBE_PCS1GLSTA_LINK_OK         1
-#define IXGBE_PCS1GLSTA_SYNK_OK         0x10
-#define IXGBE_PCS1GLSTA_AN_COMPLETE     0x10000
-#define IXGBE_PCS1GLSTA_AN_PAGE_RX      0x20000
-#define IXGBE_PCS1GLSTA_AN_TIMED_OUT    0x40000
-#define IXGBE_PCS1GLSTA_AN_REMOTE_FAULT 0x80000
-#define IXGBE_PCS1GLSTA_AN_ERROR_RWS    0x100000
+#define IXGBE_PCS1GLSTA_LINK_OK		1
+#define IXGBE_PCS1GLSTA_SYNK_OK		0x10
+#define IXGBE_PCS1GLSTA_AN_COMPLETE	0x10000
+#define IXGBE_PCS1GLSTA_AN_PAGE_RX	0x20000
+#define IXGBE_PCS1GLSTA_AN_TIMED_OUT	0x40000
+#define IXGBE_PCS1GLSTA_AN_REMOTE_FAULT	0x80000
+#define IXGBE_PCS1GLSTA_AN_ERROR_RWS	0x100000
 
-#define IXGBE_PCS1GANA_SYM_PAUSE        0x80
-#define IXGBE_PCS1GANA_ASM_PAUSE        0x100
+#define IXGBE_PCS1GANA_SYM_PAUSE	0x80
+#define IXGBE_PCS1GANA_ASM_PAUSE	0x100
 
 /* PCS1GLCTL Bit Masks */
-#define IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN  0x00040000 /* PCS 1G autoneg to en */
-#define IXGBE_PCS1GLCTL_FLV_LINK_UP     1
-#define IXGBE_PCS1GLCTL_FORCE_LINK      0x20
-#define IXGBE_PCS1GLCTL_LOW_LINK_LATCH  0x40
-#define IXGBE_PCS1GLCTL_AN_ENABLE       0x10000
-#define IXGBE_PCS1GLCTL_AN_RESTART      0x20000
+#define IXGBE_PCS1GLCTL_AN_1G_TIMEOUT_EN 0x00040000 /* PCS 1G autoneg to en */
+#define IXGBE_PCS1GLCTL_FLV_LINK_UP	1
+#define IXGBE_PCS1GLCTL_FORCE_LINK	0x20
+#define IXGBE_PCS1GLCTL_LOW_LINK_LATCH	0x40
+#define IXGBE_PCS1GLCTL_AN_ENABLE	0x10000
+#define IXGBE_PCS1GLCTL_AN_RESTART	0x20000
 
 /* ANLP1 Bit Masks */
-#define IXGBE_ANLP1_PAUSE               0x0C00
-#define IXGBE_ANLP1_SYM_PAUSE           0x0400
-#define IXGBE_ANLP1_ASM_PAUSE           0x0800
-#define IXGBE_ANLP1_AN_STATE_MASK       0x000f0000
+#define IXGBE_ANLP1_PAUSE		0x0C00
+#define IXGBE_ANLP1_SYM_PAUSE		0x0400
+#define IXGBE_ANLP1_ASM_PAUSE		0x0800
+#define IXGBE_ANLP1_AN_STATE_MASK	0x000f0000
 
 /* SW Semaphore Register bitmasks */
-#define IXGBE_SWSM_SMBI 0x00000001 /* Driver Semaphore bit */
-#define IXGBE_SWSM_SWESMBI 0x00000002 /* FW Semaphore bit */
-#define IXGBE_SWSM_WMNG 0x00000004 /* Wake MNG Clock */
-#define IXGBE_SWFW_REGSMP 0x80000000 /* Register Semaphore bit 31 */
+#define IXGBE_SWSM_SMBI		0x00000001 /* Driver Semaphore bit */
+#define IXGBE_SWSM_SWESMBI	0x00000002 /* FW Semaphore bit */
+#define IXGBE_SWSM_WMNG		0x00000004 /* Wake MNG Clock */
+#define IXGBE_SWFW_REGSMP	0x80000000 /* Register Semaphore bit 31 */
 
 /* SW_FW_SYNC/GSSR definitions */
 #define IXGBE_GSSR_EEP_SM		0x0001
@@ -1983,40 +2266,43 @@ enum {
 #define IXGBE_GSSR_NVM_UPDATE_SM	0x0200
 #define IXGBE_GSSR_SW_MNG_SM		0x0400
 #define IXGBE_GSSR_TOKEN_SM	0x40000000 /* SW bit for shared access */
-#define IXGBE_GSSR_SHARED_I2C_SM	0x1806 /* Wait for both phys & I2Cs */
-#define IXGBE_GSSR_I2C_MASK		0x1800
-#define IXGBE_GSSR_NVM_PHY_MASK		0xF
+#define IXGBE_GSSR_SHARED_I2C_SM 0x1806 /* Wait for both phys and both I2Cs */
+#define IXGBE_GSSR_I2C_MASK	0x1800
+#define IXGBE_GSSR_NVM_PHY_MASK	0xF
 
 /* FW Status register bitmask */
-#define IXGBE_FWSTS_FWRI    0x00000200 /* Firmware Reset Indication */
+#define IXGBE_FWSTS_FWRI	0x00000200 /* Firmware Reset Indication */
 
 /* EEC Register */
-#define IXGBE_EEC_SK        0x00000001 /* EEPROM Clock */
-#define IXGBE_EEC_CS        0x00000002 /* EEPROM Chip Select */
-#define IXGBE_EEC_DI        0x00000004 /* EEPROM Data In */
-#define IXGBE_EEC_DO        0x00000008 /* EEPROM Data Out */
-#define IXGBE_EEC_FWE_MASK  0x00000030 /* FLASH Write Enable */
-#define IXGBE_EEC_FWE_DIS   0x00000010 /* Disable FLASH writes */
-#define IXGBE_EEC_FWE_EN    0x00000020 /* Enable FLASH writes */
-#define IXGBE_EEC_FWE_SHIFT 4
-#define IXGBE_EEC_REQ       0x00000040 /* EEPROM Access Request */
-#define IXGBE_EEC_GNT       0x00000080 /* EEPROM Access Grant */
-#define IXGBE_EEC_PRES      0x00000100 /* EEPROM Present */
-#define IXGBE_EEC_ARD       0x00000200 /* EEPROM Auto Read Done */
-#define IXGBE_EEC_FLUP      0x00800000 /* Flash update command */
-#define IXGBE_EEC_SEC1VAL   0x02000000 /* Sector 1 Valid */
-#define IXGBE_EEC_FLUDONE   0x04000000 /* Flash update done */
+#define IXGBE_EEC_SK		0x00000001 /* EEPROM Clock */
+#define IXGBE_EEC_CS		0x00000002 /* EEPROM Chip Select */
+#define IXGBE_EEC_DI		0x00000004 /* EEPROM Data In */
+#define IXGBE_EEC_DO		0x00000008 /* EEPROM Data Out */
+#define IXGBE_EEC_FWE_MASK	0x00000030 /* FLASH Write Enable */
+#define IXGBE_EEC_FWE_DIS	0x00000010 /* Disable FLASH writes */
+#define IXGBE_EEC_FWE_EN	0x00000020 /* Enable FLASH writes */
+#define IXGBE_EEC_FWE_SHIFT	4
+#define IXGBE_EEC_REQ		0x00000040 /* EEPROM Access Request */
+#define IXGBE_EEC_GNT		0x00000080 /* EEPROM Access Grant */
+#define IXGBE_EEC_PRES		0x00000100 /* EEPROM Present */
+#define IXGBE_EEC_ARD		0x00000200 /* EEPROM Auto Read Done */
+#define IXGBE_EEC_FLUP		0x00800000 /* Flash update command */
+#define IXGBE_EEC_SEC1VAL	0x02000000 /* Sector 1 Valid */
+#define IXGBE_EEC_FLUDONE	0x04000000 /* Flash update done */
 /* EEPROM Addressing bits based on type (0-small, 1-large) */
-#define IXGBE_EEC_ADDR_SIZE 0x00000400
-#define IXGBE_EEC_SIZE      0x00007800 /* EEPROM Size */
-#define IXGBE_EERD_MAX_ADDR 0x00003FFF /* EERD alows 14 bits for addr. */
+#define IXGBE_EEC_ADDR_SIZE	0x00000400
+#define IXGBE_EEC_SIZE		0x00007800 /* EEPROM Size */
+#define IXGBE_EERD_MAX_ADDR	0x00003FFF /* EERD alows 14 bits for addr. */
 
-#define IXGBE_EEC_SIZE_SHIFT          11
-#define IXGBE_EEPROM_WORD_SIZE_SHIFT  6
-#define IXGBE_EEPROM_OPCODE_BITS      8
+#define IXGBE_EEC_SIZE_SHIFT		11
+#define IXGBE_EEPROM_WORD_SIZE_SHIFT	6
+#define IXGBE_EEPROM_OPCODE_BITS	8
+
+/* FLA Register */
+#define IXGBE_FLA_LOCKED	0x00000040
 
 /* Part Number String Length */
-#define IXGBE_PBANUM_LENGTH 11
+#define IXGBE_PBANUM_LENGTH	11
 
 /* Checksum and EEPROM pointers */
 #define IXGBE_PBANUM_PTR_GUARD		0xFAFA
@@ -2047,139 +2333,164 @@ enum {
 #define IXGBE_FW_PTR			0x0F
 #define IXGBE_PBANUM0_PTR		0x15
 #define IXGBE_PBANUM1_PTR		0x16
+#define IXGBE_ALT_MAC_ADDR_PTR		0x37
 #define IXGBE_FREE_SPACE_PTR		0X3E
 
 /* External Thermal Sensor Config */
-#define IXGBE_ETS_CFG                   0x26
-#define IXGBE_ETS_LTHRES_DELTA_MASK     0x07C0
-#define IXGBE_ETS_LTHRES_DELTA_SHIFT    6
-#define IXGBE_ETS_TYPE_MASK             0x0038
-#define IXGBE_ETS_TYPE_SHIFT            3
-#define IXGBE_ETS_TYPE_EMC              0x000
-#define IXGBE_ETS_TYPE_EMC_SHIFTED      0x000
-#define IXGBE_ETS_NUM_SENSORS_MASK      0x0007
-#define IXGBE_ETS_DATA_LOC_MASK         0x3C00
-#define IXGBE_ETS_DATA_LOC_SHIFT        10
-#define IXGBE_ETS_DATA_INDEX_MASK       0x0300
-#define IXGBE_ETS_DATA_INDEX_SHIFT      8
-#define IXGBE_ETS_DATA_HTHRESH_MASK     0x00FF
-
-#define IXGBE_SAN_MAC_ADDR_PTR  0x28
-#define IXGBE_DEVICE_CAPS       0x2C
-#define IXGBE_SERIAL_NUMBER_MAC_ADDR 0x11
-#define IXGBE_PCIE_MSIX_82599_CAPS  0x72
+#define IXGBE_ETS_CFG			0x26
+#define IXGBE_ETS_LTHRES_DELTA_MASK	0x07C0
+#define IXGBE_ETS_LTHRES_DELTA_SHIFT	6
+#define IXGBE_ETS_TYPE_MASK		0x0038
+#define IXGBE_ETS_TYPE_SHIFT		3
+#define IXGBE_ETS_TYPE_EMC		0x000
+#define IXGBE_ETS_NUM_SENSORS_MASK	0x0007
+#define IXGBE_ETS_DATA_LOC_MASK		0x3C00
+#define IXGBE_ETS_DATA_LOC_SHIFT	10
+#define IXGBE_ETS_DATA_INDEX_MASK	0x0300
+#define IXGBE_ETS_DATA_INDEX_SHIFT	8
+#define IXGBE_ETS_DATA_HTHRESH_MASK	0x00FF
+
+#define IXGBE_SAN_MAC_ADDR_PTR		0x28
+#define IXGBE_DEVICE_CAPS		0x2C
+#define IXGBE_82599_SERIAL_NUMBER_MAC_ADDR	0x11
+#define IXGBE_X550_SERIAL_NUMBER_MAC_ADDR	0x04
+
+#define IXGBE_PCIE_MSIX_82599_CAPS	0x72
 #define IXGBE_MAX_MSIX_VECTORS_82599	0x40
-#define IXGBE_PCIE_MSIX_82598_CAPS  0x62
+#define IXGBE_PCIE_MSIX_82598_CAPS	0x62
 #define IXGBE_MAX_MSIX_VECTORS_82598	0x13
 
 /* MSI-X capability fields masks */
-#define IXGBE_PCIE_MSIX_TBL_SZ_MASK     0x7FF
+#define IXGBE_PCIE_MSIX_TBL_SZ_MASK	0x7FF
 
 /* Legacy EEPROM word offsets */
-#define IXGBE_ISCSI_BOOT_CAPS           0x0033
-#define IXGBE_ISCSI_SETUP_PORT_0        0x0030
-#define IXGBE_ISCSI_SETUP_PORT_1        0x0034
+#define IXGBE_ISCSI_BOOT_CAPS		0x0033
+#define IXGBE_ISCSI_SETUP_PORT_0	0x0030
+#define IXGBE_ISCSI_SETUP_PORT_1	0x0034
 
 /* EEPROM Commands - SPI */
-#define IXGBE_EEPROM_MAX_RETRY_SPI      5000 /* Max wait 5ms for RDY signal */
-#define IXGBE_EEPROM_STATUS_RDY_SPI     0x01
-#define IXGBE_EEPROM_READ_OPCODE_SPI    0x03  /* EEPROM read opcode */
-#define IXGBE_EEPROM_WRITE_OPCODE_SPI   0x02  /* EEPROM write opcode */
-#define IXGBE_EEPROM_A8_OPCODE_SPI      0x08  /* opcode bit-3 = addr bit-8 */
-#define IXGBE_EEPROM_WREN_OPCODE_SPI    0x06  /* EEPROM set Write Ena latch */
+#define IXGBE_EEPROM_MAX_RETRY_SPI	5000 /* Max wait 5ms for RDY signal */
+#define IXGBE_EEPROM_STATUS_RDY_SPI	0x01
+#define IXGBE_EEPROM_READ_OPCODE_SPI	0x03  /* EEPROM read opcode */
+#define IXGBE_EEPROM_WRITE_OPCODE_SPI	0x02  /* EEPROM write opcode */
+#define IXGBE_EEPROM_A8_OPCODE_SPI	0x08  /* opcode bit-3 = addr bit-8 */
+#define IXGBE_EEPROM_WREN_OPCODE_SPI	0x06  /* EEPROM set Write Ena latch */
 /* EEPROM reset Write Enable latch */
-#define IXGBE_EEPROM_WRDI_OPCODE_SPI    0x04
-#define IXGBE_EEPROM_RDSR_OPCODE_SPI    0x05  /* EEPROM read Status reg */
-#define IXGBE_EEPROM_WRSR_OPCODE_SPI    0x01  /* EEPROM write Status reg */
-#define IXGBE_EEPROM_ERASE4K_OPCODE_SPI 0x20  /* EEPROM ERASE 4KB */
-#define IXGBE_EEPROM_ERASE64K_OPCODE_SPI  0xD8  /* EEPROM ERASE 64KB */
-#define IXGBE_EEPROM_ERASE256_OPCODE_SPI  0xDB  /* EEPROM ERASE 256B */
+#define IXGBE_EEPROM_WRDI_OPCODE_SPI	0x04
+#define IXGBE_EEPROM_RDSR_OPCODE_SPI	0x05  /* EEPROM read Status reg */
+#define IXGBE_EEPROM_WRSR_OPCODE_SPI	0x01  /* EEPROM write Status reg */
+#define IXGBE_EEPROM_ERASE4K_OPCODE_SPI	0x20  /* EEPROM ERASE 4KB */
+#define IXGBE_EEPROM_ERASE64K_OPCODE_SPI	0xD8  /* EEPROM ERASE 64KB */
+#define IXGBE_EEPROM_ERASE256_OPCODE_SPI	0xDB  /* EEPROM ERASE 256B */
 
 /* EEPROM Read Register */
-#define IXGBE_EEPROM_RW_REG_DATA   16 /* data offset in EEPROM read reg */
-#define IXGBE_EEPROM_RW_REG_DONE   2  /* Offset to READ done bit */
-#define IXGBE_EEPROM_RW_REG_START  1  /* First bit to start operation */
-#define IXGBE_EEPROM_RW_ADDR_SHIFT 2  /* Shift to the address bits */
-#define IXGBE_NVM_POLL_WRITE       1  /* Flag for polling for write complete */
-#define IXGBE_NVM_POLL_READ        0  /* Flag for polling for read complete */
-
-#define NVM_INIT_CTRL_3			0x38
-#define NVM_INIT_CTRL_3_LPLU		0x8
-#define NVM_INIT_CTRL_3_D10GMP_PORT0	0x40
-#define NVM_INIT_CTRL_3_D10GMP_PORT1	0x100
-
-#define IXGBE_EEPROM_PAGE_SIZE_MAX       128
-#define IXGBE_EEPROM_RD_BUFFER_MAX_COUNT 512 /* EEPROM words # read in burst */
-#define IXGBE_EEPROM_WR_BUFFER_MAX_COUNT 256 /* EEPROM words # wr in burst */
-
-#define IXGBE_EEPROM_CTRL_2	1 /* EEPROM CTRL word 2 */
-#define IXGBE_EEPROM_CCD_BIT	2 /* EEPROM Core Clock Disable bit */
+#define IXGBE_EEPROM_RW_REG_DATA	16 /* data offset in EEPROM read reg */
+#define IXGBE_EEPROM_RW_REG_DONE	2 /* Offset to READ done bit */
+#define IXGBE_EEPROM_RW_REG_START	1 /* First bit to start operation */
+#define IXGBE_EEPROM_RW_ADDR_SHIFT	2 /* Shift to the address bits */
+#define IXGBE_NVM_POLL_WRITE		1 /* Flag for polling for wr complete */
+#define IXGBE_NVM_POLL_READ		0 /* Flag for polling for rd complete */
+
+#define NVM_INIT_CTRL_3		0x38
+#define NVM_INIT_CTRL_3_LPLU	0x8
+#define NVM_INIT_CTRL_3_D10GMP_PORT0 0x40
+#define NVM_INIT_CTRL_3_D10GMP_PORT1 0x100
+
+#define IXGBE_ETH_LENGTH_OF_ADDRESS	6
+
+#define IXGBE_EEPROM_PAGE_SIZE_MAX	128
+#define IXGBE_EEPROM_RD_BUFFER_MAX_COUNT	256 /* words rd in burst */
+#define IXGBE_EEPROM_WR_BUFFER_MAX_COUNT	256 /* words wr in burst */
+#define IXGBE_EEPROM_CTRL_2		1 /* EEPROM CTRL word 2 */
+#define IXGBE_EEPROM_CCD_BIT		2
 
 #ifndef IXGBE_EEPROM_GRANT_ATTEMPTS
-#define IXGBE_EEPROM_GRANT_ATTEMPTS 1000 /* EEPROM # attempts to gain grant */
+#define IXGBE_EEPROM_GRANT_ATTEMPTS	1000 /* EEPROM attempts to gain grant */
 #endif
 
 #ifndef IXGBE_EERD_EEWR_ATTEMPTS
 /* Number of 5 microseconds we wait for EERD read and
  * EERW write to complete */
-#define IXGBE_EERD_EEWR_ATTEMPTS 100000
+#define IXGBE_EERD_EEWR_ATTEMPTS	100000
 #endif
 
 #ifndef IXGBE_FLUDONE_ATTEMPTS
 /* # attempts we wait for flush update to complete */
-#define IXGBE_FLUDONE_ATTEMPTS 20000
+#define IXGBE_FLUDONE_ATTEMPTS		20000
 #endif
 
-#define IXGBE_PCIE_CTRL2                 0x5   /* PCIe Control 2 Offset */
-#define IXGBE_PCIE_CTRL2_DUMMY_ENABLE    0x8   /* Dummy Function Enable */
-#define IXGBE_PCIE_CTRL2_LAN_DISABLE     0x2   /* LAN PCI Disable */
-#define IXGBE_PCIE_CTRL2_DISABLE_SELECT  0x1   /* LAN Disable Select */
-
-#define IXGBE_SAN_MAC_ADDR_PORT0_OFFSET  0x0
-#define IXGBE_SAN_MAC_ADDR_PORT1_OFFSET  0x3
-#define IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP  0x1
-#define IXGBE_DEVICE_CAPS_FCOE_OFFLOADS  0x2
-#define IXGBE_DEVICE_CAPS_NO_CROSSTALK_WR	BIT(7)
-#define IXGBE_FW_LESM_PARAMETERS_PTR     0x2
-#define IXGBE_FW_LESM_STATE_1            0x1
-#define IXGBE_FW_LESM_STATE_ENABLED      0x8000 /* LESM Enable bit */
-#define IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR   0x4
-#define IXGBE_FW_PATCH_VERSION_4         0x7
-#define IXGBE_FCOE_IBA_CAPS_BLK_PTR         0x33 /* iSCSI/FCOE block */
-#define IXGBE_FCOE_IBA_CAPS_FCOE            0x20 /* FCOE flags */
-#define IXGBE_ISCSI_FCOE_BLK_PTR            0x17 /* iSCSI/FCOE block */
-#define IXGBE_ISCSI_FCOE_FLAGS_OFFSET       0x0  /* FCOE flags */
-#define IXGBE_ISCSI_FCOE_FLAGS_ENABLE       0x1  /* FCOE flags enable bit */
-#define IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR      0x27 /* Alt. SAN MAC block */
-#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET  0x0 /* Alt. SAN MAC capability */
-#define IXGBE_ALT_SAN_MAC_ADDR_PORT0_OFFSET 0x1 /* Alt. SAN MAC 0 offset */
-#define IXGBE_ALT_SAN_MAC_ADDR_PORT1_OFFSET 0x4 /* Alt. SAN MAC 1 offset */
-#define IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET  0x7 /* Alt. WWNN prefix offset */
-#define IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET  0x8 /* Alt. WWPN prefix offset */
-#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_SANMAC  0x0 /* Alt. SAN MAC exists */
-#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN  0x1 /* Alt. WWN base exists */
-
-#define IXGBE_DEVICE_CAPS_WOL_PORT0_1  0x4 /* WoL supported on ports 0 & 1 */
-#define IXGBE_DEVICE_CAPS_WOL_PORT0    0x8 /* WoL supported on port 0 */
-#define IXGBE_DEVICE_CAPS_WOL_MASK     0xC /* Mask for WoL capabilities */
+#define IXGBE_PCIE_CTRL2		0x5   /* PCIe Control 2 Offset */
+#define IXGBE_PCIE_CTRL2_DUMMY_ENABLE	0x8   /* Dummy Function Enable */
+#define IXGBE_PCIE_CTRL2_LAN_DISABLE	0x2   /* LAN PCI Disable */
+#define IXGBE_PCIE_CTRL2_DISABLE_SELECT	0x1   /* LAN Disable Select */
+
+#define IXGBE_SAN_MAC_ADDR_PORT0_OFFSET		0x0
+#define IXGBE_SAN_MAC_ADDR_PORT1_OFFSET		0x3
+#define IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP		0x1
+#define IXGBE_DEVICE_CAPS_FCOE_OFFLOADS		0x2
+#define IXGBE_DEVICE_CAPS_NO_CROSSTALK_WR	(1 << 7)
+#define IXGBE_FW_LESM_PARAMETERS_PTR		0x2
+#define IXGBE_FW_LESM_STATE_1			0x1
+#define IXGBE_FW_LESM_STATE_ENABLED		0x8000 /* LESM Enable bit */
+#define IXGBE_FW_LESM_2_STATES_ENABLED_MASK	0x1F
+#define IXGBE_FW_LESM_2_STATES_ENABLED		0x12
+#define IXGBE_FW_LESM_STATE0_10G_ENABLED	0x6FFF
+#define IXGBE_FW_LESM_STATE1_10G_ENABLED	0x4FFF
+#define IXGBE_FW_LESM_STATE0_10G_DISABLED	0x0FFF
+#define IXGBE_FW_LESM_STATE1_10G_DISABLED	0x2FFF
+#define IXGBE_FW_LESM_PORT0_STATE0_OFFSET	0x2
+#define IXGBE_FW_LESM_PORT0_STATE1_OFFSET	0x3
+#define IXGBE_FW_LESM_PORT1_STATE0_OFFSET	0x6
+#define IXGBE_FW_LESM_PORT1_STATE1_OFFSET	0x7
+#define IXGBE_FW_PASSTHROUGH_PATCH_CONFIG_PTR	0x4
+#define IXGBE_FW_PATCH_VERSION_4		0x7
+#define IXGBE_FCOE_IBA_CAPS_BLK_PTR		0x33 /* iSCSI/FCOE block */
+#define IXGBE_FCOE_IBA_CAPS_FCOE		0x20 /* FCOE flags */
+#define IXGBE_ISCSI_FCOE_BLK_PTR		0x17 /* iSCSI/FCOE block */
+#define IXGBE_ISCSI_FCOE_FLAGS_OFFSET		0x0 /* FCOE flags */
+#define IXGBE_ISCSI_FCOE_FLAGS_ENABLE		0x1 /* FCOE flags enable bit */
+#define IXGBE_ALT_SAN_MAC_ADDR_BLK_PTR		0x27 /* Alt. SAN MAC block */
+#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_OFFSET	0x0 /* Alt SAN MAC capability */
+#define IXGBE_ALT_SAN_MAC_ADDR_PORT0_OFFSET	0x1 /* Alt SAN MAC 0 offset */
+#define IXGBE_ALT_SAN_MAC_ADDR_PORT1_OFFSET	0x4 /* Alt SAN MAC 1 offset */
+#define IXGBE_ALT_SAN_MAC_ADDR_WWNN_OFFSET	0x7 /* Alt WWNN prefix offset */
+#define IXGBE_ALT_SAN_MAC_ADDR_WWPN_OFFSET	0x8 /* Alt WWPN prefix offset */
+#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_SANMAC	0x0 /* Alt SAN MAC exists */
+#define IXGBE_ALT_SAN_MAC_ADDR_CAPS_ALTWWN	0x1 /* Alt WWN base exists */
+
+/* FW header offset */
+#define IXGBE_X540_FW_PASSTHROUGH_PATCH_CONFIG_PTR	0x4
+#define IXGBE_X540_FW_MODULE_MASK			0x7FFF
+/* 4KB multiplier */
+#define IXGBE_X540_FW_MODULE_LENGTH			0x1000
+/* version word 2 (month & day) */
+#define IXGBE_X540_FW_PATCH_VERSION_2		0x5
+/* version word 3 (silicon compatibility & year) */
+#define IXGBE_X540_FW_PATCH_VERSION_3		0x6
+/* version word 4 (major & minor numbers) */
+#define IXGBE_X540_FW_PATCH_VERSION_4		0x7
+
+#define IXGBE_DEVICE_CAPS_WOL_PORT0_1	0x4 /* WoL supported on ports 0 & 1 */
+#define IXGBE_DEVICE_CAPS_WOL_PORT0	0x8 /* WoL supported on port 0 */
+#define IXGBE_DEVICE_CAPS_WOL_MASK	0xC /* Mask for WoL capabilities */
 
 /* PCI Bus Info */
-#define IXGBE_PCI_DEVICE_STATUS   0xAA
-#define IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING   0x0020
-#define IXGBE_PCI_LINK_STATUS     0xB2
-#define IXGBE_PCI_DEVICE_CONTROL2 0xC8
-#define IXGBE_PCI_LINK_WIDTH      0x3F0
-#define IXGBE_PCI_LINK_WIDTH_1    0x10
-#define IXGBE_PCI_LINK_WIDTH_2    0x20
-#define IXGBE_PCI_LINK_WIDTH_4    0x40
-#define IXGBE_PCI_LINK_WIDTH_8    0x80
-#define IXGBE_PCI_LINK_SPEED      0xF
-#define IXGBE_PCI_LINK_SPEED_2500 0x1
-#define IXGBE_PCI_LINK_SPEED_5000 0x2
-#define IXGBE_PCI_LINK_SPEED_8000 0x3
-#define IXGBE_PCI_HEADER_TYPE_REGISTER  0x0E
-#define IXGBE_PCI_HEADER_TYPE_MULTIFUNC 0x80
-#define IXGBE_PCI_DEVICE_CONTROL2_16ms  0x0005
+#define IXGBE_PCI_DEVICE_STATUS		0xAA
+#define IXGBE_PCI_DEVICE_STATUS_TRANSACTION_PENDING	0x0020
+#define IXGBE_PCI_LINK_STATUS		0xB2
+#define IXGBE_PCI_DEVICE_CONTROL2	0xC8
+#define IXGBE_PCI_LINK_WIDTH		0x3F0
+#define IXGBE_PCI_LINK_WIDTH_1		0x10
+#define IXGBE_PCI_LINK_WIDTH_2		0x20
+#define IXGBE_PCI_LINK_WIDTH_4		0x40
+#define IXGBE_PCI_LINK_WIDTH_8		0x80
+#define IXGBE_PCI_LINK_SPEED		0xF
+#define IXGBE_PCI_LINK_SPEED_2500	0x1
+#define IXGBE_PCI_LINK_SPEED_5000	0x2
+#define IXGBE_PCI_LINK_SPEED_8000	0x3
+#define IXGBE_PCI_HEADER_TYPE_REGISTER	0x0E
+#define IXGBE_PCI_HEADER_TYPE_MULTIFUNC	0x80
+#define IXGBE_PCI_DEVICE_CONTROL2_16ms	0x0005
 
 #define IXGBE_PCIDEVCTRL2_TIMEO_MASK	0xf
 #define IXGBE_PCIDEVCTRL2_16_32ms_def	0x0
@@ -2195,51 +2506,60 @@ enum {
 /* Number of 100 microseconds we wait for PCI Express master disable */
 #define IXGBE_PCI_MASTER_DISABLE_TIMEOUT	800
 
+/* Check whether address is multicast. This is little-endian specific check.*/
+#define IXGBE_IS_MULTICAST(Address) \
+		(bool)(((u8 *)(Address))[0] & ((u8)0x01))
+
+/* Check whether an address is broadcast. */
+#define IXGBE_IS_BROADCAST(Address) \
+		((((u8 *)(Address))[0] == ((u8)0xff)) && \
+		(((u8 *)(Address))[1] == ((u8)0xff)))
+
 /* RAH */
-#define IXGBE_RAH_VIND_MASK     0x003C0000
-#define IXGBE_RAH_VIND_SHIFT    18
-#define IXGBE_RAH_AV            0x80000000
-#define IXGBE_CLEAR_VMDQ_ALL    0xFFFFFFFF
+#define IXGBE_RAH_VIND_MASK	0x003C0000
+#define IXGBE_RAH_VIND_SHIFT	18
+#define IXGBE_RAH_AV		0x80000000
+#define IXGBE_CLEAR_VMDQ_ALL	0xFFFFFFFF
 
 /* Header split receive */
-#define IXGBE_RFCTL_ISCSI_DIS       0x00000001
-#define IXGBE_RFCTL_ISCSI_DWC_MASK  0x0000003E
-#define IXGBE_RFCTL_ISCSI_DWC_SHIFT 1
+#define IXGBE_RFCTL_ISCSI_DIS		0x00000001
+#define IXGBE_RFCTL_ISCSI_DWC_MASK	0x0000003E
+#define IXGBE_RFCTL_ISCSI_DWC_SHIFT	1
 #define IXGBE_RFCTL_RSC_DIS		0x00000020
-#define IXGBE_RFCTL_NFSW_DIS        0x00000040
-#define IXGBE_RFCTL_NFSR_DIS        0x00000080
-#define IXGBE_RFCTL_NFS_VER_MASK    0x00000300
-#define IXGBE_RFCTL_NFS_VER_SHIFT   8
-#define IXGBE_RFCTL_NFS_VER_2       0
-#define IXGBE_RFCTL_NFS_VER_3       1
-#define IXGBE_RFCTL_NFS_VER_4       2
-#define IXGBE_RFCTL_IPV6_DIS        0x00000400
-#define IXGBE_RFCTL_IPV6_XSUM_DIS   0x00000800
-#define IXGBE_RFCTL_IPFRSP_DIS      0x00004000
-#define IXGBE_RFCTL_IPV6_EX_DIS     0x00010000
-#define IXGBE_RFCTL_NEW_IPV6_EXT_DIS 0x00020000
+#define IXGBE_RFCTL_NFSW_DIS		0x00000040
+#define IXGBE_RFCTL_NFSR_DIS		0x00000080
+#define IXGBE_RFCTL_NFS_VER_MASK	0x00000300
+#define IXGBE_RFCTL_NFS_VER_SHIFT	8
+#define IXGBE_RFCTL_NFS_VER_2		0
+#define IXGBE_RFCTL_NFS_VER_3		1
+#define IXGBE_RFCTL_NFS_VER_4		2
+#define IXGBE_RFCTL_IPV6_DIS		0x00000400
+#define IXGBE_RFCTL_IPV6_XSUM_DIS	0x00000800
+#define IXGBE_RFCTL_IPFRSP_DIS		0x00004000
+#define IXGBE_RFCTL_IPV6_EX_DIS		0x00010000
+#define IXGBE_RFCTL_NEW_IPV6_EXT_DIS	0x00020000
 
 /* Transmit Config masks */
-#define IXGBE_TXDCTL_ENABLE     0x02000000 /* Enable specific Tx Queue */
-#define IXGBE_TXDCTL_SWFLSH     0x04000000 /* Tx Desc. write-back flushing */
-#define IXGBE_TXDCTL_WTHRESH_SHIFT      16 /* shift to WTHRESH bits */
+#define IXGBE_TXDCTL_ENABLE		0x02000000 /* Ena specific Tx Queue */
+#define IXGBE_TXDCTL_SWFLSH		0x04000000 /* Tx Desc. wr-bk flushing */
+#define IXGBE_TXDCTL_WTHRESH_SHIFT	16 /* shift to WTHRESH bits */
 /* Enable short packet padding to 64 bytes */
-#define IXGBE_TX_PAD_ENABLE     0x00000400
-#define IXGBE_JUMBO_FRAME_ENABLE 0x00000004  /* Allow jumbo frames */
+#define IXGBE_TX_PAD_ENABLE		0x00000400
+#define IXGBE_JUMBO_FRAME_ENABLE	0x00000004  /* Allow jumbo frames */
 /* This allows for 16K packets + 4k for vlan */
-#define IXGBE_MAX_FRAME_SZ      0x40040000
+#define IXGBE_MAX_FRAME_SZ		0x40040000
 
-#define IXGBE_TDWBAL_HEAD_WB_ENABLE   0x1      /* Tx head write-back enable */
-#define IXGBE_TDWBAL_SEQNUM_WB_ENABLE 0x2      /* Tx seq# write-back enable */
+#define IXGBE_TDWBAL_HEAD_WB_ENABLE	0x1 /* Tx head write-back enable */
+#define IXGBE_TDWBAL_SEQNUM_WB_ENABLE	0x2 /* Tx seq# write-back enable */
 
 /* Receive Config masks */
-#define IXGBE_RXCTRL_RXEN       0x00000001  /* Enable Receiver */
-#define IXGBE_RXCTRL_DMBYPS     0x00000002  /* Descriptor Monitor Bypass */
-#define IXGBE_RXDCTL_ENABLE     0x02000000  /* Enable specific Rx Queue */
-#define IXGBE_RXDCTL_SWFLSH     0x04000000  /* Rx Desc. write-back flushing */
-#define IXGBE_RXDCTL_RLPMLMASK  0x00003FFF  /* Only supported on the X540 */
-#define IXGBE_RXDCTL_RLPML_EN   0x00008000
-#define IXGBE_RXDCTL_VME        0x40000000  /* VLAN mode enable */
+#define IXGBE_RXCTRL_RXEN		0x00000001 /* Enable Receiver */
+#define IXGBE_RXCTRL_DMBYPS		0x00000002 /* Desc Monitor Bypass */
+#define IXGBE_RXDCTL_ENABLE		0x02000000 /* Ena specific Rx Queue */
+#define IXGBE_RXDCTL_SWFLSH		0x04000000 /* Rx Desc wr-bk flushing */
+#define IXGBE_RXDCTL_RLPMLMASK		0x00003FFF /* X540 supported only */
+#define IXGBE_RXDCTL_RLPML_EN		0x00008000
+#define IXGBE_RXDCTL_VME		0x40000000 /* VLAN mode enable */
 
 #define IXGBE_TSAUXC_EN_CLK		0x00000004
 #define IXGBE_TSAUXC_SYNCLK		0x00000008
@@ -2265,8 +2585,15 @@ enum {
 #define IXGBE_TSYNCRXCTL_TYPE_EVENT_V2	0x0A
 #define IXGBE_TSYNCRXCTL_ENABLED	0x00000010 /* Rx Timestamping enabled */
 #define IXGBE_TSYNCRXCTL_TSIP_UT_EN	0x00800000 /* Rx Timestamp in Packet */
+#define IXGBE_TSYNCRXCTL_TSIP_UP_MASK	0xFF000000 /* Rx Timestamp UP Mask */
 
+#define IXGBE_TSIM_SYS_WRAP		0x00000001
 #define IXGBE_TSIM_TXTS			0x00000002
+#define IXGBE_TSIM_TADJ			0x00000080
+
+#define IXGBE_TSICR_SYS_WRAP		IXGBE_TSIM_SYS_WRAP
+#define IXGBE_TSICR_TXTS		IXGBE_TSIM_TXTS
+#define IXGBE_TSICR_TADJ		IXGBE_TSIM_TADJ
 
 #define IXGBE_RXMTRL_V1_CTRLT_MASK	0x000000FF
 #define IXGBE_RXMTRL_V1_SYNC_MSG	0x00
@@ -2275,61 +2602,59 @@ enum {
 #define IXGBE_RXMTRL_V1_DELAY_RESP_MSG	0x03
 #define IXGBE_RXMTRL_V1_MGMT_MSG	0x04
 
-#define IXGBE_RXMTRL_V2_MSGID_MASK		0x0000FF00
-#define IXGBE_RXMTRL_V2_SYNC_MSG		0x0000
-#define IXGBE_RXMTRL_V2_DELAY_REQ_MSG		0x0100
-#define IXGBE_RXMTRL_V2_PDELAY_REQ_MSG		0x0200
-#define IXGBE_RXMTRL_V2_PDELAY_RESP_MSG		0x0300
-#define IXGBE_RXMTRL_V2_FOLLOWUP_MSG		0x0800
-#define IXGBE_RXMTRL_V2_DELAY_RESP_MSG		0x0900
-#define IXGBE_RXMTRL_V2_PDELAY_FOLLOWUP_MSG	0x0A00
-#define IXGBE_RXMTRL_V2_ANNOUNCE_MSG		0x0B00
-#define IXGBE_RXMTRL_V2_SIGNALING_MSG		0x0C00
-#define IXGBE_RXMTRL_V2_MGMT_MSG		0x0D00
-
-#define IXGBE_FCTRL_SBP 0x00000002 /* Store Bad Packet */
-#define IXGBE_FCTRL_MPE 0x00000100 /* Multicast Promiscuous Ena*/
-#define IXGBE_FCTRL_UPE 0x00000200 /* Unicast Promiscuous Ena */
-#define IXGBE_FCTRL_BAM 0x00000400 /* Broadcast Accept Mode */
-#define IXGBE_FCTRL_PMCF 0x00001000 /* Pass MAC Control Frames */
-#define IXGBE_FCTRL_DPF 0x00002000 /* Discard Pause Frame */
+#define IXGBE_RXMTRL_V2_MSGID_MASK	0x0000FF00
+#define IXGBE_RXMTRL_V2_SYNC_MSG	0x0000
+#define IXGBE_RXMTRL_V2_DELAY_REQ_MSG	0x0100
+#define IXGBE_RXMTRL_V2_PDELAY_REQ_MSG	0x0200
+#define IXGBE_RXMTRL_V2_PDELAY_RESP_MSG	0x0300
+#define IXGBE_RXMTRL_V2_FOLLOWUP_MSG	0x0800
+#define IXGBE_RXMTRL_V2_DELAY_RESP_MSG	0x0900
+#define IXGBE_RXMTRL_V2_PDELAY_FOLLOWUP_MSG 0x0A00
+#define IXGBE_RXMTRL_V2_ANNOUNCE_MSG	0x0B00
+#define IXGBE_RXMTRL_V2_SIGNALLING_MSG	0x0C00
+#define IXGBE_RXMTRL_V2_MGMT_MSG	0x0D00
+
+#define IXGBE_FCTRL_SBP		0x00000002 /* Store Bad Packet */
+#define IXGBE_FCTRL_MPE		0x00000100 /* Multicast Promiscuous Ena*/
+#define IXGBE_FCTRL_UPE		0x00000200 /* Unicast Promiscuous Ena */
+#define IXGBE_FCTRL_BAM		0x00000400 /* Broadcast Accept Mode */
+#define IXGBE_FCTRL_PMCF	0x00001000 /* Pass MAC Control Frames */
+#define IXGBE_FCTRL_DPF		0x00002000 /* Discard Pause Frame */
 /* Receive Priority Flow Control Enable */
-#define IXGBE_FCTRL_RPFCE 0x00004000
-#define IXGBE_FCTRL_RFCE 0x00008000 /* Receive Flow Control Ena */
-#define IXGBE_MFLCN_PMCF        0x00000001 /* Pass MAC Control Frames */
-#define IXGBE_MFLCN_DPF         0x00000002 /* Discard Pause Frame */
-#define IXGBE_MFLCN_RPFCE       0x00000004 /* Receive Priority FC Enable */
-#define IXGBE_MFLCN_RFCE        0x00000008 /* Receive FC Enable */
-#define IXGBE_MFLCN_RPFCE_MASK	0x00000FF4 /* Receive FC Mask */
-
-#define IXGBE_MFLCN_RPFCE_SHIFT		 4
+#define IXGBE_FCTRL_RPFCE	0x00004000
+#define IXGBE_FCTRL_RFCE	0x00008000 /* Receive Flow Control Ena */
+#define IXGBE_MFLCN_PMCF	0x00000001 /* Pass MAC Control Frames */
+#define IXGBE_MFLCN_DPF		0x00000002 /* Discard Pause Frame */
+#define IXGBE_MFLCN_RPFCE	0x00000004 /* Receive Priority FC Enable */
+#define IXGBE_MFLCN_RFCE	0x00000008 /* Receive FC Enable */
+#define IXGBE_MFLCN_RPFCE_MASK	0x00000FF4 /* Rx Priority FC bitmap mask */
+#define IXGBE_MFLCN_RPFCE_SHIFT	4 /* Rx Priority FC bitmap shift */
 
 /* Multiple Receive Queue Control */
-#define IXGBE_MRQC_RSSEN                 0x00000001  /* RSS Enable */
-#define IXGBE_MRQC_MRQE_MASK                    0xF /* Bits 3:0 */
-#define IXGBE_MRQC_RT8TCEN               0x00000002 /* 8 TC no RSS */
-#define IXGBE_MRQC_RT4TCEN               0x00000003 /* 4 TC no RSS */
-#define IXGBE_MRQC_RTRSS8TCEN            0x00000004 /* 8 TC w/ RSS */
-#define IXGBE_MRQC_RTRSS4TCEN            0x00000005 /* 4 TC w/ RSS */
-#define IXGBE_MRQC_VMDQEN                0x00000008 /* VMDq2 64 pools no RSS */
-#define IXGBE_MRQC_VMDQRSS32EN           0x0000000A /* VMDq2 32 pools w/ RSS */
-#define IXGBE_MRQC_VMDQRSS64EN           0x0000000B /* VMDq2 64 pools w/ RSS */
-#define IXGBE_MRQC_VMDQRT8TCEN           0x0000000C /* VMDq2/RT 16 pool 8 TC */
-#define IXGBE_MRQC_VMDQRT4TCEN           0x0000000D /* VMDq2/RT 32 pool 4 TC */
-#define IXGBE_MRQC_RSS_FIELD_MASK        0xFFFF0000
-#define IXGBE_MRQC_RSS_FIELD_IPV4_TCP    0x00010000
-#define IXGBE_MRQC_RSS_FIELD_IPV4        0x00020000
+#define IXGBE_MRQC_RSSEN	0x00000001  /* RSS Enable */
+#define IXGBE_MRQC_MRQE_MASK	0xF /* Bits 3:0 */
+#define IXGBE_MRQC_RT8TCEN	0x00000002 /* 8 TC no RSS */
+#define IXGBE_MRQC_RT4TCEN	0x00000003 /* 4 TC no RSS */
+#define IXGBE_MRQC_RTRSS8TCEN	0x00000004 /* 8 TC w/ RSS */
+#define IXGBE_MRQC_RTRSS4TCEN	0x00000005 /* 4 TC w/ RSS */
+#define IXGBE_MRQC_VMDQEN	0x00000008 /* VMDq2 64 pools no RSS */
+#define IXGBE_MRQC_VMDQRSS32EN	0x0000000A /* VMDq2 32 pools w/ RSS */
+#define IXGBE_MRQC_VMDQRSS64EN	0x0000000B /* VMDq2 64 pools w/ RSS */
+#define IXGBE_MRQC_VMDQRT8TCEN	0x0000000C /* VMDq2/RT 16 pool 8 TC */
+#define IXGBE_MRQC_VMDQRT4TCEN	0x0000000D /* VMDq2/RT 32 pool 4 TC */
+#define IXGBE_MRQC_L3L4TXSWEN	0x00008000 /* Enable L3/L4 Tx switch */
+#define IXGBE_MRQC_RSS_FIELD_MASK	0xFFFF0000
+#define IXGBE_MRQC_RSS_FIELD_IPV4_TCP	0x00010000
+#define IXGBE_MRQC_RSS_FIELD_IPV4	0x00020000
 #define IXGBE_MRQC_RSS_FIELD_IPV6_EX_TCP 0x00040000
-#define IXGBE_MRQC_RSS_FIELD_IPV6_EX     0x00080000
-#define IXGBE_MRQC_RSS_FIELD_IPV6        0x00100000
-#define IXGBE_MRQC_RSS_FIELD_IPV6_TCP    0x00200000
-#define IXGBE_MRQC_RSS_FIELD_IPV4_UDP    0x00400000
-#define IXGBE_MRQC_RSS_FIELD_IPV6_UDP    0x00800000
+#define IXGBE_MRQC_RSS_FIELD_IPV6_EX	0x00080000
+#define IXGBE_MRQC_RSS_FIELD_IPV6	0x00100000
+#define IXGBE_MRQC_RSS_FIELD_IPV6_TCP	0x00200000
+#define IXGBE_MRQC_RSS_FIELD_IPV4_UDP	0x00400000
+#define IXGBE_MRQC_RSS_FIELD_IPV6_UDP	0x00800000
 #define IXGBE_MRQC_RSS_FIELD_IPV6_EX_UDP 0x01000000
-#define IXGBE_MRQC_MULTIPLE_RSS          0x00002000
-#define IXGBE_MRQC_L3L4TXSWEN            0x00008000
-
-#define IXGBE_FWSM_TS_ENABLED	0x1
+#define IXGBE_MRQC_MULTIPLE_RSS		0x00002000
+#define IXGBE_MRQC_L3L4TXSWEN		0x00008000
 
 /* Queue Drop Enable */
 #define IXGBE_QDE_ENABLE	0x00000001
@@ -2337,296 +2662,377 @@ enum {
 #define IXGBE_QDE_IDX_MASK	0x00007F00
 #define IXGBE_QDE_IDX_SHIFT	8
 #define IXGBE_QDE_WRITE		0x00010000
-
-#define IXGBE_TXD_POPTS_IXSM 0x01       /* Insert IP checksum */
-#define IXGBE_TXD_POPTS_TXSM 0x02       /* Insert TCP/UDP checksum */
-#define IXGBE_TXD_CMD_EOP    0x01000000 /* End of Packet */
-#define IXGBE_TXD_CMD_IFCS   0x02000000 /* Insert FCS (Ethernet CRC) */
-#define IXGBE_TXD_CMD_IC     0x04000000 /* Insert Checksum */
-#define IXGBE_TXD_CMD_RS     0x08000000 /* Report Status */
-#define IXGBE_TXD_CMD_DEXT   0x20000000 /* Descriptor extension (0 = legacy) */
-#define IXGBE_TXD_CMD_VLE    0x40000000 /* Add VLAN tag */
-#define IXGBE_TXD_STAT_DD    0x00000001 /* Descriptor Done */
-
+#define IXGBE_QDE_READ		0x00020000
+
+#define IXGBE_TXD_POPTS_IXSM	0x01 /* Insert IP checksum */
+#define IXGBE_TXD_POPTS_TXSM	0x02 /* Insert TCP/UDP checksum */
+#define IXGBE_TXD_CMD_EOP	0x01000000 /* End of Packet */
+#define IXGBE_TXD_CMD_IFCS	0x02000000 /* Insert FCS (Ethernet CRC) */
+#define IXGBE_TXD_CMD_IC	0x04000000 /* Insert Checksum */
+#define IXGBE_TXD_CMD_RS	0x08000000 /* Report Status */
+#define IXGBE_TXD_CMD_DEXT	0x20000000 /* Desc extension (0 = legacy) */
+#define IXGBE_TXD_CMD_VLE	0x40000000 /* Add VLAN tag */
+#define IXGBE_TXD_STAT_DD	0x00000001 /* Descriptor Done */
+
+#define IXGBE_RXDADV_IPSEC_STATUS_SECP		0x00020000
+#define IXGBE_RXDADV_IPSEC_ERROR_INVALID_PROTOCOL 0x08000000
+#define IXGBE_RXDADV_IPSEC_ERROR_INVALID_LENGTH	0x10000000
+#define IXGBE_RXDADV_IPSEC_ERROR_AUTH_FAILED	0x18000000
+#define IXGBE_RXDADV_IPSEC_ERROR_BIT_MASK	0x18000000
 /* Multiple Transmit Queue Command Register */
-#define IXGBE_MTQC_RT_ENA       0x1 /* DCB Enable */
-#define IXGBE_MTQC_VT_ENA       0x2 /* VMDQ2 Enable */
-#define IXGBE_MTQC_64Q_1PB      0x0 /* 64 queues 1 pack buffer */
-#define IXGBE_MTQC_32VF         0x8 /* 4 TX Queues per pool w/32VF's */
-#define IXGBE_MTQC_64VF         0x4 /* 2 TX Queues per pool w/64VF's */
-#define IXGBE_MTQC_8TC_8TQ      0xC /* 8 TC if RT_ENA or 8 TQ if VT_ENA */
-#define IXGBE_MTQC_4TC_4TQ	0x8 /* 4 TC if RT_ENA or 4 TQ if VT_ENA */
+#define IXGBE_MTQC_RT_ENA	0x1 /* DCB Enable */
+#define IXGBE_MTQC_VT_ENA	0x2 /* VMDQ2 Enable */
+#define IXGBE_MTQC_64Q_1PB	0x0 /* 64 queues 1 pack buffer */
+#define IXGBE_MTQC_32VF		0x8 /* 4 TX Queues per pool w/32VF's */
+#define IXGBE_MTQC_64VF		0x4 /* 2 TX Queues per pool w/64VF's */
+#define IXGBE_MTQC_4TC_4TQ	0x8 /* 4 TC if RT_ENA and VT_ENA */
+#define IXGBE_MTQC_8TC_8TQ	0xC /* 8 TC if RT_ENA or 8 TQ if VT_ENA */
 
 /* Receive Descriptor bit definitions */
-#define IXGBE_RXD_STAT_DD       0x01    /* Descriptor Done */
-#define IXGBE_RXD_STAT_EOP      0x02    /* End of Packet */
-#define IXGBE_RXD_STAT_FLM      0x04    /* FDir Match */
-#define IXGBE_RXD_STAT_VP       0x08    /* IEEE VLAN Packet */
-#define IXGBE_RXDADV_NEXTP_MASK   0x000FFFF0 /* Next Descriptor Index */
-#define IXGBE_RXDADV_NEXTP_SHIFT  0x00000004
-#define IXGBE_RXD_STAT_UDPCS    0x10    /* UDP xsum calculated */
-#define IXGBE_RXD_STAT_L4CS     0x20    /* L4 xsum calculated */
-#define IXGBE_RXD_STAT_IPCS     0x40    /* IP xsum calculated */
-#define IXGBE_RXD_STAT_PIF      0x80    /* passed in-exact filter */
-#define IXGBE_RXD_STAT_CRCV     0x100   /* Speculative CRC Valid */
-#define IXGBE_RXD_STAT_OUTERIPCS  0x100 /* Cloud IP xsum calculated */
-#define IXGBE_RXD_STAT_VEXT     0x200   /* 1st VLAN found */
-#define IXGBE_RXD_STAT_UDPV     0x400   /* Valid UDP checksum */
-#define IXGBE_RXD_STAT_DYNINT   0x800   /* Pkt caused INT via DYNINT */
-#define IXGBE_RXD_STAT_LLINT    0x800   /* Pkt caused Low Latency Interrupt */
-#define IXGBE_RXD_STAT_TSIP     0x08000 /* Time Stamp in packet buffer */
-#define IXGBE_RXD_STAT_TS       0x10000 /* Time Stamp */
-#define IXGBE_RXD_STAT_SECP     0x20000 /* Security Processing */
-#define IXGBE_RXD_STAT_LB       0x40000 /* Loopback Status */
-#define IXGBE_RXD_STAT_ACK      0x8000  /* ACK Packet indication */
-#define IXGBE_RXD_ERR_CE        0x01    /* CRC Error */
-#define IXGBE_RXD_ERR_LE        0x02    /* Length Error */
-#define IXGBE_RXD_ERR_PE        0x08    /* Packet Error */
-#define IXGBE_RXD_ERR_OSE       0x10    /* Oversize Error */
-#define IXGBE_RXD_ERR_USE       0x20    /* Undersize Error */
-#define IXGBE_RXD_ERR_TCPE      0x40    /* TCP/UDP Checksum Error */
-#define IXGBE_RXD_ERR_IPE       0x80    /* IP Checksum Error */
-#define IXGBE_RXDADV_ERR_MASK           0xfff00000 /* RDESC.ERRORS mask */
-#define IXGBE_RXDADV_ERR_SHIFT          20         /* RDESC.ERRORS shift */
+#define IXGBE_RXD_STAT_DD	0x01 /* Descriptor Done */
+#define IXGBE_RXD_STAT_EOP	0x02 /* End of Packet */
+#define IXGBE_RXD_STAT_FLM	0x04 /* FDir Match */
+#define IXGBE_RXD_STAT_VP	0x08 /* IEEE VLAN Packet */
+#define IXGBE_RXDADV_NEXTP_MASK	0x000FFFF0 /* Next Descriptor Index */
+#define IXGBE_RXDADV_NEXTP_SHIFT	0x00000004
+#define IXGBE_RXD_STAT_UDPCS	0x10 /* UDP xsum calculated */
+#define IXGBE_RXD_STAT_L4CS	0x20 /* L4 xsum calculated */
+#define IXGBE_RXD_STAT_IPCS	0x40 /* IP xsum calculated */
+#define IXGBE_RXD_STAT_PIF	0x80 /* passed in-exact filter */
+#define IXGBE_RXD_STAT_CRCV	0x100 /* Speculative CRC Valid */
+#define IXGBE_RXD_STAT_OUTERIPCS	0x100 /* Cloud IP xsum calculated */
+#define IXGBE_RXD_STAT_VEXT	0x200 /* 1st VLAN found */
+#define IXGBE_RXD_STAT_UDPV	0x400 /* Valid UDP checksum */
+#define IXGBE_RXD_STAT_DYNINT	0x800 /* Pkt caused INT via DYNINT */
+#define IXGBE_RXD_STAT_LLINT	0x800 /* Pkt caused Low Latency Interrupt */
+#define IXGBE_RXD_STAT_TSIP	0x08000 /* Time Stamp in packet buffer */
+#define IXGBE_RXD_STAT_TS	0x10000 /* Time Stamp */
+#define IXGBE_RXD_STAT_SECP	0x20000 /* Security Processing */
+#define IXGBE_RXD_STAT_LB	0x40000 /* Loopback Status */
+#define IXGBE_RXD_STAT_ACK	0x8000 /* ACK Packet indication */
+#define IXGBE_RXD_ERR_CE	0x01 /* CRC Error */
+#define IXGBE_RXD_ERR_LE	0x02 /* Length Error */
+#define IXGBE_RXD_ERR_PE	0x08 /* Packet Error */
+#define IXGBE_RXD_ERR_OSE	0x10 /* Oversize Error */
+#define IXGBE_RXD_ERR_USE	0x20 /* Undersize Error */
+#define IXGBE_RXD_ERR_TCPE	0x40 /* TCP/UDP Checksum Error */
+#define IXGBE_RXD_ERR_IPE	0x80 /* IP Checksum Error */
+#define IXGBE_RXDADV_ERR_MASK		0xfff00000 /* RDESC.ERRORS mask */
+#define IXGBE_RXDADV_ERR_SHIFT		20 /* RDESC.ERRORS shift */
 #define IXGBE_RXDADV_ERR_OUTERIPER	0x04000000 /* CRC IP Header error */
-#define IXGBE_RXDADV_ERR_FCEOFE         0x80000000 /* FCoEFe/IPE */
-#define IXGBE_RXDADV_ERR_FCERR          0x00700000 /* FCERR/FDIRERR */
-#define IXGBE_RXDADV_ERR_FDIR_LEN       0x00100000 /* FDIR Length error */
-#define IXGBE_RXDADV_ERR_FDIR_DROP      0x00200000 /* FDIR Drop error */
-#define IXGBE_RXDADV_ERR_FDIR_COLL      0x00400000 /* FDIR Collision error */
-#define IXGBE_RXDADV_ERR_HBO    0x00800000 /*Header Buffer Overflow */
-#define IXGBE_RXDADV_ERR_CE     0x01000000 /* CRC Error */
-#define IXGBE_RXDADV_ERR_LE     0x02000000 /* Length Error */
-#define IXGBE_RXDADV_ERR_PE     0x08000000 /* Packet Error */
-#define IXGBE_RXDADV_ERR_OSE    0x10000000 /* Oversize Error */
-#define IXGBE_RXDADV_ERR_IPSEC_INV_PROTOCOL  0x08000000 /* overlap ERR_PE  */
-#define IXGBE_RXDADV_ERR_IPSEC_INV_LENGTH    0x10000000 /* overlap ERR_OSE */
-#define IXGBE_RXDADV_ERR_IPSEC_AUTH_FAILED   0x18000000
-#define IXGBE_RXDADV_ERR_USE    0x20000000 /* Undersize Error */
-#define IXGBE_RXDADV_ERR_TCPE   0x40000000 /* TCP/UDP Checksum Error */
-#define IXGBE_RXDADV_ERR_IPE    0x80000000 /* IP Checksum Error */
-#define IXGBE_RXD_VLAN_ID_MASK  0x0FFF  /* VLAN ID is in lower 12 bits */
-#define IXGBE_RXD_PRI_MASK      0xE000  /* Priority is in upper 3 bits */
-#define IXGBE_RXD_PRI_SHIFT     13
-#define IXGBE_RXD_CFI_MASK      0x1000  /* CFI is bit 12 */
-#define IXGBE_RXD_CFI_SHIFT     12
-
-#define IXGBE_RXDADV_STAT_DD            IXGBE_RXD_STAT_DD  /* Done */
-#define IXGBE_RXDADV_STAT_EOP           IXGBE_RXD_STAT_EOP /* End of Packet */
-#define IXGBE_RXDADV_STAT_FLM           IXGBE_RXD_STAT_FLM /* FDir Match */
-#define IXGBE_RXDADV_STAT_VP            IXGBE_RXD_STAT_VP  /* IEEE VLAN Pkt */
-#define IXGBE_RXDADV_STAT_MASK          0x000fffff /* Stat/NEXTP: bit 0-19 */
-#define IXGBE_RXDADV_STAT_FCEOFS        0x00000040 /* FCoE EOF/SOF Stat */
-#define IXGBE_RXDADV_STAT_FCSTAT        0x00000030 /* FCoE Pkt Stat */
-#define IXGBE_RXDADV_STAT_FCSTAT_NOMTCH 0x00000000 /* 00: No Ctxt Match */
-#define IXGBE_RXDADV_STAT_FCSTAT_NODDP  0x00000010 /* 01: Ctxt w/o DDP */
-#define IXGBE_RXDADV_STAT_FCSTAT_FCPRSP 0x00000020 /* 10: Recv. FCP_RSP */
-#define IXGBE_RXDADV_STAT_FCSTAT_DDP    0x00000030 /* 11: Ctxt w/ DDP */
-#define IXGBE_RXDADV_STAT_TS		0x00010000 /* IEEE 1588 Time Stamp */
-#define IXGBE_RXDADV_STAT_SECP		0x00020000 /* IPsec/MACsec pkt found */
+#define IXGBE_RXDADV_ERR_RXE		0x20000000 /* Any MAC Error */
+#define IXGBE_RXDADV_ERR_FCEOFE		0x80000000 /* FCEOFe/IPE */
+#define IXGBE_RXDADV_ERR_FCERR		0x00700000 /* FCERR/FDIRERR */
+#define IXGBE_RXDADV_ERR_FDIR_LEN	0x00100000 /* FDIR Length error */
+#define IXGBE_RXDADV_ERR_FDIR_DROP	0x00200000 /* FDIR Drop error */
+#define IXGBE_RXDADV_ERR_FDIR_COLL	0x00400000 /* FDIR Collision error */
+#define IXGBE_RXDADV_ERR_HBO	0x00800000 /*Header Buffer Overflow */
+#define IXGBE_RXDADV_ERR_CE	0x01000000 /* CRC Error */
+#define IXGBE_RXDADV_ERR_LE	0x02000000 /* Length Error */
+#define IXGBE_RXDADV_ERR_PE	0x08000000 /* Packet Error */
+#define IXGBE_RXDADV_ERR_OSE	0x10000000 /* Oversize Error */
+#define IXGBE_RXDADV_ERR_USE	0x20000000 /* Undersize Error */
+#define IXGBE_RXDADV_ERR_TCPE	0x40000000 /* TCP/UDP Checksum Error */
+#define IXGBE_RXDADV_ERR_IPE	0x80000000 /* IP Checksum Error */
+#define IXGBE_RXD_VLAN_ID_MASK	0x0FFF  /* VLAN ID is in lower 12 bits */
+#define IXGBE_RXD_PRI_MASK	0xE000  /* Priority is in upper 3 bits */
+#define IXGBE_RXD_PRI_SHIFT	13
+#define IXGBE_RXD_CFI_MASK	0x1000  /* CFI is bit 12 */
+#define IXGBE_RXD_CFI_SHIFT	12
+
+#define IXGBE_RXDADV_STAT_DD		IXGBE_RXD_STAT_DD  /* Done */
+#define IXGBE_RXDADV_STAT_EOP		IXGBE_RXD_STAT_EOP /* End of Packet */
+#define IXGBE_RXDADV_STAT_FLM		IXGBE_RXD_STAT_FLM /* FDir Match */
+#define IXGBE_RXDADV_STAT_VP		IXGBE_RXD_STAT_VP  /* IEEE VLAN Pkt */
+#define IXGBE_RXDADV_STAT_MASK		0x000fffff /* Stat/NEXTP: bit 0-19 */
+#define IXGBE_RXDADV_STAT_FCEOFS	0x00000040 /* FCoE EOF/SOF Stat */
+#define IXGBE_RXDADV_STAT_FCSTAT	0x00000030 /* FCoE Pkt Stat */
+#define IXGBE_RXDADV_STAT_FCSTAT_NOMTCH	0x00000000 /* 00: No Ctxt Match */
+#define IXGBE_RXDADV_STAT_FCSTAT_NODDP	0x00000010 /* 01: Ctxt w/o DDP */
+#define IXGBE_RXDADV_STAT_FCSTAT_FCPRSP	0x00000020 /* 10: Recv. FCP_RSP */
+#define IXGBE_RXDADV_STAT_FCSTAT_DDP	0x00000030 /* 11: Ctxt w/ DDP */
+#define IXGBE_RXDADV_STAT_TS		0x00010000 /* IEEE1588 Time Stamp */
+#define IXGBE_RXDADV_STAT_TSIP		0x00008000 /* Time Stamp in packet buffer */
 
 /* PSRTYPE bit definitions */
-#define IXGBE_PSRTYPE_TCPHDR    0x00000010
-#define IXGBE_PSRTYPE_UDPHDR    0x00000020
-#define IXGBE_PSRTYPE_IPV4HDR   0x00000100
-#define IXGBE_PSRTYPE_IPV6HDR   0x00000200
-#define IXGBE_PSRTYPE_L2HDR     0x00001000
+#define IXGBE_PSRTYPE_TCPHDR	0x00000010
+#define IXGBE_PSRTYPE_UDPHDR	0x00000020
+#define IXGBE_PSRTYPE_IPV4HDR	0x00000100
+#define IXGBE_PSRTYPE_IPV6HDR	0x00000200
+#define IXGBE_PSRTYPE_L2HDR	0x00001000
 
 /* SRRCTL bit definitions */
-#define IXGBE_SRRCTL_BSIZEPKT_SHIFT     10     /* so many KBs */
-#define IXGBE_SRRCTL_RDMTS_SHIFT        22
-#define IXGBE_SRRCTL_RDMTS_MASK         0x01C00000
-#define IXGBE_SRRCTL_DROP_EN            0x10000000
-#define IXGBE_SRRCTL_BSIZEPKT_MASK      0x0000007F
-#define IXGBE_SRRCTL_BSIZEHDR_MASK      0x00003F00
-#define IXGBE_SRRCTL_DESCTYPE_LEGACY    0x00000000
+#define IXGBE_SRRCTL_BSIZEPKT_SHIFT	10 /* so many KBs */
+#define IXGBE_SRRCTL_BSIZEHDRSIZE_SHIFT	2 /* 64byte resolution (>> 6)
+					   * + at bit 8 offset (<< 8)
+					   *  = (<< 2)
+					   */
+#define IXGBE_SRRCTL_RDMTS_SHIFT	22
+#define IXGBE_SRRCTL_RDMTS_MASK		0x01C00000
+#define IXGBE_SRRCTL_DROP_EN		0x10000000
+#define IXGBE_SRRCTL_BSIZEPKT_MASK	0x0000007F
+#define IXGBE_SRRCTL_BSIZEHDR_MASK	0x00003F00
+#define IXGBE_SRRCTL_DESCTYPE_LEGACY	0x00000000
 #define IXGBE_SRRCTL_DESCTYPE_ADV_ONEBUF 0x02000000
-#define IXGBE_SRRCTL_DESCTYPE_HDR_SPLIT  0x04000000
+#define IXGBE_SRRCTL_DESCTYPE_HDR_SPLIT	0x04000000
 #define IXGBE_SRRCTL_DESCTYPE_HDR_REPLICATION_LARGE_PKT 0x08000000
 #define IXGBE_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS 0x0A000000
-#define IXGBE_SRRCTL_DESCTYPE_MASK      0x0E000000
+#define IXGBE_SRRCTL_DESCTYPE_MASK	0x0E000000
 
-#define IXGBE_RXDPS_HDRSTAT_HDRSP       0x00008000
-#define IXGBE_RXDPS_HDRSTAT_HDRLEN_MASK 0x000003FF
+#define IXGBE_RXDPS_HDRSTAT_HDRSP	0x00008000
+#define IXGBE_RXDPS_HDRSTAT_HDRLEN_MASK	0x000003FF
 
-#define IXGBE_RXDADV_RSSTYPE_MASK       0x0000000F
-#define IXGBE_RXDADV_PKTTYPE_MASK       0x0000FFF0
-#define IXGBE_RXDADV_PKTTYPE_MASK_EX    0x0001FFF0
-#define IXGBE_RXDADV_HDRBUFLEN_MASK     0x00007FE0
-#define IXGBE_RXDADV_RSCCNT_MASK        0x001E0000
-#define IXGBE_RXDADV_RSCCNT_SHIFT       17
-#define IXGBE_RXDADV_HDRBUFLEN_SHIFT    5
-#define IXGBE_RXDADV_SPLITHEADER_EN     0x00001000
-#define IXGBE_RXDADV_SPH                0x8000
+#define IXGBE_RXDADV_RSSTYPE_MASK	0x0000000F
+#define IXGBE_RXDADV_PKTTYPE_MASK	0x0000FFF0
+#define IXGBE_RXDADV_PKTTYPE_MASK_EX	0x0001FFF0
+#define IXGBE_RXDADV_HDRBUFLEN_MASK	0x00007FE0
+#define IXGBE_RXDADV_RSCCNT_MASK	0x001E0000
+#define IXGBE_RXDADV_RSCCNT_SHIFT	17
+#define IXGBE_RXDADV_HDRBUFLEN_SHIFT	5
+#define IXGBE_RXDADV_SPLITHEADER_EN	0x00001000
+#define IXGBE_RXDADV_SPH		0x8000
 
 /* RSS Hash results */
-#define IXGBE_RXDADV_RSSTYPE_NONE       0x00000000
-#define IXGBE_RXDADV_RSSTYPE_IPV4_TCP   0x00000001
-#define IXGBE_RXDADV_RSSTYPE_IPV4       0x00000002
-#define IXGBE_RXDADV_RSSTYPE_IPV6_TCP   0x00000003
-#define IXGBE_RXDADV_RSSTYPE_IPV6_EX    0x00000004
-#define IXGBE_RXDADV_RSSTYPE_IPV6       0x00000005
+#define IXGBE_RXDADV_RSSTYPE_NONE	0x00000000
+#define IXGBE_RXDADV_RSSTYPE_IPV4_TCP	0x00000001
+#define IXGBE_RXDADV_RSSTYPE_IPV4	0x00000002
+#define IXGBE_RXDADV_RSSTYPE_IPV6_TCP	0x00000003
+#define IXGBE_RXDADV_RSSTYPE_IPV6_EX	0x00000004
+#define IXGBE_RXDADV_RSSTYPE_IPV6	0x00000005
 #define IXGBE_RXDADV_RSSTYPE_IPV6_TCP_EX 0x00000006
-#define IXGBE_RXDADV_RSSTYPE_IPV4_UDP   0x00000007
-#define IXGBE_RXDADV_RSSTYPE_IPV6_UDP   0x00000008
+#define IXGBE_RXDADV_RSSTYPE_IPV4_UDP	0x00000007
+#define IXGBE_RXDADV_RSSTYPE_IPV6_UDP	0x00000008
 #define IXGBE_RXDADV_RSSTYPE_IPV6_UDP_EX 0x00000009
 
 /* RSS Packet Types as indicated in the receive descriptor. */
-#define IXGBE_RXDADV_PKTTYPE_NONE       0x00000000
-#define IXGBE_RXDADV_PKTTYPE_IPV4       0x00000010 /* IPv4 hdr present */
-#define IXGBE_RXDADV_PKTTYPE_IPV4_EX    0x00000020 /* IPv4 hdr + extensions */
-#define IXGBE_RXDADV_PKTTYPE_IPV6       0x00000040 /* IPv6 hdr present */
-#define IXGBE_RXDADV_PKTTYPE_IPV6_EX    0x00000080 /* IPv6 hdr + extensions */
-#define IXGBE_RXDADV_PKTTYPE_TCP        0x00000100 /* TCP hdr present */
-#define IXGBE_RXDADV_PKTTYPE_UDP        0x00000200 /* UDP hdr present */
-#define IXGBE_RXDADV_PKTTYPE_SCTP       0x00000400 /* SCTP hdr present */
-#define IXGBE_RXDADV_PKTTYPE_NFS        0x00000800 /* NFS hdr present */
+#define IXGBE_RXDADV_PKTTYPE_NONE	0x00000000
+#define IXGBE_RXDADV_PKTTYPE_IPV4	0x00000010 /* IPv4 hdr present */
+#define IXGBE_RXDADV_PKTTYPE_IPV4_EX	0x00000020 /* IPv4 hdr + extensions */
+#define IXGBE_RXDADV_PKTTYPE_IPV6	0x00000040 /* IPv6 hdr present */
+#define IXGBE_RXDADV_PKTTYPE_IPV6_EX	0x00000080 /* IPv6 hdr + extensions */
+#define IXGBE_RXDADV_PKTTYPE_TCP	0x00000100 /* TCP hdr present */
+#define IXGBE_RXDADV_PKTTYPE_UDP	0x00000200 /* UDP hdr present */
+#define IXGBE_RXDADV_PKTTYPE_SCTP	0x00000400 /* SCTP hdr present */
+#define IXGBE_RXDADV_PKTTYPE_NFS	0x00000800 /* NFS hdr present */
+#define IXGBE_RXDADV_PKTTYPE_GENEVE	0x00000800 /* GENEVE hdr present */
 #define IXGBE_RXDADV_PKTTYPE_VXLAN	0x00000800 /* VXLAN hdr present */
 #define IXGBE_RXDADV_PKTTYPE_TUNNEL	0x00010000 /* Tunnel type */
-#define IXGBE_RXDADV_PKTTYPE_IPSEC_ESP  0x00001000 /* IPSec ESP */
-#define IXGBE_RXDADV_PKTTYPE_IPSEC_AH   0x00002000 /* IPSec AH */
-#define IXGBE_RXDADV_PKTTYPE_LINKSEC    0x00004000 /* LinkSec Encap */
-#define IXGBE_RXDADV_PKTTYPE_ETQF       0x00008000 /* PKTTYPE is ETQF index */
-#define IXGBE_RXDADV_PKTTYPE_ETQF_MASK  0x00000070 /* ETQF has 8 indices */
-#define IXGBE_RXDADV_PKTTYPE_ETQF_SHIFT 4          /* Right-shift 4 bits */
+#define IXGBE_RXDADV_PKTTYPE_IPSEC_ESP	0x00001000 /* IPSec ESP */
+#define IXGBE_RXDADV_PKTTYPE_IPSEC_AH	0x00002000 /* IPSec AH */
+#define IXGBE_RXDADV_PKTTYPE_LINKSEC	0x00004000 /* LinkSec Encap */
+#define IXGBE_RXDADV_PKTTYPE_ETQF	0x00008000 /* PKTTYPE is ETQF index */
+#define IXGBE_RXDADV_PKTTYPE_ETQF_MASK	0x00000070 /* ETQF has 8 indices */
+#define IXGBE_RXDADV_PKTTYPE_ETQF_SHIFT	4 /* Right-shift 4 bits */
+
+/* Security Processing bit Indication */
+#define IXGBE_RXDADV_LNKSEC_STATUS_SECP		0x00020000
+#define IXGBE_RXDADV_LNKSEC_ERROR_NO_SA_MATCH	0x08000000
+#define IXGBE_RXDADV_LNKSEC_ERROR_REPLAY_ERROR	0x10000000
+#define IXGBE_RXDADV_LNKSEC_ERROR_BIT_MASK	0x18000000
+#define IXGBE_RXDADV_LNKSEC_ERROR_BAD_SIG	0x18000000
 
 /* Masks to determine if packets should be dropped due to frame errors */
 #define IXGBE_RXD_ERR_FRAME_ERR_MASK ( \
-				      IXGBE_RXD_ERR_CE | \
-				      IXGBE_RXD_ERR_LE | \
-				      IXGBE_RXD_ERR_PE | \
-				      IXGBE_RXD_ERR_OSE | \
-				      IXGBE_RXD_ERR_USE)
+				IXGBE_RXD_ERR_CE | \
+				IXGBE_RXD_ERR_LE | \
+				IXGBE_RXD_ERR_PE | \
+				IXGBE_RXD_ERR_OSE | \
+				IXGBE_RXD_ERR_USE)
 
 #define IXGBE_RXDADV_ERR_FRAME_ERR_MASK ( \
-				      IXGBE_RXDADV_ERR_CE | \
-				      IXGBE_RXDADV_ERR_LE | \
-				      IXGBE_RXDADV_ERR_PE | \
-				      IXGBE_RXDADV_ERR_OSE | \
-				      IXGBE_RXDADV_ERR_IPSEC_INV_PROTOCOL | \
-				      IXGBE_RXDADV_ERR_IPSEC_INV_LENGTH | \
-				      IXGBE_RXDADV_ERR_USE)
+				IXGBE_RXDADV_ERR_CE | \
+				IXGBE_RXDADV_ERR_LE | \
+				IXGBE_RXDADV_ERR_PE | \
+				IXGBE_RXDADV_ERR_OSE | \
+				IXGBE_RXDADV_ERR_USE)
+
+#define IXGBE_RXDADV_ERR_FRAME_ERR_MASK_82599	IXGBE_RXDADV_ERR_RXE
 
 /* Multicast bit mask */
-#define IXGBE_MCSTCTRL_MFE      0x4
+#define IXGBE_MCSTCTRL_MFE	0x4
 
 /* Number of Transmit and Receive Descriptors must be a multiple of 8 */
-#define IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE  8
-#define IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE  8
-#define IXGBE_REQ_TX_BUFFER_GRANULARITY   1024
+#define IXGBE_REQ_TX_DESCRIPTOR_MULTIPLE	8
+#define IXGBE_REQ_RX_DESCRIPTOR_MULTIPLE	8
+#define IXGBE_REQ_TX_BUFFER_GRANULARITY		1024
 
 /* Vlan-specific macros */
-#define IXGBE_RX_DESC_SPECIAL_VLAN_MASK  0x0FFF /* VLAN ID in lower 12 bits */
-#define IXGBE_RX_DESC_SPECIAL_PRI_MASK   0xE000 /* Priority in upper 3 bits */
-#define IXGBE_RX_DESC_SPECIAL_PRI_SHIFT  0x000D /* Priority in upper 3 of 16 */
-#define IXGBE_TX_DESC_SPECIAL_PRI_SHIFT  IXGBE_RX_DESC_SPECIAL_PRI_SHIFT
-
-/* SR-IOV specific macros */
-#define IXGBE_MBVFICR_INDEX(vf_number)   (vf_number >> 4)
-#define IXGBE_MBVFICR(_i)		(0x00710 + ((_i) * 4))
-#define IXGBE_VFLRE(_i)		((((_i) & 1) ? 0x001C0 : 0x00600))
-#define IXGBE_VFLREC(_i)		(0x00700 + ((_i) * 4))
+#define IXGBE_RX_DESC_SPECIAL_VLAN_MASK	0x0FFF /* VLAN ID in lower 12 bits */
+#define IXGBE_RX_DESC_SPECIAL_PRI_MASK	0xE000 /* Priority in upper 3 bits */
+#define IXGBE_RX_DESC_SPECIAL_PRI_SHIFT	0x000D /* Priority in upper 3 of 16 */
+#define IXGBE_TX_DESC_SPECIAL_PRI_SHIFT	IXGBE_RX_DESC_SPECIAL_PRI_SHIFT
 /* Translated register #defines */
+#define IXGBE_PVFCTRL(P)	(0x00300 + (4 * (P)))
+#define IXGBE_PVFSTATUS(P)	(0x00008 + (0 * (P)))
+#define IXGBE_PVFLINKS(P)	(0x042A4 + (0 * (P)))
+#define IXGBE_PVFRTIMER(P)	(0x00048 + (0 * (P)))
+#define IXGBE_PVFMAILBOX(P)	(0x04C00 + (4 * (P)))
+#define IXGBE_PVFRXMEMWRAP(P)	(0x03190 + (0 * (P)))
+#define IXGBE_PVTEICR(P)	(0x00B00 + (4 * (P)))
+#define IXGBE_PVTEICS(P)	(0x00C00 + (4 * (P)))
+#define IXGBE_PVTEIMS(P)	(0x00D00 + (4 * (P)))
+#define IXGBE_PVTEIMC(P)	(0x00E00 + (4 * (P)))
+#define IXGBE_PVTEIAC(P)	(0x00F00 + (4 * (P)))
+#define IXGBE_PVTEIAM(P)	(0x04D00 + (4 * (P)))
+#define IXGBE_PVTEITR(P)	(((P) < 24) ? (0x00820 + ((P) * 4)) : \
+				 (0x012300 + (((P) - 24) * 4)))
+#define IXGBE_PVTIVAR(P)	(0x12500 + (4 * (P)))
+#define IXGBE_PVTIVAR_MISC(P)	(0x04E00 + (4 * (P)))
+#define IXGBE_PVTRSCINT(P)	(0x12000 + (4 * (P)))
+#define IXGBE_VFPBACL(P)	(0x110C8 + (4 * (P)))
+#define IXGBE_PVFRDBAL(P)	((P < 64) ? (0x01000 + (0x40 * (P))) \
+				 : (0x0D000 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFRDBAH(P)	((P < 64) ? (0x01004 + (0x40 * (P))) \
+				 : (0x0D004 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFRDLEN(P)	((P < 64) ? (0x01008 + (0x40 * (P))) \
+				 : (0x0D008 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFRDH(P)		((P < 64) ? (0x01010 + (0x40 * (P))) \
+				 : (0x0D010 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFRDT(P)		((P < 64) ? (0x01018 + (0x40 * (P))) \
+				 : (0x0D018 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFRXDCTL(P)	((P < 64) ? (0x01028 + (0x40 * (P))) \
+				 : (0x0D028 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFSRRCTL(P)	((P < 64) ? (0x01014 + (0x40 * (P))) \
+				 : (0x0D014 + (0x40 * ((P) - 64))))
+#define IXGBE_PVFPSRTYPE(P)	(0x0EA00 + (4 * (P)))
+#define IXGBE_PVFTDBAL(P)	(0x06000 + (0x40 * (P)))
+#define IXGBE_PVFTDBAH(P)	(0x06004 + (0x40 * (P)))
+#define IXGBE_PVFTDLEN(P)	(0x06008 + (0x40 * (P)))
 #define IXGBE_PVFTDH(P)		(0x06010 + (0x40 * (P)))
 #define IXGBE_PVFTDT(P)		(0x06018 + (0x40 * (P)))
 #define IXGBE_PVFTXDCTL(P)	(0x06028 + (0x40 * (P)))
 #define IXGBE_PVFTDWBAL(P)	(0x06038 + (0x40 * (P)))
 #define IXGBE_PVFTDWBAH(P)	(0x0603C + (0x40 * (P)))
+#define IXGBE_PVFDCA_RXCTRL(P)	(((P) < 64) ? (0x0100C + (0x40 * (P))) \
+				 : (0x0D00C + (0x40 * ((P) - 64))))
+#define IXGBE_PVFDCA_TXCTRL(P)	(0x0600C + (0x40 * (P)))
+#define IXGBE_PVFGPRC(x)	(0x0101C + (0x40 * (x)))
+#define IXGBE_PVFGPTC(x)	(0x08300 + (0x04 * (x)))
+#define IXGBE_PVFGORC_LSB(x)	(0x01020 + (0x40 * (x)))
+#define IXGBE_PVFGORC_MSB(x)	(0x0D020 + (0x40 * (x)))
+#define IXGBE_PVFGOTC_LSB(x)	(0x08400 + (0x08 * (x)))
+#define IXGBE_PVFGOTC_MSB(x)	(0x08404 + (0x08 * (x)))
+#define IXGBE_PVFMPRC(x)	(0x0D01C + (0x40 * (x)))
 
 #define IXGBE_PVFTDWBALn(q_per_pool, vf_number, vf_q_index) \
 		(IXGBE_PVFTDWBAL((q_per_pool)*(vf_number) + (vf_q_index)))
 #define IXGBE_PVFTDWBAHn(q_per_pool, vf_number, vf_q_index) \
 		(IXGBE_PVFTDWBAH((q_per_pool)*(vf_number) + (vf_q_index)))
 
-#define IXGBE_PVFTDHN(q_per_pool, vf_number, vf_q_index) \
+#define IXGBE_PVFTDHn(q_per_pool, vf_number, vf_q_index) \
 		(IXGBE_PVFTDH((q_per_pool)*(vf_number) + (vf_q_index)))
-#define IXGBE_PVFTDTN(q_per_pool, vf_number, vf_q_index) \
+#define IXGBE_PVFTDTn(q_per_pool, vf_number, vf_q_index) \
 		(IXGBE_PVFTDT((q_per_pool)*(vf_number) + (vf_q_index)))
 
+/* Little Endian defines */
+#ifndef __le16
+#define __le16  u16
+#endif
+#ifndef __le32
+#define __le32  u32
+#endif
+#ifndef __le64
+#define __le64  u64
+
+#endif
+#ifndef __be16
+/* Big Endian defines */
+#define __be16  u16
+#define __be32  u32
+#define __be64  u64
+
+#endif
 enum ixgbe_fdir_pballoc_type {
 	IXGBE_FDIR_PBALLOC_NONE = 0,
 	IXGBE_FDIR_PBALLOC_64K  = 1,
 	IXGBE_FDIR_PBALLOC_128K = 2,
 	IXGBE_FDIR_PBALLOC_256K = 3,
 };
-#define IXGBE_FDIR_PBALLOC_SIZE_SHIFT           16
 
 /* Flow Director register values */
-#define IXGBE_FDIRCTRL_PBALLOC_64K              0x00000001
-#define IXGBE_FDIRCTRL_PBALLOC_128K             0x00000002
-#define IXGBE_FDIRCTRL_PBALLOC_256K             0x00000003
-#define IXGBE_FDIRCTRL_INIT_DONE                0x00000008
-#define IXGBE_FDIRCTRL_PERFECT_MATCH            0x00000010
-#define IXGBE_FDIRCTRL_REPORT_STATUS            0x00000020
-#define IXGBE_FDIRCTRL_REPORT_STATUS_ALWAYS     0x00000080
-#define IXGBE_FDIRCTRL_DROP_Q_SHIFT             8
-#define IXGBE_FDIRCTRL_FLEX_SHIFT               16
+#define IXGBE_FDIRCTRL_PBALLOC_64K		0x00000001
+#define IXGBE_FDIRCTRL_PBALLOC_128K		0x00000002
+#define IXGBE_FDIRCTRL_PBALLOC_256K		0x00000003
+#define IXGBE_FDIRCTRL_INIT_DONE		0x00000008
+#define IXGBE_FDIRCTRL_PERFECT_MATCH		0x00000010
+#define IXGBE_FDIRCTRL_REPORT_STATUS		0x00000020
+#define IXGBE_FDIRCTRL_REPORT_STATUS_ALWAYS	0x00000080
+#define IXGBE_FDIRCTRL_DROP_Q_SHIFT		8
+#define IXGBE_FDIRCTRL_DROP_Q_MASK		0x00007F00
+#define IXGBE_FDIRCTRL_FLEX_SHIFT		16
 #define IXGBE_FDIRCTRL_DROP_NO_MATCH		0x00008000
 #define IXGBE_FDIRCTRL_FILTERMODE_SHIFT		21
 #define IXGBE_FDIRCTRL_FILTERMODE_MACVLAN	0x0001 /* bit 23:21, 001b */
 #define IXGBE_FDIRCTRL_FILTERMODE_CLOUD		0x0002 /* bit 23:21, 010b */
-#define IXGBE_FDIRCTRL_SEARCHLIM                0x00800000
-#define IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT         24
-#define IXGBE_FDIRCTRL_FULL_THRESH_MASK         0xF0000000
-#define IXGBE_FDIRCTRL_FULL_THRESH_SHIFT        28
-
-#define IXGBE_FDIRTCPM_DPORTM_SHIFT             16
-#define IXGBE_FDIRUDPM_DPORTM_SHIFT             16
-#define IXGBE_FDIRIP6M_DIPM_SHIFT               16
-#define IXGBE_FDIRM_VLANID                      0x00000001
-#define IXGBE_FDIRM_VLANP                       0x00000002
-#define IXGBE_FDIRM_POOL                        0x00000004
-#define IXGBE_FDIRM_L4P                         0x00000008
-#define IXGBE_FDIRM_FLEX                        0x00000010
-#define IXGBE_FDIRM_DIPv6                       0x00000020
-
-#define IXGBE_FDIRFREE_FREE_MASK                0xFFFF
-#define IXGBE_FDIRFREE_FREE_SHIFT               0
-#define IXGBE_FDIRFREE_COLL_MASK                0x7FFF0000
-#define IXGBE_FDIRFREE_COLL_SHIFT               16
-#define IXGBE_FDIRLEN_MAXLEN_MASK               0x3F
-#define IXGBE_FDIRLEN_MAXLEN_SHIFT              0
-#define IXGBE_FDIRLEN_MAXHASH_MASK              0x7FFF0000
-#define IXGBE_FDIRLEN_MAXHASH_SHIFT             16
-#define IXGBE_FDIRUSTAT_ADD_MASK                0xFFFF
-#define IXGBE_FDIRUSTAT_ADD_SHIFT               0
-#define IXGBE_FDIRUSTAT_REMOVE_MASK             0xFFFF0000
-#define IXGBE_FDIRUSTAT_REMOVE_SHIFT            16
-#define IXGBE_FDIRFSTAT_FADD_MASK               0x00FF
-#define IXGBE_FDIRFSTAT_FADD_SHIFT              0
-#define IXGBE_FDIRFSTAT_FREMOVE_MASK            0xFF00
-#define IXGBE_FDIRFSTAT_FREMOVE_SHIFT           8
-#define IXGBE_FDIRPORT_DESTINATION_SHIFT        16
-#define IXGBE_FDIRVLAN_FLEX_SHIFT               16
-#define IXGBE_FDIRHASH_BUCKET_VALID_SHIFT       15
-#define IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT       16
-
-#define IXGBE_FDIRCMD_CMD_MASK                  0x00000003
-#define IXGBE_FDIRCMD_CMD_ADD_FLOW              0x00000001
-#define IXGBE_FDIRCMD_CMD_REMOVE_FLOW           0x00000002
-#define IXGBE_FDIRCMD_CMD_QUERY_REM_FILT        0x00000003
-#define IXGBE_FDIRCMD_FILTER_VALID              0x00000004
-#define IXGBE_FDIRCMD_FILTER_UPDATE             0x00000008
-#define IXGBE_FDIRCMD_IPv6DMATCH                0x00000010
-#define IXGBE_FDIRCMD_L4TYPE_UDP                0x00000020
-#define IXGBE_FDIRCMD_L4TYPE_TCP                0x00000040
-#define IXGBE_FDIRCMD_L4TYPE_SCTP               0x00000060
-#define IXGBE_FDIRCMD_IPV6                      0x00000080
-#define IXGBE_FDIRCMD_CLEARHT                   0x00000100
-#define IXGBE_FDIRCMD_DROP                      0x00000200
-#define IXGBE_FDIRCMD_INT                       0x00000400
-#define IXGBE_FDIRCMD_LAST                      0x00000800
-#define IXGBE_FDIRCMD_COLLISION                 0x00001000
-#define IXGBE_FDIRCMD_QUEUE_EN                  0x00008000
-#define IXGBE_FDIRCMD_FLOW_TYPE_SHIFT           5
-#define IXGBE_FDIRCMD_RX_QUEUE_SHIFT            16
-#define IXGBE_FDIRCMD_RX_TUNNEL_FILTER_SHIFT	23
-#define IXGBE_FDIRCMD_VT_POOL_SHIFT             24
-#define IXGBE_FDIR_INIT_DONE_POLL               10
-#define IXGBE_FDIRCMD_CMD_POLL                  10
+#define IXGBE_FDIRCTRL_SEARCHLIM		0x00800000
+#define IXGBE_FDIRCTRL_FILTERMODE_MASK		0x00E00000
+#define IXGBE_FDIRCTRL_MAX_LENGTH_SHIFT		24
+#define IXGBE_FDIRCTRL_FULL_THRESH_MASK		0xF0000000
+#define IXGBE_FDIRCTRL_FULL_THRESH_SHIFT	28
+
+#define IXGBE_FDIRTCPM_DPORTM_SHIFT		16
+#define IXGBE_FDIRUDPM_DPORTM_SHIFT		16
+#define IXGBE_FDIRIP6M_DIPM_SHIFT		16
+#define IXGBE_FDIRM_VLANID			0x00000001
+#define IXGBE_FDIRM_VLANP			0x00000002
+#define IXGBE_FDIRM_POOL			0x00000004
+#define IXGBE_FDIRM_L4P				0x00000008
+#define IXGBE_FDIRM_FLEX			0x00000010
+#define IXGBE_FDIRM_DIPv6			0x00000020
+#define IXGBE_FDIRM_L3P				0x00000040
+
+#define IXGBE_FDIRIP6M_INNER_MAC	0x03F0 /* bit 9:4 */
+#define IXGBE_FDIRIP6M_TUNNEL_TYPE	0x0800 /* bit 11 */
+#define IXGBE_FDIRIP6M_TNI_VNI		0xF000 /* bit 15:12 */
+#define IXGBE_FDIRIP6M_TNI_VNI_24	0x1000 /* bit 12 */
+#define IXGBE_FDIRIP6M_ALWAYS_MASK	0x040F /* bit 10, 3:0 */
+
+#define IXGBE_FDIRFREE_FREE_MASK		0xFFFF
+#define IXGBE_FDIRFREE_FREE_SHIFT		0
+#define IXGBE_FDIRFREE_COLL_MASK		0x7FFF0000
+#define IXGBE_FDIRFREE_COLL_SHIFT		16
+#define IXGBE_FDIRLEN_MAXLEN_MASK		0x3F
+#define IXGBE_FDIRLEN_MAXLEN_SHIFT		0
+#define IXGBE_FDIRLEN_MAXHASH_MASK		0x7FFF0000
+#define IXGBE_FDIRLEN_MAXHASH_SHIFT		16
+#define IXGBE_FDIRUSTAT_ADD_MASK		0xFFFF
+#define IXGBE_FDIRUSTAT_ADD_SHIFT		0
+#define IXGBE_FDIRUSTAT_REMOVE_MASK		0xFFFF0000
+#define IXGBE_FDIRUSTAT_REMOVE_SHIFT		16
+#define IXGBE_FDIRFSTAT_FADD_MASK		0x00FF
+#define IXGBE_FDIRFSTAT_FADD_SHIFT		0
+#define IXGBE_FDIRFSTAT_FREMOVE_MASK		0xFF00
+#define IXGBE_FDIRFSTAT_FREMOVE_SHIFT		8
+#define IXGBE_FDIRPORT_DESTINATION_SHIFT	16
+#define IXGBE_FDIRVLAN_FLEX_SHIFT		16
+#define IXGBE_FDIRHASH_BUCKET_VALID_SHIFT	15
+#define IXGBE_FDIRHASH_SIG_SW_INDEX_SHIFT	16
+
+#define IXGBE_FDIRCMD_CMD_MASK			0x00000003
+#define IXGBE_FDIRCMD_CMD_ADD_FLOW		0x00000001
+#define IXGBE_FDIRCMD_CMD_REMOVE_FLOW		0x00000002
+#define IXGBE_FDIRCMD_CMD_QUERY_REM_FILT	0x00000003
+#define IXGBE_FDIRCMD_FILTER_VALID		0x00000004
+#define IXGBE_FDIRCMD_FILTER_UPDATE		0x00000008
+#define IXGBE_FDIRCMD_IPv6DMATCH		0x00000010
+#define IXGBE_FDIRCMD_L4TYPE_UDP		0x00000020
+#define IXGBE_FDIRCMD_L4TYPE_TCP		0x00000040
+#define IXGBE_FDIRCMD_L4TYPE_SCTP		0x00000060
+#define IXGBE_FDIRCMD_IPV6			0x00000080
+#define IXGBE_FDIRCMD_CLEARHT			0x00000100
+#define IXGBE_FDIRCMD_DROP			0x00000200
+#define IXGBE_FDIRCMD_INT			0x00000400
+#define IXGBE_FDIRCMD_LAST			0x00000800
+#define IXGBE_FDIRCMD_COLLISION			0x00001000
+#define IXGBE_FDIRCMD_QUEUE_EN			0x00008000
+#define IXGBE_FDIRCMD_FLOW_TYPE_SHIFT		5
+#define IXGBE_FDIRCMD_RX_QUEUE_SHIFT		16
+#define IXGBE_FDIRCMD_TUNNEL_FILTER_SHIFT	23
+#define IXGBE_FDIRCMD_VT_POOL_SHIFT		24
+#define IXGBE_FDIR_INIT_DONE_POLL		10
+#define IXGBE_FDIRCMD_CMD_POLL			10
 #define IXGBE_FDIRCMD_TUNNEL_FILTER		0x00800000
-
-#define IXGBE_FDIR_DROP_QUEUE                   127
+#define IXGBE_FDIR_DROP_QUEUE			127
 
 /* Manageablility Host Interface defines */
 #define IXGBE_HI_MAX_BLOCK_BYTE_LENGTH	1792 /* Num of bytes in range */
@@ -2635,12 +3041,13 @@ enum ixgbe_fdir_pballoc_type {
 #define IXGBE_HI_FLASH_ERASE_TIMEOUT	1000 /* Process Erase command limit */
 #define IXGBE_HI_FLASH_UPDATE_TIMEOUT	5000 /* Process Update command limit */
 #define IXGBE_HI_FLASH_APPLY_TIMEOUT	0 /* Process Apply command limit */
+#define IXGBE_HI_PHY_MGMT_REQ_TIMEOUT	2000 /* Wait up to 2 seconds */
 
 /* CEM Support */
 #define FW_CEM_HDR_LEN			0x4
 #define FW_CEM_CMD_DRIVER_INFO		0xDD
 #define FW_CEM_CMD_DRIVER_INFO_LEN	0x5
-#define FW_CEM_CMD_RESERVED		0x0
+#define FW_CEM_CMD_RESERVED		0X0
 #define FW_CEM_UNUSED_VER		0x0
 #define FW_CEM_MAX_RETRIES		3
 #define FW_CEM_RESP_STATUS_SUCCESS	0x1
@@ -2657,7 +3064,7 @@ enum ixgbe_fdir_pballoc_type {
 #define FW_DISABLE_RXEN_CMD		0xDE
 #define FW_DISABLE_RXEN_LEN		0x1
 #define FW_PHY_MGMT_REQ_CMD		0x20
-#define FW_PHY_TOKEN_REQ_CMD		0x0A
+#define FW_PHY_TOKEN_REQ_CMD		0xA
 #define FW_PHY_TOKEN_REQ_LEN		2
 #define FW_PHY_TOKEN_REQ		0
 #define FW_PHY_TOKEN_REL		1
@@ -2675,56 +3082,59 @@ enum ixgbe_fdir_pballoc_type {
 #define FW_PHY_ACT_REQ_LEN		(4 + 4 * FW_PHY_ACT_DATA_COUNT)
 #define FW_PHY_ACT_INIT_PHY		1
 #define FW_PHY_ACT_SETUP_LINK		2
-#define FW_PHY_ACT_LINK_SPEED_10	BIT(0)
-#define FW_PHY_ACT_LINK_SPEED_100	BIT(1)
-#define FW_PHY_ACT_LINK_SPEED_1G	BIT(2)
-#define FW_PHY_ACT_LINK_SPEED_2_5G	BIT(3)
-#define FW_PHY_ACT_LINK_SPEED_5G	BIT(4)
-#define FW_PHY_ACT_LINK_SPEED_10G	BIT(5)
-#define FW_PHY_ACT_LINK_SPEED_20G	BIT(6)
-#define FW_PHY_ACT_LINK_SPEED_25G	BIT(7)
-#define FW_PHY_ACT_LINK_SPEED_40G	BIT(8)
-#define FW_PHY_ACT_LINK_SPEED_50G	BIT(9)
-#define FW_PHY_ACT_LINK_SPEED_100G	BIT(10)
+#define FW_PHY_ACT_LINK_SPEED_10	(1u << 0)
+#define FW_PHY_ACT_LINK_SPEED_100	(1u << 1)
+#define FW_PHY_ACT_LINK_SPEED_1G	(1u << 2)
+#define FW_PHY_ACT_LINK_SPEED_2_5G	(1u << 3)
+#define FW_PHY_ACT_LINK_SPEED_5G	(1u << 4)
+#define FW_PHY_ACT_LINK_SPEED_10G	(1u << 5)
+#define FW_PHY_ACT_LINK_SPEED_20G	(1u << 6)
+#define FW_PHY_ACT_LINK_SPEED_25G	(1u << 7)
+#define FW_PHY_ACT_LINK_SPEED_40G	(1u << 8)
+#define FW_PHY_ACT_LINK_SPEED_50G	(1u << 9)
+#define FW_PHY_ACT_LINK_SPEED_100G	(1u << 10)
 #define FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT 16
-#define FW_PHY_ACT_SETUP_LINK_PAUSE_MASK (3 << \
-					  HW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT)
+#define FW_PHY_ACT_SETUP_LINK_PAUSE_MASK (3u << \
+					  FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT)
 #define FW_PHY_ACT_SETUP_LINK_PAUSE_NONE 0u
 #define FW_PHY_ACT_SETUP_LINK_PAUSE_TX	1u
 #define FW_PHY_ACT_SETUP_LINK_PAUSE_RX	2u
 #define FW_PHY_ACT_SETUP_LINK_PAUSE_RXTX 3u
-#define FW_PHY_ACT_SETUP_LINK_LP	BIT(18)
-#define FW_PHY_ACT_SETUP_LINK_HP	BIT(19)
-#define FW_PHY_ACT_SETUP_LINK_EEE	BIT(20)
-#define FW_PHY_ACT_SETUP_LINK_AN	BIT(22)
-#define FW_PHY_ACT_SETUP_LINK_RSP_DOWN	BIT(0)
+#define FW_PHY_ACT_SETUP_LINK_LP	(1u << 18)
+#define FW_PHY_ACT_SETUP_LINK_HP	(1u << 19)
+#define FW_PHY_ACT_SETUP_LINK_EEE	(1u << 20)
+#define FW_PHY_ACT_SETUP_LINK_AN	(1u << 22)
+#define FW_PHY_ACT_SETUP_LINK_RSP_DOWN	(1u << 0)
 #define FW_PHY_ACT_GET_LINK_INFO	3
-#define FW_PHY_ACT_GET_LINK_INFO_EEE	BIT(19)
-#define FW_PHY_ACT_GET_LINK_INFO_FC_TX	BIT(20)
-#define FW_PHY_ACT_GET_LINK_INFO_FC_RX	BIT(21)
-#define FW_PHY_ACT_GET_LINK_INFO_POWER	BIT(22)
-#define FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE	BIT(24)
-#define FW_PHY_ACT_GET_LINK_INFO_TEMP	BIT(25)
-#define FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX	BIT(28)
-#define FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX	BIT(29)
+#define FW_PHY_ACT_GET_LINK_INFO_EEE	(1u << 19)
+#define FW_PHY_ACT_GET_LINK_INFO_FC_TX	(1u << 20)
+#define FW_PHY_ACT_GET_LINK_INFO_FC_RX	(1u << 21)
+#define FW_PHY_ACT_GET_LINK_INFO_POWER	(1u << 22)
+#define FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE	(1u << 24)
+#define FW_PHY_ACT_GET_LINK_INFO_TEMP	(1u << 25)
+#define FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX	(1u << 28)
+#define FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX	(1u << 29)
 #define FW_PHY_ACT_FORCE_LINK_DOWN	4
-#define FW_PHY_ACT_FORCE_LINK_DOWN_OFF	BIT(0)
+#define FW_PHY_ACT_FORCE_LINK_DOWN_OFF	(1u << 0)
 #define FW_PHY_ACT_PHY_SW_RESET		5
 #define FW_PHY_ACT_PHY_HW_RESET		6
 #define FW_PHY_ACT_GET_PHY_INFO		7
 #define FW_PHY_ACT_UD_2			0x1002
-#define FW_PHY_ACT_UD_2_10G_KR_EEE	BIT(6)
-#define FW_PHY_ACT_UD_2_10G_KX4_EEE	BIT(5)
-#define FW_PHY_ACT_UD_2_1G_KX_EEE	BIT(4)
-#define FW_PHY_ACT_UD_2_10G_T_EEE	BIT(3)
-#define FW_PHY_ACT_UD_2_1G_T_EEE	BIT(2)
-#define FW_PHY_ACT_UD_2_100M_TX_EEE	BIT(1)
+#define FW_PHY_ACT_UD_2_10G_KR_EEE	(1u << 6)
+#define FW_PHY_ACT_UD_2_10G_KX4_EEE	(1u << 5)
+#define FW_PHY_ACT_UD_2_1G_KX_EEE	(1u << 4)
+#define FW_PHY_ACT_UD_2_10G_T_EEE	(1u << 3)
+#define FW_PHY_ACT_UD_2_1G_T_EEE	(1u << 2)
+#define FW_PHY_ACT_UD_2_100M_TX_EEE	(1u << 1)
 #define FW_PHY_ACT_RETRIES		50
 #define FW_PHY_INFO_SPEED_MASK		0xFFFu
 #define FW_PHY_INFO_ID_HI_MASK		0xFFFF0000u
 #define FW_PHY_INFO_ID_LO_MASK		0x0000FFFFu
 
 /* Host Interface Command Structures */
+
+#pragma pack(push, 1)
+
 struct ixgbe_hic_hdr {
 	u8 cmd;
 	u8 buf_len;
@@ -2745,7 +3155,7 @@ struct ixgbe_hic_hdr2_req {
 struct ixgbe_hic_hdr2_rsp {
 	u8 cmd;
 	u8 buf_lenl;
-	u8 buf_lenh_status;     /* 7-5: high bits of buf_len, 4-0: status */
+	u8 buf_lenh_status;	/* 7-5: high bits of buf_len, 4-0: status */
 	u8 checksum;
 };
 
@@ -2787,8 +3197,8 @@ struct ixgbe_hic_read_shadow_ram {
 
 struct ixgbe_hic_write_shadow_ram {
 	union ixgbe_hic_hdr2 hdr;
-	__be32 address;
-	__be16 length;
+	u32 address;
+	u16 length;
 	u16 pad2;
 	u16 data;
 	u16 pad3;
@@ -2816,7 +3226,7 @@ struct ixgbe_hic_internal_phy_req {
 	u16 rsv1;
 	__be32 write_data;
 	u16 pad;
-} __packed;
+};
 
 struct ixgbe_hic_internal_phy_resp {
 	struct ixgbe_hic_hdr hdr;
@@ -2836,20 +3246,53 @@ struct ixgbe_hic_phy_activity_resp {
 	__be32 data[FW_PHY_ACT_DATA_COUNT];
 };
 
+#pragma pack(pop)
+
+/* Transmit Descriptor - Legacy */
+struct ixgbe_legacy_tx_desc {
+	u64 buffer_addr; /* Address of the descriptor's data buffer */
+	union {
+		__le32 data;
+		struct {
+			__le16 length; /* Data buffer length */
+			u8 cso; /* Checksum offset */
+			u8 cmd; /* Descriptor control */
+		} flags;
+	} lower;
+	union {
+		__le32 data;
+		struct {
+			u8 status; /* Descriptor status */
+			u8 css; /* Checksum start */
+			__le16 vlan;
+		} fields;
+	} upper;
+};
+
 /* Transmit Descriptor - Advanced */
 union ixgbe_adv_tx_desc {
 	struct {
-		__le64 buffer_addr;      /* Address of descriptor's data buf */
+		__le64 buffer_addr; /* Address of descriptor's data buf */
 		__le32 cmd_type_len;
 		__le32 olinfo_status;
 	} read;
 	struct {
-		__le64 rsvd;       /* Reserved */
+		__le64 rsvd; /* Reserved */
 		__le32 nxtseq_seed;
 		__le32 status;
 	} wb;
 };
 
+/* Receive Descriptor - Legacy */
+struct ixgbe_legacy_rx_desc {
+	__le64 buffer_addr; /* Address of the descriptor's data buffer */
+	__le16 length; /* Length of data DMAed into data buffer */
+	__le16 csum; /* Packet checksum */
+	u8 status;   /* Descriptor status */
+	u8 errors;   /* Descriptor Errors */
+	__le16 vlan;
+};
+
 /* Receive Descriptor - Advanced */
 union ixgbe_adv_rx_desc {
 	struct {
@@ -2884,68 +3327,76 @@ union ixgbe_adv_rx_desc {
 /* Context descriptors */
 struct ixgbe_adv_tx_context_desc {
 	__le32 vlan_macip_lens;
-	__le32 fceof_saidx;
+	__le32 seqnum_seed;
 	__le32 type_tucmd_mlhl;
 	__le32 mss_l4len_idx;
 };
 
 /* Adv Transmit Descriptor Config Masks */
-#define IXGBE_ADVTXD_DTALEN_MASK      0x0000FFFF /* Data buf length(bytes) */
-#define IXGBE_ADVTXD_MAC_LINKSEC      0x00040000 /* Insert LinkSec */
-#define IXGBE_ADVTXD_MAC_TSTAMP	      0x00080000 /* IEEE 1588 Time Stamp */
-#define IXGBE_ADVTXD_IPSEC_SA_INDEX_MASK   0x000003FF /* IPSec SA index */
-#define IXGBE_ADVTXD_IPSEC_ESP_LEN_MASK    0x000001FF /* IPSec ESP length */
-#define IXGBE_ADVTXD_DTYP_MASK  0x00F00000 /* DTYP mask */
-#define IXGBE_ADVTXD_DTYP_CTXT  0x00200000 /* Advanced Context Desc */
-#define IXGBE_ADVTXD_DTYP_DATA  0x00300000 /* Advanced Data Descriptor */
-#define IXGBE_ADVTXD_DCMD_EOP   IXGBE_TXD_CMD_EOP  /* End of Packet */
-#define IXGBE_ADVTXD_DCMD_IFCS  IXGBE_TXD_CMD_IFCS /* Insert FCS */
-#define IXGBE_ADVTXD_DCMD_RS    IXGBE_TXD_CMD_RS   /* Report Status */
-#define IXGBE_ADVTXD_DCMD_DDTYP_ISCSI 0x10000000    /* DDP hdr type or iSCSI */
-#define IXGBE_ADVTXD_DCMD_DEXT  IXGBE_TXD_CMD_DEXT /* Desc ext (1=Adv) */
-#define IXGBE_ADVTXD_DCMD_VLE   IXGBE_TXD_CMD_VLE  /* VLAN pkt enable */
-#define IXGBE_ADVTXD_DCMD_TSE   0x80000000 /* TCP Seg enable */
-#define IXGBE_ADVTXD_STAT_DD    IXGBE_TXD_STAT_DD  /* Descriptor Done */
-#define IXGBE_ADVTXD_STAT_SN_CRC      0x00000002 /* NXTSEQ/SEED pres in WB */
-#define IXGBE_ADVTXD_STAT_RSV   0x0000000C /* STA Reserved */
-#define IXGBE_ADVTXD_IDX_SHIFT  4 /* Adv desc Index shift */
-#define IXGBE_ADVTXD_CC         0x00000080 /* Check Context */
-#define IXGBE_ADVTXD_POPTS_SHIFT      8  /* Adv desc POPTS shift */
-#define IXGBE_ADVTXD_POPTS_IXSM (IXGBE_TXD_POPTS_IXSM << \
-				 IXGBE_ADVTXD_POPTS_SHIFT)
-#define IXGBE_ADVTXD_POPTS_TXSM (IXGBE_TXD_POPTS_TXSM << \
-				 IXGBE_ADVTXD_POPTS_SHIFT)
-#define IXGBE_ADVTXD_POPTS_IPSEC     0x00000400 /* IPSec offload request */
-#define IXGBE_ADVTXD_POPTS_ISCO_1ST  0x00000000 /* 1st TSO of iSCSI PDU */
-#define IXGBE_ADVTXD_POPTS_ISCO_MDL  0x00000800 /* Middle TSO of iSCSI PDU */
-#define IXGBE_ADVTXD_POPTS_ISCO_LAST 0x00001000 /* Last TSO of iSCSI PDU */
-#define IXGBE_ADVTXD_POPTS_ISCO_FULL 0x00001800 /* 1st&Last TSO-full iSCSI PDU */
-#define IXGBE_ADVTXD_POPTS_RSV       0x00002000 /* POPTS Reserved */
-#define IXGBE_ADVTXD_PAYLEN_SHIFT    14 /* Adv desc PAYLEN shift */
-#define IXGBE_ADVTXD_MACLEN_SHIFT    9  /* Adv ctxt desc mac len shift */
-#define IXGBE_ADVTXD_VLAN_SHIFT      16  /* Adv ctxt vlan tag shift */
-#define IXGBE_ADVTXD_TUCMD_IPV4      0x00000400  /* IP Packet Type: 1=IPv4 */
-#define IXGBE_ADVTXD_TUCMD_IPV6      0x00000000  /* IP Packet Type: 0=IPv6 */
-#define IXGBE_ADVTXD_TUCMD_L4T_UDP   0x00000000  /* L4 Packet TYPE of UDP */
-#define IXGBE_ADVTXD_TUCMD_L4T_TCP   0x00000800  /* L4 Packet TYPE of TCP */
-#define IXGBE_ADVTXD_TUCMD_L4T_SCTP  0x00001000  /* L4 Packet TYPE of SCTP */
-#define IXGBE_ADVTXD_TUCMD_L4T_RSV     0x00001800 /* RSV L4 Packet TYPE */
-#define IXGBE_ADVTXD_TUCMD_MKRREQ    0x00002000 /*Req requires Markers and CRC*/
+#define IXGBE_ADVTXD_DTALEN_MASK	0x0000FFFF /* Data buf length(bytes) */
+#define IXGBE_ADVTXD_MAC_LINKSEC	0x00040000 /* Insert LinkSec */
+#define IXGBE_ADVTXD_MAC_TSTAMP		0x00080000 /* IEEE1588 time stamp */
+#define IXGBE_ADVTXD_IPSEC_SA_INDEX_MASK 0x000003FF /* IPSec SA index */
+#define IXGBE_ADVTXD_IPSEC_ESP_LEN_MASK	0x000001FF /* IPSec ESP length */
+#define IXGBE_ADVTXD_DTYP_MASK		0x00F00000 /* DTYP mask */
+#define IXGBE_ADVTXD_DTYP_CTXT		0x00200000 /* Adv Context Desc */
+#define IXGBE_ADVTXD_DTYP_DATA		0x00300000 /* Adv Data Descriptor */
+#define IXGBE_ADVTXD_DCMD_EOP		IXGBE_TXD_CMD_EOP  /* End of Packet */
+#define IXGBE_ADVTXD_DCMD_IFCS		IXGBE_TXD_CMD_IFCS /* Insert FCS */
+#define IXGBE_ADVTXD_DCMD_RS		IXGBE_TXD_CMD_RS /* Report Status */
+#define IXGBE_ADVTXD_DCMD_DDTYP_ISCSI	0x10000000 /* DDP hdr type or iSCSI */
+#define IXGBE_ADVTXD_DCMD_DEXT		IXGBE_TXD_CMD_DEXT /* Desc ext 1=Adv */
+#define IXGBE_ADVTXD_DCMD_VLE		IXGBE_TXD_CMD_VLE  /* VLAN pkt enable */
+#define IXGBE_ADVTXD_DCMD_TSE		0x80000000 /* TCP Seg enable */
+#define IXGBE_ADVTXD_STAT_DD		IXGBE_TXD_STAT_DD  /* Descriptor Done */
+#define IXGBE_ADVTXD_STAT_SN_CRC	0x00000002 /* NXTSEQ/SEED pres in WB */
+#define IXGBE_ADVTXD_STAT_RSV		0x0000000C /* STA Reserved */
+#define IXGBE_ADVTXD_IDX_SHIFT		4 /* Adv desc Index shift */
+#define IXGBE_ADVTXD_CC			0x00000080 /* Check Context */
+#define IXGBE_ADVTXD_POPTS_SHIFT	8  /* Adv desc POPTS shift */
+#define IXGBE_ADVTXD_POPTS_IXSM		(IXGBE_TXD_POPTS_IXSM << \
+					 IXGBE_ADVTXD_POPTS_SHIFT)
+#define IXGBE_ADVTXD_POPTS_TXSM		(IXGBE_TXD_POPTS_TXSM << \
+					 IXGBE_ADVTXD_POPTS_SHIFT)
+#define IXGBE_ADVTXD_POPTS_ISCO_1ST	0x00000000 /* 1st TSO of iSCSI PDU */
+#define IXGBE_ADVTXD_POPTS_ISCO_MDL	0x00000800 /* Middle TSO of iSCSI PDU */
+#define IXGBE_ADVTXD_POPTS_ISCO_LAST	0x00001000 /* Last TSO of iSCSI PDU */
+/* 1st&Last TSO-full iSCSI PDU */
+#define IXGBE_ADVTXD_POPTS_ISCO_FULL	0x00001800
+#define IXGBE_ADVTXD_POPTS_RSV		0x00002000 /* POPTS Reserved */
+#define IXGBE_ADVTXD_PAYLEN_SHIFT	14 /* Adv desc PAYLEN shift */
+#define IXGBE_ADVTXD_MACLEN_SHIFT	9  /* Adv ctxt desc mac len shift */
+#define IXGBE_ADVTXD_VLAN_SHIFT		16  /* Adv ctxt vlan tag shift */
+#define IXGBE_ADVTXD_TUCMD_IPV4		0x00000400 /* IP Packet Type: 1=IPv4 */
+#define IXGBE_ADVTXD_TUCMD_IPV6		0x00000000 /* IP Packet Type: 0=IPv6 */
+#define IXGBE_ADVTXD_TUCMD_L4T_UDP	0x00000000 /* L4 Packet TYPE of UDP */
+#define IXGBE_ADVTXD_TUCMD_L4T_TCP	0x00000800 /* L4 Packet TYPE of TCP */
+#define IXGBE_ADVTXD_TUCMD_L4T_SCTP	0x00001000 /* L4 Packet TYPE of SCTP */
+#define IXGBE_ADVTXD_TUCMD_L4T_RSV	0x00001800 /* RSV L4 Packet TYPE */
+#define IXGBE_ADVTXD_TUCMD_MKRREQ	0x00002000 /* req Markers and CRC */
+#define IXGBE_ADVTXD_POPTS_IPSEC	0x00000400 /* IPSec offload request */
 #define IXGBE_ADVTXD_TUCMD_IPSEC_TYPE_ESP 0x00002000 /* IPSec Type ESP */
 #define IXGBE_ADVTXD_TUCMD_IPSEC_ENCRYPT_EN 0x00004000/* ESP Encrypt Enable */
-#define IXGBE_ADVTXT_TUCMD_FCOE      0x00008000       /* FCoE Frame Type */
-#define IXGBE_ADVTXD_FCOEF_SOF       (BIT(2) << 10) /* FC SOF index */
-#define IXGBE_ADVTXD_FCOEF_PARINC    (BIT(3) << 10) /* Rel_Off in F_CTL */
-#define IXGBE_ADVTXD_FCOEF_ORIE      (BIT(4) << 10) /* Orientation: End */
-#define IXGBE_ADVTXD_FCOEF_ORIS      (BIT(5) << 10) /* Orientation: Start */
-#define IXGBE_ADVTXD_FCOEF_EOF_N     (0u << 10)  /* 00: EOFn */
-#define IXGBE_ADVTXD_FCOEF_EOF_T     (1u << 10)  /* 01: EOFt */
-#define IXGBE_ADVTXD_FCOEF_EOF_NI    (2u << 10)  /* 10: EOFni */
-#define IXGBE_ADVTXD_FCOEF_EOF_A     (3u << 10)  /* 11: EOFa */
-#define IXGBE_ADVTXD_FCOEF_EOF_MASK  (3u << 10)  /* FC EOF index */
-#define IXGBE_ADVTXD_L4LEN_SHIFT     8  /* Adv ctxt L4LEN shift */
-#define IXGBE_ADVTXD_MSS_SHIFT       16  /* Adv ctxt MSS shift */
-
+#define IXGBE_ADVTXT_TUCMD_FCOE		0x00008000 /* FCoE Frame Type */
+#define IXGBE_ADVTXD_FCOEF_EOF_MASK	(0x3 << 10) /* FC EOF index */
+#define IXGBE_ADVTXD_FCOEF_SOF		((1 << 2) << 10) /* FC SOF index */
+#define IXGBE_ADVTXD_FCOEF_PARINC	((1 << 3) << 10) /* Rel_Off in F_CTL */
+#define IXGBE_ADVTXD_FCOEF_ORIE		((1 << 4) << 10) /* Orientation End */
+#define IXGBE_ADVTXD_FCOEF_ORIS		((1 << 5) << 10) /* Orientation Start */
+#define IXGBE_ADVTXD_FCOEF_EOF_N	(0x0 << 10) /* 00: EOFn */
+#define IXGBE_ADVTXD_FCOEF_EOF_T	(0x1 << 10) /* 01: EOFt */
+#define IXGBE_ADVTXD_FCOEF_EOF_NI	(0x2 << 10) /* 10: EOFni */
+#define IXGBE_ADVTXD_FCOEF_EOF_A	(0x3 << 10) /* 11: EOFa */
+#define IXGBE_ADVTXD_L4LEN_SHIFT	8  /* Adv ctxt L4LEN shift */
+#define IXGBE_ADVTXD_MSS_SHIFT		16  /* Adv ctxt MSS shift */
+
+#define IXGBE_ADVTXD_OUTER_IPLEN	16 /* Adv ctxt OUTERIPLEN shift */
+#define IXGBE_ADVTXD_TUNNEL_LEN 	24 /* Adv ctxt TUNNELLEN shift */
+#define IXGBE_ADVTXD_TUNNEL_TYPE_SHIFT	16 /* Adv Tx Desc Tunnel Type shift */
+#define IXGBE_ADVTXD_OUTERIPCS_SHIFT	17 /* Adv Tx Desc OUTERIPCS Shift */
+#define IXGBE_ADVTXD_TUNNEL_TYPE_NVGRE	1  /* Adv Tx Desc Tunnel Type NVGRE */
+/* Adv Tx Desc OUTERIPCS Shift for X550EM_a */
+#define IXGBE_ADVTXD_OUTERIPCS_SHIFT_X550EM_a	26
 /* Autonegotiation advertised speeds */
 typedef u32 ixgbe_autoneg_advertised;
 /* Link speed */
@@ -2957,19 +3408,40 @@ typedef u32 ixgbe_link_speed;
 #define IXGBE_LINK_SPEED_2_5GB_FULL	0x0400
 #define IXGBE_LINK_SPEED_5GB_FULL	0x0800
 #define IXGBE_LINK_SPEED_10GB_FULL	0x0080
-#define IXGBE_LINK_SPEED_82598_AUTONEG (IXGBE_LINK_SPEED_1GB_FULL | \
-					IXGBE_LINK_SPEED_10GB_FULL)
-#define IXGBE_LINK_SPEED_82599_AUTONEG (IXGBE_LINK_SPEED_100_FULL | \
-					IXGBE_LINK_SPEED_1GB_FULL | \
-					IXGBE_LINK_SPEED_10GB_FULL)
+#define IXGBE_LINK_SPEED_82598_AUTONEG	(IXGBE_LINK_SPEED_1GB_FULL | \
+					 IXGBE_LINK_SPEED_10GB_FULL)
+#define IXGBE_LINK_SPEED_82599_AUTONEG	(IXGBE_LINK_SPEED_100_FULL | \
+					 IXGBE_LINK_SPEED_1GB_FULL | \
+					 IXGBE_LINK_SPEED_10GB_FULL)
+
+/* Physical layer type */
+typedef u64 ixgbe_physical_layer;
+#define IXGBE_PHYSICAL_LAYER_UNKNOWN		0
+#define IXGBE_PHYSICAL_LAYER_10GBASE_T		0x00001
+#define IXGBE_PHYSICAL_LAYER_1000BASE_T		0x00002
+#define IXGBE_PHYSICAL_LAYER_100BASE_TX		0x00004
+#define IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU	0x00008
+#define IXGBE_PHYSICAL_LAYER_10GBASE_LR		0x00010
+#define IXGBE_PHYSICAL_LAYER_10GBASE_LRM	0x00020
+#define IXGBE_PHYSICAL_LAYER_10GBASE_SR		0x00040
+#define IXGBE_PHYSICAL_LAYER_10GBASE_KX4	0x00080
+#define IXGBE_PHYSICAL_LAYER_10GBASE_CX4	0x00100
+#define IXGBE_PHYSICAL_LAYER_1000BASE_KX	0x00200
+#define IXGBE_PHYSICAL_LAYER_1000BASE_BX	0x00400
+#define IXGBE_PHYSICAL_LAYER_10GBASE_KR		0x00800
+#define IXGBE_PHYSICAL_LAYER_10GBASE_XAUI	0x01000
+#define IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA	0x02000
+#define IXGBE_PHYSICAL_LAYER_1000BASE_SX	0x04000
+#define IXGBE_PHYSICAL_LAYER_10BASE_T		0x08000
+#define IXGBE_PHYSICAL_LAYER_2500BASE_KX	0x10000
 
 /* Flow Control Data Sheet defined values
  * Calculation and defines taken from 802.1bb Annex O
  */
 
 /* BitTimes (BT) conversion */
-#define IXGBE_BT2KB(BT) ((BT + (8 * 1024 - 1)) / (8 * 1024))
-#define IXGBE_B2BT(BT) (BT * 8)
+#define IXGBE_BT2KB(BT)		((BT + (8 * 1024 - 1)) / (8 * 1024))
+#define IXGBE_B2BT(BT)		(BT * 8)
 
 /* Calculate Delay to respond to PFC */
 #define IXGBE_PFC_D	672
@@ -2979,8 +3451,8 @@ typedef u32 ixgbe_link_speed;
 #define IXGBE_CABLE_DO	5000 /* Delay Optical */
 
 /* Calculate Interface Delay X540 */
-#define IXGBE_PHY_DC	25600	/* Delay 10G BASET */
-#define IXGBE_MAC_DC	8192	/* Delay Copper XAUI interface */
+#define IXGBE_PHY_DC	25600 /* Delay 10G BASET */
+#define IXGBE_MAC_DC	8192  /* Delay Copper XAUI interface */
 #define IXGBE_XAUI_DC	(2 * 2048) /* Delay Copper Phy */
 
 #define IXGBE_ID_X540	(IXGBE_MAC_DC + IXGBE_XAUI_DC + IXGBE_PHY_DC)
@@ -3026,8 +3498,8 @@ typedef u32 ixgbe_link_speed;
 			(2 * IXGBE_LOW_DV_X540(_max_frame_tc))
 
 /* Software ATR hash keys */
-#define IXGBE_ATR_BUCKET_HASH_KEY    0x3DAD14E2
-#define IXGBE_ATR_SIGNATURE_HASH_KEY 0x174D3614
+#define IXGBE_ATR_BUCKET_HASH_KEY	0x3DAD14E2
+#define IXGBE_ATR_SIGNATURE_HASH_KEY	0x174D3614
 
 /* Software ATR input stream values and masks */
 #define IXGBE_ATR_HASH_MASK		0x7fff
@@ -3038,14 +3510,22 @@ typedef u32 ixgbe_link_speed;
 #define IXGBE_ATR_L4TYPE_IPV6_MASK	0x4
 #define IXGBE_ATR_L4TYPE_TUNNEL_MASK	0x10
 enum ixgbe_atr_flow_type {
-	IXGBE_ATR_FLOW_TYPE_IPV4   = 0x0,
-	IXGBE_ATR_FLOW_TYPE_UDPV4  = 0x1,
-	IXGBE_ATR_FLOW_TYPE_TCPV4  = 0x2,
-	IXGBE_ATR_FLOW_TYPE_SCTPV4 = 0x3,
-	IXGBE_ATR_FLOW_TYPE_IPV6   = 0x4,
-	IXGBE_ATR_FLOW_TYPE_UDPV6  = 0x5,
-	IXGBE_ATR_FLOW_TYPE_TCPV6  = 0x6,
-	IXGBE_ATR_FLOW_TYPE_SCTPV6 = 0x7,
+	IXGBE_ATR_FLOW_TYPE_IPV4	= 0x0,
+	IXGBE_ATR_FLOW_TYPE_UDPV4	= 0x1,
+	IXGBE_ATR_FLOW_TYPE_TCPV4	= 0x2,
+	IXGBE_ATR_FLOW_TYPE_SCTPV4	= 0x3,
+	IXGBE_ATR_FLOW_TYPE_IPV6	= 0x4,
+	IXGBE_ATR_FLOW_TYPE_UDPV6	= 0x5,
+	IXGBE_ATR_FLOW_TYPE_TCPV6	= 0x6,
+	IXGBE_ATR_FLOW_TYPE_SCTPV6	= 0x7,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_IPV4	= 0x10,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_UDPV4	= 0x11,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_TCPV4	= 0x12,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_SCTPV4	= 0x13,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_IPV6	= 0x14,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_UDPV6	= 0x15,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_TCPV6	= 0x16,
+	IXGBE_ATR_FLOW_TYPE_TUNNELED_SCTPV6	= 0x17,
 };
 
 /* Flow Director ATR input struct. */
@@ -3053,28 +3533,34 @@ union ixgbe_atr_input {
 	/*
 	 * Byte layout in order, all values with MSB first:
 	 *
-	 * vm_pool    - 1 byte
-	 * flow_type  - 1 byte
-	 * vlan_id    - 2 bytes
-	 * src_ip     - 16 bytes
-	 * dst_ip     - 16 bytes
-	 * src_port   - 2 bytes
-	 * dst_port   - 2 bytes
-	 * flex_bytes - 2 bytes
-	 * bkt_hash   - 2 bytes
+	 * vm_pool	- 1 byte
+	 * flow_type	- 1 byte
+	 * vlan_id	- 2 bytes
+	 * src_ip	- 16 bytes
+	 * inner_mac	- 6 bytes
+	 * cloud_mode	- 2 bytes
+	 * tni_vni	- 4 bytes
+	 * dst_ip	- 16 bytes
+	 * src_port	- 2 bytes
+	 * dst_port	- 2 bytes
+	 * flex_bytes	- 2 bytes
+	 * bkt_hash	- 2 bytes
 	 */
 	struct {
-		u8     vm_pool;
-		u8     flow_type;
+		u8 vm_pool;
+		u8 flow_type;
 		__be16 vlan_id;
 		__be32 dst_ip[4];
 		__be32 src_ip[4];
+		u8 inner_mac[6];
+		__be16 tunnel_type;
+		__be32 tni_vni;
 		__be16 src_port;
 		__be16 dst_port;
 		__be16 flex_bytes;
 		__be16 bkt_hash;
 	} formatted;
-	__be32 dword_stream[11];
+	__be32 dword_stream[14];
 };
 
 /* Flow Director compressed ATR hash input struct */
@@ -3093,10 +3579,11 @@ union ixgbe_atr_hash_dword {
 	__be32 dword;
 };
 
-#define IXGBE_MVALS_INIT(m)		\
+#define IXGBE_MVALS_INIT(m)	\
 	IXGBE_CAT(EEC, m),		\
 	IXGBE_CAT(FLA, m),		\
 	IXGBE_CAT(GRC, m),		\
+	IXGBE_CAT(SRAMREL, m),		\
 	IXGBE_CAT(FACTPS, m),		\
 	IXGBE_CAT(SWSM, m),		\
 	IXGBE_CAT(SWFW_SYNC, m),	\
@@ -3119,10 +3606,21 @@ union ixgbe_atr_hash_dword {
 	IXGBE_CAT(I2CCTL, m)
 
 enum ixgbe_mvals {
-	IXGBE_MVALS_INIT(IDX),
+	IXGBE_MVALS_INIT(_IDX),
 	IXGBE_MVALS_IDX_LIMIT
 };
 
+/*
+ * Unavailable: The FCoE Boot Option ROM is not present in the flash.
+ * Disabled: Present; boot order is not set for any targets on the port.
+ * Enabled: Present; boot order is set for at least one target on the port.
+ */
+enum ixgbe_fcoe_boot_status {
+	ixgbe_fcoe_bootstatus_disabled = 0,
+	ixgbe_fcoe_bootstatus_enabled = 1,
+	ixgbe_fcoe_bootstatus_unavailable = 0xFFFF
+};
+
 enum ixgbe_eeprom_type {
 	ixgbe_eeprom_uninitialized = 0,
 	ixgbe_eeprom_spi,
@@ -3137,7 +3635,7 @@ enum ixgbe_mac_type {
 	ixgbe_mac_X540,
 	ixgbe_mac_X550,
 	ixgbe_mac_X550EM_x,
-	ixgbe_mac_x550em_a,
+	ixgbe_mac_X550EM_a,
 	ixgbe_num_macs
 };
 
@@ -3167,7 +3665,7 @@ enum ixgbe_phy_type {
 	ixgbe_phy_qsfp_active_unknown,
 	ixgbe_phy_qsfp_intel,
 	ixgbe_phy_qsfp_unknown,
-	ixgbe_phy_sfp_unsupported,
+	ixgbe_phy_sfp_unsupported, /*Enforce bit set with unsupported module*/
 	ixgbe_phy_sgmii,
 	ixgbe_phy_fw,
 	ixgbe_phy_generic
@@ -3176,15 +3674,15 @@ enum ixgbe_phy_type {
 /*
  * SFP+ module type IDs:
  *
- * ID   Module Type
+ * ID	Module Type
  * =============
- * 0    SFP_DA_CU
- * 1    SFP_SR
- * 2    SFP_LR
- * 3    SFP_DA_CU_CORE0 - 82599-specific
- * 4    SFP_DA_CU_CORE1 - 82599-specific
- * 5    SFP_SR/LR_CORE0 - 82599-specific
- * 6    SFP_SR/LR_CORE1 - 82599-specific
+ * 0	SFP_DA_CU
+ * 1	SFP_SR
+ * 2	SFP_LR
+ * 3	SFP_DA_CU_CORE0 - 82599-specific
+ * 4	SFP_DA_CU_CORE1 - 82599-specific
+ * 5	SFP_SR/LR_CORE0 - 82599-specific
+ * 6	SFP_SR/LR_CORE1 - 82599-specific
  */
 enum ixgbe_sfp_type {
 	ixgbe_sfp_type_da_cu = 0,
@@ -3210,7 +3708,6 @@ enum ixgbe_media_type {
 	ixgbe_media_type_unknown = 0,
 	ixgbe_media_type_fiber,
 	ixgbe_media_type_fiber_qsfp,
-	ixgbe_media_type_fiber_lco,
 	ixgbe_media_type_copper,
 	ixgbe_media_type_backplane,
 	ixgbe_media_type_cx4,
@@ -3237,6 +3734,8 @@ enum ixgbe_smart_speed {
 /* PCI bus types */
 enum ixgbe_bus_type {
 	ixgbe_bus_type_unknown = 0,
+	ixgbe_bus_type_pci,
+	ixgbe_bus_type_pcix,
 	ixgbe_bus_type_pci_express,
 	ixgbe_bus_type_internal,
 	ixgbe_bus_type_reserved
@@ -3244,27 +3743,27 @@ enum ixgbe_bus_type {
 
 /* PCI bus speeds */
 enum ixgbe_bus_speed {
-	ixgbe_bus_speed_unknown = 0,
-	ixgbe_bus_speed_33      = 33,
-	ixgbe_bus_speed_66      = 66,
-	ixgbe_bus_speed_100     = 100,
-	ixgbe_bus_speed_120     = 120,
-	ixgbe_bus_speed_133     = 133,
-	ixgbe_bus_speed_2500    = 2500,
-	ixgbe_bus_speed_5000    = 5000,
-	ixgbe_bus_speed_8000    = 8000,
+	ixgbe_bus_speed_unknown	= 0,
+	ixgbe_bus_speed_33	= 33,
+	ixgbe_bus_speed_66	= 66,
+	ixgbe_bus_speed_100	= 100,
+	ixgbe_bus_speed_120	= 120,
+	ixgbe_bus_speed_133	= 133,
+	ixgbe_bus_speed_2500	= 2500,
+	ixgbe_bus_speed_5000	= 5000,
+	ixgbe_bus_speed_8000	= 8000,
 	ixgbe_bus_speed_reserved
 };
 
 /* PCI bus widths */
 enum ixgbe_bus_width {
-	ixgbe_bus_width_unknown = 0,
-	ixgbe_bus_width_pcie_x1 = 1,
-	ixgbe_bus_width_pcie_x2 = 2,
-	ixgbe_bus_width_pcie_x4 = 4,
-	ixgbe_bus_width_pcie_x8 = 8,
-	ixgbe_bus_width_32      = 32,
-	ixgbe_bus_width_64      = 64,
+	ixgbe_bus_width_unknown	= 0,
+	ixgbe_bus_width_pcie_x1	= 1,
+	ixgbe_bus_width_pcie_x2	= 2,
+	ixgbe_bus_width_pcie_x4	= 4,
+	ixgbe_bus_width_pcie_x8	= 8,
+	ixgbe_bus_width_32	= 32,
+	ixgbe_bus_width_64	= 64,
 	ixgbe_bus_width_reserved
 };
 
@@ -3273,7 +3772,6 @@ struct ixgbe_addr_filter_info {
 	u32 rar_used_count;
 	u32 mta_in_use;
 	u32 overflow_promisc;
-	bool uc_set_promisc;
 	bool user_set_promisc;
 };
 
@@ -3283,15 +3781,15 @@ struct ixgbe_bus_info {
 	enum ixgbe_bus_width width;
 	enum ixgbe_bus_type type;
 
-	u8 func;
+	u16 func;
 	u8 lan_id;
-	u8 instance_id;
+	u16 instance_id;
 };
 
 /* Flow control parameters */
 struct ixgbe_fc_info {
-	u32 high_water[MAX_TRAFFIC_CLASS]; /* Flow Control High-water */
-	u32 low_water[MAX_TRAFFIC_CLASS]; /* Flow Control Low-water */
+	u32 high_water[IXGBE_DCB_MAX_TRAFFIC_CLASS]; /* Flow Ctrl High-water */
+	u32 low_water[IXGBE_DCB_MAX_TRAFFIC_CLASS]; /* Flow Ctrl Low-water */
 	u16 pause_time; /* Flow Control Pause timer */
 	bool send_xon; /* Flow control send XON */
 	bool strict_ieee; /* Strict IEEE mode */
@@ -3352,8 +3850,6 @@ struct ixgbe_hw_stats {
 	u64 mptc;
 	u64 bptc;
 	u64 xec;
-	u64 rqsmr[16];
-	u64 tqsmr[8];
 	u64 qprc[16];
 	u64 qptc[16];
 	u64 qbrc[16];
@@ -3367,6 +3863,7 @@ struct ixgbe_hw_stats {
 	u64 fdirmatch;
 	u64 fdirmiss;
 	u64 fccrc;
+	u64 fclast;
 	u64 fcoerpdc;
 	u64 fcoeprc;
 	u64 fcoeptc;
@@ -3374,12 +3871,43 @@ struct ixgbe_hw_stats {
 	u64 fcoedwtc;
 	u64 fcoe_noddp;
 	u64 fcoe_noddp_ext_buff;
+	u64 ldpcec;
+	u64 pcrc8ec;
 	u64 b2ospc;
 	u64 b2ogprc;
 	u64 o2bgptc;
 	u64 o2bspc;
 };
 
+/* NVM Update commands */
+#define IXGBE_NVMUPD_CMD_REG_READ	0x0000000B
+#define IXGBE_NVMUPD_CMD_REG_WRITE	0x0000000C
+
+/* NVM Update features API */
+#define IXGBE_NVMUPD_FEATURES_API_VER_MAJOR		0
+#define IXGBE_NVMUPD_FEATURES_API_VER_MINOR		0
+#define IXGBE_NVMUPD_FEATURES_API_FEATURES_ARRAY_LEN	12
+#define IXGBE_NVMUPD_EXEC_FEATURES			0xe
+#define IXGBE_NVMUPD_FEATURE_FLAT_NVM_SUPPORT		BIT(0)
+#define IXGBE_NVMUPD_FEATURE_REGISTER_ACCESS_SUPPORT	BIT(1)
+
+#define IXGBE_NVMUPD_MOD_PNT_MASK			0xFF
+
+struct ixgbe_nvm_access {
+	u32 command;
+	u32 config;
+	u32 offset;	/* in bytes */
+	u32 data_size;	/* in bytes */
+	u8 data[1];
+};
+
+struct ixgbe_nvm_features {
+	u8 major;
+	u8 minor;
+	u16 size;
+	u8 features[IXGBE_NVMUPD_FEATURES_API_FEATURES_ARRAY_LEN];
+};
+
 /* forward declaration */
 struct ixgbe_hw;
 
@@ -3405,19 +3933,22 @@ struct ixgbe_mac_operations {
 	s32 (*start_hw)(struct ixgbe_hw *);
 	s32 (*clear_hw_cntrs)(struct ixgbe_hw *);
 	enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw *);
+	u64 (*get_supported_physical_layer)(struct ixgbe_hw *);
 	s32 (*get_mac_addr)(struct ixgbe_hw *, u8 *);
 	s32 (*get_san_mac_addr)(struct ixgbe_hw *, u8 *);
+	s32 (*set_san_mac_addr)(struct ixgbe_hw *, u8 *);
 	s32 (*get_device_caps)(struct ixgbe_hw *, u16 *);
 	s32 (*get_wwn_prefix)(struct ixgbe_hw *, u16 *, u16 *);
+	s32 (*get_fcoe_boot_status)(struct ixgbe_hw *, u16 *);
 	s32 (*stop_adapter)(struct ixgbe_hw *);
 	s32 (*get_bus_info)(struct ixgbe_hw *);
 	void (*set_lan_id)(struct ixgbe_hw *);
 	s32 (*read_analog_reg8)(struct ixgbe_hw*, u32, u8*);
 	s32 (*write_analog_reg8)(struct ixgbe_hw*, u32, u8);
 	s32 (*setup_sfp)(struct ixgbe_hw *);
-	s32 (*disable_rx_buff)(struct ixgbe_hw *);
-	s32 (*enable_rx_buff)(struct ixgbe_hw *);
 	s32 (*enable_rx_dma)(struct ixgbe_hw *, u32);
+	s32 (*disable_sec_rx_path)(struct ixgbe_hw *);
+	s32 (*enable_sec_rx_path)(struct ixgbe_hw *);
 	s32 (*acquire_swfw_sync)(struct ixgbe_hw *, u32);
 	void (*release_swfw_sync)(struct ixgbe_hw *, u32);
 	void (*init_swfw_sync)(struct ixgbe_hw *);
@@ -3428,7 +3959,6 @@ struct ixgbe_mac_operations {
 	void (*disable_tx_laser)(struct ixgbe_hw *);
 	void (*enable_tx_laser)(struct ixgbe_hw *);
 	void (*flap_tx_laser)(struct ixgbe_hw *);
-	void (*stop_link_on_d3)(struct ixgbe_hw *);
 	s32 (*setup_link)(struct ixgbe_hw *, ixgbe_link_speed, bool);
 	s32 (*setup_mac_link)(struct ixgbe_hw *, ixgbe_link_speed, bool);
 	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool);
@@ -3436,8 +3966,8 @@ struct ixgbe_mac_operations {
 				     bool *);
 	void (*set_rate_select_speed)(struct ixgbe_hw *, ixgbe_link_speed);
 
-	/* Packet Buffer Manipulation */
-	void (*set_rxpba)(struct ixgbe_hw *, int, u32, int);
+	/* Packet Buffer manipulation */
+	void (*setup_rxpba)(struct ixgbe_hw *, int, u32, int);
 
 	/* LED */
 	s32 (*led_on)(struct ixgbe_hw *, u32);
@@ -3448,19 +3978,27 @@ struct ixgbe_mac_operations {
 
 	/* RAR, Multicast, VLAN */
 	s32 (*set_rar)(struct ixgbe_hw *, u32, u8 *, u32, u32);
+	s32 (*set_uc_addr)(struct ixgbe_hw *, u32, u8 *);
 	s32 (*clear_rar)(struct ixgbe_hw *, u32);
+	s32 (*insert_mac_addr)(struct ixgbe_hw *, u8 *, u32);
 	s32 (*set_vmdq)(struct ixgbe_hw *, u32, u32);
 	s32 (*set_vmdq_san_mac)(struct ixgbe_hw *, u32);
 	s32 (*clear_vmdq)(struct ixgbe_hw *, u32, u32);
 	s32 (*init_rx_addrs)(struct ixgbe_hw *);
-	s32 (*update_mc_addr_list)(struct ixgbe_hw *, struct net_device *);
+	s32 (*update_uc_addr_list)(struct ixgbe_hw *, u8 *, u32,
+				   ixgbe_mc_addr_itr);
+	s32 (*update_mc_addr_list)(struct ixgbe_hw *, u8 *, u32,
+				   ixgbe_mc_addr_itr, bool clear);
 	s32 (*enable_mc)(struct ixgbe_hw *);
 	s32 (*disable_mc)(struct ixgbe_hw *);
 	s32 (*clear_vfta)(struct ixgbe_hw *);
 	s32 (*set_vfta)(struct ixgbe_hw *, u32, u32, bool, bool);
+	s32 (*set_vlvf)(struct ixgbe_hw *, u32, u32, bool, u32 *, u32,
+			bool);
 	s32 (*init_uta_tables)(struct ixgbe_hw *);
 	void (*set_mac_anti_spoofing)(struct ixgbe_hw *, bool, int);
 	void (*set_vlan_anti_spoofing)(struct ixgbe_hw *, bool, int);
+	s32 (*toggle_txdctl)(struct ixgbe_hw *hw, u32 vf_index);
 
 	/* Flow Control */
 	s32 (*fc_enable)(struct ixgbe_hw *);
@@ -3472,19 +4010,23 @@ struct ixgbe_mac_operations {
 			      const char *);
 	s32 (*get_thermal_sensor_data)(struct ixgbe_hw *);
 	s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw *hw);
-	bool (*fw_recovery_mode)(struct ixgbe_hw *hw);
+	void (*get_rtrup2tc)(struct ixgbe_hw *hw, u8 *map);
 	void (*disable_rx)(struct ixgbe_hw *hw);
 	void (*enable_rx)(struct ixgbe_hw *hw);
 	void (*set_source_address_pruning)(struct ixgbe_hw *, bool,
 					   unsigned int);
 	void (*set_ethertype_anti_spoofing)(struct ixgbe_hw *, bool, int);
-
-	/* DMA Coalescing */
-	s32 (*dmac_config)(struct ixgbe_hw *hw);
 	s32 (*dmac_update_tcs)(struct ixgbe_hw *hw);
 	s32 (*dmac_config_tcs)(struct ixgbe_hw *hw);
+	s32 (*dmac_config)(struct ixgbe_hw *hw);
+	s32 (*setup_eee)(struct ixgbe_hw *hw, bool enable_eee);
 	s32 (*read_iosf_sb_reg)(struct ixgbe_hw *, u32, u32, u32 *);
 	s32 (*write_iosf_sb_reg)(struct ixgbe_hw *, u32, u32, u32);
+	void (*disable_mdd)(struct ixgbe_hw *hw);
+	void (*enable_mdd)(struct ixgbe_hw *hw);
+	void (*mdd_event)(struct ixgbe_hw *hw, u32 *vf_bitmap);
+	void (*restore_mdd_vf)(struct ixgbe_hw *hw, u32 vf);
+	bool (*fw_recovery_mode)(struct ixgbe_hw *hw);
 };
 
 struct ixgbe_phy_operations {
@@ -3500,11 +4042,13 @@ struct ixgbe_phy_operations {
 	s32 (*setup_internal_link)(struct ixgbe_hw *);
 	s32 (*setup_link_speed)(struct ixgbe_hw *, ixgbe_link_speed, bool);
 	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *);
+	s32 (*get_firmware_version)(struct ixgbe_hw *, u16 *);
 	s32 (*read_i2c_byte)(struct ixgbe_hw *, u8, u8, u8 *);
 	s32 (*write_i2c_byte)(struct ixgbe_hw *, u8, u8, u8);
 	s32 (*read_i2c_sff8472)(struct ixgbe_hw *, u8 , u8 *);
 	s32 (*read_i2c_eeprom)(struct ixgbe_hw *, u8 , u8 *);
 	s32 (*write_i2c_eeprom)(struct ixgbe_hw *, u8, u8);
+	void (*i2c_bus_clear)(struct ixgbe_hw *);
 	s32 (*check_overtemp)(struct ixgbe_hw *);
 	s32 (*set_phy_power)(struct ixgbe_hw *, bool on);
 	s32 (*enter_lplu)(struct ixgbe_hw *);
@@ -3530,185 +4074,166 @@ struct ixgbe_link_info {
 };
 
 struct ixgbe_eeprom_info {
-	struct ixgbe_eeprom_operations  ops;
-	enum ixgbe_eeprom_type          type;
-	u32                             semaphore_delay;
-	u16                             word_size;
-	u16                             address_bits;
-	u16                             word_page_size;
-	u16				ctrl_word_3;
+	struct ixgbe_eeprom_operations ops;
+	enum ixgbe_eeprom_type type;
+	u32 semaphore_delay;
+	u16 word_size;
+	u16 address_bits;
+	u16 word_page_size;
+	u16 ctrl_word_3;
 };
 
 #define IXGBE_FLAGS_DOUBLE_RESET_REQUIRED	0x01
 struct ixgbe_mac_info {
-	struct ixgbe_mac_operations     ops;
-	enum ixgbe_mac_type             type;
-	u8                              addr[ETH_ALEN];
-	u8                              perm_addr[ETH_ALEN];
-	u8                              san_addr[ETH_ALEN];
+	struct ixgbe_mac_operations ops;
+	enum ixgbe_mac_type type;
+	u8 addr[IXGBE_ETH_LENGTH_OF_ADDRESS];
+	u8 perm_addr[IXGBE_ETH_LENGTH_OF_ADDRESS];
+	u8 san_addr[IXGBE_ETH_LENGTH_OF_ADDRESS];
 	/* prefix for World Wide Node Name (WWNN) */
-	u16                             wwnn_prefix;
+	u16 wwnn_prefix;
 	/* prefix for World Wide Port Name (WWPN) */
-	u16                             wwpn_prefix;
-	u16				max_msix_vectors;
+	u16 wwpn_prefix;
 #define IXGBE_MAX_MTA			128
-	u32				mta_shadow[IXGBE_MAX_MTA];
-	s32                             mc_filter_type;
-	u32                             mcft_size;
-	u32                             vft_size;
-	u32                             num_rar_entries;
-	u32                             rar_highwater;
-	u32				rx_pb_size;
-	u32                             max_tx_queues;
-	u32                             max_rx_queues;
-	u32                             orig_autoc;
-	u32                             orig_autoc2;
-	bool                            orig_link_settings_stored;
-	bool                            autotry_restart;
-	u8                              flags;
-	u8				san_mac_rar_index;
+	u32 mta_shadow[IXGBE_MAX_MTA];
+	s32 mc_filter_type;
+	u32 mcft_size;
+	u32 vft_size;
+	u32 num_rar_entries;
+	u32 rar_highwater;
+	u32 rx_pb_size;
+	u32 max_tx_queues;
+	u32 max_rx_queues;
+	u32 orig_autoc;
+	u8  san_mac_rar_index;
+	bool get_link_status;
+	u32 orig_autoc2;
+	u16 max_msix_vectors;
+	bool arc_subsystem_valid;
+	bool orig_link_settings_stored;
+	bool autotry_restart;
+	u8 flags;
 	struct ixgbe_thermal_sensor_data  thermal_sensor_data;
-	bool				set_lben;
-	u8				led_link_act;
+	bool thermal_sensor_enabled;
+	struct ixgbe_dmac_config dmac_config;
+	bool set_lben;
+	u32  max_link_up_time;
+	u8   led_link_act;
 };
 
 struct ixgbe_phy_info {
-	struct ixgbe_phy_operations     ops;
-	struct mdio_if_info		mdio;
-	enum ixgbe_phy_type             type;
-	u32                             id;
-	enum ixgbe_sfp_type             sfp_type;
-	bool                            sfp_setup_needed;
-	u32                             revision;
-	enum ixgbe_media_type           media_type;
-	u32				phy_semaphore_mask;
-	bool                            reset_disable;
-	ixgbe_autoneg_advertised        autoneg_advertised;
-	ixgbe_link_speed		speeds_supported;
-	ixgbe_link_speed		eee_speeds_supported;
-	ixgbe_link_speed		eee_speeds_advertised;
-	enum ixgbe_smart_speed          smart_speed;
-	bool                            smart_speed_active;
-	bool                            multispeed_fiber;
-	bool                            reset_if_overtemp;
-	bool                            qsfp_shared_i2c_bus;
-	u32				nw_mng_if_sel;
+	struct ixgbe_phy_operations ops;
+	enum ixgbe_phy_type type;
+	u32 addr;
+	u32 id;
+	enum ixgbe_sfp_type sfp_type;
+	bool sfp_setup_needed;
+	u32 revision;
+	enum ixgbe_media_type media_type;
+	u32 phy_semaphore_mask;
+	bool reset_disable;
+	ixgbe_autoneg_advertised autoneg_advertised;
+	ixgbe_link_speed speeds_supported;
+	ixgbe_link_speed eee_speeds_supported;
+	ixgbe_link_speed eee_speeds_advertised;
+	enum ixgbe_smart_speed smart_speed;
+	bool smart_speed_active;
+	bool multispeed_fiber;
+	bool reset_if_overtemp;
+	bool qsfp_shared_i2c_bus;
+	u32 nw_mng_if_sel;
 };
 
 #include "ixgbe_mbx.h"
 
-struct ixgbe_mbx_operations {
-	s32 (*init_params)(struct ixgbe_hw *hw);
-	s32 (*read)(struct ixgbe_hw *, u32 *, u16,  u16);
-	s32 (*write)(struct ixgbe_hw *, u32 *, u16, u16);
-	s32 (*read_posted)(struct ixgbe_hw *, u32 *, u16,  u16);
-	s32 (*write_posted)(struct ixgbe_hw *, u32 *, u16, u16);
-	s32 (*check_for_msg)(struct ixgbe_hw *, u16);
-	s32 (*check_for_ack)(struct ixgbe_hw *, u16);
-	s32 (*check_for_rst)(struct ixgbe_hw *, u16);
-};
-
-struct ixgbe_mbx_stats {
-	u32 msgs_tx;
-	u32 msgs_rx;
-
-	u32 acks;
-	u32 reqs;
-	u32 rsts;
-};
-
-struct ixgbe_mbx_info {
-	const struct ixgbe_mbx_operations *ops;
-	struct ixgbe_mbx_stats stats;
-	u32 timeout;
-	u32 usec_delay;
-	u32 v2p_mailbox;
-	u16 size;
-};
-
 struct ixgbe_hw {
-	u8 __iomem			*hw_addr;
-	void				*back;
-	struct ixgbe_mac_info		mac;
-	struct ixgbe_addr_filter_info	addr_ctrl;
-	struct ixgbe_fc_info		fc;
-	struct ixgbe_phy_info		phy;
-	struct ixgbe_link_info		link;
-	struct ixgbe_eeprom_info	eeprom;
-	struct ixgbe_bus_info		bus;
-	struct ixgbe_mbx_info		mbx;
-	const u32			*mvals;
-	u16				device_id;
-	u16				vendor_id;
-	u16				subsystem_device_id;
-	u16				subsystem_vendor_id;
-	u8				revision_id;
-	bool				adapter_stopped;
-	bool				force_full_reset;
-	bool				allow_unsupported_sfp;
-	bool				wol_enabled;
-	bool				need_crosstalk_fix;
-};
-
-struct ixgbe_info {
-	enum ixgbe_mac_type		mac;
-	s32 				(*get_invariants)(struct ixgbe_hw *);
-	const struct ixgbe_mac_operations	*mac_ops;
-	const struct ixgbe_eeprom_operations	*eeprom_ops;
-	const struct ixgbe_phy_operations	*phy_ops;
-	const struct ixgbe_mbx_operations	*mbx_ops;
-	const struct ixgbe_link_operations	*link_ops;
-	const u32			*mvals;
+	u8 IOMEM *hw_addr;
+	void *back;
+	struct ixgbe_mac_info mac;
+	struct ixgbe_addr_filter_info addr_ctrl;
+	struct ixgbe_fc_info fc;
+	struct ixgbe_phy_info phy;
+	struct ixgbe_link_info link;
+	struct ixgbe_eeprom_info eeprom;
+	struct ixgbe_bus_info bus;
+	struct ixgbe_mbx_info mbx;
+	const u32 *mvals;
+	u16 device_id;
+	u16 vendor_id;
+	u16 subsystem_device_id;
+	u16 subsystem_vendor_id;
+	u8 revision_id;
+	bool adapter_stopped;
+	int api_version;
+	bool force_full_reset;
+	bool allow_unsupported_sfp;
+	bool wol_enabled;
+	bool need_crosstalk_fix;
+	/* NVM Update features */
+	struct ixgbe_nvm_features nvmupd_features;
 };
 
+#define ixgbe_call_func(hw, func, params, error) \
+		(func != NULL) ? func params : error
 
 /* Error Codes */
-#define IXGBE_ERR_EEPROM                        -1
-#define IXGBE_ERR_EEPROM_CHECKSUM               -2
-#define IXGBE_ERR_PHY                           -3
-#define IXGBE_ERR_CONFIG                        -4
-#define IXGBE_ERR_PARAM                         -5
-#define IXGBE_ERR_MAC_TYPE                      -6
-#define IXGBE_ERR_UNKNOWN_PHY                   -7
-#define IXGBE_ERR_LINK_SETUP                    -8
-#define IXGBE_ERR_ADAPTER_STOPPED               -9
-#define IXGBE_ERR_INVALID_MAC_ADDR              -10
-#define IXGBE_ERR_DEVICE_NOT_SUPPORTED          -11
-#define IXGBE_ERR_MASTER_REQUESTS_PENDING       -12
-#define IXGBE_ERR_INVALID_LINK_SETTINGS         -13
-#define IXGBE_ERR_AUTONEG_NOT_COMPLETE          -14
-#define IXGBE_ERR_RESET_FAILED                  -15
-#define IXGBE_ERR_SWFW_SYNC                     -16
-#define IXGBE_ERR_PHY_ADDR_INVALID              -17
-#define IXGBE_ERR_I2C                           -18
-#define IXGBE_ERR_SFP_NOT_SUPPORTED             -19
-#define IXGBE_ERR_SFP_NOT_PRESENT               -20
-#define IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT       -21
-#define IXGBE_ERR_NO_SAN_ADDR_PTR               -22
-#define IXGBE_ERR_FDIR_REINIT_FAILED            -23
-#define IXGBE_ERR_EEPROM_VERSION                -24
-#define IXGBE_ERR_NO_SPACE                      -25
-#define IXGBE_ERR_OVERTEMP                      -26
-#define IXGBE_ERR_FC_NOT_NEGOTIATED             -27
-#define IXGBE_ERR_FC_NOT_SUPPORTED              -28
-#define IXGBE_ERR_SFP_SETUP_NOT_COMPLETE        -30
-#define IXGBE_ERR_PBA_SECTION                   -31
-#define IXGBE_ERR_INVALID_ARGUMENT              -32
-#define IXGBE_ERR_HOST_INTERFACE_COMMAND        -33
+#define IXGBE_SUCCESS				0
+#define IXGBE_ERR_EEPROM			-1
+#define IXGBE_ERR_EEPROM_CHECKSUM		-2
+#define IXGBE_ERR_PHY				-3
+#define IXGBE_ERR_CONFIG			-4
+#define IXGBE_ERR_PARAM				-5
+#define IXGBE_ERR_MAC_TYPE			-6
+#define IXGBE_ERR_UNKNOWN_PHY			-7
+#define IXGBE_ERR_LINK_SETUP			-8
+#define IXGBE_ERR_ADAPTER_STOPPED		-9
+#define IXGBE_ERR_INVALID_MAC_ADDR		-10
+#define IXGBE_ERR_DEVICE_NOT_SUPPORTED		-11
+#define IXGBE_ERR_MASTER_REQUESTS_PENDING	-12
+#define IXGBE_ERR_INVALID_LINK_SETTINGS		-13
+#define IXGBE_ERR_AUTONEG_NOT_COMPLETE		-14
+#define IXGBE_ERR_RESET_FAILED			-15
+#define IXGBE_ERR_SWFW_SYNC			-16
+#define IXGBE_ERR_PHY_ADDR_INVALID		-17
+#define IXGBE_ERR_I2C				-18
+#define IXGBE_ERR_SFP_NOT_SUPPORTED		-19
+#define IXGBE_ERR_SFP_NOT_PRESENT		-20
+#define IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT	-21
+#define IXGBE_ERR_NO_SAN_ADDR_PTR		-22
+#define IXGBE_ERR_FDIR_REINIT_FAILED		-23
+#define IXGBE_ERR_EEPROM_VERSION		-24
+#define IXGBE_ERR_NO_SPACE			-25
+#define IXGBE_ERR_OVERTEMP			-26
+#define IXGBE_ERR_FC_NOT_NEGOTIATED		-27
+#define IXGBE_ERR_FC_NOT_SUPPORTED		-28
+#define IXGBE_ERR_SFP_SETUP_NOT_COMPLETE	-30
+#define IXGBE_ERR_PBA_SECTION			-31
+#define IXGBE_ERR_INVALID_ARGUMENT		-32
+#define IXGBE_ERR_HOST_INTERFACE_COMMAND	-33
+#define IXGBE_ERR_OUT_OF_MEM			-34
+#define IXGBE_ERR_FEATURE_NOT_SUPPORTED		-36
+#define IXGBE_ERR_EEPROM_PROTECTED_REGION	-37
 #define IXGBE_ERR_FDIR_CMD_INCOMPLETE		-38
 #define IXGBE_ERR_FW_RESP_INVALID		-39
 #define IXGBE_ERR_TOKEN_RETRY			-40
-#define IXGBE_NOT_IMPLEMENTED                   0x7FFFFFFF
+#define IXGBE_ERR_MBX				-41
+#define IXGBE_ERR_MBX_NOMSG			-42
+#define IXGBE_ERR_TIMEOUT			-43
+
+#define IXGBE_NOT_IMPLEMENTED			0x7FFFFFFF
 
 #define IXGBE_FUSES0_GROUP(_i)		(0x11158 + ((_i) * 4))
-#define IXGBE_FUSES0_300MHZ		BIT(5)
-#define IXGBE_FUSES0_REV_MASK		(3u << 6)
+#define IXGBE_FUSES0_300MHZ		(1 << 5)
+#define IXGBE_FUSES0_REV_MASK		(3 << 6)
 
 #define IXGBE_KRM_PORT_CAR_GEN_CTRL(P)	((P) ? 0x8010 : 0x4010)
 #define IXGBE_KRM_LINK_S1(P)		((P) ? 0x8200 : 0x4200)
 #define IXGBE_KRM_LINK_CTRL_1(P)	((P) ? 0x820C : 0x420C)
 #define IXGBE_KRM_AN_CNTL_1(P)		((P) ? 0x822C : 0x422C)
+#define IXGBE_KRM_AN_CNTL_4(P)		((P) ? 0x8238 : 0x4238)
 #define IXGBE_KRM_AN_CNTL_8(P)		((P) ? 0x8248 : 0x4248)
+#define IXGBE_KRM_PCS_KX_AN(P)		((P) ? 0x9918 : 0x5918)
+#define IXGBE_KRM_PCS_KX_AN_LP(P)	((P) ? 0x991C : 0x591C)
 #define IXGBE_KRM_SGMII_CTRL(P)		((P) ? 0x82A0 : 0x42A0)
 #define IXGBE_KRM_LP_BASE_PAGE_HIGH(P)	((P) ? 0x836C : 0x436C)
 #define IXGBE_KRM_DSP_TXFFE_STATE_4(P)	((P) ? 0x8634 : 0x4634)
@@ -3720,90 +4245,112 @@ struct ixgbe_info {
 #define IXGBE_KRM_RX_ANA_CTL(P)		((P) ? 0x9A00 : 0x5A00)
 
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_DA		~(0x3 << 20)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR		BIT(20)
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR		(1u << 20)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_LR		(0x2 << 20)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN		BIT(25)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN		BIT(26)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN		BIT(27)
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN		(1u << 25)
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN		(1u << 26)
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN		(1u << 27)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10M		~(0x7 << 28)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_100M		BIT(28)
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_100M		(1u << 28)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G		(0x2 << 28)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10G		(0x3 << 28)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_AN		(0x4 << 28)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_2_5G		(0x7 << 28)
 #define IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK		(0x7 << 28)
-#define IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART	BIT(31)
-
-#define IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_32B		BIT(9)
-#define IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_KRPCS		BIT(11)
-
-#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK	(7u << 8)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G	(2u << 8)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G	(4u << 8)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN		BIT(12)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN	BIT(13)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_FEC_REQ		BIT(14)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_FEC		BIT(15)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX		BIT(16)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR		BIT(18)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KX		BIT(24)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KR		BIT(26)
-#define IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE		BIT(28)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE		BIT(29)
-#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART		BIT(31)
-
-#define IXGBE_KRM_AN_CNTL_1_SYM_PAUSE			BIT(28)
-#define IXGBE_KRM_AN_CNTL_1_ASM_PAUSE			BIT(29)
-
-#define IXGBE_KRM_AN_CNTL_8_LINEAR			BIT(0)
-#define IXGBE_KRM_AN_CNTL_8_LIMITING			BIT(1)
-
-#define IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE		BIT(10)
-#define IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE		BIT(11)
-#define IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D	BIT(12)
-#define IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D		BIT(19)
-
-#define IXGBE_KRM_DSP_TXFFE_STATE_C0_EN			BIT(6)
-#define IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN		BIT(15)
-#define IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN		BIT(16)
-
-#define IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL	BIT(4)
-#define IXGBE_KRM_RX_TRN_LINKUP_CTRL_PROTOCOL_BYPASS	BIT(2)
-
-#define IXGBE_KRM_PMD_DFX_BURNIN_TX_RX_KR_LB_MASK	(3u << 16)
-
-#define IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN	BIT(1)
-#define IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN	BIT(2)
-#define IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN		BIT(3)
-#define IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN		BIT(31)
-
-#define IXGBE_SB_IOSF_INDIRECT_CTRL		0x00011144
-#define IXGBE_SB_IOSF_INDIRECT_DATA		0x00011148
+#define IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART	(1u << 31)
+
+#define IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_32B		(1 << 9)
+#define IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_KRPCS		(1 << 11)
+
+#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK	(0x7 << 8)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G	(2 << 8)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G	(4 << 8)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_SGMII_EN		(1 << 12)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CLAUSE_37_EN	(1 << 13)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_FEC_REQ		(1 << 14)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_FEC		(1 << 15)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KX		(1 << 16)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_CAP_KR		(1 << 18)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KX		(1 << 24)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_EEE_CAP_KR		(1 << 26)
+#define IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE		(1 << 28)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE		(1 << 29)
+#define IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART		(1 << 31)
+
+#define IXGBE_KRM_AN_CNTL_1_SYM_PAUSE			(1 << 28)
+#define IXGBE_KRM_AN_CNTL_1_ASM_PAUSE			(1 << 29)
+#define IXGBE_KRM_PCS_KX_AN_SYM_PAUSE			(1 << 1)
+#define IXGBE_KRM_PCS_KX_AN_ASM_PAUSE			(1 << 2)
+#define IXGBE_KRM_PCS_KX_AN_LP_SYM_PAUSE		(1 << 2)
+#define IXGBE_KRM_PCS_KX_AN_LP_ASM_PAUSE		(1 << 3)
+#define IXGBE_KRM_AN_CNTL_4_ECSR_AN37_OVER_73		(1 << 29)
+#define IXGBE_KRM_AN_CNTL_8_LINEAR			(1 << 0)
+#define IXGBE_KRM_AN_CNTL_8_LIMITING			(1 << 1)
+
+#define IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE		(1 << 10)
+#define IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE		(1 << 11)
+
+#define IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_100_D	(1 << 12)
+#define IXGBE_KRM_SGMII_CTRL_MAC_TAR_FORCE_10_D		(1 << 19)
+
+#define IXGBE_KRM_DSP_TXFFE_STATE_C0_EN			(1 << 6)
+#define IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN		(1 << 15)
+#define IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN		(1 << 16)
+
+#define IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL	(1 << 4)
+#define IXGBE_KRM_RX_TRN_LINKUP_CTRL_PROTOCOL_BYPASS	(1 << 2)
+
+#define IXGBE_KRM_PMD_DFX_BURNIN_TX_RX_KR_LB_MASK	(0x3 << 16)
+
+#define IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN	(1 << 1)
+#define IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN	(1 << 2)
+#define IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN		(1 << 3)
+#define IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN		(1 << 31)
+
+#define IXGBE_SB_IOSF_INDIRECT_CTRL	0x00011144
+#define IXGBE_SB_IOSF_INDIRECT_DATA	0x00011148
 
 #define IXGBE_SB_IOSF_CTRL_ADDR_SHIFT		0
 #define IXGBE_SB_IOSF_CTRL_ADDR_MASK		0xFF
 #define IXGBE_SB_IOSF_CTRL_RESP_STAT_SHIFT	18
-#define IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK \
+#define IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK	\
 				(0x3 << IXGBE_SB_IOSF_CTRL_RESP_STAT_SHIFT)
 #define IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT	20
-#define IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK \
+#define IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK	\
 				(0xFF << IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT)
 #define IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT	28
 #define IXGBE_SB_IOSF_CTRL_TARGET_SELECT_MASK	0x7
 #define IXGBE_SB_IOSF_CTRL_BUSY_SHIFT		31
-#define IXGBE_SB_IOSF_CTRL_BUSY		BIT(IXGBE_SB_IOSF_CTRL_BUSY_SHIFT)
+#define IXGBE_SB_IOSF_CTRL_BUSY		(1 << IXGBE_SB_IOSF_CTRL_BUSY_SHIFT)
 #define IXGBE_SB_IOSF_TARGET_KR_PHY	0
 
 #define IXGBE_NW_MNG_IF_SEL		0x00011178
-#define IXGBE_NW_MNG_IF_SEL_MDIO_ACT		BIT(1)
-#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_10M	BIT(17)
-#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_100M	BIT(18)
-#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_1G	BIT(19)
-#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G	BIT(20)
-#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_10G	BIT(21)
-#define IXGBE_NW_MNG_IF_SEL_SGMII_ENABLE	BIT(25)
-#define IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE	BIT(24) /* X552 only */
-#define IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT	3
+#define IXGBE_NW_MNG_IF_SEL_MDIO_ACT	(1u << 1)
+#define IXGBE_NW_MNG_IF_SEL_MDIO_IF_MODE	(1u << 2)
+#define IXGBE_NW_MNG_IF_SEL_EN_SHARED_MDIO	(1u << 13)
+#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_10M	(1u << 17)
+#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_100M	(1u << 18)
+#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_1G	(1u << 19)
+#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G	(1u << 20)
+#define IXGBE_NW_MNG_IF_SEL_PHY_SPEED_10G	(1u << 21)
+#define IXGBE_NW_MNG_IF_SEL_SGMII_ENABLE	(1u << 25)
+#define IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE (1 << 24) /* X552 reg field only */
+#define IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT 3
 #define IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD	\
 				(0x1F << IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT)
+
+/* Code Command (Flash I/F Interface) */
+#define IXGBE_HOST_INTERFACE_FLASH_READ_CMD			0x30
+#define IXGBE_HOST_INTERFACE_SHADOW_RAM_READ_CMD		0x31
+#define IXGBE_HOST_INTERFACE_FLASH_WRITE_CMD			0x32
+#define IXGBE_HOST_INTERFACE_SHADOW_RAM_WRITE_CMD		0x33
+#define IXGBE_HOST_INTERFACE_FLASH_MODULE_UPDATE_CMD		0x34
+#define IXGBE_HOST_INTERFACE_FLASH_BLOCK_EREASE_CMD		0x35
+#define IXGBE_HOST_INTERFACE_SHADOW_RAM_DUMP_CMD		0x36
+#define IXGBE_HOST_INTERFACE_FLASH_INFO_CMD			0x37
+#define IXGBE_HOST_INTERFACE_APPLY_UPDATE_CMD			0x38
+#define IXGBE_HOST_INTERFACE_MASK_CMD				0x000000FF
+
+#include "ixgbe_osdep2.h"
+
 #endif /* _IXGBE_TYPE_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
index 4b93ba149ec5..89d10e7c9e5a 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.c
@@ -1,13 +1,11 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
-#include <linux/pci.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-
-#include "ixgbe.h"
-#include "ixgbe_phy.h"
 #include "ixgbe_x540.h"
+#include "ixgbe_type.h"
+#include "ixgbe_api.h"
+#include "ixgbe_common.h"
+#include "ixgbe_phy.h"
 
 #define IXGBE_X540_MAX_TX_QUEUES	128
 #define IXGBE_X540_MAX_RX_QUEUES	128
@@ -16,55 +14,164 @@
 #define IXGBE_X540_VFT_TBL_SIZE		128
 #define IXGBE_X540_RX_PB_SIZE		384
 
-static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw);
-static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw);
-static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
-static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
-
-enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)
-{
-	return ixgbe_media_type_copper;
-}
+STATIC s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw);
+STATIC s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
+STATIC void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
 
-s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw)
+/**
+ * ixgbe_init_ops_X540 - Inits func ptrs and MAC type
+ * @hw: pointer to hardware structure
+ *
+ * Initialize the function pointers and assign the MAC type for X540.
+ * Does not touch the hardware.
+ **/
+s32 ixgbe_init_ops_X540(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 	struct ixgbe_phy_info *phy = &hw->phy;
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	s32 ret_val;
+	u16 i;
 
-	/* set_phy_power was set by default to NULL */
+	DEBUGFUNC("ixgbe_init_ops_X540");
+
+	ret_val = ixgbe_init_phy_ops_generic(hw);
+	ret_val = ixgbe_init_ops_generic(hw);
+
+	/* EEPROM */
+	eeprom->ops.init_params = ixgbe_init_eeprom_params_X540;
+	eeprom->ops.read = ixgbe_read_eerd_X540;
+	eeprom->ops.read_buffer = ixgbe_read_eerd_buffer_X540;
+	eeprom->ops.write = ixgbe_write_eewr_X540;
+	eeprom->ops.write_buffer = ixgbe_write_eewr_buffer_X540;
+	eeprom->ops.update_checksum = ixgbe_update_eeprom_checksum_X540;
+	eeprom->ops.validate_checksum = ixgbe_validate_eeprom_checksum_X540;
+	eeprom->ops.calc_checksum = ixgbe_calc_eeprom_checksum_X540;
+
+	/* PHY */
+	phy->ops.init = ixgbe_init_phy_ops_generic;
+	phy->ops.reset = NULL;
 	phy->ops.set_phy_power = ixgbe_set_copper_phy_power;
 
-	mac->mcft_size = IXGBE_X540_MC_TBL_SIZE;
-	mac->vft_size = IXGBE_X540_VFT_TBL_SIZE;
-	mac->num_rar_entries = IXGBE_X540_RAR_ENTRIES;
-	mac->rx_pb_size = IXGBE_X540_RX_PB_SIZE;
-	mac->max_rx_queues = IXGBE_X540_MAX_RX_QUEUES;
-	mac->max_tx_queues = IXGBE_X540_MAX_TX_QUEUES;
-	mac->max_msix_vectors = ixgbe_get_pcie_msix_count_generic(hw);
+	/* MAC */
+	mac->ops.reset_hw = ixgbe_reset_hw_X540;
+	mac->ops.get_media_type = ixgbe_get_media_type_X540;
+	mac->ops.get_supported_physical_layer =
+				    ixgbe_get_supported_physical_layer_X540;
+	mac->ops.read_analog_reg8 = NULL;
+	mac->ops.write_analog_reg8 = NULL;
+	mac->ops.start_hw = ixgbe_start_hw_X540;
+	mac->ops.get_san_mac_addr = ixgbe_get_san_mac_addr_generic;
+	mac->ops.set_san_mac_addr = ixgbe_set_san_mac_addr_generic;
+	mac->ops.get_device_caps = ixgbe_get_device_caps_generic;
+	mac->ops.get_wwn_prefix = ixgbe_get_wwn_prefix_generic;
+	mac->ops.get_fcoe_boot_status = ixgbe_get_fcoe_boot_status_generic;
+	mac->ops.acquire_swfw_sync = ixgbe_acquire_swfw_sync_X540;
+	mac->ops.release_swfw_sync = ixgbe_release_swfw_sync_X540;
+	mac->ops.init_swfw_sync = ixgbe_init_swfw_sync_X540;
+	mac->ops.disable_sec_rx_path = ixgbe_disable_sec_rx_path_generic;
+	mac->ops.enable_sec_rx_path = ixgbe_enable_sec_rx_path_generic;
+
+	/* RAR, Multicast, VLAN */
+	mac->ops.set_vmdq = ixgbe_set_vmdq_generic;
+	mac->ops.set_vmdq_san_mac = ixgbe_set_vmdq_san_mac_generic;
+	mac->ops.clear_vmdq = ixgbe_clear_vmdq_generic;
+	mac->ops.insert_mac_addr = ixgbe_insert_mac_addr_generic;
+	mac->rar_highwater = 1;
+	mac->ops.set_vfta = ixgbe_set_vfta_generic;
+	mac->ops.set_vlvf = ixgbe_set_vlvf_generic;
+	mac->ops.clear_vfta = ixgbe_clear_vfta_generic;
+	mac->ops.init_uta_tables = ixgbe_init_uta_tables_generic;
+	mac->ops.set_mac_anti_spoofing = ixgbe_set_mac_anti_spoofing;
+	mac->ops.set_vlan_anti_spoofing = ixgbe_set_vlan_anti_spoofing;
+
+	/* Link */
+	mac->ops.get_link_capabilities =
+				ixgbe_get_copper_link_capabilities_generic;
+	mac->ops.setup_link = ixgbe_setup_mac_link_X540;
+	mac->ops.setup_rxpba = ixgbe_set_rxpba_generic;
+	mac->ops.check_link = ixgbe_check_mac_link_generic;
+
+	mac->mcft_size		= IXGBE_X540_MC_TBL_SIZE;
+	mac->vft_size		= IXGBE_X540_VFT_TBL_SIZE;
+	mac->num_rar_entries	= IXGBE_X540_RAR_ENTRIES;
+	mac->rx_pb_size		= IXGBE_X540_RX_PB_SIZE;
+	mac->max_rx_queues	= IXGBE_X540_MAX_RX_QUEUES;
+	mac->max_tx_queues	= IXGBE_X540_MAX_TX_QUEUES;
+	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
+
+	/*
+	 * FWSM register
+	 * ARC supported; valid only if manageability features are
+	 * enabled.
+	 */
+	mac->arc_subsystem_valid = !!(IXGBE_READ_REG(hw, IXGBE_FWSM_BY_MAC(hw))
+				     & IXGBE_FWSM_MODE_MASK);
+
+	for (i = 0; i < 64; i++)
+		hw->mbx.ops[i].init_params = ixgbe_init_mbx_params_pf;
+
+	/* LEDs */
+	mac->ops.blink_led_start = ixgbe_blink_led_start_X540;
+	mac->ops.blink_led_stop = ixgbe_blink_led_stop_X540;
+
+	/* Manageability interface */
+	mac->ops.set_fw_drv_ver = ixgbe_set_fw_drv_ver_generic;
 
-	return 0;
+	mac->ops.get_rtrup2tc = ixgbe_dcb_get_rtrup2tc_generic;
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_get_link_capabilities_X540 - Determines link capabilities
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @autoneg: true when autoneg or autotry is enabled
+ *
+ * Determines the link capabilities by reading the AUTOC register.
+ **/
+s32 ixgbe_get_link_capabilities_X540(struct ixgbe_hw *hw,
+				     ixgbe_link_speed *speed,
+				     bool *autoneg)
+{
+	ixgbe_get_copper_link_capabilities_generic(hw, speed, autoneg);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_get_media_type_X540 - Get media type
+ * @hw: pointer to hardware structure
+ *
+ * Returns the media type (fiber, copper, backplane)
+ **/
+enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)
+{
+	UNREFERENCED_1PARAMETER(hw);
+	return ixgbe_media_type_copper;
 }
 
 /**
- *  ixgbe_setup_mac_link_X540 - Set the auto advertised capabilitires
- *  @hw: pointer to hardware structure
- *  @speed: new link speed
- *  @autoneg_wait_to_complete: true when waiting for completion is needed
+ * ixgbe_setup_mac_link_X540 - Sets the auto advertised capabilities
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
  **/
-s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw,
+			      ixgbe_link_speed speed,
 			      bool autoneg_wait_to_complete)
 {
-	return hw->phy.ops.setup_link_speed(hw, speed,
-					    autoneg_wait_to_complete);
+	DEBUGFUNC("ixgbe_setup_mac_link_X540");
+	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait_to_complete);
 }
 
 /**
- *  ixgbe_reset_hw_X540 - Perform hardware reset
- *  @hw: pointer to hardware structure
+ * ixgbe_reset_hw_X540 - Perform hardware reset
+ * @hw: pointer to hardware structure
  *
- *  Resets the hardware by resetting the transmit and receive units, masks
- *  and clears all interrupts, perform a PHY reset, and perform a link (MAC)
- *  reset.
+ * Resets the hardware by resetting the transmit and receive units, masks
+ * and clears all interrupts, and perform a reset.
  **/
 s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
 {
@@ -72,41 +179,43 @@ s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
 	u32 ctrl, i;
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
 
+	DEBUGFUNC("ixgbe_reset_hw_X540");
+
 	/* Call adapter stop to disable tx/rx and clear interrupts */
 	status = hw->mac.ops.stop_adapter(hw);
-	if (status)
-		return status;
+	if (status != IXGBE_SUCCESS)
+		goto reset_hw_out;
 
 	/* flush pending Tx transactions */
 	ixgbe_clear_tx_pending(hw);
 
 mac_reset_top:
 	status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
-	if (status) {
-		hw_dbg(hw, "semaphore failed with %d", status);
+	if (status != IXGBE_SUCCESS) {
+		ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+			"semaphore failed with %d", status);
 		return IXGBE_ERR_SWFW_SYNC;
 	}
-
 	ctrl = IXGBE_CTRL_RST;
 	ctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);
 	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
 	IXGBE_WRITE_FLUSH(hw);
 	hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-	usleep_range(1000, 1200);
 
 	/* Poll for reset bit to self-clear indicating reset is complete */
 	for (i = 0; i < 10; i++) {
+		usec_delay(1);
 		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
 		if (!(ctrl & IXGBE_CTRL_RST_MASK))
 			break;
-		udelay(1);
 	}
 
 	if (ctrl & IXGBE_CTRL_RST_MASK) {
 		status = IXGBE_ERR_RESET_FAILED;
-		hw_dbg(hw, "Reset polling failed to complete.\n");
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "Reset polling failed to complete.\n");
 	}
-	msleep(100);
+	msec_delay(100);
 
 	/*
 	 * Double resets are required for recovery from certain error
@@ -129,14 +238,14 @@ s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
 	 * clear the multicast table.  Also reset num_rar_entries to 128,
 	 * since we modify this value when programming the SAN MAC address.
 	 */
-	hw->mac.num_rar_entries = IXGBE_X540_MAX_TX_QUEUES;
+	hw->mac.num_rar_entries = 128;
 	hw->mac.ops.init_rx_addrs(hw);
 
 	/* Store the permanent SAN mac address */
 	hw->mac.ops.get_san_mac_addr(hw, hw->mac.san_addr);
 
 	/* Add the SAN MAC address to the RAR only if it's a valid address */
-	if (is_valid_ether_addr(hw->mac.san_addr)) {
+	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
 		/* Save the SAN MAC RAR index */
 		hw->mac.san_mac_rar_index = hw->mac.num_rar_entries - 1;
 
@@ -155,34 +264,65 @@ s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
 	hw->mac.ops.get_wwn_prefix(hw, &hw->mac.wwnn_prefix,
 				   &hw->mac.wwpn_prefix);
 
+reset_hw_out:
 	return status;
 }
 
 /**
- *  ixgbe_start_hw_X540 - Prepare hardware for Tx/Rx
- *  @hw: pointer to hardware structure
+ * ixgbe_start_hw_X540 - Prepare hardware for Tx/Rx
+ * @hw: pointer to hardware structure
  *
- *  Starts the hardware using the generic start_hw function
- *  and the generation start_hw function.
- *  Then performs revision-specific operations, if any.
+ * Starts the hardware using the generic start_hw function
+ * and the generation start_hw function.
+ * Then performs revision-specific operations, if any.
  **/
 s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)
 {
-	s32 ret_val;
+	s32 ret_val = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_start_hw_X540");
 
 	ret_val = ixgbe_start_hw_generic(hw);
-	if (ret_val)
-		return ret_val;
+	if (ret_val != IXGBE_SUCCESS)
+		goto out;
+
+	ixgbe_start_hw_gen2(hw);
+
+out:
+	return ret_val;
+}
 
-	return ixgbe_start_hw_gen2(hw);
+/**
+ * ixgbe_get_supported_physical_layer_X540 - Returns physical layer type
+ * @hw: pointer to hardware structure
+ *
+ * Determines physical layer capabilities of the current configuration.
+ **/
+u64 ixgbe_get_supported_physical_layer_X540(struct ixgbe_hw *hw)
+{
+	u64 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+	u16 ext_ability = 0;
+
+	DEBUGFUNC("ixgbe_get_supported_physical_layer_X540");
+
+	hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
+	IXGBE_MDIO_PMA_PMD_DEV_TYPE, &ext_ability);
+	if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
+		physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
+	if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
+		physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
+	if (ext_ability & IXGBE_MDIO_PHY_100BASETX_ABILITY)
+		physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
+
+	return physical_layer;
 }
 
 /**
- *  ixgbe_init_eeprom_params_X540 - Initialize EEPROM params
- *  @hw: pointer to hardware structure
+ * ixgbe_init_eeprom_params_X540 - Initialize EEPROM params
+ * @hw: pointer to hardware structure
  *
- *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
- *  ixgbe_hw struct in order to set up EEPROM access.
+ * Initializes the EEPROM parameters ixgbe_eeprom_info within the
+ * ixgbe_hw struct in order to set up EEPROM access.
  **/
 s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)
 {
@@ -190,138 +330,157 @@ s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)
 	u32 eec;
 	u16 eeprom_size;
 
+	DEBUGFUNC("ixgbe_init_eeprom_params_X540");
+
 	if (eeprom->type == ixgbe_eeprom_uninitialized) {
 		eeprom->semaphore_delay = 10;
 		eeprom->type = ixgbe_flash;
 
-		eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+		eec = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 		eeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>
 				    IXGBE_EEC_SIZE_SHIFT);
-		eeprom->word_size = BIT(eeprom_size +
-					IXGBE_EEPROM_WORD_SIZE_SHIFT);
+		eeprom->word_size = 1 << (eeprom_size +
+					  IXGBE_EEPROM_WORD_SIZE_SHIFT);
 
 		hw_dbg(hw, "Eeprom params: type = %d, size = %d\n",
-		       eeprom->type, eeprom->word_size);
+			  eeprom->type, eeprom->word_size);
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_read_eerd_X540- Read EEPROM word using EERD
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @data: word read from the EEPROM
+ * ixgbe_read_eerd_X540- Read EEPROM word using EERD
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @data: word read from the EEPROM
  *
- *  Reads a 16 bit word from the EEPROM using the EERD register.
+ * Reads a 16 bit word from the EEPROM using the EERD register.
  **/
-static s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)
+s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)
 {
-	s32 status;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))
-		return IXGBE_ERR_SWFW_SYNC;
-
-	status = ixgbe_read_eerd_generic(hw, offset, data);
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_read_eerd_X540");
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) ==
+	    IXGBE_SUCCESS) {
+		status = ixgbe_read_eerd_generic(hw, offset, data);
+		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	} else {
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
 
-	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
 	return status;
 }
 
 /**
- *  ixgbe_read_eerd_buffer_X540 - Read EEPROM word(s) using EERD
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @words: number of words
- *  @data: word(s) read from the EEPROM
+ * ixgbe_read_eerd_buffer_X540- Read EEPROM word(s) using EERD
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @words: number of words
+ * @data: word(s) read from the EEPROM
  *
- *  Reads a 16 bit word(s) from the EEPROM using the EERD register.
+ * Reads a 16 bit word(s) from the EEPROM using the EERD register.
  **/
-static s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,
-				       u16 offset, u16 words, u16 *data)
+s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,
+				u16 offset, u16 words, u16 *data)
 {
-	s32 status;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))
-		return IXGBE_ERR_SWFW_SYNC;
-
-	status = ixgbe_read_eerd_buffer_generic(hw, offset, words, data);
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_read_eerd_buffer_X540");
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) ==
+	    IXGBE_SUCCESS) {
+		status = ixgbe_read_eerd_buffer_generic(hw, offset,
+							words, data);
+		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	} else {
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
 
-	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
 	return status;
 }
 
 /**
- *  ixgbe_write_eewr_X540 - Write EEPROM word using EEWR
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @data: word write to the EEPROM
+ * ixgbe_write_eewr_X540 - Write EEPROM word using EEWR
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @data: word write to the EEPROM
  *
- *  Write a 16 bit word to the EEPROM using the EEWR register.
+ * Write a 16 bit word to the EEPROM using the EEWR register.
  **/
-static s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)
+s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)
 {
-	s32 status;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))
-		return IXGBE_ERR_SWFW_SYNC;
-
-	status = ixgbe_write_eewr_generic(hw, offset, data);
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_write_eewr_X540");
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) ==
+	    IXGBE_SUCCESS) {
+		status = ixgbe_write_eewr_generic(hw, offset, data);
+		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	} else {
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
 
-	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
 	return status;
 }
 
 /**
- *  ixgbe_write_eewr_buffer_X540 - Write EEPROM word(s) using EEWR
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @words: number of words
- *  @data: word(s) write to the EEPROM
+ * ixgbe_write_eewr_buffer_X540 - Write EEPROM word(s) using EEWR
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @words: number of words
+ * @data: word(s) write to the EEPROM
  *
- *  Write a 16 bit word(s) to the EEPROM using the EEWR register.
+ * Write a 16 bit word(s) to the EEPROM using the EEWR register.
  **/
-static s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,
-					u16 offset, u16 words, u16 *data)
+s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,
+				 u16 offset, u16 words, u16 *data)
 {
-	s32 status;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))
-		return IXGBE_ERR_SWFW_SYNC;
-
-	status = ixgbe_write_eewr_buffer_generic(hw, offset, words, data);
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_write_eewr_buffer_X540");
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) ==
+	    IXGBE_SUCCESS) {
+		status = ixgbe_write_eewr_buffer_generic(hw, offset,
+							 words, data);
+		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	} else {
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
 
-	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
 	return status;
 }
 
 /**
- *  ixgbe_calc_eeprom_checksum_X540 - Calculates and returns the checksum
+ * ixgbe_calc_eeprom_checksum_X540 - Calculates and returns the checksum
+ *
+ * This function does not use synchronization for EERD and EEWR. It can
+ * be used internally by function which utilize ixgbe_acquire_swfw_sync_X540.
  *
- *  This function does not use synchronization for EERD and EEWR. It can
- *  be used internally by function which utilize ixgbe_acquire_swfw_sync_X540.
+ * @hw: pointer to hardware structure
  *
- *  @hw: pointer to hardware structure
+ * Returns a negative error code on error, or the 16-bit checksum
  **/
-static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
+s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
 {
-	u16 i;
-	u16 j;
+	u16 i, j;
 	u16 checksum = 0;
 	u16 length = 0;
 	u16 pointer = 0;
 	u16 word = 0;
-	u16 checksum_last_word = IXGBE_EEPROM_CHECKSUM;
 	u16 ptr_start = IXGBE_PCIE_ANALOG_PTR;
 
-	/*
-	 * Do not use hw->eeprom.ops.read because we do not want to take
+	/* Do not use hw->eeprom.ops.read because we do not want to take
 	 * the synchronization semaphores here. Instead use
 	 * ixgbe_read_eerd_generic
 	 */
 
-	/* Include 0x0-0x3F in the checksum */
-	for (i = 0; i < checksum_last_word; i++) {
+	DEBUGFUNC("ixgbe_calc_eeprom_checksum_X540");
+
+	/* Include 0x0 up to IXGBE_EEPROM_CHECKSUM; do not include the
+	 * checksum itself
+	 */
+	for (i = 0; i < IXGBE_EEPROM_CHECKSUM; i++) {
 		if (ixgbe_read_eerd_generic(hw, i, &word)) {
 			hw_dbg(hw, "EEPROM read failed\n");
 			return IXGBE_ERR_EEPROM;
@@ -329,8 +488,7 @@ static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
 		checksum += word;
 	}
 
-	/*
-	 * Include all data from pointers 0x3, 0x6-0xE.  This excludes the
+	/* Include all data from pointers 0x3, 0x6-0xE.  This excludes the
 	 * FW, PHY module, and PCIe Expansion/Option ROM pointers.
 	 */
 	for (i = ptr_start; i < IXGBE_FW_PTR; i++) {
@@ -339,7 +497,7 @@ static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
 
 		if (ixgbe_read_eerd_generic(hw, i, &pointer)) {
 			hw_dbg(hw, "EEPROM read failed\n");
-			break;
+			return IXGBE_ERR_EEPROM;
 		}
 
 		/* Skip pointer section if the pointer is invalid. */
@@ -372,20 +530,22 @@ static s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
 }
 
 /**
- *  ixgbe_validate_eeprom_checksum_X540 - Validate EEPROM checksum
- *  @hw: pointer to hardware structure
- *  @checksum_val: calculated checksum
+ * ixgbe_validate_eeprom_checksum_X540 - Validate EEPROM checksum
+ * @hw: pointer to hardware structure
+ * @checksum_val: calculated checksum
  *
- *  Performs checksum calculation and validates the EEPROM checksum.  If the
- *  caller does not need checksum_val, the value can be NULL.
+ * Performs checksum calculation and validates the EEPROM checksum.  If the
+ * caller does not need checksum_val, the value can be NULL.
  **/
-static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,
-					       u16 *checksum_val)
+s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,
+					u16 *checksum_val)
 {
 	s32 status;
 	u16 checksum;
 	u16 read_checksum = 0;
 
+	DEBUGFUNC("ixgbe_validate_eeprom_checksum_X540");
+
 	/* Read the first word from the EEPROM. If this times out or fails, do
 	 * not continue or we could be in for a very long wait while every
 	 * EEPROM read fails
@@ -417,7 +577,8 @@ static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,
 	 * calculated checksum
 	 */
 	if (read_checksum != checksum) {
-		hw_dbg(hw, "Invalid EEPROM checksum");
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+			     "Invalid EEPROM checksum");
 		status = IXGBE_ERR_EEPROM_CHECKSUM;
 	}
 
@@ -439,11 +600,13 @@ static s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,
  * checksum and updates the EEPROM and instructs the hardware to update
  * the flash.
  **/
-static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
+s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
 {
 	s32 status;
 	u16 checksum;
 
+	DEBUGFUNC("ixgbe_update_eeprom_checksum_X540");
+
 	/* Read the first word from the EEPROM. If this times out or fails, do
 	 * not continue or we could be in for a very long wait while every
 	 * EEPROM read fails
@@ -455,7 +618,7 @@ static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
 	}
 
 	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM))
-		return  IXGBE_ERR_SWFW_SYNC;
+		return IXGBE_ERR_SWFW_SYNC;
 
 	status = hw->eeprom.ops.calc_checksum(hw);
 	if (status < 0)
@@ -474,6 +637,7 @@ static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
 
 out:
 	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+
 	return status;
 }
 
@@ -484,41 +648,43 @@ static s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
  * Set FLUP (bit 23) of the EEC register to instruct Hardware to copy
  * EEPROM from shadow RAM to the flash device.
  **/
-static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
+s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
 {
 	u32 flup;
 	s32 status;
 
+	DEBUGFUNC("ixgbe_update_flash_X540");
+
 	status = ixgbe_poll_flash_update_done_X540(hw);
 	if (status == IXGBE_ERR_EEPROM) {
 		hw_dbg(hw, "Flash update time out\n");
-		return status;
+		goto out;
 	}
 
-	flup = IXGBE_READ_REG(hw, IXGBE_EEC(hw)) | IXGBE_EEC_FLUP;
-	IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);
+	flup = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw)) | IXGBE_EEC_FLUP;
+	IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), flup);
 
 	status = ixgbe_poll_flash_update_done_X540(hw);
-	if (status == 0)
+	if (status == IXGBE_SUCCESS)
 		hw_dbg(hw, "Flash update complete\n");
 	else
 		hw_dbg(hw, "Flash update time out\n");
 
-	if (hw->revision_id == 0) {
-		flup = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
+	if (hw->mac.type == ixgbe_mac_X540 && hw->revision_id == 0) {
+		flup = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
 
 		if (flup & IXGBE_EEC_SEC1VAL) {
 			flup |= IXGBE_EEC_FLUP;
-			IXGBE_WRITE_REG(hw, IXGBE_EEC(hw), flup);
+			IXGBE_WRITE_REG(hw, IXGBE_EEC_BY_MAC(hw), flup);
 		}
 
 		status = ixgbe_poll_flash_update_done_X540(hw);
-		if (status == 0)
+		if (status == IXGBE_SUCCESS)
 			hw_dbg(hw, "Flash update complete\n");
 		else
 			hw_dbg(hw, "Flash update time out\n");
 	}
-
+out:
 	return status;
 }
 
@@ -529,18 +695,28 @@ static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
  * Polls the FLUDONE (bit 26) of the EEC Register to determine when the
  * flash update is done.
  **/
-static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
 {
 	u32 i;
 	u32 reg;
+	s32 status = IXGBE_ERR_EEPROM;
+
+	DEBUGFUNC("ixgbe_poll_flash_update_done_X540");
 
 	for (i = 0; i < IXGBE_FLUDONE_ATTEMPTS; i++) {
-		reg = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
-		if (reg & IXGBE_EEC_FLUDONE)
-			return 0;
-		udelay(5);
+		reg = IXGBE_READ_REG(hw, IXGBE_EEC_BY_MAC(hw));
+		if (reg & IXGBE_EEC_FLUDONE) {
+			status = IXGBE_SUCCESS;
+			break;
+		}
+		msec_delay(5);
 	}
-	return IXGBE_ERR_EEPROM;
+
+	if (i == IXGBE_FLUDONE_ATTEMPTS)
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "Flash update status polling timed out");
+
+	return status;
 }
 
 /**
@@ -554,43 +730,50 @@ static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
 s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
 {
 	u32 swmask = mask & IXGBE_GSSR_NVM_PHY_MASK;
-	u32 swi2c_mask = mask & IXGBE_GSSR_I2C_MASK;
 	u32 fwmask = swmask << 5;
+	u32 swi2c_mask = mask & IXGBE_GSSR_I2C_MASK;
 	u32 timeout = 200;
 	u32 hwmask = 0;
 	u32 swfw_sync;
 	u32 i;
 
+	DEBUGFUNC("ixgbe_acquire_swfw_sync_X540");
+
 	if (swmask & IXGBE_GSSR_EEP_SM)
-		hwmask = IXGBE_GSSR_FLASH_SM;
+		hwmask |= IXGBE_GSSR_FLASH_SM;
 
-	/* SW only mask does not have FW bit pair */
+	/* SW only mask doesn't have FW bit pair */
 	if (mask & IXGBE_GSSR_SW_MNG_SM)
 		swmask |= IXGBE_GSSR_SW_MNG_SM;
 
 	swmask |= swi2c_mask;
 	fwmask |= swi2c_mask << 2;
+	if (hw->mac.type >= ixgbe_mac_X550)
+		timeout = 1000;
+
 	for (i = 0; i < timeout; i++) {
 		/* SW NVM semaphore bit is used for access to all
 		 * SW_FW_SYNC bits (not just NVM)
 		 */
-		if (ixgbe_get_swfw_sync_semaphore(hw))
+		if (ixgbe_get_swfw_sync_semaphore(hw)) {
+			hw_dbg(hw, "Failed to get NVM access and register semaphore, returning IXGBE_ERR_SWFW_SYNC\n");
 			return IXGBE_ERR_SWFW_SYNC;
+		}
 
-		swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));
+		swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw));
 		if (!(swfw_sync & (fwmask | swmask | hwmask))) {
 			swfw_sync |= swmask;
-			IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);
+			IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw),
+					swfw_sync);
 			ixgbe_release_swfw_sync_semaphore(hw);
-			usleep_range(5000, 6000);
-			return 0;
+			return IXGBE_SUCCESS;
 		}
 		/* Firmware currently using resource (fwmask), hardware
 		 * currently using resource (hwmask), or other software
 		 * thread currently using resource (swmask)
 		 */
 		ixgbe_release_swfw_sync_semaphore(hw);
-		usleep_range(5000, 10000);
+		msec_delay(5);
 	}
 
 	/* If the resource is not released by the FW/HW the SW can assume that
@@ -598,15 +781,17 @@ s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
 	 * of the requested resource(s) while ignoring the corresponding FW/HW
 	 * bits in the SW_FW_SYNC register.
 	 */
-	if (ixgbe_get_swfw_sync_semaphore(hw))
+	if (ixgbe_get_swfw_sync_semaphore(hw)) {
+		hw_dbg(hw, "Failed to get NVM sempahore and register semaphore while forcefully ignoring FW sempahore bit(s) and setting SW semaphore bit(s), returning IXGBE_ERR_SWFW_SYNC\n");
 		return IXGBE_ERR_SWFW_SYNC;
-	swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));
+	}
+	swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw));
 	if (swfw_sync & (fwmask | hwmask)) {
 		swfw_sync |= swmask;
-		IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);
+		IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw), swfw_sync);
 		ixgbe_release_swfw_sync_semaphore(hw);
-		usleep_range(5000, 6000);
-		return 0;
+		msec_delay(5);
+		return IXGBE_SUCCESS;
 	}
 	/* If the resource is not released by other SW the SW can assume that
 	 * the other SW malfunctions. In that case the SW should clear all SW
@@ -622,9 +807,11 @@ s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
 			rmask |= IXGBE_GSSR_I2C_MASK;
 		ixgbe_release_swfw_sync_X540(hw, rmask);
 		ixgbe_release_swfw_sync_semaphore(hw);
+		hw_dbg(hw, "Resource not released by other SW, returning IXGBE_ERR_SWFW_SYNC\n");
 		return IXGBE_ERR_SWFW_SYNC;
 	}
 	ixgbe_release_swfw_sync_semaphore(hw);
+	hw_dbg(hw, "Returning error IXGBE_ERR_SWFW_SYNC\n");
 
 	return IXGBE_ERR_SWFW_SYNC;
 }
@@ -642,16 +829,18 @@ void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
 	u32 swmask = mask & (IXGBE_GSSR_NVM_PHY_MASK | IXGBE_GSSR_SW_MNG_SM);
 	u32 swfw_sync;
 
+	DEBUGFUNC("ixgbe_release_swfw_sync_X540");
+
 	if (mask & IXGBE_GSSR_I2C_MASK)
 		swmask |= mask & IXGBE_GSSR_I2C_MASK;
 	ixgbe_get_swfw_sync_semaphore(hw);
 
-	swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));
+	swfw_sync = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw));
 	swfw_sync &= ~swmask;
-	IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swfw_sync);
+	IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw), swfw_sync);
 
 	ixgbe_release_swfw_sync_semaphore(hw);
-	usleep_range(5000, 6000);
+	msec_delay(2);
 }
 
 /**
@@ -659,76 +848,90 @@ void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask)
  * @hw: pointer to hardware structure
  *
  * Sets the hardware semaphores so SW/FW can gain control of shared resources
- */
-static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
+ **/
+STATIC s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_ERR_EEPROM;
 	u32 timeout = 2000;
 	u32 i;
 	u32 swsm;
 
+	DEBUGFUNC("ixgbe_get_swfw_sync_semaphore");
+
 	/* Get SMBI software semaphore between device drivers first */
 	for (i = 0; i < timeout; i++) {
-		/* If the SMBI bit is 0 when we read it, then the bit will be
+		/*
+		 * If the SMBI bit is 0 when we read it, then the bit will be
 		 * set and we have the semaphore
 		 */
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
-		if (!(swsm & IXGBE_SWSM_SMBI))
+		swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
+		if (!(swsm & IXGBE_SWSM_SMBI)) {
+			status = IXGBE_SUCCESS;
 			break;
-		usleep_range(50, 100);
-	}
-
-	if (i == timeout) {
-		hw_dbg(hw,
-		       "Software semaphore SMBI between device drivers not granted.\n");
-		return IXGBE_ERR_EEPROM;
+		}
+		usec_delay(50);
 	}
 
 	/* Now get the semaphore between SW/FW through the REGSMP bit */
-	for (i = 0; i < timeout; i++) {
-		swsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));
-		if (!(swsm & IXGBE_SWFW_REGSMP))
-			return 0;
+	if (status == IXGBE_SUCCESS) {
+		for (i = 0; i < timeout; i++) {
+			swsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw));
+			if (!(swsm & IXGBE_SWFW_REGSMP))
+				break;
 
-		usleep_range(50, 100);
+			usec_delay(50);
+		}
+
+		/*
+		 * Release semaphores and return error if SW NVM semaphore
+		 * was not granted because we don't have access to the EEPROM
+		 */
+		if (i >= timeout) {
+			ERROR_REPORT1(IXGBE_ERROR_POLLING,
+				"REGSMP Software NVM semaphore not granted.\n");
+			ixgbe_release_swfw_sync_semaphore(hw);
+			status = IXGBE_ERR_EEPROM;
+		}
+	} else {
+		ERROR_REPORT1(IXGBE_ERROR_POLLING,
+			     "Software semaphore SMBI between device drivers "
+			     "not granted.\n");
 	}
 
-	/* Release semaphores and return error if SW NVM semaphore
-	 * was not granted because we do not have access to the EEPROM
-	 */
-	hw_dbg(hw, "REGSMP Software NVM semaphore not granted\n");
-	ixgbe_release_swfw_sync_semaphore(hw);
-	return IXGBE_ERR_EEPROM;
+	return status;
 }
 
 /**
- * ixgbe_release_nvm_semaphore - Release hardware semaphore
+ * ixgbe_release_swfw_sync_semaphore - Release hardware semaphore
  * @hw: pointer to hardware structure
  *
  * This function clears hardware semaphore bits.
  **/
-static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
+STATIC void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
 {
-	 u32 swsm;
+	u32 swsm;
+
+	DEBUGFUNC("ixgbe_release_swfw_sync_semaphore");
 
 	/* Release both semaphores by writing 0 to the bits REGSMP and SMBI */
 
-	swsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC(hw));
+	swsm = IXGBE_READ_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw));
 	swsm &= ~IXGBE_SWFW_REGSMP;
-	IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC(hw), swsm);
+	IXGBE_WRITE_REG(hw, IXGBE_SWFW_SYNC_BY_MAC(hw), swsm);
 
-	swsm = IXGBE_READ_REG(hw, IXGBE_SWSM(hw));
+	swsm = IXGBE_READ_REG(hw, IXGBE_SWSM_BY_MAC(hw));
 	swsm &= ~IXGBE_SWSM_SMBI;
-	IXGBE_WRITE_REG(hw, IXGBE_SWSM(hw), swsm);
+	IXGBE_WRITE_REG(hw, IXGBE_SWSM_BY_MAC(hw), swsm);
 
 	IXGBE_WRITE_FLUSH(hw);
 }
 
 /**
- *  ixgbe_init_swfw_sync_X540 - Release hardware semaphore
- *  @hw: pointer to hardware structure
+ * ixgbe_init_swfw_sync_X540 - Release hardware semaphore
+ * @hw: pointer to hardware structure
  *
- *  This function reset hardware semaphore bits for a semaphore that may
- *  have be left locked due to a catastrophic failure.
+ * This function reset hardware semaphore bits for a semaphore that may
+ * have be left locked due to a catastrophic failure.
  **/
 void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)
 {
@@ -746,8 +949,9 @@ void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)
 	/* Acquire and release all software resources. */
 	rmask = IXGBE_GSSR_EEP_SM | IXGBE_GSSR_PHY0_SM |
 		IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_MAC_CSR_SM |
-		IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_I2C_MASK;
+		IXGBE_GSSR_SW_MNG_SM;
 
+	rmask |= IXGBE_GSSR_I2C_MASK;
 	ixgbe_acquire_swfw_sync_X540(hw, rmask);
 	ixgbe_release_swfw_sync_X540(hw, rmask);
 }
@@ -758,7 +962,7 @@ void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw)
  * @index: led number to blink
  *
  * Devices that implement the version 2 interface:
- *   X540
+ *  X540
  **/
 s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
 {
@@ -767,15 +971,18 @@ s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
 	ixgbe_link_speed speed;
 	bool link_up;
 
+	DEBUGFUNC("ixgbe_blink_led_start_X540");
+
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
 
-	/* Link should be up in order for the blink bit in the LED control
+	/*
+	 * Link should be up in order for the blink bit in the LED control
 	 * register to work. Force link and speed in the MAC if link is down.
 	 * This will be reversed when we stop the blinking.
 	 */
 	hw->mac.ops.check_link(hw, &speed, &link_up, false);
-	if (!link_up) {
+	if (link_up == false) {
 		macc_reg = IXGBE_READ_REG(hw, IXGBE_MACC);
 		macc_reg |= IXGBE_MACC_FLU | IXGBE_MACC_FSV_10G | IXGBE_MACC_FS;
 		IXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);
@@ -787,7 +994,7 @@ s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_LEDCTL, ledctl_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -796,7 +1003,7 @@ s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
  * @index: led number to stop blinking
  *
  * Devices that implement the version 2 interface:
- *   X540
+ *  X540
  **/
 s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)
 {
@@ -806,6 +1013,8 @@ s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)
 	if (index > 3)
 		return IXGBE_ERR_PARAM;
 
+	DEBUGFUNC("ixgbe_blink_led_stop_X540");
+
 	/* Restore the LED to its default value. */
 	ledctl_reg = IXGBE_READ_REG(hw, IXGBE_LEDCTL);
 	ledctl_reg &= ~IXGBE_LED_MODE_MASK(index);
@@ -819,104 +1028,5 @@ s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)
 	IXGBE_WRITE_REG(hw, IXGBE_MACC, macc_reg);
 	IXGBE_WRITE_FLUSH(hw);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
-static const struct ixgbe_mac_operations mac_ops_X540 = {
-	.init_hw                = &ixgbe_init_hw_generic,
-	.reset_hw               = &ixgbe_reset_hw_X540,
-	.start_hw               = &ixgbe_start_hw_X540,
-	.clear_hw_cntrs         = &ixgbe_clear_hw_cntrs_generic,
-	.get_media_type         = &ixgbe_get_media_type_X540,
-	.enable_rx_dma          = &ixgbe_enable_rx_dma_generic,
-	.get_mac_addr           = &ixgbe_get_mac_addr_generic,
-	.get_san_mac_addr       = &ixgbe_get_san_mac_addr_generic,
-	.get_device_caps        = &ixgbe_get_device_caps_generic,
-	.get_wwn_prefix         = &ixgbe_get_wwn_prefix_generic,
-	.stop_adapter           = &ixgbe_stop_adapter_generic,
-	.get_bus_info           = &ixgbe_get_bus_info_generic,
-	.set_lan_id             = &ixgbe_set_lan_id_multi_port_pcie,
-	.read_analog_reg8       = NULL,
-	.write_analog_reg8      = NULL,
-	.setup_link             = &ixgbe_setup_mac_link_X540,
-	.set_rxpba		= &ixgbe_set_rxpba_generic,
-	.check_link             = &ixgbe_check_mac_link_generic,
-	.get_link_capabilities  = &ixgbe_get_copper_link_capabilities_generic,
-	.led_on                 = &ixgbe_led_on_generic,
-	.led_off                = &ixgbe_led_off_generic,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.blink_led_start        = &ixgbe_blink_led_start_X540,
-	.blink_led_stop         = &ixgbe_blink_led_stop_X540,
-	.set_rar                = &ixgbe_set_rar_generic,
-	.clear_rar              = &ixgbe_clear_rar_generic,
-	.set_vmdq               = &ixgbe_set_vmdq_generic,
-	.set_vmdq_san_mac	= &ixgbe_set_vmdq_san_mac_generic,
-	.clear_vmdq             = &ixgbe_clear_vmdq_generic,
-	.init_rx_addrs          = &ixgbe_init_rx_addrs_generic,
-	.update_mc_addr_list    = &ixgbe_update_mc_addr_list_generic,
-	.enable_mc              = &ixgbe_enable_mc_generic,
-	.disable_mc             = &ixgbe_disable_mc_generic,
-	.clear_vfta             = &ixgbe_clear_vfta_generic,
-	.set_vfta               = &ixgbe_set_vfta_generic,
-	.fc_enable              = &ixgbe_fc_enable_generic,
-	.setup_fc		= ixgbe_setup_fc_generic,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.set_fw_drv_ver         = &ixgbe_set_fw_drv_ver_generic,
-	.init_uta_tables        = &ixgbe_init_uta_tables_generic,
-	.setup_sfp              = NULL,
-	.set_mac_anti_spoofing  = &ixgbe_set_mac_anti_spoofing,
-	.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing,
-	.acquire_swfw_sync      = &ixgbe_acquire_swfw_sync_X540,
-	.release_swfw_sync      = &ixgbe_release_swfw_sync_X540,
-	.init_swfw_sync		= &ixgbe_init_swfw_sync_X540,
-	.disable_rx_buff	= &ixgbe_disable_rx_buff_generic,
-	.enable_rx_buff		= &ixgbe_enable_rx_buff_generic,
-	.get_thermal_sensor_data = NULL,
-	.init_thermal_sensor_thresh = NULL,
-	.prot_autoc_read	= &prot_autoc_read_generic,
-	.prot_autoc_write	= &prot_autoc_write_generic,
-	.enable_rx		= &ixgbe_enable_rx_generic,
-	.disable_rx		= &ixgbe_disable_rx_generic,
-};
-
-static const struct ixgbe_eeprom_operations eeprom_ops_X540 = {
-	.init_params            = &ixgbe_init_eeprom_params_X540,
-	.read                   = &ixgbe_read_eerd_X540,
-	.read_buffer		= &ixgbe_read_eerd_buffer_X540,
-	.write                  = &ixgbe_write_eewr_X540,
-	.write_buffer		= &ixgbe_write_eewr_buffer_X540,
-	.calc_checksum		= &ixgbe_calc_eeprom_checksum_X540,
-	.validate_checksum      = &ixgbe_validate_eeprom_checksum_X540,
-	.update_checksum        = &ixgbe_update_eeprom_checksum_X540,
-};
-
-static const struct ixgbe_phy_operations phy_ops_X540 = {
-	.identify               = &ixgbe_identify_phy_generic,
-	.identify_sfp           = &ixgbe_identify_sfp_module_generic,
-	.init			= NULL,
-	.reset                  = NULL,
-	.read_reg               = &ixgbe_read_phy_reg_generic,
-	.write_reg              = &ixgbe_write_phy_reg_generic,
-	.setup_link             = &ixgbe_setup_phy_link_generic,
-	.setup_link_speed       = &ixgbe_setup_phy_link_speed_generic,
-	.read_i2c_byte          = &ixgbe_read_i2c_byte_generic,
-	.write_i2c_byte         = &ixgbe_write_i2c_byte_generic,
-	.read_i2c_sff8472	= &ixgbe_read_i2c_sff8472_generic,
-	.read_i2c_eeprom        = &ixgbe_read_i2c_eeprom_generic,
-	.write_i2c_eeprom       = &ixgbe_write_i2c_eeprom_generic,
-	.check_overtemp         = &ixgbe_tn_check_overtemp,
-	.set_phy_power          = &ixgbe_set_copper_phy_power,
-};
-
-static const u32 ixgbe_mvals_X540[IXGBE_MVALS_IDX_LIMIT] = {
-	IXGBE_MVALS_INIT(X540)
-};
-
-const struct ixgbe_info ixgbe_X540_info = {
-	.mac                    = ixgbe_mac_X540,
-	.get_invariants         = &ixgbe_get_invariants_X540,
-	.mac_ops                = &mac_ops_X540,
-	.eeprom_ops             = &eeprom_ops_X540,
-	.phy_ops                = &phy_ops_X540,
-	.mbx_ops                = &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_X540,
-};
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h
index e246c0d2a427..82f60bd2d98a 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x540.h
@@ -1,19 +1,37 @@
 /* SPDX-License-Identifier: GPL-2.0 */
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_X540_H_
+#define _IXGBE_X540_H_
 
 #include "ixgbe_type.h"
 
-s32 ixgbe_get_invariants_X540(struct ixgbe_hw *hw);
+s32 ixgbe_get_link_capabilities_X540(struct ixgbe_hw *hw,
+				     ixgbe_link_speed *speed, bool *autoneg);
+enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw);
 s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,
-			      bool autoneg_wait_to_complete);
+			      bool link_up_wait_to_complete);
 s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw);
 s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw);
-enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw);
-s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,
-			      bool autoneg_wait_to_complete);
-s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index);
-s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index);
+u64 ixgbe_get_supported_physical_layer_X540(struct ixgbe_hw *hw);
+
+s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw);
+s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data);
+s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words,
+				u16 *data);
+s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data);
+s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words,
+				 u16 *data);
+s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw);
+s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw, u16 *checksum_val);
+s32 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw);
+s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw);
+
 s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask);
 void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u32 mask);
 void ixgbe_init_swfw_sync_X540(struct ixgbe_hw *hw);
-s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw);
+
+s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index);
+s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index);
+#endif /* _IXGBE_X540_H_ */
+
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
index 5e339afa682a..df2f37f214f4 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c
@@ -1,86 +1,75 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 1999 - 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
+#include "ixgbe_x550.h"
 #include "ixgbe_x540.h"
 #include "ixgbe_type.h"
+#include "ixgbe_api.h"
 #include "ixgbe_common.h"
 #include "ixgbe_phy.h"
 
-static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *, ixgbe_link_speed);
-static s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *);
-static void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *);
-static void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *);
-static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *);
+STATIC s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed);
+STATIC s32 ixgbe_acquire_swfw_sync_X550a(struct ixgbe_hw *, u32 mask);
+STATIC void ixgbe_release_swfw_sync_X550a(struct ixgbe_hw *, u32 mask);
+STATIC s32 ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw);
 
-static s32 ixgbe_get_invariants_X550_x(struct ixgbe_hw *hw)
-{
-	struct ixgbe_mac_info *mac = &hw->mac;
-	struct ixgbe_phy_info *phy = &hw->phy;
-	struct ixgbe_link_info *link = &hw->link;
-
-	/* Start with X540 invariants, since so simular */
-	ixgbe_get_invariants_X540(hw);
-
-	if (mac->ops.get_media_type(hw) != ixgbe_media_type_copper)
-		phy->ops.set_phy_power = NULL;
-
-	link->addr = IXGBE_CS4227;
-
-	return 0;
-}
-
-static s32 ixgbe_get_invariants_X550_x_fw(struct ixgbe_hw *hw)
-{
-	struct ixgbe_phy_info *phy = &hw->phy;
-
-	/* Start with X540 invariants, since so similar */
-	ixgbe_get_invariants_X540(hw);
-
-	phy->ops.set_phy_power = NULL;
-
-	return 0;
-}
-
-static s32 ixgbe_get_invariants_X550_a(struct ixgbe_hw *hw)
-{
-	struct ixgbe_mac_info *mac = &hw->mac;
-	struct ixgbe_phy_info *phy = &hw->phy;
-
-	/* Start with X540 invariants, since so simular */
-	ixgbe_get_invariants_X540(hw);
-
-	if (mac->ops.get_media_type(hw) != ixgbe_media_type_copper)
-		phy->ops.set_phy_power = NULL;
-
-	return 0;
-}
-
-static s32 ixgbe_get_invariants_X550_a_fw(struct ixgbe_hw *hw)
-{
-	struct ixgbe_phy_info *phy = &hw->phy;
-
-	/* Start with X540 invariants, since so similar */
-	ixgbe_get_invariants_X540(hw);
-
-	phy->ops.set_phy_power = NULL;
-
-	return 0;
-}
-
-/** ixgbe_setup_mux_ctl - Setup ESDP register for I2C mux control
- *  @hw: pointer to hardware structure
+/**
+ * ixgbe_init_ops_X550 - Inits func ptrs and MAC type
+ * @hw: pointer to hardware structure
+ *
+ * Initialize the function pointers and assign the MAC type for X550.
+ * Does not touch the hardware.
  **/
-static void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw)
+s32 ixgbe_init_ops_X550(struct ixgbe_hw *hw)
 {
-	u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
+	struct ixgbe_mac_info *mac = &hw->mac;
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	s32 ret_val;
 
-	if (hw->bus.lan_id) {
-		esdp &= ~(IXGBE_ESDP_SDP1_NATIVE | IXGBE_ESDP_SDP1);
-		esdp |= IXGBE_ESDP_SDP1_DIR;
+	DEBUGFUNC("ixgbe_init_ops_X550");
+
+	ret_val = ixgbe_init_ops_X540(hw);
+	mac->ops.dmac_config = ixgbe_dmac_config_X550;
+	mac->ops.dmac_config_tcs = ixgbe_dmac_config_tcs_X550;
+	mac->ops.dmac_update_tcs = ixgbe_dmac_update_tcs_X550;
+	mac->ops.setup_eee = NULL;
+	mac->ops.set_source_address_pruning =
+			ixgbe_set_source_address_pruning_X550;
+	mac->ops.set_ethertype_anti_spoofing =
+			ixgbe_set_ethertype_anti_spoofing_X550;
+
+	mac->ops.get_rtrup2tc = ixgbe_dcb_get_rtrup2tc_generic;
+	eeprom->ops.init_params = ixgbe_init_eeprom_params_X550;
+	eeprom->ops.calc_checksum = ixgbe_calc_eeprom_checksum_X550;
+	eeprom->ops.read = ixgbe_read_ee_hostif_X550;
+	eeprom->ops.read_buffer = ixgbe_read_ee_hostif_buffer_X550;
+	eeprom->ops.write = ixgbe_write_ee_hostif_X550;
+	eeprom->ops.write_buffer = ixgbe_write_ee_hostif_buffer_X550;
+	eeprom->ops.update_checksum = ixgbe_update_eeprom_checksum_X550;
+	eeprom->ops.validate_checksum = ixgbe_validate_eeprom_checksum_X550;
+
+	mac->ops.disable_mdd = ixgbe_disable_mdd_X550;
+	mac->ops.enable_mdd = ixgbe_enable_mdd_X550;
+	mac->ops.mdd_event = ixgbe_mdd_event_X550;
+	mac->ops.restore_mdd_vf = ixgbe_restore_mdd_vf_X550;
+	mac->ops.fw_recovery_mode = ixgbe_fw_recovery_mode_X550;
+	mac->ops.disable_rx = ixgbe_disable_rx_x550;
+	/* Manageability interface */
+	mac->ops.set_fw_drv_ver = ixgbe_set_fw_drv_ver_x550;
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_X_1G_T:
+		hw->mac.ops.led_on = NULL;
+		hw->mac.ops.led_off = NULL;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_10G_T:
+		hw->mac.ops.led_on = ixgbe_led_on_t_X550em;
+		hw->mac.ops.led_off = ixgbe_led_off_t_X550em;
+		break;
+	default:
+		break;
 	}
-	esdp &= ~(IXGBE_ESDP_SDP0_NATIVE | IXGBE_ESDP_SDP0_DIR);
-	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
-	IXGBE_WRITE_FLUSH(hw);
+	return ret_val;
 }
 
 /**
@@ -90,8 +79,8 @@ static void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw)
  * @value: pointer to receive value read
  *
  * Returns status code
- */
-static s32 ixgbe_read_cs4227(struct ixgbe_hw *hw, u16 reg, u16 *value)
+ **/
+STATIC s32 ixgbe_read_cs4227(struct ixgbe_hw *hw, u16 reg, u16 *value)
 {
 	return hw->link.ops.read_link_unlocked(hw, hw->link.addr, reg, value);
 }
@@ -103,8 +92,8 @@ static s32 ixgbe_read_cs4227(struct ixgbe_hw *hw, u16 reg, u16 *value)
  * @value: value to write to register
  *
  * Returns status code
- */
-static s32 ixgbe_write_cs4227(struct ixgbe_hw *hw, u16 reg, u16 value)
+ **/
+STATIC s32 ixgbe_write_cs4227(struct ixgbe_hw *hw, u16 reg, u16 value)
 {
 	return hw->link.ops.write_link_unlocked(hw, hw->link.addr, reg, value);
 }
@@ -116,14 +105,15 @@ static s32 ixgbe_write_cs4227(struct ixgbe_hw *hw, u16 reg, u16 value)
  * @value: pointer to receive read value
  *
  * Returns status code
- */
-static s32 ixgbe_read_pe(struct ixgbe_hw *hw, u8 reg, u8 *value)
+ **/
+STATIC s32 ixgbe_read_pe(struct ixgbe_hw *hw, u8 reg, u8 *value)
 {
 	s32 status;
 
-	status = ixgbe_read_i2c_byte_generic_unlocked(hw, reg, IXGBE_PE, value);
-	if (status)
-		hw_err(hw, "port expander access failed with %d\n", status);
+	status = ixgbe_read_i2c_byte_unlocked(hw, reg, IXGBE_PE, value);
+	if (status != IXGBE_SUCCESS)
+		ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+			      "port expander access failed with %d\n", status);
 	return status;
 }
 
@@ -134,15 +124,15 @@ static s32 ixgbe_read_pe(struct ixgbe_hw *hw, u8 reg, u8 *value)
  * @value: value to write
  *
  * Returns status code
- */
-static s32 ixgbe_write_pe(struct ixgbe_hw *hw, u8 reg, u8 value)
+ **/
+STATIC s32 ixgbe_write_pe(struct ixgbe_hw *hw, u8 reg, u8 value)
 {
 	s32 status;
 
-	status = ixgbe_write_i2c_byte_generic_unlocked(hw, reg, IXGBE_PE,
-						       value);
-	if (status)
-		hw_err(hw, "port expander access failed with %d\n", status);
+	status = ixgbe_write_i2c_byte_unlocked(hw, reg, IXGBE_PE, value);
+	if (status != IXGBE_SUCCESS)
+		ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+			      "port expander access failed with %d\n", status);
 	return status;
 }
 
@@ -152,8 +142,8 @@ static s32 ixgbe_write_pe(struct ixgbe_hw *hw, u8 reg, u8 value)
  *
  * This function assumes that the caller has acquired the proper semaphore.
  * Returns error code
- */
-static s32 ixgbe_reset_cs4227(struct ixgbe_hw *hw)
+ **/
+STATIC s32 ixgbe_reset_cs4227(struct ixgbe_hw *hw)
 {
 	s32 status;
 	u32 retry;
@@ -162,106 +152,117 @@ static s32 ixgbe_reset_cs4227(struct ixgbe_hw *hw)
 
 	/* Trigger hard reset. */
 	status = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 	reg |= IXGBE_PE_BIT1;
 	status = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	status = ixgbe_read_pe(hw, IXGBE_PE_CONFIG, &reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 	reg &= ~IXGBE_PE_BIT1;
 	status = ixgbe_write_pe(hw, IXGBE_PE_CONFIG, reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	status = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 	reg &= ~IXGBE_PE_BIT1;
 	status = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	usleep_range(IXGBE_CS4227_RESET_HOLD, IXGBE_CS4227_RESET_HOLD + 100);
+	usec_delay(IXGBE_CS4227_RESET_HOLD);
 
 	status = ixgbe_read_pe(hw, IXGBE_PE_OUTPUT, &reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 	reg |= IXGBE_PE_BIT1;
 	status = ixgbe_write_pe(hw, IXGBE_PE_OUTPUT, reg);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* Wait for the reset to complete. */
-	msleep(IXGBE_CS4227_RESET_DELAY);
+	msec_delay(IXGBE_CS4227_RESET_DELAY);
 	for (retry = 0; retry < IXGBE_CS4227_RETRIES; retry++) {
 		status = ixgbe_read_cs4227(hw, IXGBE_CS4227_EFUSE_STATUS,
 					   &value);
-		if (!status && value == IXGBE_CS4227_EEPROM_LOAD_OK)
+		if (status == IXGBE_SUCCESS &&
+		    value == IXGBE_CS4227_EEPROM_LOAD_OK)
 			break;
-		msleep(IXGBE_CS4227_CHECK_DELAY);
+		msec_delay(IXGBE_CS4227_CHECK_DELAY);
 	}
 	if (retry == IXGBE_CS4227_RETRIES) {
-		hw_err(hw, "CS4227 reset did not complete\n");
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+			"CS4227 reset did not complete.");
 		return IXGBE_ERR_PHY;
 	}
 
 	status = ixgbe_read_cs4227(hw, IXGBE_CS4227_EEPROM_STATUS, &value);
-	if (status || !(value & IXGBE_CS4227_EEPROM_LOAD_OK)) {
-		hw_err(hw, "CS4227 EEPROM did not load successfully\n");
+	if (status != IXGBE_SUCCESS ||
+	    !(value & IXGBE_CS4227_EEPROM_LOAD_OK)) {
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+			"CS4227 EEPROM did not load successfully.");
 		return IXGBE_ERR_PHY;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_check_cs4227 - Check CS4227 and reset as needed
  * @hw: pointer to hardware structure
- */
-static void ixgbe_check_cs4227(struct ixgbe_hw *hw)
+ **/
+STATIC void ixgbe_check_cs4227(struct ixgbe_hw *hw)
 {
+	s32 status = IXGBE_SUCCESS;
 	u32 swfw_mask = hw->phy.phy_semaphore_mask;
-	s32 status;
-	u16 value;
+	u16 value = 0;
 	u8 retry;
 
 	for (retry = 0; retry < IXGBE_CS4227_RETRIES; retry++) {
 		status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
-		if (status) {
-			hw_err(hw, "semaphore failed with %d\n", status);
-			msleep(IXGBE_CS4227_CHECK_DELAY);
+		if (status != IXGBE_SUCCESS) {
+			ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+				"semaphore failed with %d", status);
+			msec_delay(IXGBE_CS4227_CHECK_DELAY);
 			continue;
 		}
 
 		/* Get status of reset flow. */
 		status = ixgbe_read_cs4227(hw, IXGBE_CS4227_SCRATCH, &value);
-		if (!status && value == IXGBE_CS4227_RESET_COMPLETE)
+
+		if (status == IXGBE_SUCCESS &&
+		    value == IXGBE_CS4227_RESET_COMPLETE)
 			goto out;
 
-		if (status || value != IXGBE_CS4227_RESET_PENDING)
+		if (status != IXGBE_SUCCESS ||
+		    value != IXGBE_CS4227_RESET_PENDING)
 			break;
 
 		/* Reset is pending. Wait and check again. */
 		hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-		msleep(IXGBE_CS4227_CHECK_DELAY);
+		msec_delay(IXGBE_CS4227_CHECK_DELAY);
 	}
+
 	/* If still pending, assume other instance failed. */
 	if (retry == IXGBE_CS4227_RETRIES) {
 		status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
-		if (status) {
-			hw_err(hw, "semaphore failed with %d\n", status);
+		if (status != IXGBE_SUCCESS) {
+			ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+				      "semaphore failed with %d", status);
 			return;
 		}
 	}
 
 	/* Reset the CS4227. */
 	status = ixgbe_reset_cs4227(hw);
-	if (status) {
-		hw_err(hw, "CS4227 reset failed: %d", status);
+	if (status != IXGBE_SUCCESS) {
+		ERROR_REPORT2(IXGBE_ERROR_INVALID_STATE,
+			"CS4227 reset failed: %d", status);
 		goto out;
 	}
 
@@ -271,44 +272,64 @@ static void ixgbe_check_cs4227(struct ixgbe_hw *hw)
 	ixgbe_write_cs4227(hw, IXGBE_CS4227_SCRATCH,
 			   IXGBE_CS4227_RESET_PENDING);
 	hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-	usleep_range(10000, 12000);
+	msec_delay(10);
 	status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
-	if (status) {
-		hw_err(hw, "semaphore failed with %d", status);
+	if (status != IXGBE_SUCCESS) {
+		ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+			"semaphore failed with %d", status);
 		return;
 	}
 
 	/* Record completion for next time. */
 	status = ixgbe_write_cs4227(hw, IXGBE_CS4227_SCRATCH,
-				    IXGBE_CS4227_RESET_COMPLETE);
+		IXGBE_CS4227_RESET_COMPLETE);
 
 out:
 	hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-	msleep(hw->eeprom.semaphore_delay);
+	msec_delay(hw->eeprom.semaphore_delay);
+}
+
+/**
+ * ixgbe_setup_mux_ctl - Setup ESDP register for I2C mux control
+ * @hw: pointer to hardware structure
+ **/
+STATIC void ixgbe_setup_mux_ctl(struct ixgbe_hw *hw)
+{
+	u32 esdp = IXGBE_READ_REG(hw, IXGBE_ESDP);
+
+	if (hw->bus.lan_id) {
+		esdp &= ~(IXGBE_ESDP_SDP1_NATIVE | IXGBE_ESDP_SDP1);
+		esdp |= IXGBE_ESDP_SDP1_DIR;
+	}
+	esdp &= ~(IXGBE_ESDP_SDP0_NATIVE | IXGBE_ESDP_SDP0_DIR);
+	IXGBE_WRITE_REG(hw, IXGBE_ESDP, esdp);
+	IXGBE_WRITE_FLUSH(hw);
 }
 
-/** ixgbe_identify_phy_x550em - Get PHY type based on device id
- *  @hw: pointer to hardware structure
+/**
+ * ixgbe_identify_phy_x550em - Get PHY type based on device id
+ * @hw: pointer to hardware structure
  *
- *  Returns error code
+ * Returns error code
  */
-static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
 {
+	hw->mac.ops.set_lan_id(hw);
+
+	ixgbe_read_mng_if_sel_x550em(hw);
+
 	switch (hw->device_id) {
 	case IXGBE_DEV_ID_X550EM_A_SFP:
-		if (hw->bus.lan_id)
-			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;
-		else
-			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
-		return ixgbe_identify_module_generic(hw);
+		return ixgbe_identify_sfp_module_X550em(hw);
 	case IXGBE_DEV_ID_X550EM_X_SFP:
 		/* set up for CS4227 usage */
-		hw->phy.phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
 		ixgbe_setup_mux_ctl(hw);
 		ixgbe_check_cs4227(hw);
-		fallthrough;
+		/* Fallthrough */
+
 	case IXGBE_DEV_ID_X550EM_A_SFP_N:
-		return ixgbe_identify_module_generic(hw);
+		return ixgbe_identify_sfp_module_X550em(hw);
+		break;
 	case IXGBE_DEV_ID_X550EM_X_KX4:
 		hw->phy.type = ixgbe_phy_x550em_kx4;
 		break;
@@ -321,11 +342,6 @@ static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
 		hw->phy.type = ixgbe_phy_x550em_kr;
 		break;
 	case IXGBE_DEV_ID_X550EM_A_10G_T:
-		if (hw->bus.lan_id)
-			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY1_SM;
-		else
-			hw->phy.phy_semaphore_mask = IXGBE_GSSR_PHY0_SM;
-		fallthrough;
 	case IXGBE_DEV_ID_X550EM_X_10G_T:
 		return ixgbe_identify_phy_generic(hw);
 	case IXGBE_DEV_ID_X550EM_X_1G_T:
@@ -334,8 +350,6 @@ static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
 	case IXGBE_DEV_ID_X550EM_A_1G_T:
 	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
 		hw->phy.type = ixgbe_phy_fw;
-		hw->phy.ops.read_reg = NULL;
-		hw->phy.ops.write_reg = NULL;
 		if (hw->bus.lan_id)
 			hw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY1_SM;
 		else
@@ -344,81 +358,7 @@ static s32 ixgbe_identify_phy_x550em(struct ixgbe_hw *hw)
 	default:
 		break;
 	}
-	return 0;
-}
-
-static s32 ixgbe_read_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,
-				     u32 device_type, u16 *phy_data)
-{
-	return IXGBE_NOT_IMPLEMENTED;
-}
-
-static s32 ixgbe_write_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,
-				      u32 device_type, u16 phy_data)
-{
-	return IXGBE_NOT_IMPLEMENTED;
-}
-
-/**
- * ixgbe_read_i2c_combined_generic - Perform I2C read combined operation
- * @hw: pointer to the hardware structure
- * @addr: I2C bus address to read from
- * @reg: I2C device register to read from
- * @val: pointer to location to receive read value
- *
- * Returns an error code on error.
- **/
-static s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr,
-					   u16 reg, u16 *val)
-{
-	return ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, true);
-}
-
-/**
- * ixgbe_read_i2c_combined_generic_unlocked - Do I2C read combined operation
- * @hw: pointer to the hardware structure
- * @addr: I2C bus address to read from
- * @reg: I2C device register to read from
- * @val: pointer to location to receive read value
- *
- * Returns an error code on error.
- **/
-static s32
-ixgbe_read_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr,
-					 u16 reg, u16 *val)
-{
-	return ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, false);
-}
-
-/**
- * ixgbe_write_i2c_combined_generic - Perform I2C write combined operation
- * @hw: pointer to the hardware structure
- * @addr: I2C bus address to write to
- * @reg: I2C device register to write to
- * @val: value to write
- *
- * Returns an error code on error.
- **/
-static s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw,
-					    u8 addr, u16 reg, u16 val)
-{
-	return ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, true);
-}
-
-/**
- * ixgbe_write_i2c_combined_generic_unlocked - Do I2C write combined operation
- * @hw: pointer to the hardware structure
- * @addr: I2C bus address to write to
- * @reg: I2C device register to write to
- * @val: value to write
- *
- * Returns an error code on error.
- **/
-static s32
-ixgbe_write_i2c_combined_generic_unlocked(struct ixgbe_hw *hw,
-					  u8 addr, u16 reg, u16 val)
-{
-	return ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, false);
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -436,7 +376,7 @@ s32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity,
 	} hic;
 	u16 retries = FW_PHY_ACT_RETRIES;
 	s32 rc;
-	u32 i;
+	u16 i;
 
 	do {
 		memset(&hic, 0, sizeof(hic));
@@ -444,22 +384,23 @@ s32 ixgbe_fw_phy_activity(struct ixgbe_hw *hw, u16 activity,
 		hic.cmd.hdr.buf_len = FW_PHY_ACT_REQ_LEN;
 		hic.cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
 		hic.cmd.port_number = hw->bus.lan_id;
-		hic.cmd.activity_id = cpu_to_le16(activity);
-		for (i = 0; i < ARRAY_SIZE(hic.cmd.data); ++i)
-			hic.cmd.data[i] = cpu_to_be32((*data)[i]);
+		hic.cmd.activity_id = IXGBE_CPU_TO_LE16(activity);
+		for (i = 0; i < FW_PHY_ACT_DATA_COUNT; ++i)
+			hic.cmd.data[i] = IXGBE_CPU_TO_BE32((*data)[i]);
 
-		rc = ixgbe_host_interface_command(hw, &hic.cmd, sizeof(hic.cmd),
+		rc = ixgbe_host_interface_command(hw, (u32 *)&hic.cmd,
+						  sizeof(hic.cmd),
 						  IXGBE_HI_COMMAND_TIMEOUT,
 						  true);
-		if (rc)
+		if (rc != IXGBE_SUCCESS)
 			return rc;
 		if (hic.rsp.hdr.cmd_or_resp.ret_status ==
 		    FW_CEM_RESP_STATUS_SUCCESS) {
 			for (i = 0; i < FW_PHY_ACT_DATA_COUNT; ++i)
-				(*data)[i] = be32_to_cpu(hic.rsp.data[i]);
-			return 0;
+				(*data)[i] = IXGBE_BE32_TO_CPU(hic.rsp.data[i]);
+			return IXGBE_SUCCESS;
 		}
-		usleep_range(20, 30);
+		usec_delay(20);
 		--retries;
 	} while (retries > 0);
 
@@ -492,19 +433,18 @@ static s32 ixgbe_get_phy_id_fw(struct ixgbe_hw *hw)
 	s32 rc;
 	u16 i;
 
-	if (hw->phy.id)
-		return 0;
-
 	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_PHY_INFO, &info);
 	if (rc)
 		return rc;
 
 	hw->phy.speeds_supported = 0;
 	phy_speeds = info[0] & FW_PHY_INFO_SPEED_MASK;
-	for (i = 0; i < ARRAY_SIZE(ixgbe_fw_map); ++i) {
+	for (i = 0; i < sizeof(ixgbe_fw_map) / sizeof(ixgbe_fw_map[0]); ++i) {
 		if (phy_speeds & ixgbe_fw_map[i].fw_speed)
 			hw->phy.speeds_supported |= ixgbe_fw_map[i].phy_speed;
 	}
+	if (!hw->phy.autoneg_advertised)
+		hw->phy.autoneg_advertised = hw->phy.speeds_supported;
 
 	hw->phy.id = info[0] & FW_PHY_INFO_ID_HI_MASK;
 	phy_id_lo = info[1] & FW_PHY_INFO_ID_LO_MASK;
@@ -512,12 +452,7 @@ static s32 ixgbe_get_phy_id_fw(struct ixgbe_hw *hw)
 	hw->phy.revision = phy_id_lo & ~IXGBE_PHY_REVISION_MASK;
 	if (!hw->phy.id || hw->phy.id == IXGBE_PHY_REVISION_MASK)
 		return IXGBE_ERR_PHY_ADDR_INVALID;
-
-	hw->phy.autoneg_advertised = hw->phy.speeds_supported;
-	hw->phy.eee_speeds_supported = IXGBE_LINK_SPEED_100_FULL |
-				       IXGBE_LINK_SPEED_1GB_FULL;
-	hw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -545,7 +480,7 @@ static s32 ixgbe_identify_phy_fw(struct ixgbe_hw *hw)
  *
  * Returns error code
  */
-static s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *hw)
+s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *hw)
 {
 	u32 setup[FW_PHY_ACT_DATA_COUNT] = { 0 };
 
@@ -553,851 +488,628 @@ static s32 ixgbe_shutdown_fw_phy(struct ixgbe_hw *hw)
 	return ixgbe_fw_phy_activity(hw, FW_PHY_ACT_FORCE_LINK_DOWN, &setup);
 }
 
-/**
- * ixgbe_setup_fw_link - Setup firmware-controlled PHYs
- * @hw: pointer to hardware structure
- */
-static s32 ixgbe_setup_fw_link(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_read_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,
+				     u32 device_type, u16 *phy_data)
 {
-	u32 setup[FW_PHY_ACT_DATA_COUNT] = { 0 };
-	s32 rc;
-	u16 i;
-
-	if (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))
-		return 0;
-
-	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
-		hw_err(hw, "rx_pause not valid in strict IEEE mode\n");
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
-	}
-
-	switch (hw->fc.requested_mode) {
-	case ixgbe_fc_full:
-		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RXTX <<
-			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
-		break;
-	case ixgbe_fc_rx_pause:
-		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RX <<
-			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
-		break;
-	case ixgbe_fc_tx_pause:
-		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_TX <<
-			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
-		break;
-	default:
-		break;
-	}
-
-	for (i = 0; i < ARRAY_SIZE(ixgbe_fw_map); ++i) {
-		if (hw->phy.autoneg_advertised & ixgbe_fw_map[i].phy_speed)
-			setup[0] |= ixgbe_fw_map[i].fw_speed;
-	}
-	setup[0] |= FW_PHY_ACT_SETUP_LINK_HP | FW_PHY_ACT_SETUP_LINK_AN;
-
-	if (hw->phy.eee_speeds_advertised)
-		setup[0] |= FW_PHY_ACT_SETUP_LINK_EEE;
+	UNREFERENCED_4PARAMETER(*hw, reg_addr, device_type, *phy_data);
+	return IXGBE_NOT_IMPLEMENTED;
+}
 
-	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_SETUP_LINK, &setup);
-	if (rc)
-		return rc;
-	if (setup[0] == FW_PHY_ACT_SETUP_LINK_RSP_DOWN)
-		return IXGBE_ERR_OVERTEMP;
-	return 0;
+STATIC s32 ixgbe_write_phy_reg_x550em(struct ixgbe_hw *hw, u32 reg_addr,
+				      u32 device_type, u16 phy_data)
+{
+	UNREFERENCED_4PARAMETER(*hw, reg_addr, device_type, phy_data);
+	return IXGBE_NOT_IMPLEMENTED;
 }
 
 /**
- * ixgbe_fc_autoneg_fw - Set up flow control for FW-controlled PHYs
- * @hw: pointer to hardware structure
+ * ixgbe_read_i2c_combined_generic - Perform I2C read combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to read from
+ * @reg: I2C device register to read from
+ * @val: pointer to location to receive read value
  *
- * Called at init time to set up flow control.
- */
-static s32 ixgbe_fc_autoneg_fw(struct ixgbe_hw *hw)
+ * Returns an error code on error.
+ **/
+STATIC s32 ixgbe_read_i2c_combined_generic(struct ixgbe_hw *hw, u8 addr,
+					   u16 reg, u16 *val)
 {
-	if (hw->fc.requested_mode == ixgbe_fc_default)
-		hw->fc.requested_mode = ixgbe_fc_full;
-
-	return ixgbe_setup_fw_link(hw);
+	return ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, true);
 }
 
-/** ixgbe_init_eeprom_params_X550 - Initialize EEPROM params
- *  @hw: pointer to hardware structure
+/**
+ * ixgbe_read_i2c_combined_generic_unlocked - Do I2C read combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to read from
+ * @reg: I2C device register to read from
+ * @val: pointer to location to receive read value
  *
- *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
- *  ixgbe_hw struct in order to set up EEPROM access.
+ * Returns an error code on error.
  **/
-static s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw)
+STATIC s32
+ixgbe_read_i2c_combined_generic_unlocked(struct ixgbe_hw *hw, u8 addr,
+					 u16 reg, u16 *val)
 {
-	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
-	u32 eec;
-	u16 eeprom_size;
-
-	if (eeprom->type == ixgbe_eeprom_uninitialized) {
-		eeprom->semaphore_delay = 10;
-		eeprom->type = ixgbe_flash;
-
-		eec = IXGBE_READ_REG(hw, IXGBE_EEC(hw));
-		eeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>
-				    IXGBE_EEC_SIZE_SHIFT);
-		eeprom->word_size = BIT(eeprom_size +
-					IXGBE_EEPROM_WORD_SIZE_SHIFT);
-
-		hw_dbg(hw, "Eeprom params: type = %d, size = %d\n",
-		       eeprom->type, eeprom->word_size);
-	}
-
-	return 0;
+	return ixgbe_read_i2c_combined_generic_int(hw, addr, reg, val, false);
 }
 
 /**
- * ixgbe_iosf_wait - Wait for IOSF command completion
- * @hw: pointer to hardware structure
- * @ctrl: pointer to location to receive final IOSF control value
- *
- * Return: failing status on timeout
+ * ixgbe_write_i2c_combined_generic - Perform I2C write combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to write to
+ * @reg: I2C device register to write to
+ * @val: value to write
  *
- * Note: ctrl can be NULL if the IOSF control register value is not needed
- */
-static s32 ixgbe_iosf_wait(struct ixgbe_hw *hw, u32 *ctrl)
+ * Returns an error code on error.
+ **/
+STATIC s32 ixgbe_write_i2c_combined_generic(struct ixgbe_hw *hw,
+					    u8 addr, u16 reg, u16 val)
 {
-	u32 i, command;
-
-	/* Check every 10 usec to see if the address cycle completed.
-	 * The SB IOSF BUSY bit will clear when the operation is
-	 * complete.
-	 */
-	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
-		command = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL);
-		if (!(command & IXGBE_SB_IOSF_CTRL_BUSY))
-			break;
-		udelay(10);
-	}
-	if (ctrl)
-		*ctrl = command;
-	if (i == IXGBE_MDIO_COMMAND_TIMEOUT) {
-		hw_dbg(hw, "IOSF wait timed out\n");
-		return IXGBE_ERR_PHY;
-	}
-
-	return 0;
+	return ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, true);
 }
 
-/** ixgbe_read_iosf_sb_reg_x550 - Writes a value to specified register of the
- *  IOSF device
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 3 bit device type
- *  @phy_data: Pointer to read data from the register
+/**
+ * ixgbe_write_i2c_combined_generic_unlocked - Do I2C write combined operation
+ * @hw: pointer to the hardware structure
+ * @addr: I2C bus address to write to
+ * @reg: I2C device register to write to
+ * @val: value to write
+ *
+ * Returns an error code on error.
  **/
-static s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
-				       u32 device_type, u32 *data)
+STATIC s32
+ixgbe_write_i2c_combined_generic_unlocked(struct ixgbe_hw *hw,
+					  u8 addr, u16 reg, u16 val)
 {
-	u32 gssr = IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_PHY0_SM;
-	u32 command, error;
-	s32 ret;
-
-	ret = hw->mac.ops.acquire_swfw_sync(hw, gssr);
-	if (ret)
-		return ret;
+	return ixgbe_write_i2c_combined_generic_int(hw, addr, reg, val, false);
+}
 
-	ret = ixgbe_iosf_wait(hw, NULL);
-	if (ret)
-		goto out;
+/**
+*  ixgbe_init_ops_X550EM - Inits func ptrs and MAC type
+*  @hw: pointer to hardware structure
+*
+*  Initialize the function pointers and for MAC type X550EM.
+*  Does not touch the hardware.
+**/
+s32 ixgbe_init_ops_X550EM(struct ixgbe_hw *hw)
+{
+	struct ixgbe_mac_info *mac = &hw->mac;
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	struct ixgbe_phy_info *phy = &hw->phy;
+	s32 ret_val;
 
-	command = ((reg_addr << IXGBE_SB_IOSF_CTRL_ADDR_SHIFT) |
-		   (device_type << IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT));
+	DEBUGFUNC("ixgbe_init_ops_X550EM");
 
-	/* Write IOSF control register */
-	IXGBE_WRITE_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL, command);
+	/* Similar to X550 so start there. */
+	ret_val = ixgbe_init_ops_X550(hw);
 
-	ret = ixgbe_iosf_wait(hw, &command);
+	/* Since this function eventually calls
+	 * ixgbe_init_ops_540 by design, we are setting
+	 * the pointers to NULL explicitly here to overwrite
+	 * the values being set in the x540 function.
+	 */
+	/* Thermal sensor not supported in x550EM */
+	mac->ops.get_thermal_sensor_data = NULL;
+	mac->ops.init_thermal_sensor_thresh = NULL;
+	mac->thermal_sensor_enabled = false;
+
+	/* FCOE not supported in x550EM */
+	mac->ops.get_san_mac_addr = NULL;
+	mac->ops.set_san_mac_addr = NULL;
+	mac->ops.get_wwn_prefix = NULL;
+	mac->ops.get_fcoe_boot_status = NULL;
+
+	/* IPsec not supported in x550EM */
+	mac->ops.disable_sec_rx_path = NULL;
+	mac->ops.enable_sec_rx_path = NULL;
+
+	/* AUTOC register is not present in x550EM. */
+	mac->ops.prot_autoc_read = NULL;
+	mac->ops.prot_autoc_write = NULL;
+
+	/* X550EM bus type is internal*/
+	hw->bus.type = ixgbe_bus_type_internal;
+	mac->ops.get_bus_info = ixgbe_get_bus_info_X550em;
+
+
+	mac->ops.get_media_type = ixgbe_get_media_type_X550em;
+	mac->ops.setup_sfp = ixgbe_setup_sfp_modules_X550em;
+	mac->ops.get_link_capabilities = ixgbe_get_link_capabilities_X550em;
+	mac->ops.reset_hw = ixgbe_reset_hw_X550em;
+	mac->ops.get_supported_physical_layer =
+				    ixgbe_get_supported_physical_layer_X550em;
+
+	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper)
+		mac->ops.setup_fc = ixgbe_setup_fc_generic;
+	else
+		mac->ops.setup_fc = ixgbe_setup_fc_X550em;
 
-	if ((command & IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK) != 0) {
-		error = (command & IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK) >>
-			 IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT;
-		hw_dbg(hw, "Failed to read, error %x\n", error);
-		return IXGBE_ERR_PHY;
+	/* PHY */
+	phy->ops.init = ixgbe_init_phy_ops_X550em;
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+		mac->ops.setup_fc = NULL;
+		phy->ops.identify = ixgbe_identify_phy_fw;
+		phy->ops.set_phy_power = NULL;
+		phy->ops.get_firmware_version = NULL;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_1G_T:
+		mac->ops.setup_fc = NULL;
+		phy->ops.identify = ixgbe_identify_phy_x550em;
+		phy->ops.set_phy_power = NULL;
+		break;
+	default:
+		phy->ops.identify = ixgbe_identify_phy_x550em;
 	}
 
-	if (!ret)
-		*data = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_DATA);
+	if (mac->ops.get_media_type(hw) != ixgbe_media_type_copper)
+		phy->ops.set_phy_power = NULL;
 
-out:
-	hw->mac.ops.release_swfw_sync(hw, gssr);
-	return ret;
+	/* EEPROM */
+	eeprom->ops.init_params = ixgbe_init_eeprom_params_X540;
+	eeprom->ops.read = ixgbe_read_ee_hostif_X550;
+	eeprom->ops.read_buffer = ixgbe_read_ee_hostif_buffer_X550;
+	eeprom->ops.write = ixgbe_write_ee_hostif_X550;
+	eeprom->ops.write_buffer = ixgbe_write_ee_hostif_buffer_X550;
+	eeprom->ops.update_checksum = ixgbe_update_eeprom_checksum_X550;
+	eeprom->ops.validate_checksum = ixgbe_validate_eeprom_checksum_X550;
+	eeprom->ops.calc_checksum = ixgbe_calc_eeprom_checksum_X550;
+
+	return ret_val;
 }
 
 /**
- * ixgbe_get_phy_token - Get the token for shared PHY access
- * @hw: Pointer to hardware structure
+ * ixgbe_setup_fw_link - Setup firmware-controlled PHYs
+ * @hw: pointer to hardware structure
  */
-static s32 ixgbe_get_phy_token(struct ixgbe_hw *hw)
+static s32 ixgbe_setup_fw_link(struct ixgbe_hw *hw)
 {
-	struct ixgbe_hic_phy_token_req token_cmd;
-	s32 status;
+	u32 setup[FW_PHY_ACT_DATA_COUNT] = { 0 };
+	s32 rc;
+	u16 i;
 
-	token_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;
-	token_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;
-	token_cmd.hdr.cmd_or_resp.cmd_resv = 0;
-	token_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
-	token_cmd.port_number = hw->bus.lan_id;
-	token_cmd.command_type = FW_PHY_TOKEN_REQ;
-	token_cmd.pad = 0;
-	status = ixgbe_host_interface_command(hw, &token_cmd, sizeof(token_cmd),
-					      IXGBE_HI_COMMAND_TIMEOUT,
-					      true);
-	if (status)
-		return status;
-	if (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)
+	if (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))
 		return 0;
-	if (token_cmd.hdr.cmd_or_resp.ret_status != FW_PHY_TOKEN_RETRY)
-		return IXGBE_ERR_FW_RESP_INVALID;
 
-	return IXGBE_ERR_TOKEN_RETRY;
+	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			      "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
+		return IXGBE_ERR_INVALID_LINK_SETTINGS;
+	}
+
+	switch (hw->fc.requested_mode) {
+	case ixgbe_fc_full:
+		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RXTX <<
+			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
+		break;
+	case ixgbe_fc_rx_pause:
+		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_RX <<
+			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
+		break;
+	case ixgbe_fc_tx_pause:
+		setup[0] |= FW_PHY_ACT_SETUP_LINK_PAUSE_TX <<
+			    FW_PHY_ACT_SETUP_LINK_PAUSE_SHIFT;
+		break;
+	default:
+		break;
+	}
+
+	for (i = 0; i < sizeof(ixgbe_fw_map) / sizeof(ixgbe_fw_map[0]); ++i) {
+		if (hw->phy.autoneg_advertised & ixgbe_fw_map[i].phy_speed)
+			setup[0] |= (u32)(ixgbe_fw_map[i].fw_speed);
+	}
+	setup[0] |= FW_PHY_ACT_SETUP_LINK_HP | FW_PHY_ACT_SETUP_LINK_AN;
+
+	if (hw->phy.eee_speeds_advertised)
+		setup[0] |= FW_PHY_ACT_SETUP_LINK_EEE;
+
+	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_SETUP_LINK, &setup);
+	if (rc)
+		return rc;
+	if (setup[0] == FW_PHY_ACT_SETUP_LINK_RSP_DOWN)
+		return IXGBE_ERR_OVERTEMP;
+	return IXGBE_SUCCESS;
 }
 
 /**
- * ixgbe_put_phy_token - Put the token for shared PHY access
- * @hw: Pointer to hardware structure
+ * ixgbe_fc_autoneg_fw _ Set up flow control for FW-controlled PHYs
+ * @hw: pointer to hardware structure
+ *
+ * Called at init time to set up flow control.
  */
-static s32 ixgbe_put_phy_token(struct ixgbe_hw *hw)
+static s32 ixgbe_fc_autoneg_fw(struct ixgbe_hw *hw)
 {
-	struct ixgbe_hic_phy_token_req token_cmd;
-	s32 status;
+	if (hw->fc.requested_mode == ixgbe_fc_default)
+		hw->fc.requested_mode = ixgbe_fc_full;
 
-	token_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;
-	token_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;
-	token_cmd.hdr.cmd_or_resp.cmd_resv = 0;
-	token_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
-	token_cmd.port_number = hw->bus.lan_id;
-	token_cmd.command_type = FW_PHY_TOKEN_REL;
-	token_cmd.pad = 0;
-	status = ixgbe_host_interface_command(hw, &token_cmd, sizeof(token_cmd),
-					      IXGBE_HI_COMMAND_TIMEOUT,
-					      true);
-	if (status)
-		return status;
-	if (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)
-		return 0;
-	return IXGBE_ERR_FW_RESP_INVALID;
+	return ixgbe_setup_fw_link(hw);
 }
 
 /**
- *  ixgbe_write_iosf_sb_reg_x550a - Write to IOSF PHY register
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 3 bit device type
- *  @data: Data to write to the register
- **/
-static s32 ixgbe_write_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
-					 __always_unused u32 device_type,
-					 u32 data)
+ * ixgbe_setup_eee_fw - Enable/disable EEE support
+ * @hw: pointer to the HW structure
+ * @enable_eee: boolean flag to enable EEE
+ *
+ * Enable/disable EEE based on enable_eee flag.
+ * This function controls EEE for firmware-based PHY implementations.
+ */
+static s32 ixgbe_setup_eee_fw(struct ixgbe_hw *hw, bool enable_eee)
 {
-	struct ixgbe_hic_internal_phy_req write_cmd;
-
-	memset(&write_cmd, 0, sizeof(write_cmd));
-	write_cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;
-	write_cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;
-	write_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
-	write_cmd.port_number = hw->bus.lan_id;
-	write_cmd.command_type = FW_INT_PHY_REQ_WRITE;
-	write_cmd.address = cpu_to_be16(reg_addr);
-	write_cmd.write_data = cpu_to_be32(data);
-
-	return ixgbe_host_interface_command(hw, &write_cmd, sizeof(write_cmd),
-					    IXGBE_HI_COMMAND_TIMEOUT, false);
+	if (!!hw->phy.eee_speeds_advertised == enable_eee)
+		return IXGBE_SUCCESS;
+	if (enable_eee)
+		hw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;
+	else
+		hw->phy.eee_speeds_advertised = 0;
+	return hw->phy.ops.setup_link(hw);
 }
 
 /**
- *  ixgbe_read_iosf_sb_reg_x550a - Read from IOSF PHY register
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 3 bit device type
- *  @data: Pointer to read data from the register
- **/
-static s32 ixgbe_read_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
-					__always_unused u32 device_type,
-					u32 *data)
+*  ixgbe_init_ops_X550EM_a - Inits func ptrs and MAC type
+*  @hw: pointer to hardware structure
+*
+*  Initialize the function pointers and for MAC type X550EM_a.
+*  Does not touch the hardware.
+**/
+s32 ixgbe_init_ops_X550EM_a(struct ixgbe_hw *hw)
 {
-	union {
-		struct ixgbe_hic_internal_phy_req cmd;
-		struct ixgbe_hic_internal_phy_resp rsp;
-	} hic;
-	s32 status;
+	struct ixgbe_mac_info *mac = &hw->mac;
+	s32 ret_val;
 
-	memset(&hic, 0, sizeof(hic));
-	hic.cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;
-	hic.cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;
-	hic.cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
-	hic.cmd.port_number = hw->bus.lan_id;
-	hic.cmd.command_type = FW_INT_PHY_REQ_READ;
-	hic.cmd.address = cpu_to_be16(reg_addr);
+	DEBUGFUNC("ixgbe_init_ops_X550EM_a");
 
-	status = ixgbe_host_interface_command(hw, &hic.cmd, sizeof(hic.cmd),
-					      IXGBE_HI_COMMAND_TIMEOUT, true);
+	/* Start with generic X550EM init */
+	ret_val = ixgbe_init_ops_X550EM(hw);
 
-	/* Extract the register value from the response. */
-	*data = be32_to_cpu(hic.rsp.read_data);
+	if (hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII ||
+	    hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII_L) {
+		mac->ops.read_iosf_sb_reg = ixgbe_read_iosf_sb_reg_x550;
+		mac->ops.write_iosf_sb_reg = ixgbe_write_iosf_sb_reg_x550;
+	} else {
+		mac->ops.read_iosf_sb_reg = ixgbe_read_iosf_sb_reg_x550a;
+		mac->ops.write_iosf_sb_reg = ixgbe_write_iosf_sb_reg_x550a;
+	}
+	mac->ops.acquire_swfw_sync = ixgbe_acquire_swfw_sync_X550a;
+	mac->ops.release_swfw_sync = ixgbe_release_swfw_sync_X550a;
 
-	return status;
+	switch (mac->ops.get_media_type(hw)) {
+	case ixgbe_media_type_fiber:
+		mac->ops.setup_fc = NULL;
+		mac->ops.fc_autoneg = ixgbe_fc_autoneg_fiber_x550em_a;
+		break;
+	case ixgbe_media_type_backplane:
+		mac->ops.fc_autoneg = ixgbe_fc_autoneg_backplane_x550em_a;
+		mac->ops.setup_fc = ixgbe_setup_fc_backplane_x550em_a;
+		break;
+	default:
+		break;
+	}
+
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+		mac->ops.fc_autoneg = ixgbe_fc_autoneg_sgmii_x550em_a;
+		mac->ops.setup_fc = ixgbe_fc_autoneg_fw;
+		mac->ops.setup_eee = ixgbe_setup_eee_fw;
+		hw->phy.eee_speeds_supported = IXGBE_LINK_SPEED_100_FULL |
+					       IXGBE_LINK_SPEED_1GB_FULL;
+		hw->phy.eee_speeds_advertised = hw->phy.eee_speeds_supported;
+		break;
+	default:
+		break;
+	}
+
+	return ret_val;
 }
 
-/** ixgbe_read_ee_hostif_buffer_X550- Read EEPROM word(s) using hostif
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @words: number of words
- *  @data: word(s) read from the EEPROM
- *
- *  Reads a 16 bit word(s) from the EEPROM using the hostif.
- **/
-static s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
-					    u16 offset, u16 words, u16 *data)
+/**
+*  ixgbe_init_ops_X550EM_x - Inits func ptrs and MAC type
+*  @hw: pointer to hardware structure
+*
+*  Initialize the function pointers and for MAC type X550EM_x.
+*  Does not touch the hardware.
+**/
+s32 ixgbe_init_ops_X550EM_x(struct ixgbe_hw *hw)
 {
-	const u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;
-	struct ixgbe_hic_read_shadow_ram buffer;
-	u32 current_word = 0;
-	u16 words_to_read;
-	s32 status;
-	u32 i;
-
-	/* Take semaphore for the entire operation. */
-	status = hw->mac.ops.acquire_swfw_sync(hw, mask);
-	if (status) {
-		hw_dbg(hw, "EEPROM read buffer - semaphore failed\n");
-		return status;
-	}
-
-	while (words) {
-		if (words > FW_MAX_READ_BUFFER_SIZE / 2)
-			words_to_read = FW_MAX_READ_BUFFER_SIZE / 2;
-		else
-			words_to_read = words;
-
-		buffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;
-		buffer.hdr.req.buf_lenh = 0;
-		buffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;
-		buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
+	struct ixgbe_mac_info *mac = &hw->mac;
+	struct ixgbe_link_info *link = &hw->link;
+	s32 ret_val;
 
-		/* convert offset from words to bytes */
-		buffer.address = (__force u32)cpu_to_be32((offset +
-							   current_word) * 2);
-		buffer.length = (__force u16)cpu_to_be16(words_to_read * 2);
-		buffer.pad2 = 0;
-		buffer.pad3 = 0;
+	DEBUGFUNC("ixgbe_init_ops_X550EM_x");
 
-		status = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),
-					    IXGBE_HI_COMMAND_TIMEOUT);
-		if (status) {
-			hw_dbg(hw, "Host interface command failed\n");
-			goto out;
-		}
+	/* Start with generic X550EM init */
+	ret_val = ixgbe_init_ops_X550EM(hw);
 
-		for (i = 0; i < words_to_read; i++) {
-			u32 reg = IXGBE_FLEX_MNG + (FW_NVM_DATA_OFFSET << 2) +
-				  2 * i;
-			u32 value = IXGBE_READ_REG(hw, reg);
+	mac->ops.read_iosf_sb_reg = ixgbe_read_iosf_sb_reg_x550;
+	mac->ops.write_iosf_sb_reg = ixgbe_write_iosf_sb_reg_x550;
+	mac->ops.acquire_swfw_sync = ixgbe_acquire_swfw_sync_X550em;
+	mac->ops.release_swfw_sync = ixgbe_release_swfw_sync_X550em;
+	link->ops.read_link = ixgbe_read_i2c_combined_generic;
+	link->ops.read_link_unlocked = ixgbe_read_i2c_combined_generic_unlocked;
+	link->ops.write_link = ixgbe_write_i2c_combined_generic;
+	link->ops.write_link_unlocked =
+				      ixgbe_write_i2c_combined_generic_unlocked;
+	link->addr = IXGBE_CS4227;
 
-			data[current_word] = (u16)(value & 0xffff);
-			current_word++;
-			i++;
-			if (i < words_to_read) {
-				value >>= 16;
-				data[current_word] = (u16)(value & 0xffff);
-				current_word++;
-			}
-		}
-		words -= words_to_read;
+	if (hw->device_id == IXGBE_DEV_ID_X550EM_X_1G_T) {
+		mac->ops.setup_fc = NULL;
+		mac->ops.setup_eee = NULL;
+		mac->ops.init_led_link_act = NULL;
 	}
 
-out:
-	hw->mac.ops.release_swfw_sync(hw, mask);
-	return status;
+	return ret_val;
 }
 
-/** ixgbe_checksum_ptr_x550 - Checksum one pointer region
- *  @hw: pointer to hardware structure
- *  @ptr: pointer offset in eeprom
- *  @size: size of section pointed by ptr, if 0 first word will be used as size
- *  @csum: address of checksum to update
+/**
+ * ixgbe_dmac_config_X550
+ * @hw: pointer to hardware structure
  *
- *  Returns error status for any failure
+ * Configure DMA coalescing. If enabling dmac, dmac is activated.
+ * When disabling dmac, dmac enable dmac bit is cleared.
  **/
-static s32 ixgbe_checksum_ptr_x550(struct ixgbe_hw *hw, u16 ptr,
-				   u16 size, u16 *csum, u16 *buffer,
-				   u32 buffer_size)
+s32 ixgbe_dmac_config_X550(struct ixgbe_hw *hw)
 {
-	u16 buf[256];
-	s32 status;
-	u16 length, bufsz, i, start;
-	u16 *local_buffer;
+	u32 reg, high_pri_tc;
 
-	bufsz = ARRAY_SIZE(buf);
+	DEBUGFUNC("ixgbe_dmac_config_X550");
 
-	/* Read a chunk at the pointer location */
-	if (!buffer) {
-		status = ixgbe_read_ee_hostif_buffer_X550(hw, ptr, bufsz, buf);
-		if (status) {
-			hw_dbg(hw, "Failed to read EEPROM image\n");
-			return status;
-		}
-		local_buffer = buf;
-	} else {
-		if (buffer_size < ptr)
-			return  IXGBE_ERR_PARAM;
-		local_buffer = &buffer[ptr];
-	}
+	/* Disable DMA coalescing before configuring */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMACR);
+	reg &= ~IXGBE_DMACR_DMAC_EN;
+	IXGBE_WRITE_REG(hw, IXGBE_DMACR, reg);
 
-	if (size) {
-		start = 0;
-		length = size;
-	} else {
-		start = 1;
-		length = local_buffer[0];
+	/* Disable DMA Coalescing if the watchdog timer is 0 */
+	if (!hw->mac.dmac_config.watchdog_timer)
+		goto out;
 
-		/* Skip pointer section if length is invalid. */
-		if (length == 0xFFFF || length == 0 ||
-		    (ptr + length) >= hw->eeprom.word_size)
-			return 0;
-	}
+	ixgbe_dmac_config_tcs_X550(hw);
 
-	if (buffer && ((u32)start + (u32)length > buffer_size))
-		return IXGBE_ERR_PARAM;
+	/* Configure DMA Coalescing Control Register */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMACR);
 
-	for (i = start; length; i++, length--) {
-		if (i == bufsz && !buffer) {
-			ptr += bufsz;
-			i = 0;
-			if (length < bufsz)
-				bufsz = length;
+	/* Set the watchdog timer in units of 40.96 usec */
+	reg &= ~IXGBE_DMACR_DMACWT_MASK;
+	reg |= (hw->mac.dmac_config.watchdog_timer * 100) / 4096;
 
-			/* Read a chunk at the pointer location */
-			status = ixgbe_read_ee_hostif_buffer_X550(hw, ptr,
-								  bufsz, buf);
-			if (status) {
-				hw_dbg(hw, "Failed to read EEPROM image\n");
-				return status;
-			}
-		}
-		*csum += local_buffer[i];
+	reg &= ~IXGBE_DMACR_HIGH_PRI_TC_MASK;
+	/* If fcoe is enabled, set high priority traffic class */
+	if (hw->mac.dmac_config.fcoe_en) {
+		high_pri_tc = 1 << hw->mac.dmac_config.fcoe_tc;
+		reg |= ((high_pri_tc << IXGBE_DMACR_HIGH_PRI_TC_SHIFT) &
+			IXGBE_DMACR_HIGH_PRI_TC_MASK);
 	}
-	return 0;
+	reg |= IXGBE_DMACR_EN_MNG_IND;
+
+	/* Enable DMA coalescing after configuration */
+	reg |= IXGBE_DMACR_DMAC_EN;
+	IXGBE_WRITE_REG(hw, IXGBE_DMACR, reg);
+
+out:
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_calc_checksum_X550 - Calculates and returns the checksum
- *  @hw: pointer to hardware structure
- *  @buffer: pointer to buffer containing calculated checksum
- *  @buffer_size: size of buffer
+/**
+ * ixgbe_dmac_config_tcs_X550
+ * @hw: pointer to hardware structure
  *
- *  Returns a negative error code on error, or the 16-bit checksum
+ * Configure DMA coalescing threshold per TC. The dmac enable bit must
+ * be cleared before configuring.
  **/
-static s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw, u16 *buffer,
-				    u32 buffer_size)
+s32 ixgbe_dmac_config_tcs_X550(struct ixgbe_hw *hw)
 {
-	u16 eeprom_ptrs[IXGBE_EEPROM_LAST_WORD + 1];
-	u16 *local_buffer;
-	s32 status;
-	u16 checksum = 0;
-	u16 pointer, i, size;
+	u32 tc, reg, pb_headroom, rx_pb_size, maxframe_size_kb;
 
-	hw->eeprom.ops.init_params(hw);
+	DEBUGFUNC("ixgbe_dmac_config_tcs_X550");
 
-	if (!buffer) {
-		/* Read pointer area */
-		status = ixgbe_read_ee_hostif_buffer_X550(hw, 0,
-						IXGBE_EEPROM_LAST_WORD + 1,
-						eeprom_ptrs);
-		if (status) {
-			hw_dbg(hw, "Failed to read EEPROM image\n");
-			return status;
-		}
-		local_buffer = eeprom_ptrs;
-	} else {
-		if (buffer_size < IXGBE_EEPROM_LAST_WORD)
-			return IXGBE_ERR_PARAM;
-		local_buffer = buffer;
+	/* Configure DMA coalescing enabled */
+	switch (hw->mac.dmac_config.link_speed) {
+	case IXGBE_LINK_SPEED_10_FULL:
+	case IXGBE_LINK_SPEED_100_FULL:
+		pb_headroom = IXGBE_DMACRXT_100M;
+		break;
+	case IXGBE_LINK_SPEED_1GB_FULL:
+		pb_headroom = IXGBE_DMACRXT_1G;
+		break;
+	default:
+		pb_headroom = IXGBE_DMACRXT_10G;
+		break;
 	}
 
-	/* For X550 hardware include 0x0-0x41 in the checksum, skip the
-	 * checksum word itself
-	 */
-	for (i = 0; i <= IXGBE_EEPROM_LAST_WORD; i++)
-		if (i != IXGBE_EEPROM_CHECKSUM)
-			checksum += local_buffer[i];
-
-	/* Include all data from pointers 0x3, 0x6-0xE.  This excludes the
-	 * FW, PHY module, and PCIe Expansion/Option ROM pointers.
-	 */
-	for (i = IXGBE_PCIE_ANALOG_PTR_X550; i < IXGBE_FW_PTR; i++) {
-		if (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)
-			continue;
-
-		pointer = local_buffer[i];
-
-		/* Skip pointer section if the pointer is invalid. */
-		if (pointer == 0xFFFF || pointer == 0 ||
-		    pointer >= hw->eeprom.word_size)
-			continue;
-
-		switch (i) {
-		case IXGBE_PCIE_GENERAL_PTR:
-			size = IXGBE_IXGBE_PCIE_GENERAL_SIZE;
-			break;
-		case IXGBE_PCIE_CONFIG0_PTR:
-		case IXGBE_PCIE_CONFIG1_PTR:
-			size = IXGBE_PCIE_CONFIG_SIZE;
-			break;
-		default:
-			size = 0;
-			break;
+	maxframe_size_kb = ((IXGBE_READ_REG(hw, IXGBE_MAXFRS) >>
+			     IXGBE_MHADD_MFS_SHIFT) / 1024);
+
+	/* Set the per Rx packet buffer receive threshold */
+	for (tc = 0; tc < IXGBE_DCB_MAX_TRAFFIC_CLASS; tc++) {
+		reg = IXGBE_READ_REG(hw, IXGBE_DMCTH(tc));
+		reg &= ~IXGBE_DMCTH_DMACRXT_MASK;
+
+		if (tc < hw->mac.dmac_config.num_tcs) {
+			/* Get Rx PB size */
+			rx_pb_size = IXGBE_READ_REG(hw, IXGBE_RXPBSIZE(tc));
+			rx_pb_size = (rx_pb_size & IXGBE_RXPBSIZE_MASK) >>
+				IXGBE_RXPBSIZE_SHIFT;
+
+			/* Calculate receive buffer threshold in kilobytes */
+			if (rx_pb_size > pb_headroom)
+				rx_pb_size = rx_pb_size - pb_headroom;
+			else
+				rx_pb_size = 0;
+
+			/* Minimum of MFS shall be set for DMCTH */
+			reg |= (rx_pb_size > maxframe_size_kb) ?
+				rx_pb_size : maxframe_size_kb;
 		}
-
-		status = ixgbe_checksum_ptr_x550(hw, pointer, size, &checksum,
-						 buffer, buffer_size);
-		if (status)
-			return status;
+		IXGBE_WRITE_REG(hw, IXGBE_DMCTH(tc), reg);
 	}
-
-	checksum = (u16)IXGBE_EEPROM_SUM - checksum;
-
-	return (s32)checksum;
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_calc_eeprom_checksum_X550 - Calculates and returns the checksum
- *  @hw: pointer to hardware structure
+/**
+ * ixgbe_dmac_update_tcs_X550
+ * @hw: pointer to hardware structure
  *
- *  Returns a negative error code on error, or the 16-bit checksum
+ * Disables dmac, updates per TC settings, and then enables dmac.
  **/
-static s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw)
+s32 ixgbe_dmac_update_tcs_X550(struct ixgbe_hw *hw)
 {
-	return ixgbe_calc_checksum_X550(hw, NULL, 0);
+	u32 reg;
+
+	DEBUGFUNC("ixgbe_dmac_update_tcs_X550");
+
+	/* Disable DMA coalescing before configuring */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMACR);
+	reg &= ~IXGBE_DMACR_DMAC_EN;
+	IXGBE_WRITE_REG(hw, IXGBE_DMACR, reg);
+
+	ixgbe_dmac_config_tcs_X550(hw);
+
+	/* Enable DMA coalescing after configuration */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMACR);
+	reg |= IXGBE_DMACR_DMAC_EN;
+	IXGBE_WRITE_REG(hw, IXGBE_DMACR, reg);
+
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_read_ee_hostif_X550 - Read EEPROM word using a host interface command
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to read
- *  @data: word read from the EEPROM
+/**
+ * ixgbe_init_eeprom_params_X550 - Initialize EEPROM params
+ * @hw: pointer to hardware structure
  *
- *   Reads a 16 bit word from the EEPROM using the hostif.
+ * Initializes the EEPROM parameters ixgbe_eeprom_info within the
+ * ixgbe_hw struct in order to set up EEPROM access.
  **/
-static s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 *data)
+s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw)
 {
-	const u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;
-	struct ixgbe_hic_read_shadow_ram buffer;
-	s32 status;
+	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
+	u32 eec;
+	u16 eeprom_size;
 
-	buffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;
-	buffer.hdr.req.buf_lenh = 0;
-	buffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;
-	buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
+	DEBUGFUNC("ixgbe_init_eeprom_params_X550");
 
-	/* convert offset from words to bytes */
-	buffer.address = (__force u32)cpu_to_be32(offset * 2);
-	/* one word */
-	buffer.length = (__force u16)cpu_to_be16(sizeof(u16));
+	if (eeprom->type == ixgbe_eeprom_uninitialized) {
+		eeprom->semaphore_delay = 10;
+		eeprom->type = ixgbe_flash;
 
-	status = hw->mac.ops.acquire_swfw_sync(hw, mask);
-	if (status)
-		return status;
+		eec = IXGBE_READ_REG(hw, IXGBE_EEC);
+		eeprom_size = (u16)((eec & IXGBE_EEC_SIZE) >>
+				    IXGBE_EEC_SIZE_SHIFT);
+		eeprom->word_size = 1 << (eeprom_size +
+					  IXGBE_EEPROM_WORD_SIZE_SHIFT);
 
-	status = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),
-				    IXGBE_HI_COMMAND_TIMEOUT);
-	if (!status) {
-		*data = (u16)IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG,
-						  FW_NVM_DATA_OFFSET);
+		hw_dbg(hw, "Eeprom params: type = %d, size = %d\n",
+			  eeprom->type, eeprom->word_size);
 	}
 
-	hw->mac.ops.release_swfw_sync(hw, mask);
-	return status;
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_validate_eeprom_checksum_X550 - Validate EEPROM checksum
- *  @hw: pointer to hardware structure
- *  @checksum_val: calculated checksum
- *
- *  Performs checksum calculation and validates the EEPROM checksum.  If the
- *  caller does not need checksum_val, the value can be NULL.
+/**
+ * ixgbe_set_source_address_pruning_X550 - Enable/Disbale source address pruning
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable source address pruning
+ * @pool: Rx pool to set source address pruning for
  **/
-static s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw,
-					       u16 *checksum_val)
+void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw, bool enable,
+					   unsigned int pool)
 {
-	s32 status;
-	u16 checksum;
-	u16 read_checksum = 0;
-
-	/* Read the first word from the EEPROM. If this times out or fails, do
-	 * not continue or we could be in for a very long wait while every
-	 * EEPROM read fails
-	 */
-	status = hw->eeprom.ops.read(hw, 0, &checksum);
-	if (status) {
-		hw_dbg(hw, "EEPROM read failed\n");
-		return status;
-	}
-
-	status = hw->eeprom.ops.calc_checksum(hw);
-	if (status < 0)
-		return status;
-
-	checksum = (u16)(status & 0xffff);
+	u64 pfflp;
 
-	status = ixgbe_read_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,
-					   &read_checksum);
-	if (status)
-		return status;
+	/* max rx pool is 63 */
+	if (pool > 63)
+		return;
 
-	/* Verify read checksum from EEPROM is the same as
-	 * calculated checksum
-	 */
-	if (read_checksum != checksum) {
-		status = IXGBE_ERR_EEPROM_CHECKSUM;
-		hw_dbg(hw, "Invalid EEPROM checksum");
-	}
+	pfflp = (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPL);
+	pfflp |= (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPH) << 32;
 
-	/* If the user cares, return the calculated checksum */
-	if (checksum_val)
-		*checksum_val = checksum;
+	if (enable)
+		pfflp |= (1ULL << pool);
+	else
+		pfflp &= ~(1ULL << pool);
 
-	return status;
+	IXGBE_WRITE_REG(hw, IXGBE_PFFLPL, (u32)pfflp);
+	IXGBE_WRITE_REG(hw, IXGBE_PFFLPH, (u32)(pfflp >> 32));
 }
 
-/** ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @data: word write to the EEPROM
+/**
+ * ixgbe_set_ethertype_anti_spoofing_X550 - Configure Ethertype anti-spoofing
+ * @hw: pointer to hardware structure
+ * @enable: enable or disable switch for Ethertype anti-spoofing
+ * @vf: Virtual Function pool - VF Pool to set for Ethertype anti-spoofing
  *
- *  Write a 16 bit word to the EEPROM using the hostif.
  **/
-static s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw, u16 offset,
-					   u16 data)
+void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw,
+		bool enable, int vf)
 {
-	s32 status;
-	struct ixgbe_hic_write_shadow_ram buffer;
-
-	buffer.hdr.req.cmd = FW_WRITE_SHADOW_RAM_CMD;
-	buffer.hdr.req.buf_lenh = 0;
-	buffer.hdr.req.buf_lenl = FW_WRITE_SHADOW_RAM_LEN;
-	buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
-
-	/* one word */
-	buffer.length = cpu_to_be16(sizeof(u16));
-	buffer.data = data;
-	buffer.address = cpu_to_be32(offset * 2);
-
-	status = ixgbe_host_interface_command(hw, &buffer, sizeof(buffer),
-					      IXGBE_HI_COMMAND_TIMEOUT, false);
-	return status;
-}
-
-/** ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @data: word write to the EEPROM
- *
- *  Write a 16 bit word to the EEPROM using the hostif.
- **/
-static s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 data)
-{
-	s32 status = 0;
-
-	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) == 0) {
-		status = ixgbe_write_ee_hostif_data_X550(hw, offset, data);
-		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
-	} else {
-		hw_dbg(hw, "write ee hostif failed to get semaphore");
-		status = IXGBE_ERR_SWFW_SYNC;
-	}
-
-	return status;
-}
+	int vf_target_reg = vf >> 3;
+	int vf_target_shift = vf % 8 + IXGBE_SPOOF_ETHERTYPEAS_SHIFT;
+	u32 pfvfspoof;
 
-/** ixgbe_update_flash_X550 - Instruct HW to copy EEPROM to Flash device
- *  @hw: pointer to hardware structure
- *
- *  Issue a shadow RAM dump to FW to copy EEPROM from shadow RAM to the flash.
- **/
-static s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw)
-{
-	s32 status = 0;
-	union ixgbe_hic_hdr2 buffer;
+	DEBUGFUNC("ixgbe_set_ethertype_anti_spoofing_X550");
 
-	buffer.req.cmd = FW_SHADOW_RAM_DUMP_CMD;
-	buffer.req.buf_lenh = 0;
-	buffer.req.buf_lenl = FW_SHADOW_RAM_DUMP_LEN;
-	buffer.req.checksum = FW_DEFAULT_CHECKSUM;
+	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
+	if (enable)
+		pfvfspoof |= (1 << vf_target_shift);
+	else
+		pfvfspoof &= ~(1 << vf_target_shift);
 
-	status = ixgbe_host_interface_command(hw, &buffer, sizeof(buffer),
-					      IXGBE_HI_COMMAND_TIMEOUT, false);
-	return status;
+	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);
 }
 
 /**
- * ixgbe_get_bus_info_X550em - Set PCI bus info
+ * ixgbe_iosf_wait - Wait for IOSF command completion
  * @hw: pointer to hardware structure
+ * @ctrl: pointer to location to receive final IOSF control value
  *
- * Sets bus link width and speed to unknown because X550em is
- * not a PCI device.
- **/
-static s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw)
-{
-	hw->bus.type  = ixgbe_bus_type_internal;
-	hw->bus.width = ixgbe_bus_width_unknown;
-	hw->bus.speed = ixgbe_bus_speed_unknown;
-
-	hw->mac.ops.set_lan_id(hw);
-
-	return 0;
-}
-
-/**
- * ixgbe_fw_recovery_mode - Check FW NVM recovery mode
- * @hw: pointer t hardware structure
- *
- * Returns true if in FW NVM recovery mode.
- */
-static bool ixgbe_fw_recovery_mode_X550(struct ixgbe_hw *hw)
-{
-	u32 fwsm;
-
-	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM(hw));
-	return !!(fwsm & IXGBE_FWSM_FW_NVM_RECOVERY_MODE);
-}
-
-/** ixgbe_disable_rx_x550 - Disable RX unit
- *
- *  Enables the Rx DMA unit for x550
- **/
-static void ixgbe_disable_rx_x550(struct ixgbe_hw *hw)
-{
-	u32 rxctrl, pfdtxgswc;
-	s32 status;
-	struct ixgbe_hic_disable_rxen fw_cmd;
-
-	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
-	if (rxctrl & IXGBE_RXCTRL_RXEN) {
-		pfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);
-		if (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {
-			pfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;
-			IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);
-			hw->mac.set_lben = true;
-		} else {
-			hw->mac.set_lben = false;
-		}
-
-		fw_cmd.hdr.cmd = FW_DISABLE_RXEN_CMD;
-		fw_cmd.hdr.buf_len = FW_DISABLE_RXEN_LEN;
-		fw_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
-		fw_cmd.port_number = hw->bus.lan_id;
-
-		status = ixgbe_host_interface_command(hw, &fw_cmd,
-					sizeof(struct ixgbe_hic_disable_rxen),
-					IXGBE_HI_COMMAND_TIMEOUT, true);
-
-		/* If we fail - disable RX using register write */
-		if (status) {
-			rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
-			if (rxctrl & IXGBE_RXCTRL_RXEN) {
-				rxctrl &= ~IXGBE_RXCTRL_RXEN;
-				IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);
-			}
-		}
-	}
-}
-
-/** ixgbe_update_eeprom_checksum_X550 - Updates the EEPROM checksum and flash
- *  @hw: pointer to hardware structure
+ * Returns failing status on timeout
  *
- *  After writing EEPROM to shadow RAM using EEWR register, software calculates
- *  checksum and updates the EEPROM and instructs the hardware to update
- *  the flash.
+ * Note: ctrl can be NULL if the IOSF control register value is not needed
  **/
-static s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_iosf_wait(struct ixgbe_hw *hw, u32 *ctrl)
 {
-	s32 status;
-	u16 checksum = 0;
+	u32 i, command = 0;
 
-	/* Read the first word from the EEPROM. If this times out or fails, do
-	 * not continue or we could be in for a very long wait while every
-	 * EEPROM read fails
+	/* Check every 10 usec to see if the address cycle completed.
+	 * The SB IOSF BUSY bit will clear when the operation is
+	 * complete
 	 */
-	status = ixgbe_read_ee_hostif_X550(hw, 0, &checksum);
-	if (status) {
-		hw_dbg(hw, "EEPROM read failed\n");
-		return status;
-	}
-
-	status = ixgbe_calc_eeprom_checksum_X550(hw);
-	if (status < 0)
-		return status;
-
-	checksum = (u16)(status & 0xffff);
-
-	status = ixgbe_write_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,
-					    checksum);
-	if (status)
-		return status;
-
-	status = ixgbe_update_flash_X550(hw);
-
-	return status;
-}
-
-/** ixgbe_write_ee_hostif_buffer_X550 - Write EEPROM word(s) using hostif
- *  @hw: pointer to hardware structure
- *  @offset: offset of  word in the EEPROM to write
- *  @words: number of words
- *  @data: word(s) write to the EEPROM
- *
- *
- *  Write a 16 bit word(s) to the EEPROM using the hostif.
- **/
-static s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
-					     u16 offset, u16 words,
-					     u16 *data)
-{
-	s32 status = 0;
-	u32 i = 0;
-
-	/* Take semaphore for the entire operation. */
-	status = hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
-	if (status) {
-		hw_dbg(hw, "EEPROM write buffer - semaphore failed\n");
-		return status;
-	}
-
-	for (i = 0; i < words; i++) {
-		status = ixgbe_write_ee_hostif_data_X550(hw, offset + i,
-							 data[i]);
-		if (status) {
-			hw_dbg(hw, "Eeprom buffered write failed\n");
+	for (i = 0; i < IXGBE_MDIO_COMMAND_TIMEOUT; i++) {
+		command = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL);
+		if ((command & IXGBE_SB_IOSF_CTRL_BUSY) == 0)
 			break;
-		}
+		usec_delay(10);
+	}
+	if (ctrl)
+		*ctrl = command;
+	if (i == IXGBE_MDIO_COMMAND_TIMEOUT) {
+		ERROR_REPORT1(IXGBE_ERROR_POLLING, "Wait timed out\n");
+		return IXGBE_ERR_PHY;
 	}
 
-	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
-
-	return status;
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_write_iosf_sb_reg_x550 - Writes a value to specified register of the
- *  IOSF device
- *
- *  @hw: pointer to hardware structure
- *  @reg_addr: 32 bit PHY register to write
- *  @device_type: 3 bit device type
- *  @data: Data to write to the register
+/**
+ * ixgbe_write_iosf_sb_reg_x550 - Writes a value to specified register
+ * of the IOSF device
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 3 bit device type
+ * @data: Data to write to the register
  **/
-static s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
-					u32 device_type, u32 data)
+s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
+			    u32 device_type, u32 data)
 {
 	u32 gssr = IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_PHY0_SM;
 	u32 command, error;
 	s32 ret;
 
-	ret = hw->mac.ops.acquire_swfw_sync(hw, gssr);
-	if (ret)
+	ret = ixgbe_acquire_swfw_semaphore(hw, gssr);
+	if (ret != IXGBE_SUCCESS)
 		return ret;
 
 	ret = ixgbe_iosf_wait(hw, NULL);
-	if (ret)
+	if (ret != IXGBE_SUCCESS)
 		goto out;
 
 	command = ((reg_addr << IXGBE_SB_IOSF_CTRL_ADDR_SHIFT) |
@@ -1414,201 +1126,397 @@ static s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
 	if ((command & IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK) != 0) {
 		error = (command & IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK) >>
 			 IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT;
-		hw_dbg(hw, "Failed to write, error %x\n", error);
-		return IXGBE_ERR_PHY;
+		ERROR_REPORT2(IXGBE_ERROR_POLLING,
+			      "Failed to write, error %x\n", error);
+		ret = IXGBE_ERR_PHY;
 	}
 
 out:
-	hw->mac.ops.release_swfw_sync(hw, gssr);
+	ixgbe_release_swfw_semaphore(hw, gssr);
 	return ret;
 }
 
 /**
- *  ixgbe_setup_ixfi_x550em_x - MAC specific iXFI configuration
- *  @hw: pointer to hardware structure
- *
- *  iXfI configuration needed for ixgbe_mac_X550EM_x devices.
+ * ixgbe_read_iosf_sb_reg_x550 - Reads specified register of the IOSF device
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 3 bit device type
+ * @data: Pointer to read data from the register
  **/
-static s32 ixgbe_setup_ixfi_x550em_x(struct ixgbe_hw *hw)
+s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
+			   u32 device_type, u32 *data)
 {
-	s32 status;
-	u32 reg_val;
+	u32 gssr = IXGBE_GSSR_PHY1_SM | IXGBE_GSSR_PHY0_SM;
+	u32 command, error;
+	s32 ret;
 
-	/* Disable training protocol FSM. */
-	status = ixgbe_read_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
-		return status;
+	ret = ixgbe_acquire_swfw_semaphore(hw, gssr);
+	if (ret != IXGBE_SUCCESS)
+		return ret;
 
-	reg_val |= IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL;
-	status = ixgbe_write_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-	if (status)
-		return status;
+	ret = ixgbe_iosf_wait(hw, NULL);
+	if (ret != IXGBE_SUCCESS)
+		goto out;
 
-	/* Disable Flex from training TXFFE. */
-	status = ixgbe_read_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
-		return status;
+	command = ((reg_addr << IXGBE_SB_IOSF_CTRL_ADDR_SHIFT) |
+		   (device_type << IXGBE_SB_IOSF_CTRL_TARGET_SELECT_SHIFT));
 
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;
-	status = ixgbe_write_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-	if (status)
-		return status;
+	/* Write IOSF control register */
+	IXGBE_WRITE_REG(hw, IXGBE_SB_IOSF_INDIRECT_CTRL, command);
 
-	status = ixgbe_read_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
-		return status;
+	ret = ixgbe_iosf_wait(hw, &command);
 
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;
-	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;
-	status = ixgbe_write_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-	if (status)
-		return status;
+	if ((command & IXGBE_SB_IOSF_CTRL_RESP_STAT_MASK) != 0) {
+		error = (command & IXGBE_SB_IOSF_CTRL_CMPL_ERR_MASK) >>
+			 IXGBE_SB_IOSF_CTRL_CMPL_ERR_SHIFT;
+		ERROR_REPORT2(IXGBE_ERROR_POLLING,
+				"Failed to read, error %x\n", error);
+		ret = IXGBE_ERR_PHY;
+	}
 
-	/* Enable override for coefficients. */
-	status = ixgbe_read_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
-		return status;
+	if (ret == IXGBE_SUCCESS)
+		*data = IXGBE_READ_REG(hw, IXGBE_SB_IOSF_INDIRECT_DATA);
 
-	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN;
-	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN;
-	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN;
-	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN;
-	status = ixgbe_write_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-	return status;
+out:
+	ixgbe_release_swfw_semaphore(hw, gssr);
+	return ret;
 }
 
 /**
- *  ixgbe_restart_an_internal_phy_x550em - restart autonegotiation for the
- *  internal PHY
- *  @hw: pointer to hardware structure
- **/
-static s32 ixgbe_restart_an_internal_phy_x550em(struct ixgbe_hw *hw)
+ * ixgbe_get_phy_token - Get the token for shared phy access
+ * @hw: Pointer to hardware structure
+ */
+
+s32 ixgbe_get_phy_token(struct ixgbe_hw *hw)
 {
+	struct ixgbe_hic_phy_token_req token_cmd;
 	s32 status;
-	u32 link_ctrl;
-
-	/* Restart auto-negotiation. */
-	status = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &link_ctrl);
 
+	token_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;
+	token_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;
+	token_cmd.hdr.cmd_or_resp.cmd_resv = 0;
+	token_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
+	token_cmd.port_number = hw->bus.lan_id;
+	token_cmd.command_type = FW_PHY_TOKEN_REQ;
+	token_cmd.pad = 0;
+	status = ixgbe_host_interface_command(hw, (u32 *)&token_cmd,
+					      sizeof(token_cmd),
+					      IXGBE_HI_COMMAND_TIMEOUT,
+					      true);
 	if (status) {
-		hw_dbg(hw, "Auto-negotiation did not complete\n");
+		hw_dbg(hw, "Issuing host interface command failed with Status = %d\n",
+			  status);
 		return status;
 	}
+	if (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)
+		return IXGBE_SUCCESS;
+	if (token_cmd.hdr.cmd_or_resp.ret_status != FW_PHY_TOKEN_RETRY) {
+		hw_dbg(hw, "Host interface command returned 0x%08x , returning IXGBE_ERR_FW_RESP_INVALID\n",
+			  token_cmd.hdr.cmd_or_resp.ret_status);
+		return IXGBE_ERR_FW_RESP_INVALID;
+	}
 
-	link_ctrl |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART;
-	status = hw->mac.ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, link_ctrl);
-
-	if (hw->mac.type == ixgbe_mac_x550em_a) {
-		u32 flx_mask_st20;
+	hw_dbg(hw, "Returning  IXGBE_ERR_TOKEN_RETRY\n");
+	return IXGBE_ERR_TOKEN_RETRY;
+}
 
-		/* Indicate to FW that AN restart has been asserted */
-		status = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_mask_st20);
+/**
+ * ixgbe_put_phy_token - Put the token for shared phy access
+ * @hw: Pointer to hardware structure
+ */
 
-		if (status) {
-			hw_dbg(hw, "Auto-negotiation did not complete\n");
-			return status;
-		}
+s32 ixgbe_put_phy_token(struct ixgbe_hw *hw)
+{
+	struct ixgbe_hic_phy_token_req token_cmd;
+	s32 status;
 
-		flx_mask_st20 |= IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART;
-		status = hw->mac.ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, flx_mask_st20);
-	}
+	token_cmd.hdr.cmd = FW_PHY_TOKEN_REQ_CMD;
+	token_cmd.hdr.buf_len = FW_PHY_TOKEN_REQ_LEN;
+	token_cmd.hdr.cmd_or_resp.cmd_resv = 0;
+	token_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
+	token_cmd.port_number = hw->bus.lan_id;
+	token_cmd.command_type = FW_PHY_TOKEN_REL;
+	token_cmd.pad = 0;
+	status = ixgbe_host_interface_command(hw, (u32 *)&token_cmd,
+					      sizeof(token_cmd),
+					      IXGBE_HI_COMMAND_TIMEOUT,
+					      true);
+	if (status)
+		return status;
+	if (token_cmd.hdr.cmd_or_resp.ret_status == FW_PHY_TOKEN_OK)
+		return IXGBE_SUCCESS;
+
+	hw_dbg(hw, "Put PHY Token host interface command failed");
+	return IXGBE_ERR_FW_RESP_INVALID;
+}
+
+/**
+ * ixgbe_write_iosf_sb_reg_x550a - Writes a value to specified register
+ * of the IOSF device
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 3 bit device type
+ * @data: Data to write to the register
+ **/
+s32 ixgbe_write_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+				  u32 device_type, u32 data)
+{
+	struct ixgbe_hic_internal_phy_req write_cmd;
+	s32 status;
+	UNREFERENCED_1PARAMETER(device_type);
+
+	memset(&write_cmd, 0, sizeof(write_cmd));
+	write_cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;
+	write_cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;
+	write_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
+	write_cmd.port_number = hw->bus.lan_id;
+	write_cmd.command_type = FW_INT_PHY_REQ_WRITE;
+	write_cmd.address = IXGBE_CPU_TO_BE16(reg_addr);
+	write_cmd.write_data = IXGBE_CPU_TO_BE32(data);
+
+	status = ixgbe_host_interface_command(hw, (u32 *)&write_cmd,
+					      sizeof(write_cmd),
+					      IXGBE_HI_COMMAND_TIMEOUT, false);
 
 	return status;
 }
 
-/** ixgbe_setup_ixfi_x550em - Configure the KR PHY for iXFI mode.
- *  @hw: pointer to hardware structure
- *  @speed: the link speed to force
- *
- *  Configures the integrated KR PHY to use iXFI mode. Used to connect an
- *  internal and external PHY at a specific speed, without autonegotiation.
+/**
+ * ixgbe_read_iosf_sb_reg_x550a - Reads specified register of the IOSF device
+ * @hw: pointer to hardware structure
+ * @reg_addr: 32 bit PHY register to write
+ * @device_type: 3 bit device type
+ * @data: Pointer to read data from the register
  **/
-static s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
+s32 ixgbe_read_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+				 u32 device_type, u32 *data)
 {
-	struct ixgbe_mac_info *mac = &hw->mac;
+	union {
+		struct ixgbe_hic_internal_phy_req cmd;
+		struct ixgbe_hic_internal_phy_resp rsp;
+	} hic;
 	s32 status;
-	u32 reg_val;
+	UNREFERENCED_1PARAMETER(device_type);
 
-	/* iXFI is only supported with X552 */
-	if (mac->type != ixgbe_mac_X550EM_x)
-		return IXGBE_ERR_LINK_SETUP;
+	memset(&hic, 0, sizeof(hic));
+	hic.cmd.hdr.cmd = FW_INT_PHY_REQ_CMD;
+	hic.cmd.hdr.buf_len = FW_INT_PHY_REQ_LEN;
+	hic.cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
+	hic.cmd.port_number = hw->bus.lan_id;
+	hic.cmd.command_type = FW_INT_PHY_REQ_READ;
+	hic.cmd.address = IXGBE_CPU_TO_BE16(reg_addr);
 
-	/* Disable AN and force speed to 10G Serial. */
-	status = ixgbe_read_iosf_sb_reg_x550(hw,
-					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
-					IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
-		return status;
+	status = ixgbe_host_interface_command(hw, (u32 *)&hic.cmd,
+					      sizeof(hic.cmd),
+					      IXGBE_HI_COMMAND_TIMEOUT, true);
 
-	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;
-	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;
+	/* Extract the register value from the response. */
+	*data = IXGBE_BE32_TO_CPU(hic.rsp.read_data);
 
-	/* Select forced link speed for internal PHY. */
-	switch (*speed) {
-	case IXGBE_LINK_SPEED_10GB_FULL:
-		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G;
+	return status;
+}
+
+/**
+ * ixgbe_disable_mdd_X550
+ * @hw: pointer to hardware structure
+ *
+ * Disable malicious driver detection
+ **/
+void ixgbe_disable_mdd_X550(struct ixgbe_hw *hw)
+{
+	u32 reg;
+
+	DEBUGFUNC("ixgbe_disable_mdd_X550");
+
+	/* Disable MDD for TX DMA and interrupt */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
+	reg &= ~(IXGBE_DMATXCTL_MDP_EN | IXGBE_DMATXCTL_MBINTEN);
+	IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg);
+
+	/* Disable MDD for RX and interrupt */
+	reg = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
+	reg &= ~(IXGBE_RDRXCTL_MDP_EN | IXGBE_RDRXCTL_MBINTEN);
+	IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, reg);
+}
+
+/**
+ * ixgbe_enable_mdd_X550
+ * @hw: pointer to hardware structure
+ *
+ * Enable malicious driver detection
+ **/
+void ixgbe_enable_mdd_X550(struct ixgbe_hw *hw)
+{
+	u32 reg;
+
+	DEBUGFUNC("ixgbe_enable_mdd_X550");
+
+	/* Enable MDD for TX DMA and interrupt */
+	reg = IXGBE_READ_REG(hw, IXGBE_DMATXCTL);
+	reg |= (IXGBE_DMATXCTL_MDP_EN | IXGBE_DMATXCTL_MBINTEN);
+	IXGBE_WRITE_REG(hw, IXGBE_DMATXCTL, reg);
+
+	/* Enable MDD for RX and interrupt */
+	reg = IXGBE_READ_REG(hw, IXGBE_RDRXCTL);
+	reg |= (IXGBE_RDRXCTL_MDP_EN | IXGBE_RDRXCTL_MBINTEN);
+	IXGBE_WRITE_REG(hw, IXGBE_RDRXCTL, reg);
+}
+
+/**
+ * ixgbe_restore_mdd_vf_X550
+ * @hw: pointer to hardware structure
+ * @vf: vf index
+ *
+ * Restore VF that was disabled during malicious driver detection event
+ **/
+void ixgbe_restore_mdd_vf_X550(struct ixgbe_hw *hw, u32 vf)
+{
+	u32 idx, reg, num_qs, start_q, bitmask;
+
+	DEBUGFUNC("ixgbe_restore_mdd_vf_X550");
+
+	/* Map VF to queues */
+	reg = IXGBE_READ_REG(hw, IXGBE_MRQC);
+	switch (reg & IXGBE_MRQC_MRQE_MASK) {
+	case IXGBE_MRQC_VMDQRT8TCEN:
+		num_qs = 8;  /* 16 VFs / pools */
+		bitmask = 0x000000FF;
 		break;
-	case IXGBE_LINK_SPEED_1GB_FULL:
-		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G;
+	case IXGBE_MRQC_VMDQRSS32EN:
+	case IXGBE_MRQC_VMDQRT4TCEN:
+		num_qs = 4;  /* 32 VFs / pools */
+		bitmask = 0x0000000F;
+		break;
+	default:            /* 64 VFs / pools */
+		num_qs = 2;
+		bitmask = 0x00000003;
+		break;
+	}
+	start_q = vf * num_qs;
+
+	/* Release vf's queues by clearing WQBR_TX and WQBR_RX (RW1C) */
+	idx = start_q / 32;
+	reg = 0;
+	reg |= (bitmask << (start_q % 32));
+	IXGBE_WRITE_REG(hw, IXGBE_WQBR_TX(idx), reg);
+	IXGBE_WRITE_REG(hw, IXGBE_WQBR_RX(idx), reg);
+}
+
+/**
+ * ixgbe_mdd_event_X550
+ * @hw: pointer to hardware structure
+ * @vf_bitmap: vf bitmap of malicious vfs
+ *
+ * Handle malicious driver detection event.
+ **/
+void ixgbe_mdd_event_X550(struct ixgbe_hw *hw, u32 *vf_bitmap)
+{
+	u32 wqbr;
+	u32 i, j, reg, q, shift, vf, idx;
+
+	DEBUGFUNC("ixgbe_mdd_event_X550");
+
+	/* figure out pool size for mapping to vf's */
+	reg = IXGBE_READ_REG(hw, IXGBE_MRQC);
+	switch (reg & IXGBE_MRQC_MRQE_MASK) {
+	case IXGBE_MRQC_VMDQRT8TCEN:
+		shift = 3;  /* 16 VFs / pools */
+		break;
+	case IXGBE_MRQC_VMDQRSS32EN:
+	case IXGBE_MRQC_VMDQRT4TCEN:
+		shift = 2;  /* 32 VFs / pools */
 		break;
 	default:
-		/* Other link speeds are not supported by internal KR PHY. */
-		return IXGBE_ERR_LINK_SETUP;
+		shift = 1;  /* 64 VFs / pools */
+		break;
 	}
 
-	status = ixgbe_write_iosf_sb_reg_x550(hw,
-				IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-	if (status)
-		return status;
+	/* Read WQBR_TX and WQBR_RX and check for malicious queues */
+	for (i = 0; i < 4; i++) {
+		wqbr = IXGBE_READ_REG(hw, IXGBE_WQBR_TX(i));
+		wqbr |= IXGBE_READ_REG(hw, IXGBE_WQBR_RX(i));
 
-	/* Additional configuration needed for x550em_x */
-	if (hw->mac.type == ixgbe_mac_X550EM_x) {
-		status = ixgbe_setup_ixfi_x550em_x(hw);
-		if (status)
-			return status;
+		if (!wqbr)
+			continue;
+
+		/* Get malicious queue */
+		for (j = 0; j < 32 && wqbr; j++) {
+
+			if (!(wqbr & (1 << j)))
+				continue;
+
+			/* Get queue from bitmask */
+			q = j + (i * 32);
+
+			/* Map queue to vf */
+			vf = (q >> shift);
+
+			/* Set vf bit in vf_bitmap */
+			idx = vf / 32;
+			vf_bitmap[idx] |= (1 << (vf % 32));
+			wqbr &= ~(1 << j);
+		}
 	}
+}
 
-	/* Toggle port SW reset by AN reset. */
-	status = ixgbe_restart_an_internal_phy_x550em(hw);
+/**
+ * ixgbe_get_media_type_X550em - Get media type
+ * @hw: pointer to hardware structure
+ *
+ * Returns the media type (fiber, copper, backplane)
+ */
+enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw)
+{
+	enum ixgbe_media_type media_type;
 
-	return status;
+	DEBUGFUNC("ixgbe_get_media_type_X550em");
+
+	/* Detect if there is a copper PHY attached. */
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_X_KR:
+	case IXGBE_DEV_ID_X550EM_X_KX4:
+	case IXGBE_DEV_ID_X550EM_X_XFI:
+	case IXGBE_DEV_ID_X550EM_A_KR:
+	case IXGBE_DEV_ID_X550EM_A_KR_L:
+		media_type = ixgbe_media_type_backplane;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_SFP:
+	case IXGBE_DEV_ID_X550EM_A_SFP:
+	case IXGBE_DEV_ID_X550EM_A_SFP_N:
+	case IXGBE_DEV_ID_X550EM_A_QSFP:
+	case IXGBE_DEV_ID_X550EM_A_QSFP_N:
+		media_type = ixgbe_media_type_fiber;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_1G_T:
+	case IXGBE_DEV_ID_X550EM_X_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_10G_T:
+		media_type = ixgbe_media_type_copper;
+		break;
+	case IXGBE_DEV_ID_X550EM_A_SGMII:
+	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
+		media_type = ixgbe_media_type_backplane;
+		hw->phy.type = ixgbe_phy_sgmii;
+		break;
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+		media_type = ixgbe_media_type_copper;
+		break;
+	default:
+		media_type = ixgbe_media_type_unknown;
+		break;
+	}
+	return media_type;
 }
 
 /**
- *  ixgbe_supported_sfp_modules_X550em - Check if SFP module type is supported
- *  @hw: pointer to hardware structure
- *  @linear: true if SFP module is linear
+ * ixgbe_supported_sfp_modules_X550em - Check if SFP module type is supported
+ * @hw: pointer to hardware structure
+ * @linear: true if SFP module is linear
  */
-static s32 ixgbe_supported_sfp_modules_X550em(struct ixgbe_hw *hw, bool *linear)
+STATIC s32 ixgbe_supported_sfp_modules_X550em(struct ixgbe_hw *hw, bool *linear)
 {
+	DEBUGFUNC("ixgbe_supported_sfp_modules_X550em");
+
 	switch (hw->phy.sfp_type) {
 	case ixgbe_sfp_type_not_present:
 		return IXGBE_ERR_SFP_NOT_PRESENT;
@@ -1633,323 +1541,111 @@ static s32 ixgbe_supported_sfp_modules_X550em(struct ixgbe_hw *hw, bool *linear)
 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
 	}
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
- * ixgbe_setup_mac_link_sfp_x550em - Configure the KR PHY for SFP.
+ * ixgbe_identify_sfp_module_X550em - Identifies SFP modules
  * @hw: pointer to hardware structure
- * @speed: the link speed to force
- * @autoneg_wait_to_complete: unused
  *
- * Configures the extern PHY and the integrated KR PHY for SFP support.
- */
-static s32
-ixgbe_setup_mac_link_sfp_x550em(struct ixgbe_hw *hw,
-				ixgbe_link_speed speed,
-				__always_unused bool autoneg_wait_to_complete)
+ * Searches for and identifies the SFP module and assigns appropriate PHY type.
+ **/
+s32 ixgbe_identify_sfp_module_X550em(struct ixgbe_hw *hw)
 {
 	s32 status;
-	u16 reg_slice, reg_val;
-	bool setup_linear = false;
+	bool linear;
 
-	/* Check if SFP module is supported and linear */
-	status = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);
+	DEBUGFUNC("ixgbe_identify_sfp_module_X550em");
 
-	/* If no SFP module present, then return success. Return success since
-	 * there is no reason to configure CS4227 and SFP not present error is
-	 * not accepted in the setup MAC link flow.
-	 */
-	if (status == IXGBE_ERR_SFP_NOT_PRESENT)
-		return 0;
+	status = ixgbe_identify_module_generic(hw);
 
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	/* Configure internal PHY for KR/KX. */
-	ixgbe_setup_kr_speed_x550em(hw, speed);
-
-	/* Configure CS4227 LINE side to proper mode. */
-	reg_slice = IXGBE_CS4227_LINE_SPARE24_LSB + (hw->bus.lan_id << 12);
-	if (setup_linear)
-		reg_val = (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 0x1;
-	else
-		reg_val = (IXGBE_CS4227_EDC_MODE_SR << 1) | 0x1;
-
-	status = hw->link.ops.write_link(hw, hw->link.addr, reg_slice,
-					 reg_val);
+	/* Check if SFP module is supported */
+	status = ixgbe_supported_sfp_modules_X550em(hw, &linear);
 
 	return status;
 }
 
 /**
- * ixgbe_setup_sfi_x550a - Configure the internal PHY for native SFI mode
+ * ixgbe_setup_sfp_modules_X550em - Setup MAC link ops
  * @hw: pointer to hardware structure
- * @speed: the link speed to force
- *
- * Configures the integrated PHY for native SFI mode. Used to connect the
- * internal PHY directly to an SFP cage, without autonegotiation.
- **/
-static s32 ixgbe_setup_sfi_x550a(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
+ */
+s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw)
 {
-	struct ixgbe_mac_info *mac = &hw->mac;
 	s32 status;
-	u32 reg_val;
+	bool linear;
 
-	/* Disable all AN and force speed to 10G Serial. */
-	status = mac->ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
-	if (status)
+	DEBUGFUNC("ixgbe_setup_sfp_modules_X550em");
+
+	/* Check if SFP module is supported */
+	status = ixgbe_supported_sfp_modules_X550em(hw, &linear);
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;
-	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;
-	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;
-	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;
+	ixgbe_init_mac_link_ops_X550em(hw);
+	hw->phy.ops.reset = NULL;
 
-	/* Select forced link speed for internal PHY. */
-	switch (*speed) {
-	case IXGBE_LINK_SPEED_10GB_FULL:
-		reg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10G;
-		break;
-	case IXGBE_LINK_SPEED_1GB_FULL:
-		reg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G;
-		break;
-	default:
-		/* Other link speeds are not supported by internal PHY. */
-		return IXGBE_ERR_LINK_SETUP;
-	}
-
-	status = mac->ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
-
-	/* Toggle port SW reset by AN reset. */
-	status = ixgbe_restart_an_internal_phy_x550em(hw);
-
-	return status;
-}
-
-/**
- * ixgbe_setup_mac_link_sfp_n - Setup internal PHY for native SFP
- * @hw: pointer to hardware structure
- * @speed: link speed
- * @autoneg_wait_to_complete: unused
- *
- * Configure the the integrated PHY for native SFP support.
- */
-static s32
-ixgbe_setup_mac_link_sfp_n(struct ixgbe_hw *hw, ixgbe_link_speed speed,
-			   __always_unused bool autoneg_wait_to_complete)
-{
-	bool setup_linear = false;
-	u32 reg_phy_int;
-	s32 ret_val;
-
-	/* Check if SFP module is supported and linear */
-	ret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);
-
-	/* If no SFP module present, then return success. Return success since
-	 * SFP not present error is not excepted in the setup MAC link flow.
-	 */
-	if (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)
-		return 0;
-
-	if (ret_val)
-		return ret_val;
-
-	/* Configure internal PHY for native SFI based on module type */
-	ret_val = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_phy_int);
-	if (ret_val)
-		return ret_val;
-
-	reg_phy_int &= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_DA;
-	if (!setup_linear)
-		reg_phy_int |= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR;
-
-	ret_val = hw->mac.ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_phy_int);
-	if (ret_val)
-		return ret_val;
-
-	/* Setup SFI internal link. */
-	return ixgbe_setup_sfi_x550a(hw, &speed);
-}
-
-/**
- * ixgbe_setup_mac_link_sfp_x550a - Setup internal PHY for SFP
- * @hw: pointer to hardware structure
- * @speed: link speed
- * @autoneg_wait_to_complete: unused
- *
- * Configure the the integrated PHY for SFP support.
- */
-static s32
-ixgbe_setup_mac_link_sfp_x550a(struct ixgbe_hw *hw, ixgbe_link_speed speed,
-			       __always_unused bool autoneg_wait_to_complete)
-{
-	u32 reg_slice, slice_offset;
-	bool setup_linear = false;
-	u16 reg_phy_ext;
-	s32 ret_val;
-
-	/* Check if SFP module is supported and linear */
-	ret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);
-
-	/* If no SFP module present, then return success. Return success since
-	 * SFP not present error is not excepted in the setup MAC link flow.
-	 */
-	if (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)
-		return 0;
-
-	if (ret_val)
-		return ret_val;
-
-	/* Configure internal PHY for KR/KX. */
-	ixgbe_setup_kr_speed_x550em(hw, speed);
-
-	if (hw->phy.mdio.prtad == MDIO_PRTAD_NONE)
-		return IXGBE_ERR_PHY_ADDR_INVALID;
-
-	/* Get external PHY SKU id */
-	ret_val = hw->phy.ops.read_reg(hw, IXGBE_CS4227_EFUSE_PDF_SKU,
-				       IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
-	if (ret_val)
-		return ret_val;
-
-	/* When configuring quad port CS4223, the MAC instance is part
-	 * of the slice offset.
-	 */
-	if (reg_phy_ext == IXGBE_CS4223_SKU_ID)
-		slice_offset = (hw->bus.lan_id +
-				(hw->bus.instance_id << 1)) << 12;
-	else
-		slice_offset = hw->bus.lan_id << 12;
-
-	/* Configure CS4227/CS4223 LINE side to proper mode. */
-	reg_slice = IXGBE_CS4227_LINE_SPARE24_LSB + slice_offset;
-
-	ret_val = hw->phy.ops.read_reg(hw, reg_slice,
-				       IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
-	if (ret_val)
-		return ret_val;
-
-	reg_phy_ext &= ~((IXGBE_CS4227_EDC_MODE_CX1 << 1) |
-			 (IXGBE_CS4227_EDC_MODE_SR << 1));
-
-	if (setup_linear)
-		reg_phy_ext |= (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 1;
-	else
-		reg_phy_ext |= (IXGBE_CS4227_EDC_MODE_SR << 1) | 1;
-
-	ret_val = hw->phy.ops.write_reg(hw, reg_slice,
-					IXGBE_MDIO_ZERO_DEV_TYPE, reg_phy_ext);
-	if (ret_val)
-		return ret_val;
-
-	/* Flush previous write with a read */
-	return hw->phy.ops.read_reg(hw, reg_slice,
-				    IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
+	return IXGBE_SUCCESS;
 }
 
 /**
- * ixgbe_setup_mac_link_t_X550em - Sets the auto advertised link speed
- * @hw: pointer to hardware structure
- * @speed: new link speed
- * @autoneg_wait: true when waiting for completion is needed
- *
- * Setup internal/external PHY link speed based on link speed, then set
- * external PHY auto advertised link speed.
- *
- * Returns error status for any failure
- **/
-static s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw,
-					 ixgbe_link_speed speed,
-					 bool autoneg_wait)
+*  ixgbe_restart_an_internal_phy_x550em - restart autonegotiation for the
+*  internal PHY
+*  @hw: pointer to hardware structure
+**/
+STATIC s32 ixgbe_restart_an_internal_phy_x550em(struct ixgbe_hw *hw)
 {
 	s32 status;
-	ixgbe_link_speed force_speed;
-
-	/* Setup internal/external PHY link speed to iXFI (10G), unless
-	 * only 1G is auto advertised then setup KX link.
-	 */
-	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
-		force_speed = IXGBE_LINK_SPEED_10GB_FULL;
-	else
-		force_speed = IXGBE_LINK_SPEED_1GB_FULL;
+	u32 link_ctrl;
 
-	/* If X552 and internal link mode is XFI, then setup XFI internal link.
-	 */
-	if (hw->mac.type == ixgbe_mac_X550EM_x &&
-	    !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE)) {
-		status = ixgbe_setup_ixfi_x550em(hw, &force_speed);
+	/* Restart auto-negotiation. */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				       IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+				       IXGBE_SB_IOSF_TARGET_KR_PHY, &link_ctrl);
 
-		if (status)
-			return status;
+	if (status) {
+		hw_dbg(hw, "Auto-negotiation did not complete\n");
+		return status;
 	}
 
-	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);
-}
-
-/** ixgbe_check_link_t_X550em - Determine link and speed status
-  * @hw: pointer to hardware structure
-  * @speed: pointer to link speed
-  * @link_up: true when link is up
-  * @link_up_wait_to_complete: bool used to wait for link up or not
-  *
-  * Check that both the MAC and X557 external PHY have link.
-  **/
-static s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw,
-				     ixgbe_link_speed *speed,
-				     bool *link_up,
-				     bool link_up_wait_to_complete)
-{
-	u32 status;
-	u16 i, autoneg_status;
-
-	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
-		return IXGBE_ERR_CONFIG;
-
-	status = ixgbe_check_mac_link_generic(hw, speed, link_up,
-					      link_up_wait_to_complete);
+	link_ctrl |= IXGBE_KRM_LINK_CTRL_1_TETH_AN_RESTART;
+	status = hw->mac.ops.write_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, link_ctrl);
 
-	/* If check link fails or MAC link is not up, then return */
-	if (status || !(*link_up))
-		return status;
+	if (hw->mac.type == ixgbe_mac_X550EM_a) {
+		u32 flx_mask_st20;
 
-	/* MAC link is up, so check external PHY link.
-	 * Link status is latching low, and can only be used to detect link
-	 * drop, and not the current status of the link without performing
-	 * back-to-back reads.
-	 */
-	for (i = 0; i < 2; i++) {
-		status = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,
-					      &autoneg_status);
+		/* Indicate to FW that AN restart has been asserted */
+		status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_mask_st20);
 
-		if (status)
+		if (status) {
+			hw_dbg(hw, "Auto-negotiation did not complete\n");
 			return status;
-	}
+		}
 
-	/* If external PHY link is not up, then indicate link not up */
-	if (!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS))
-		*link_up = false;
+		flx_mask_st20 |= IXGBE_KRM_PMD_FLX_MASK_ST20_FW_AN_RESTART;
+		status = hw->mac.ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, flx_mask_st20);
+	}
 
-	return 0;
+	return status;
 }
 
 /**
  * ixgbe_setup_sgmii - Set up link for sgmii
  * @hw: pointer to hardware structure
- * @speed: unused
- * @autoneg_wait_to_complete: unused
+ * @speed: new link speed
+ * @autoneg_wait: true when waiting for completion is needed
  */
-static s32
-ixgbe_setup_sgmii(struct ixgbe_hw *hw, __always_unused ixgbe_link_speed speed,
-		  __always_unused bool autoneg_wait_to_complete)
+STATIC s32 ixgbe_setup_sgmii(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+			     bool autoneg_wait)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 	u32 lval, sval, flx_val;
@@ -1987,14 +1683,8 @@ ixgbe_setup_sgmii(struct ixgbe_hw *hw, __always_unused ixgbe_link_speed speed,
 		return rc;
 
 	rc = mac->ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);
-	if (rc)
-		return rc;
-
-	rc = mac->ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);
+				    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				    IXGBE_SB_IOSF_TARGET_KR_PHY, &flx_val);
 	if (rc)
 		return rc;
 
@@ -2005,22 +1695,25 @@ ixgbe_setup_sgmii(struct ixgbe_hw *hw, __always_unused ixgbe_link_speed speed,
 	flx_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;
 
 	rc = mac->ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, flx_val);
+				    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				    IXGBE_SB_IOSF_TARGET_KR_PHY, flx_val);
 	if (rc)
 		return rc;
 
 	rc = ixgbe_restart_an_internal_phy_x550em(hw);
-	return rc;
+	if (rc)
+		return rc;
+
+	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);
 }
 
 /**
- * ixgbe_setup_sgmii_fw - Set up link for sgmii with firmware-controlled PHYs
+ * ixgbe_setup_sgmii_fw - Set up link for internal PHY SGMII auto-negotiation
  * @hw: pointer to hardware structure
- * @speed: the link speed to force
+ * @speed: new link speed
  * @autoneg_wait: true when waiting for completion is needed
  */
-static s32 ixgbe_setup_sgmii_fw(struct ixgbe_hw *hw, ixgbe_link_speed speed,
+STATIC s32 ixgbe_setup_sgmii_fw(struct ixgbe_hw *hw, ixgbe_link_speed speed,
 				bool autoneg_wait)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
@@ -2082,174 +1775,81 @@ static s32 ixgbe_setup_sgmii_fw(struct ixgbe_hw *hw, ixgbe_link_speed speed,
 	if (rc)
 		return rc;
 
-	ixgbe_restart_an_internal_phy_x550em(hw);
+	rc = ixgbe_restart_an_internal_phy_x550em(hw);
 
 	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait);
 }
 
 /**
- * ixgbe_fc_autoneg_sgmii_x550em_a - Enable flow control IEEE clause 37
+ * ixgbe_init_mac_link_ops_X550em - init mac link function pointers
  * @hw: pointer to hardware structure
- *
- * Enable flow control according to IEEE clause 37.
  */
-static void ixgbe_fc_autoneg_sgmii_x550em_a(struct ixgbe_hw *hw)
-{
-	s32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;
-	u32 info[FW_PHY_ACT_DATA_COUNT] = { 0 };
-	ixgbe_link_speed speed;
-	bool link_up;
-
-	/* AN should have completed when the cable was plugged in.
-	 * Look for reasons to bail out.  Bail out if:
-	 * - FC autoneg is disabled, or if
-	 * - link is not up.
-	 */
-	if (hw->fc.disable_fc_autoneg)
-		goto out;
-
-	hw->mac.ops.check_link(hw, &speed, &link_up, false);
-	if (!link_up)
-		goto out;
-
-	/* Check if auto-negotiation has completed */
-	status = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &info);
-	if (status || !(info[0] & FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE)) {
-		status = IXGBE_ERR_FC_NOT_NEGOTIATED;
-		goto out;
-	}
-
-	/* Negotiate the flow control */
-	status = ixgbe_negotiate_fc(hw, info[0], info[0],
-				    FW_PHY_ACT_GET_LINK_INFO_FC_RX,
-				    FW_PHY_ACT_GET_LINK_INFO_FC_TX,
-				    FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX,
-				    FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX);
-
-out:
-	if (!status) {
-		hw->fc.fc_was_autonegged = true;
-	} else {
-		hw->fc.fc_was_autonegged = false;
-		hw->fc.current_mode = hw->fc.requested_mode;
-	}
-}
-
-/** ixgbe_init_mac_link_ops_X550em_a - Init mac link function pointers
- *  @hw: pointer to hardware structure
- **/
-static void ixgbe_init_mac_link_ops_X550em_a(struct ixgbe_hw *hw)
+void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw)
 {
 	struct ixgbe_mac_info *mac = &hw->mac;
 
-	switch (mac->ops.get_media_type(hw)) {
+	DEBUGFUNC("ixgbe_init_mac_link_ops_X550em");
+
+	switch (hw->mac.ops.get_media_type(hw)) {
 	case ixgbe_media_type_fiber:
-		mac->ops.setup_fc = NULL;
-		mac->ops.fc_autoneg = ixgbe_fc_autoneg_fiber_x550em_a;
+		/* CS4227 does not support autoneg, so disable the laser control
+		 * functions for SFP+ fiber
+		 */
+		mac->ops.disable_tx_laser = NULL;
+		mac->ops.enable_tx_laser = NULL;
+		mac->ops.flap_tx_laser = NULL;
+		mac->ops.setup_link = ixgbe_setup_mac_link_multispeed_fiber;
+		mac->ops.set_rate_select_speed =
+					ixgbe_set_soft_rate_select_speed;
+
+		if ((hw->device_id == IXGBE_DEV_ID_X550EM_A_SFP_N) ||
+		    (hw->device_id == IXGBE_DEV_ID_X550EM_A_SFP))
+			mac->ops.setup_mac_link =
+						ixgbe_setup_mac_link_sfp_x550a;
+		else
+			mac->ops.setup_mac_link =
+						ixgbe_setup_mac_link_sfp_x550em;
 		break;
 	case ixgbe_media_type_copper:
-		if (hw->device_id != IXGBE_DEV_ID_X550EM_A_1G_T &&
-		    hw->device_id != IXGBE_DEV_ID_X550EM_A_1G_T_L) {
-			mac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;
+		if (hw->device_id == IXGBE_DEV_ID_X550EM_X_1G_T)
 			break;
+		if (hw->mac.type == ixgbe_mac_X550EM_a) {
+			if (hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T ||
+			    hw->device_id == IXGBE_DEV_ID_X550EM_A_1G_T_L) {
+				mac->ops.setup_link = ixgbe_setup_sgmii_fw;
+				mac->ops.check_link =
+						   ixgbe_check_mac_link_generic;
+			} else {
+				mac->ops.setup_link =
+						  ixgbe_setup_mac_link_t_X550em;
+			}
+		} else {
+			mac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;
+			mac->ops.check_link = ixgbe_check_link_t_X550em;
 		}
-		mac->ops.fc_autoneg = ixgbe_fc_autoneg_sgmii_x550em_a;
-		mac->ops.setup_fc = ixgbe_fc_autoneg_fw;
-		mac->ops.setup_link = ixgbe_setup_sgmii_fw;
-		mac->ops.check_link = ixgbe_check_mac_link_generic;
 		break;
 	case ixgbe_media_type_backplane:
-		mac->ops.fc_autoneg = ixgbe_fc_autoneg_backplane_x550em_a;
-		mac->ops.setup_fc = ixgbe_setup_fc_backplane_x550em_a;
+		if (hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII ||
+		    hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII_L)
+			mac->ops.setup_link = ixgbe_setup_sgmii;
 		break;
 	default:
 		break;
 	}
 }
 
-/** ixgbe_init_mac_link_ops_X550em - init mac link function pointers
- *  @hw: pointer to hardware structure
- **/
-static void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw)
-{
-	struct ixgbe_mac_info *mac = &hw->mac;
-
-	mac->ops.setup_fc = ixgbe_setup_fc_x550em;
-
-	switch (mac->ops.get_media_type(hw)) {
-	case ixgbe_media_type_fiber:
-		/* CS4227 does not support autoneg, so disable the laser control
-		 * functions for SFP+ fiber
-		 */
-		mac->ops.disable_tx_laser = NULL;
-		mac->ops.enable_tx_laser = NULL;
-		mac->ops.flap_tx_laser = NULL;
-		mac->ops.setup_link = ixgbe_setup_mac_link_multispeed_fiber;
-		switch (hw->device_id) {
-		case IXGBE_DEV_ID_X550EM_A_SFP_N:
-			mac->ops.setup_mac_link = ixgbe_setup_mac_link_sfp_n;
-			break;
-		case IXGBE_DEV_ID_X550EM_A_SFP:
-			mac->ops.setup_mac_link =
-						ixgbe_setup_mac_link_sfp_x550a;
-			break;
-		default:
-			mac->ops.setup_mac_link =
-						ixgbe_setup_mac_link_sfp_x550em;
-			break;
-		}
-		mac->ops.set_rate_select_speed =
-					ixgbe_set_soft_rate_select_speed;
-		break;
-	case ixgbe_media_type_copper:
-		if (hw->device_id == IXGBE_DEV_ID_X550EM_X_1G_T)
-			break;
-		mac->ops.setup_link = ixgbe_setup_mac_link_t_X550em;
-		mac->ops.setup_fc = ixgbe_setup_fc_generic;
-		mac->ops.check_link = ixgbe_check_link_t_X550em;
-		break;
-	case ixgbe_media_type_backplane:
-		if (hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII ||
-		    hw->device_id == IXGBE_DEV_ID_X550EM_A_SGMII_L)
-			mac->ops.setup_link = ixgbe_setup_sgmii;
-		break;
-	default:
-		break;
-	}
-
-	/* Additional modification for X550em_a devices */
-	if (hw->mac.type == ixgbe_mac_x550em_a)
-		ixgbe_init_mac_link_ops_X550em_a(hw);
-}
-
-/** ixgbe_setup_sfp_modules_X550em - Setup SFP module
- * @hw: pointer to hardware structure
- */
-static s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw)
-{
-	s32 status;
-	bool linear;
-
-	/* Check if SFP module is supported */
-	status = ixgbe_supported_sfp_modules_X550em(hw, &linear);
-	if (status)
-		return status;
-
-	ixgbe_init_mac_link_ops_X550em(hw);
-	hw->phy.ops.reset = NULL;
-
-	return 0;
-}
-
-/** ixgbe_get_link_capabilities_x550em - Determines link capabilities
+/**
+ * ixgbe_get_link_capabilities_x550em - Determines link capabilities
  * @hw: pointer to hardware structure
  * @speed: pointer to link speed
  * @autoneg: true when autoneg or autotry is enabled
- **/
-static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
-					      ixgbe_link_speed *speed,
-					      bool *autoneg)
+ */
+s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
+				       ixgbe_link_speed *speed,
+				       bool *autoneg)
 {
+	DEBUGFUNC("ixgbe_get_link_capabilities_X550em");
+
 	if (hw->phy.type == ixgbe_phy_fw) {
 		*autoneg = true;
 		*speed = hw->phy.speeds_supported;
@@ -2258,15 +1858,17 @@ static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
 
 	/* SFP */
 	if (hw->phy.media_type == ixgbe_media_type_fiber) {
+
 		/* CS4227 SFP must not enable auto-negotiation */
 		*autoneg = false;
 
+		/* Check if 1G SFP module. */
 		if (hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
-		    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1 ||
-		    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
+		    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1
+		    || hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core0 ||
 		    hw->phy.sfp_type == ixgbe_sfp_type_1g_lx_core1) {
 			*speed = IXGBE_LINK_SPEED_1GB_FULL;
-			return 0;
+			return IXGBE_SUCCESS;
 		}
 
 		/* Link capabilities are based on SFP */
@@ -2276,57 +1878,55 @@ static s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
 		else
 			*speed = IXGBE_LINK_SPEED_10GB_FULL;
 	} else {
+		*autoneg = true;
+
 		switch (hw->phy.type) {
-		case ixgbe_phy_x550em_kx4:
-			*speed = IXGBE_LINK_SPEED_1GB_FULL |
-				 IXGBE_LINK_SPEED_2_5GB_FULL |
-				 IXGBE_LINK_SPEED_10GB_FULL;
-			break;
 		case ixgbe_phy_x550em_xfi:
 			*speed = IXGBE_LINK_SPEED_1GB_FULL |
 				 IXGBE_LINK_SPEED_10GB_FULL;
+			*autoneg = false;
 			break;
 		case ixgbe_phy_ext_1g_t:
 		case ixgbe_phy_sgmii:
 			*speed = IXGBE_LINK_SPEED_1GB_FULL;
 			break;
 		case ixgbe_phy_x550em_kr:
-			if (hw->mac.type == ixgbe_mac_x550em_a) {
+			if (hw->mac.type == ixgbe_mac_X550EM_a) {
 				/* check different backplane modes */
 				if (hw->phy.nw_mng_if_sel &
-				    IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G) {
+					   IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G) {
 					*speed = IXGBE_LINK_SPEED_2_5GB_FULL;
 					break;
 				} else if (hw->device_id ==
-					   IXGBE_DEV_ID_X550EM_A_KR_L) {
+						   IXGBE_DEV_ID_X550EM_A_KR_L) {
 					*speed = IXGBE_LINK_SPEED_1GB_FULL;
 					break;
 				}
 			}
-			fallthrough;
+			/* fall through */
 		default:
 			*speed = IXGBE_LINK_SPEED_10GB_FULL |
 				 IXGBE_LINK_SPEED_1GB_FULL;
 			break;
 		}
-		*autoneg = true;
 	}
-	return 0;
+
+	return IXGBE_SUCCESS;
 }
 
 /**
  * ixgbe_get_lasi_ext_t_x550em - Determime external Base T PHY interrupt cause
  * @hw: pointer to hardware structure
  * @lsc: pointer to boolean flag which indicates whether external Base T
- *	 PHY interrupt is lsc
+ *      PHY interrupt is lsc
  *
  * Determime if external Base T PHY interrupt cause is high temperature
  * failure alarm or link status change.
  *
  * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
  * failure alarm, else return PHY access status.
- **/
-static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
+ */
+STATIC s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
 {
 	u32 status;
 	u16 reg;
@@ -2335,27 +1935,29 @@ static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
 
 	/* Vendor alarm triggered */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
 
-	if (status || !(reg & IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN))
+	if (status != IXGBE_SUCCESS ||
+	    !(reg & IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN))
 		return status;
 
 	/* Vendor Auto-Neg alarm triggered or Global alarm 1 triggered */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_FLAG,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
 
-	if (status || !(reg & (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |
-				IXGBE_MDIO_GLOBAL_ALARM_1_INT)))
+	if (status != IXGBE_SUCCESS ||
+	    !(reg & (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |
+	    IXGBE_MDIO_GLOBAL_ALARM_1_INT)))
 		return status;
 
 	/* Global alarm triggered */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_ALARM_1,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
 
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* If high temperature failure, then return over temp error and exit */
@@ -2363,13 +1965,13 @@ static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
 		/* power down the PHY in case the PHY FW didn't already */
 		ixgbe_set_copper_phy_power(hw, false);
 		return IXGBE_ERR_OVERTEMP;
-	}
-	if (reg & IXGBE_MDIO_GLOBAL_ALM_1_DEV_FAULT) {
+	} else if (reg & IXGBE_MDIO_GLOBAL_ALM_1_DEV_FAULT) {
 		/*  device fault alarm triggered */
 		status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_FAULT_MSG,
-					  MDIO_MMD_VEND1,
+					  IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 					  &reg);
-		if (status)
+
+		if (status != IXGBE_SUCCESS)
 			return status;
 
 		/* if device fault was due to high temp alarm handle and exit */
@@ -2382,23 +1984,24 @@ static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
 
 	/* Vendor alarm 2 triggered */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_CHIP_STD_INT_FLAG,
-				      MDIO_MMD_AN, &reg);
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
 
-	if (status || !(reg & IXGBE_MDIO_GLOBAL_STD_ALM2_INT))
+	if (status != IXGBE_SUCCESS ||
+	    !(reg & IXGBE_MDIO_GLOBAL_STD_ALM2_INT))
 		return status;
 
 	/* link connect/disconnect event occurred */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM2,
-				      MDIO_MMD_AN, &reg);
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
 
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* Indicate LSC */
 	if (reg & IXGBE_MDIO_AUTO_NEG_VEN_LSC)
 		*lsc = true;
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -2409,8 +2012,8 @@ static s32 ixgbe_get_lasi_ext_t_x550em(struct ixgbe_hw *hw, bool *lsc)
  * Base T PHY
  *
  * Returns PHY access status
- **/
-static s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)
+ */
+STATIC s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)
 {
 	u32 status;
 	u16 reg;
@@ -2429,97 +2032,77 @@ static s32 ixgbe_enable_lasi_ext_t_x550em(struct ixgbe_hw *hw)
 	 * as the internal link to the external PHY. Hence adding a check here
 	 * to avoid enabling LASI interrupts for X553 devices.
 	 */
-	if (hw->mac.type != ixgbe_mac_x550em_a) {
+	if (hw->mac.type != ixgbe_mac_X550EM_a) {
 		status = hw->phy.ops.read_reg(hw,
-					    IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
-					    MDIO_MMD_AN, &reg);
-		if (status)
+					IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
+					IXGBE_MDIO_AUTO_NEG_DEV_TYPE, &reg);
+
+		if (status != IXGBE_SUCCESS)
 			return status;
 
 		reg |= IXGBE_MDIO_PMA_TX_VEN_LASI_INT_EN;
 
 		status = hw->phy.ops.write_reg(hw,
-					    IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
-					    MDIO_MMD_AN, reg);
-		if (status)
+					IXGBE_MDIO_PMA_TX_VEN_LASI_INT_MASK,
+					IXGBE_MDIO_AUTO_NEG_DEV_TYPE, reg);
+
+		if (status != IXGBE_SUCCESS)
 			return status;
 	}
 
 	/* Enable high temperature failure and global fault alarms */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	reg |= (IXGBE_MDIO_GLOBAL_INT_HI_TEMP_EN |
 		IXGBE_MDIO_GLOBAL_INT_DEV_FAULT_EN);
 
 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_MASK,
-				       MDIO_MMD_VEND1,
+				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				       reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* Enable vendor Auto-Neg alarm and Global Interrupt Mask 1 alarm */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	reg |= (IXGBE_MDIO_GLOBAL_AN_VEN_ALM_INT_EN |
 		IXGBE_MDIO_GLOBAL_ALARM_1_INT);
 
 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_VEN_MASK,
-				       MDIO_MMD_VEND1,
+				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				       reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* Enable chip-wide vendor alarm */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,
-				      MDIO_MMD_VEND1,
+				      IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				      &reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	reg |= IXGBE_MDIO_GLOBAL_VEN_ALM_INT_EN;
 
 	status = hw->phy.ops.write_reg(hw, IXGBE_MDIO_GLOBAL_INT_CHIP_STD_MASK,
-				       MDIO_MMD_VEND1,
+				       IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
 				       reg);
 
 	return status;
 }
 
-/**
- * ixgbe_handle_lasi_ext_t_x550em - Handle external Base T PHY interrupt
- * @hw: pointer to hardware structure
- *
- * Handle external Base T PHY interrupt. If high temperature
- * failure alarm then return error, else if link status change
- * then setup internal/external PHY link
- *
- * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
- * failure alarm, else return PHY access status.
- **/
-static s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)
-{
-	struct ixgbe_phy_info *phy = &hw->phy;
-	bool lsc;
-	u32 status;
-
-	status = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);
-	if (status)
-		return status;
-
-	if (lsc && phy->ops.setup_internal_link)
-		return phy->ops.setup_internal_link(hw);
-
-	return 0;
-}
-
 /**
  * ixgbe_setup_kr_speed_x550em - Configure the KR PHY for link speed.
  * @hw: pointer to hardware structure
@@ -2527,7 +2110,7 @@ static s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)
  *
  * Configures the integrated KR PHY.
  **/
-static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,
+STATIC s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,
 				       ixgbe_link_speed speed)
 {
 	s32 status;
@@ -2555,11 +2138,11 @@ static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,
 					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
 					IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
 
-	if (hw->mac.type == ixgbe_mac_x550em_a) {
+	if (hw->mac.type == ixgbe_mac_X550EM_a) {
 		/* Set lane mode  to KR auto negotiation */
 		status = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+				    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				    IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
 
 		if (status)
 			return status;
@@ -2571,456 +2154,1591 @@ static s32 ixgbe_setup_kr_speed_x550em(struct ixgbe_hw *hw,
 		reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;
 
 		status = hw->mac.ops.write_iosf_sb_reg(hw,
-				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+				    IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				    IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
 	}
 
 	return ixgbe_restart_an_internal_phy_x550em(hw);
 }
 
 /**
- * ixgbe_setup_kr_x550em - Configure the KR PHY
+ * ixgbe_reset_phy_fw - Reset firmware-controlled PHYs
  * @hw: pointer to hardware structure
- **/
-static s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw)
+ */
+static s32 ixgbe_reset_phy_fw(struct ixgbe_hw *hw)
 {
-	/* leave link alone for 2.5G */
-	if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL)
-		return 0;
-
-	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+	u32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };
+	s32 rc;
 
-	return ixgbe_setup_kr_speed_x550em(hw, hw->phy.autoneg_advertised);
-}
+	if (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))
+		return IXGBE_SUCCESS;
 
-/** ixgbe_ext_phy_t_x550em_get_link - Get ext phy link status
- *  @hw: address of hardware structure
- *  @link_up: address of boolean to indicate link status
- *
- *  Returns error code if unable to get link status.
- **/
-static s32 ixgbe_ext_phy_t_x550em_get_link(struct ixgbe_hw *hw, bool *link_up)
-{
-	u32 ret;
-	u16 autoneg_status;
+	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_PHY_SW_RESET, &store);
+	if (rc)
+		return rc;
+	memset(store, 0, sizeof(store));
 
-	*link_up = false;
+	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_INIT_PHY, &store);
+	if (rc)
+		return rc;
 
-	/* read this twice back to back to indicate current status */
-	ret = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,
-				   &autoneg_status);
-	if (ret)
-		return ret;
+	return ixgbe_setup_fw_link(hw);
+}
 
-	ret = hw->phy.ops.read_reg(hw, MDIO_STAT1, MDIO_MMD_AN,
-				   &autoneg_status);
-	if (ret)
-		return ret;
+/**
+ * ixgbe_check_overtemp_fw - Check firmware-controlled PHYs for overtemp
+ * @hw: pointer to hardware structure
+ */
+static s32 ixgbe_check_overtemp_fw(struct ixgbe_hw *hw)
+{
+	u32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };
+	s32 rc;
 
-	*link_up = !!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS);
+	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &store);
+	if (rc)
+		return rc;
 
-	return 0;
+	if (store[0] & FW_PHY_ACT_GET_LINK_INFO_TEMP) {
+		ixgbe_shutdown_fw_phy(hw);
+		return IXGBE_ERR_OVERTEMP;
+	}
+	return IXGBE_SUCCESS;
 }
 
-/** ixgbe_setup_internal_phy_t_x550em - Configure KR PHY to X557 link
- *  @hw: point to hardware structure
- *
- *  Configures the link between the integrated KR PHY and the external X557 PHY
- *  The driver will call this function when it gets a link status change
- *  interrupt from the X557 PHY. This function configures the link speed
- *  between the PHYs to match the link speed of the BASE-T link.
+/**
+ * ixgbe_read_mng_if_sel_x550em - Read NW_MNG_IF_SEL register
+ * @hw: pointer to hardware structure
  *
- * A return of a non-zero value indicates an error, and the base driver should
- * not report link up.
+ * Read NW_MNG_IF_SEL register and save field values, and check for valid field
+ * values.
  **/
-static s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw)
+STATIC s32 ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw)
 {
-	ixgbe_link_speed force_speed;
-	bool link_up;
-	u32 status;
-	u16 speed;
-
-	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
-		return IXGBE_ERR_CONFIG;
+	/* Save NW management interface connected on board. This is used
+	 * to determine internal PHY mode.
+	 */
+	hw->phy.nw_mng_if_sel = IXGBE_READ_REG(hw, IXGBE_NW_MNG_IF_SEL);
 
-	if (!(hw->mac.type == ixgbe_mac_X550EM_x &&
-	      !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE))) {
-		speed = IXGBE_LINK_SPEED_10GB_FULL |
-			IXGBE_LINK_SPEED_1GB_FULL;
-		return ixgbe_setup_kr_speed_x550em(hw, speed);
+	/* If X552 (X550EM_a) and MDIO is connected to external PHY, then set
+	 * PHY address. This register field was has only been used for X552.
+	 */
+	if (hw->mac.type == ixgbe_mac_X550EM_a &&
+	    hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_MDIO_ACT) {
+		hw->phy.addr = (hw->phy.nw_mng_if_sel &
+				IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>
+			       IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;
 	}
 
-	/* If link is not up, then there is no setup necessary so return  */
-	status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
-	if (status)
-		return status;
+	return IXGBE_SUCCESS;
+}
 
-	if (!link_up)
-		return 0;
+/**
+ * ixgbe_init_phy_ops_X550em - PHY/SFP specific init
+ * @hw: pointer to hardware structure
+ *
+ * Initialize any function pointers that were not able to be
+ * set during init_shared_code because the PHY/SFP type was
+ * not known.  Perform the SFP init if necessary.
+ */
+s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw)
+{
+	struct ixgbe_phy_info *phy = &hw->phy;
+	s32 ret_val;
 
-	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_STAT,
-				      MDIO_MMD_AN,
-				      &speed);
-	if (status)
-		return status;
+	DEBUGFUNC("ixgbe_init_phy_ops_X550em");
 
-	/* If link is not still up, then no setup is necessary so return */
-	status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
-	if (status)
-		return status;
+	hw->mac.ops.set_lan_id(hw);
+	ixgbe_read_mng_if_sel_x550em(hw);
 
-	if (!link_up)
-		return 0;
+	if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) {
+		phy->phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
+		ixgbe_setup_mux_ctl(hw);
+		phy->ops.identify_sfp = ixgbe_identify_sfp_module_X550em;
+	}
 
-	/* clear everything but the speed and duplex bits */
-	speed &= IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK;
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+		phy->ops.read_reg_mdi = NULL;
+		phy->ops.write_reg_mdi = NULL;
+		hw->phy.ops.read_reg = NULL;
+		hw->phy.ops.write_reg = NULL;
+		phy->ops.check_overtemp = ixgbe_check_overtemp_fw;
+		if (hw->bus.lan_id)
+			hw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY1_SM;
+		else
+			hw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY0_SM;
 
-	switch (speed) {
-	case IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL:
-		force_speed = IXGBE_LINK_SPEED_10GB_FULL;
 		break;
-	case IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL:
-		force_speed = IXGBE_LINK_SPEED_1GB_FULL;
+	case IXGBE_DEV_ID_X550EM_A_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_SFP:
+		hw->phy.ops.read_reg = ixgbe_read_phy_reg_x550a;
+		hw->phy.ops.write_reg = ixgbe_write_phy_reg_x550a;
+		if (hw->bus.lan_id)
+			hw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY1_SM;
+		else
+			hw->phy.phy_semaphore_mask |= IXGBE_GSSR_PHY0_SM;
 		break;
+	case IXGBE_DEV_ID_X550EM_X_SFP:
+		/* set up for CS4227 usage */
+		hw->phy.phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
+		break;
+	case IXGBE_DEV_ID_X550EM_X_1G_T:
+		phy->ops.read_reg_mdi = NULL;
+		phy->ops.write_reg_mdi = NULL;
 	default:
-		/* Internal PHY does not support anything else */
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
+		break;
 	}
 
-	return ixgbe_setup_ixfi_x550em(hw, &force_speed);
-}
+	/* Identify the PHY or SFP module */
+	ret_val = phy->ops.identify(hw);
+	if (ret_val == IXGBE_ERR_SFP_NOT_SUPPORTED ||
+	    ret_val == IXGBE_ERR_PHY_ADDR_INVALID)
+		return ret_val;
 
-/** ixgbe_reset_phy_t_X550em - Performs X557 PHY reset and enables LASI
- *  @hw: pointer to hardware structure
- **/
-static s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw)
-{
-	s32 status;
+	/* Setup function pointers based on detected hardware */
+	ixgbe_init_mac_link_ops_X550em(hw);
+	if (phy->sfp_type != ixgbe_sfp_type_unknown)
+		phy->ops.reset = NULL;
+
+	/* Set functions pointers based on phy type */
+	switch (hw->phy.type) {
+	case ixgbe_phy_x550em_kx4:
+		phy->ops.setup_link = NULL;
+		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
+		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
+		break;
+	case ixgbe_phy_x550em_kr:
+		phy->ops.setup_link = ixgbe_setup_kr_x550em;
+		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
+		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
+		break;
+	case ixgbe_phy_ext_1g_t:
+		/* link is managed by FW */
+		phy->ops.setup_link = NULL;
+		phy->ops.reset = NULL;
+		break;
+	case ixgbe_phy_x550em_xfi:
+		/* link is managed by HW */
+		phy->ops.setup_link = NULL;
+		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
+		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
+		break;
+	case ixgbe_phy_x550em_ext_t:
+		/* If internal link mode is XFI, then setup iXFI internal link,
+		 * else setup KR now.
+		 */
+		phy->ops.setup_internal_link =
+					      ixgbe_setup_internal_phy_t_x550em;
+
+		/* setup SW LPLU only for first revision of X550EM_x */
+		if ((hw->mac.type == ixgbe_mac_X550EM_x) &&
+		    !(IXGBE_FUSES0_REV_MASK &
+		      IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0))))
+			phy->ops.enter_lplu = ixgbe_enter_lplu_t_x550em;
+
+		phy->ops.handle_lasi = ixgbe_handle_lasi_ext_t_x550em;
+		phy->ops.reset = ixgbe_reset_phy_t_X550em;
+		break;
+	case ixgbe_phy_sgmii:
+		phy->ops.setup_link = NULL;
+		break;
+	case ixgbe_phy_fw:
+		phy->ops.setup_link = ixgbe_setup_fw_link;
+		phy->ops.reset = ixgbe_reset_phy_fw;
+		break;
+	default:
+		break;
+	}
+	return ret_val;
+}
+
+/**
+ * ixgbe_set_mdio_speed - Set MDIO clock speed
+ * @hw: pointer to hardware structure
+ */
+STATIC void ixgbe_set_mdio_speed(struct ixgbe_hw *hw)
+{
+	u32 hlreg0;
+
+	switch (hw->device_id) {
+	case IXGBE_DEV_ID_X550EM_X_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_SGMII:
+	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
+	case IXGBE_DEV_ID_X550EM_A_10G_T:
+	case IXGBE_DEV_ID_X550EM_A_SFP:
+	case IXGBE_DEV_ID_X550EM_A_QSFP:
+		/* Config MDIO clock speed before the first MDIO PHY access */
+		hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
+		hlreg0 &= ~IXGBE_HLREG0_MDCSPD;
+		IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
+		break;
+	case IXGBE_DEV_ID_X550EM_A_1G_T:
+	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
+		/* Select fast MDIO clock speed for these devices */
+		hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
+		hlreg0 |= IXGBE_HLREG0_MDCSPD;
+		IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ * ixgbe_reset_hw_X550em - Perform hardware reset
+ * @hw: pointer to hardware structure
+ *
+ * Resets the hardware by resetting the transmit and receive units, masks
+ * and clears all interrupts, perform a PHY reset, and perform a link (MAC)
+ * reset.
+ */
+s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw)
+{
+	ixgbe_link_speed link_speed;
+	s32 status;
+	u32 ctrl = 0;
+	u32 i;
+	bool link_up = false;
+	u32 swfw_mask = hw->phy.phy_semaphore_mask;
+
+	DEBUGFUNC("ixgbe_reset_hw_X550em");
+
+	/* Call adapter stop to disable Tx/Rx and clear interrupts */
+	status = hw->mac.ops.stop_adapter(hw);
+	if (status != IXGBE_SUCCESS) {
+		hw_dbg(hw, "Failed to stop adapter, STATUS = %d\n", status);
+		return status;
+	}
+	/* flush pending Tx transactions */
+	ixgbe_clear_tx_pending(hw);
+
+	ixgbe_set_mdio_speed(hw);
+
+	/* PHY ops must be identified and initialized prior to reset */
+	status = hw->phy.ops.init(hw);
+
+	if (status)
+		hw_dbg(hw, "Failed to initialize PHY ops, STATUS = %d\n",
+			  status);
+
+	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED ||
+	    status == IXGBE_ERR_PHY_ADDR_INVALID) {
+		hw_dbg(hw, "Returning from reset HW due to PHY init failure\n");
+		return status;
+	}
+
+	/* start the external PHY */
+	if (hw->phy.type == ixgbe_phy_x550em_ext_t) {
+		status = ixgbe_init_ext_t_x550em(hw);
+		if (status) {
+			hw_dbg(hw, "Failed to start the external PHY, STATUS = %d\n",
+				  status);
+			return status;
+		}
+	}
+
+	/* Setup SFP module if there is one present. */
+	if (hw->phy.sfp_setup_needed) {
+		status = hw->mac.ops.setup_sfp(hw);
+		hw->phy.sfp_setup_needed = false;
+	}
+
+	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
+		return status;
+
+	/* Reset PHY */
+	if (!hw->phy.reset_disable && hw->phy.ops.reset) {
+		if (hw->phy.ops.reset(hw) == IXGBE_ERR_OVERTEMP)
+			return IXGBE_ERR_OVERTEMP;
+	}
+
+mac_reset_top:
+	/* Issue global reset to the MAC.  Needs to be SW reset if link is up.
+	 * If link reset is used when link is up, it might reset the PHY when
+	 * mng is using it.  If link is down or the flag to force full link
+	 * reset is set, then perform link reset.
+	 */
+	ctrl = IXGBE_CTRL_LNK_RST;
+	if (!hw->force_full_reset) {
+		hw->mac.ops.check_link(hw, &link_speed, &link_up, false);
+		if (link_up)
+			ctrl = IXGBE_CTRL_RST;
+	}
+
+	status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
+	if (status != IXGBE_SUCCESS) {
+		ERROR_REPORT2(IXGBE_ERROR_CAUTION,
+			"semaphore failed with %d", status);
+		return IXGBE_ERR_SWFW_SYNC;
+	}
+	ctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);
+	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
+	IXGBE_WRITE_FLUSH(hw);
+	hw->mac.ops.release_swfw_sync(hw, swfw_mask);
+
+	/* Poll for reset bit to self-clear meaning reset is complete */
+	for (i = 0; i < 10; i++) {
+		usec_delay(1);
+		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
+		if (!(ctrl & IXGBE_CTRL_RST_MASK))
+			break;
+	}
+
+	if (ctrl & IXGBE_CTRL_RST_MASK) {
+		status = IXGBE_ERR_RESET_FAILED;
+		hw_dbg(hw, "Reset polling failed to complete.\n");
+	}
+
+	msec_delay(50);
+
+	/* Double resets are required for recovery from certain error
+	 * conditions.  Between resets, it is necessary to stall to
+	 * allow time for any pending HW events to complete.
+	 */
+	if (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {
+		hw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
+		goto mac_reset_top;
+	}
+
+	/* Store the permanent mac address */
+	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
+
+	/* Store MAC address from RAR0, clear receive address registers, and
+	 * clear the multicast table.  Also reset num_rar_entries to 128,
+	 * since we modify this value when programming the SAN MAC address.
+	 */
+	hw->mac.num_rar_entries = 128;
+	hw->mac.ops.init_rx_addrs(hw);
+
+	ixgbe_set_mdio_speed(hw);
+
+	if (hw->device_id == IXGBE_DEV_ID_X550EM_X_SFP)
+		ixgbe_setup_mux_ctl(hw);
+
+	if (status != IXGBE_SUCCESS)
+		hw_dbg(hw, "Reset HW failed, STATUS = %d\n", status);
+
+	return status;
+}
+
+/**
+ * ixgbe_init_ext_t_x550em - Start (unstall) the external Base T PHY.
+ * @hw: pointer to hardware structure
+ */
+s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw)
+{
+	u32 status;
+	u16 reg;
+
+	status = hw->phy.ops.read_reg(hw,
+				      IXGBE_MDIO_TX_VENDOR_ALARMS_3,
+				      IXGBE_MDIO_PMA_PMD_DEV_TYPE,
+				      &reg);
+
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* If PHY FW reset completed bit is set then this is the first
+	 * SW instance after a power on so the PHY FW must be un-stalled.
+	 */
+	if (reg & IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK) {
+		status = hw->phy.ops.read_reg(hw,
+					IXGBE_MDIO_GLOBAL_RES_PR_10,
+					IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+					&reg);
+
+		if (status != IXGBE_SUCCESS)
+			return status;
+
+		reg &= ~IXGBE_MDIO_POWER_UP_STALL;
+
+		status = hw->phy.ops.write_reg(hw,
+					IXGBE_MDIO_GLOBAL_RES_PR_10,
+					IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE,
+					reg);
+
+		if (status != IXGBE_SUCCESS)
+			return status;
+	}
+
+	return status;
+}
+
+/**
+ * ixgbe_setup_kr_x550em - Configure the KR PHY.
+ * @hw: pointer to hardware structure
+ **/
+s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw)
+{
+	/* leave link alone for 2.5G */
+	if (hw->phy.autoneg_advertised & IXGBE_LINK_SPEED_2_5GB_FULL)
+		return IXGBE_SUCCESS;
+
+	if (ixgbe_check_reset_blocked(hw))
+		return 0;
+
+	return ixgbe_setup_kr_speed_x550em(hw, hw->phy.autoneg_advertised);
+}
+
+/**
+ * ixgbe_setup_mac_link_sfp_x550em - Setup internal/external the PHY for SFP
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: unused
+ *
+ * Configure the external PHY and the integrated KR PHY for SFP support.
+ **/
+s32 ixgbe_setup_mac_link_sfp_x550em(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete)
+{
+	s32 ret_val;
+	u16 reg_slice, reg_val;
+	bool setup_linear = false;
+	UNREFERENCED_1PARAMETER(autoneg_wait_to_complete);
+
+	/* Check if SFP module is supported and linear */
+	ret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);
+
+	/* If no SFP module present, then return success. Return success since
+	 * there is no reason to configure CS4227 and SFP not present error is
+	 * not excepted in the setup MAC link flow.
+	 */
+	if (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)
+		return IXGBE_SUCCESS;
+
+	if (ret_val != IXGBE_SUCCESS)
+		return ret_val;
+
+	/* Configure internal PHY for KR/KX. */
+	ixgbe_setup_kr_speed_x550em(hw, speed);
+
+	/* Configure CS4227 LINE side to proper mode. */
+	reg_slice = IXGBE_CS4227_LINE_SPARE24_LSB +
+		    (hw->bus.lan_id << 12);
+	if (setup_linear)
+		reg_val = (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 0x1;
+	else
+		reg_val = (IXGBE_CS4227_EDC_MODE_SR << 1) | 0x1;
+	ret_val = hw->link.ops.write_link(hw, hw->link.addr, reg_slice,
+					  reg_val);
+	return ret_val;
+}
+
+/**
+ * ixgbe_setup_sfi_x550a - Configure the internal PHY for native SFI mode
+ * @hw: pointer to hardware structure
+ * @speed: the link speed to force
+ *
+ * Configures the integrated PHY for native SFI mode. Used to connect the
+ * internal PHY directly to an SFP cage, without autonegotiation.
+ **/
+STATIC s32 ixgbe_setup_sfi_x550a(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
+{
+	struct ixgbe_mac_info *mac = &hw->mac;
+	s32 status;
+	u32 reg_val;
+
+	/* Disable all AN and force speed to 10G Serial. */
+	status = mac->ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN_EN;
+	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_AN37_EN;
+	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SGMII_EN;
+	reg_val &= ~IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_MASK;
+
+	/* Select forced link speed for internal PHY. */
+	switch (*speed) {
+	case IXGBE_LINK_SPEED_10GB_FULL:
+		reg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_10G;
+		break;
+	case IXGBE_LINK_SPEED_1GB_FULL:
+		reg_val |= IXGBE_KRM_PMD_FLX_MASK_ST20_SPEED_1G;
+		break;
+	default:
+		/* Other link speeds are not supported by internal PHY. */
+		return IXGBE_ERR_LINK_SETUP;
+	}
+
+	status = mac->ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+
+	/* Toggle port SW reset by AN reset. */
+	status = ixgbe_restart_an_internal_phy_x550em(hw);
+
+	return status;
+}
+
+/**
+ * ixgbe_setup_mac_link_sfp_x550a - Setup internal PHY for SFP
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: unused
+ *
+ * Configure the the integrated PHY for SFP support.
+ **/
+s32 ixgbe_setup_mac_link_sfp_x550a(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete)
+{
+	s32 ret_val;
+	u16 reg_phy_ext;
+	bool setup_linear = false;
+	u32 reg_slice, reg_phy_int, slice_offset;
+
+	UNREFERENCED_1PARAMETER(autoneg_wait_to_complete);
+
+	/* Check if SFP module is supported and linear */
+	ret_val = ixgbe_supported_sfp_modules_X550em(hw, &setup_linear);
+
+	/* If no SFP module present, then return success. Return success since
+	 * SFP not present error is not excepted in the setup MAC link flow.
+	 */
+	if (ret_val == IXGBE_ERR_SFP_NOT_PRESENT)
+		return IXGBE_SUCCESS;
+
+	if (ret_val != IXGBE_SUCCESS)
+		return ret_val;
+
+	if (hw->device_id == IXGBE_DEV_ID_X550EM_A_SFP_N) {
+		/* Configure internal PHY for native SFI based on module type */
+		ret_val = hw->mac.ops.read_iosf_sb_reg(hw,
+				   IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				   IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_phy_int);
+
+		if (ret_val != IXGBE_SUCCESS)
+			return ret_val;
+
+		reg_phy_int &= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_DA;
+		if (!setup_linear)
+			reg_phy_int |= IXGBE_KRM_PMD_FLX_MASK_ST20_SFI_10G_SR;
+
+		ret_val = hw->mac.ops.write_iosf_sb_reg(hw,
+				   IXGBE_KRM_PMD_FLX_MASK_ST20(hw->bus.lan_id),
+				   IXGBE_SB_IOSF_TARGET_KR_PHY, reg_phy_int);
+
+		if (ret_val != IXGBE_SUCCESS)
+			return ret_val;
+
+		/* Setup SFI internal link. */
+		ret_val = ixgbe_setup_sfi_x550a(hw, &speed);
+	} else {
+		/* Configure internal PHY for KR/KX. */
+		ixgbe_setup_kr_speed_x550em(hw, speed);
+
+		if (hw->phy.addr == 0x0 || hw->phy.addr == 0xFFFF) {
+			/* Find Address */
+			hw_dbg(hw, "Invalid NW_MNG_IF_SEL.MDIO_PHY_ADD value\n");
+			return IXGBE_ERR_PHY_ADDR_INVALID;
+		}
+
+		/* Get external PHY SKU id */
+		ret_val = hw->phy.ops.read_reg(hw, IXGBE_CS4227_EFUSE_PDF_SKU,
+					IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
+
+		if (ret_val != IXGBE_SUCCESS)
+			return ret_val;
+
+		/* When configuring quad port CS4223, the MAC instance is part
+		 * of the slice offset.
+		 */
+		if (reg_phy_ext == IXGBE_CS4223_SKU_ID)
+			slice_offset = (hw->bus.lan_id +
+					(hw->bus.instance_id << 1)) << 12;
+		else
+			slice_offset = hw->bus.lan_id << 12;
+
+		/* Configure CS4227/CS4223 LINE side to proper mode. */
+		reg_slice = IXGBE_CS4227_LINE_SPARE24_LSB + slice_offset;
+
+		ret_val = hw->phy.ops.read_reg(hw, reg_slice,
+					IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
+
+		if (ret_val != IXGBE_SUCCESS)
+			return ret_val;
+
+		reg_phy_ext &= ~((IXGBE_CS4227_EDC_MODE_CX1 << 1) |
+				 (IXGBE_CS4227_EDC_MODE_SR << 1));
+
+		if (setup_linear)
+			reg_phy_ext |= (IXGBE_CS4227_EDC_MODE_CX1 << 1) | 0x1;
+		else
+			reg_phy_ext |= (IXGBE_CS4227_EDC_MODE_SR << 1) | 0x1;
+		ret_val = hw->phy.ops.write_reg(hw, reg_slice,
+					 IXGBE_MDIO_ZERO_DEV_TYPE, reg_phy_ext);
+
+		/* Flush previous write with a read */
+		ret_val = hw->phy.ops.read_reg(hw, reg_slice,
+					IXGBE_MDIO_ZERO_DEV_TYPE, &reg_phy_ext);
+	}
+	return ret_val;
+}
+
+/**
+ * ixgbe_setup_ixfi_x550em_x - MAC specific iXFI configuration
+ * @hw: pointer to hardware structure
+ *
+ * iXfI configuration needed for ixgbe_mac_X550EM_x devices.
+ **/
+STATIC s32 ixgbe_setup_ixfi_x550em_x(struct ixgbe_hw *hw)
+{
+	struct ixgbe_mac_info *mac = &hw->mac;
+	s32 status;
+	u32 reg_val;
+
+	/* Disable training protocol FSM. */
+	status = mac->ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val |= IXGBE_KRM_RX_TRN_LINKUP_CTRL_CONV_WO_PROTOCOL;
+	status = mac->ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Disable Flex from training TXFFE. */
+	status = mac->ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;
+	status = mac->ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_DSP_TXFFE_STATE_4(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	status = mac->ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_C0_EN;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CP1_CN1_EN;
+	reg_val &= ~IXGBE_KRM_DSP_TXFFE_STATE_CO_ADAPT_EN;
+	status = mac->ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_DSP_TXFFE_STATE_5(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Enable override for coefficients. */
+	status = mac->ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_OVRRD_EN;
+	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CZERO_EN;
+	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CPLUS1_OVRRD_EN;
+	reg_val |= IXGBE_KRM_TX_COEFF_CTRL_1_CMINUS1_OVRRD_EN;
+	status = mac->ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_TX_COEFF_CTRL_1(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	return status;
+}
+
+/**
+ * ixgbe_setup_ixfi_x550em - Configure the KR PHY for iXFI mode.
+ * @hw: pointer to hardware structure
+ * @speed: the link speed to force
+ *
+ * Configures the integrated KR PHY to use iXFI mode. Used to connect an
+ * internal and external PHY at a specific speed, without autonegotiation.
+ **/
+STATIC s32 ixgbe_setup_ixfi_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed)
+{
+	struct ixgbe_mac_info *mac = &hw->mac;
+	s32 status;
+	u32 reg_val;
+
+	/* iXFI is only supported with X552 */
+	if (mac->type != ixgbe_mac_X550EM_x)
+		return IXGBE_ERR_LINK_SETUP;
+
+	/* Disable AN and force speed to 10G Serial. */
+	status = mac->ops.read_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;
+	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;
+
+	/* Select forced link speed for internal PHY. */
+	switch (*speed) {
+	case IXGBE_LINK_SPEED_10GB_FULL:
+		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G;
+		break;
+	case IXGBE_LINK_SPEED_1GB_FULL:
+		reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_1G;
+		break;
+	default:
+		/* Other link speeds are not supported by internal KR PHY. */
+		return IXGBE_ERR_LINK_SETUP;
+	}
+
+	status = mac->ops.write_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Additional configuration needed for x550em_x */
+	if (hw->mac.type == ixgbe_mac_X550EM_x) {
+		status = ixgbe_setup_ixfi_x550em_x(hw);
+		if (status != IXGBE_SUCCESS)
+			return status;
+	}
+
+	/* Toggle port SW reset by AN reset. */
+	status = ixgbe_restart_an_internal_phy_x550em(hw);
+
+	return status;
+}
+
+/**
+ * ixgbe_ext_phy_t_x550em_get_link - Get ext phy link status
+ * @hw: address of hardware structure
+ * @link_up: address of boolean to indicate link status
+ *
+ * Returns error code if unable to get link status.
+ */
+STATIC s32 ixgbe_ext_phy_t_x550em_get_link(struct ixgbe_hw *hw, bool *link_up)
+{
+	u32 ret;
+	u16 autoneg_status;
+
+	*link_up = false;
+
+	/* read this twice back to back to indicate current status */
+	ret = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
+				   IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+				   &autoneg_status);
+	if (ret != IXGBE_SUCCESS)
+		return ret;
+
+	ret = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
+				   IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+				   &autoneg_status);
+	if (ret != IXGBE_SUCCESS)
+		return ret;
+
+	*link_up = !!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS);
+
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_setup_internal_phy_t_x550em - Configure KR PHY to X557 link
+ * @hw: point to hardware structure
+ *
+ * Configures the link between the integrated KR PHY and the external X557 PHY
+ * The driver will call this function when it gets a link status change
+ * interrupt from the X557 PHY. This function configures the link speed
+ * between the PHYs to match the link speed of the BASE-T link.
+ *
+ * A return of a non-zero value indicates an error, and the base driver should
+ * not report link up.
+ */
+s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw)
+{
+	ixgbe_link_speed force_speed;
+	bool link_up;
+	u32 status;
+	u16 speed;
+
+	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
+		return IXGBE_ERR_CONFIG;
+
+	if (hw->mac.type == ixgbe_mac_X550EM_x &&
+	    !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE)) {
+		/* If link is down, there is no setup necessary so return  */
+		status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
+		if (status != IXGBE_SUCCESS)
+			return status;
+
+		if (!link_up)
+			return IXGBE_SUCCESS;
+
+		status = hw->phy.ops.read_reg(hw,
+					      IXGBE_MDIO_AUTO_NEG_VENDOR_STAT,
+					      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+					      &speed);
+		if (status != IXGBE_SUCCESS)
+			return status;
+
+		/* If link is still down - no setup is required so return */
+		status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
+		if (status != IXGBE_SUCCESS)
+			return status;
+		if (!link_up)
+			return IXGBE_SUCCESS;
+
+		/* clear everything but the speed and duplex bits */
+		speed &= IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_MASK;
+
+		switch (speed) {
+		case IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_10GB_FULL:
+			force_speed = IXGBE_LINK_SPEED_10GB_FULL;
+			break;
+		case IXGBE_MDIO_AUTO_NEG_VENDOR_STATUS_1GB_FULL:
+			force_speed = IXGBE_LINK_SPEED_1GB_FULL;
+			break;
+		default:
+			/* Internal PHY does not support anything else */
+			return IXGBE_ERR_INVALID_LINK_SETTINGS;
+		}
+
+		return ixgbe_setup_ixfi_x550em(hw, &force_speed);
+	} else {
+		speed = IXGBE_LINK_SPEED_10GB_FULL |
+			IXGBE_LINK_SPEED_1GB_FULL;
+		return ixgbe_setup_kr_speed_x550em(hw, speed);
+	}
+}
+
+/**
+ * ixgbe_setup_phy_loopback_x550em - Configure the KR PHY for loopback.
+ * @hw: pointer to hardware structure
+ *
+ * Configures the integrated KR PHY to use internal loopback mode.
+ **/
+s32 ixgbe_setup_phy_loopback_x550em(struct ixgbe_hw *hw)
+{
+	s32 status;
+	u32 reg_val;
+
+	/* Disable AN and force speed to 10G Serial. */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_AN_ENABLE;
+	reg_val &= ~IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_MASK;
+	reg_val |= IXGBE_KRM_LINK_CTRL_1_TETH_FORCE_SPEED_10G;
+	status = hw->mac.ops.write_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_CTRL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Set near-end loopback clocks. */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_PORT_CAR_GEN_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val |= IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_32B;
+	reg_val |= IXGBE_KRM_PORT_CAR_GEN_CTRL_NELB_KRPCS;
+	status = hw->mac.ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_PORT_CAR_GEN_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Set loopback enable. */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_DFX_BURNIN(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val |= IXGBE_KRM_PMD_DFX_BURNIN_TX_RX_KR_LB_MASK;
+	status = hw->mac.ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_PMD_DFX_BURNIN(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Training bypass. */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+	if (status != IXGBE_SUCCESS)
+		return status;
+	reg_val |= IXGBE_KRM_RX_TRN_LINKUP_CTRL_PROTOCOL_BYPASS;
+	status = hw->mac.ops.write_iosf_sb_reg(hw,
+				IXGBE_KRM_RX_TRN_LINKUP_CTRL(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+
+	return status;
+}
+
+/**
+ * ixgbe_read_ee_hostif_X550 - Read EEPROM word using a host interface command
+ * assuming that the semaphore is already obtained.
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @data: word read from the EEPROM
+ *
+ * Reads a 16 bit word from the EEPROM using the hostif.
+ **/
+s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset, u16 *data)
+{
+	const u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;
+	struct ixgbe_hic_read_shadow_ram buffer;
+	s32 status;
+
+	DEBUGFUNC("ixgbe_read_ee_hostif_X550");
+	buffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;
+	buffer.hdr.req.buf_lenh = 0;
+	buffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;
+	buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
+
+	/* convert offset from words to bytes */
+	buffer.address = IXGBE_CPU_TO_BE32(offset * 2);
+	/* one word */
+	buffer.length = IXGBE_CPU_TO_BE16(sizeof(u16));
+	buffer.pad2 = 0;
+	buffer.data = 0;
+	buffer.pad3 = 0;
+
+	status = hw->mac.ops.acquire_swfw_sync(hw, mask);
+	if (status)
+		return status;
+
+	status = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),
+				    IXGBE_HI_COMMAND_TIMEOUT);
+	if (!status) {
+		*data = (u16)IXGBE_READ_REG_ARRAY(hw, IXGBE_FLEX_MNG,
+						  FW_NVM_DATA_OFFSET);
+	}
+
+	hw->mac.ops.release_swfw_sync(hw, mask);
+	return status;
+}
+
+/**
+ * ixgbe_read_ee_hostif_buffer_X550- Read EEPROM word(s) using hostif
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to read
+ * @words: number of words
+ * @data: word(s) read from the EEPROM
+ *
+ * Reads a 16 bit word(s) from the EEPROM using the hostif.
+ **/
+s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
+				     u16 offset, u16 words, u16 *data)
+{
+	const u32 mask = IXGBE_GSSR_SW_MNG_SM | IXGBE_GSSR_EEP_SM;
+	struct ixgbe_hic_read_shadow_ram buffer;
+	u32 current_word = 0;
+	u16 words_to_read;
+	s32 status;
+	u32 i;
 
-	status = ixgbe_reset_phy_generic(hw);
+	DEBUGFUNC("ixgbe_read_ee_hostif_buffer_X550");
+
+	/* Take semaphore for the entire operation. */
+	status = hw->mac.ops.acquire_swfw_sync(hw, mask);
+	if (status) {
+		hw_dbg(hw, "EEPROM read buffer - semaphore failed\n");
+		return status;
+	}
+
+	while (words) {
+		if (words > FW_MAX_READ_BUFFER_SIZE / 2)
+			words_to_read = FW_MAX_READ_BUFFER_SIZE / 2;
+		else
+			words_to_read = words;
+
+		buffer.hdr.req.cmd = FW_READ_SHADOW_RAM_CMD;
+		buffer.hdr.req.buf_lenh = 0;
+		buffer.hdr.req.buf_lenl = FW_READ_SHADOW_RAM_LEN;
+		buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
+
+		/* convert offset from words to bytes */
+		buffer.address = IXGBE_CPU_TO_BE32((offset + current_word) * 2);
+		buffer.length = IXGBE_CPU_TO_BE16(words_to_read * 2);
+		buffer.pad2 = 0;
+		buffer.data = 0;
+		buffer.pad3 = 0;
+
+		status = ixgbe_hic_unlocked(hw, (u32 *)&buffer, sizeof(buffer),
+					    IXGBE_HI_COMMAND_TIMEOUT);
+
+		if (status) {
+			hw_dbg(hw, "Host interface command failed\n");
+			goto out;
+		}
+
+		for (i = 0; i < words_to_read; i++) {
+			u32 reg = IXGBE_FLEX_MNG + (FW_NVM_DATA_OFFSET << 2) +
+				  2 * i;
+			u32 value = IXGBE_READ_REG(hw, reg);
+
+			data[current_word] = (u16)(value & 0xffff);
+			current_word++;
+			i++;
+			if (i < words_to_read) {
+				value >>= 16;
+				data[current_word] = (u16)(value & 0xffff);
+				current_word++;
+			}
+		}
+		words -= words_to_read;
+	}
+
+out:
+	hw->mac.ops.release_swfw_sync(hw, mask);
+	return status;
+}
+
+/**
+ * ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @data: word write to the EEPROM
+ *
+ * Write a 16 bit word to the EEPROM using the hostif.
+ **/
+s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw, u16 offset,
+				    u16 data)
+{
+	s32 status;
+	struct ixgbe_hic_write_shadow_ram buffer;
+
+	DEBUGFUNC("ixgbe_write_ee_hostif_data_X550");
+
+	buffer.hdr.req.cmd = FW_WRITE_SHADOW_RAM_CMD;
+	buffer.hdr.req.buf_lenh = 0;
+	buffer.hdr.req.buf_lenl = FW_WRITE_SHADOW_RAM_LEN;
+	buffer.hdr.req.checksum = FW_DEFAULT_CHECKSUM;
+
+	 /* one word */
+	buffer.length = IXGBE_CPU_TO_BE16(sizeof(u16));
+	buffer.data = data;
+	buffer.address = IXGBE_CPU_TO_BE32(offset * 2);
+
+	status = ixgbe_host_interface_command(hw, (u32 *)&buffer,
+					      sizeof(buffer),
+					      IXGBE_HI_COMMAND_TIMEOUT, true);
+	if (status != IXGBE_SUCCESS) {
+		hw_dbg(hw, "for offset %04x failed with status %d\n",
+			  offset, status);
+		return status;
+	}
+
+	if (buffer.hdr.rsp.buf_lenh_status != FW_CEM_RESP_STATUS_SUCCESS) {
+		hw_dbg(hw, "for offset %04x host interface return status %02x\n",
+			  offset, buffer.hdr.rsp.buf_lenh_status);
+		return IXGBE_ERR_HOST_INTERFACE_COMMAND;
+	}
+
+	return status;
+}
+
+/**
+ * ixgbe_write_ee_hostif_X550 - Write EEPROM word using hostif
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @data: word write to the EEPROM
+ *
+ * Write a 16 bit word to the EEPROM using the hostif.
+ **/
+s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset,
+			       u16 data)
+{
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_write_ee_hostif_X550");
+
+	if (hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM) ==
+	    IXGBE_SUCCESS) {
+		status = ixgbe_write_ee_hostif_data_X550(hw, offset, data);
+		hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	} else {
+		hw_dbg(hw, "write ee hostif failed to get semaphore");
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
+
+	return status;
+}
+
+/**
+ * ixgbe_write_ee_hostif_buffer_X550 - Write EEPROM word(s) using hostif
+ * @hw: pointer to hardware structure
+ * @offset: offset of  word in the EEPROM to write
+ * @words: number of words
+ * @data: word(s) write to the EEPROM
+ *
+ * Write a 16 bit word(s) to the EEPROM using the hostif.
+ **/
+s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
+				      u16 offset, u16 words, u16 *data)
+{
+	s32 status = IXGBE_SUCCESS;
+	u32 i = 0;
+
+	DEBUGFUNC("ixgbe_write_ee_hostif_buffer_X550");
+
+	/* Take semaphore for the entire operation. */
+	status = hw->mac.ops.acquire_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+	if (status != IXGBE_SUCCESS) {
+		hw_dbg(hw, "EEPROM write buffer - semaphore failed\n");
+		goto out;
+	}
+
+	for (i = 0; i < words; i++) {
+		status = ixgbe_write_ee_hostif_data_X550(hw, offset + i,
+							 data[i]);
+
+		if (status != IXGBE_SUCCESS) {
+			hw_dbg(hw, "Eeprom buffered write failed\n");
+			break;
+		}
+	}
+
+	hw->mac.ops.release_swfw_sync(hw, IXGBE_GSSR_EEP_SM);
+out:
+
+	return status;
+}
+
+/**
+ * ixgbe_checksum_ptr_x550 - Checksum one pointer region
+ * @hw: pointer to hardware structure
+ * @ptr: pointer offset in eeprom
+ * @size: size of section pointed by ptr, if 0 first word will be used as size
+ * @csum: address of checksum to update
+ * @buffer: pointer to buffer containing calculated checksum
+ * @buffer_size: size of buffer
+ *
+ * Returns error status for any failure
+ */
+STATIC s32 ixgbe_checksum_ptr_x550(struct ixgbe_hw *hw, u16 ptr,
+				   u16 size, u16 *csum, u16 *buffer,
+				   u32 buffer_size)
+{
+	u16 buf[256];
+	s32 status;
+	u16 length, bufsz, i, start;
+	u16 *local_buffer;
+
+	bufsz = sizeof(buf) / sizeof(buf[0]);
+
+	/* Read a chunk at the pointer location */
+	if (!buffer) {
+		status = ixgbe_read_ee_hostif_buffer_X550(hw, ptr, bufsz, buf);
+		if (status) {
+			hw_dbg(hw, "Failed to read EEPROM image\n");
+			return status;
+		}
+		local_buffer = buf;
+	} else {
+		if (buffer_size < ptr)
+			return  IXGBE_ERR_PARAM;
+		local_buffer = &buffer[ptr];
+	}
+
+	if (size) {
+		start = 0;
+		length = size;
+	} else {
+		start = 1;
+		length = local_buffer[0];
+
+		/* Skip pointer section if length is invalid. */
+		if (length == 0xFFFF || length == 0 ||
+		    (ptr + length) >= hw->eeprom.word_size)
+			return IXGBE_SUCCESS;
+	}
+
+	if (buffer && ((u32)start + (u32)length > buffer_size))
+		return IXGBE_ERR_PARAM;
+
+	for (i = start; length; i++, length--) {
+		if (i == bufsz && !buffer) {
+			ptr += bufsz;
+			i = 0;
+			if (length < bufsz)
+				bufsz = length;
+
+			/* Read a chunk at the pointer location */
+			status = ixgbe_read_ee_hostif_buffer_X550(hw, ptr,
+								  bufsz, buf);
+			if (status) {
+				hw_dbg(hw, "Failed to read EEPROM image\n");
+				return status;
+			}
+		}
+		*csum += local_buffer[i];
+	}
+	return IXGBE_SUCCESS;
+}
+
+/**
+ * ixgbe_calc_checksum_X550 - Calculates and returns the checksum
+ * @hw: pointer to hardware structure
+ * @buffer: pointer to buffer containing calculated checksum
+ * @buffer_size: size of buffer
+ *
+ * Returns a negative error code on error, or the 16-bit checksum
+ **/
+s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw, u16 *buffer, u32 buffer_size)
+{
+	u16 eeprom_ptrs[IXGBE_EEPROM_LAST_WORD + 1];
+	u16 *local_buffer;
+	s32 status;
+	u16 checksum = 0;
+	u16 pointer, i, size;
+
+	DEBUGFUNC("ixgbe_calc_eeprom_checksum_X550");
+
+	hw->eeprom.ops.init_params(hw);
+
+	if (!buffer) {
+		/* Read pointer area */
+		status = ixgbe_read_ee_hostif_buffer_X550(hw, 0,
+						     IXGBE_EEPROM_LAST_WORD + 1,
+						     eeprom_ptrs);
+		if (status) {
+			hw_dbg(hw, "Failed to read EEPROM image\n");
+			return status;
+		}
+		local_buffer = eeprom_ptrs;
+	} else {
+		if (buffer_size < IXGBE_EEPROM_LAST_WORD)
+			return IXGBE_ERR_PARAM;
+		local_buffer = buffer;
+	}
+
+	/*
+	 * For X550 hardware include 0x0-0x41 in the checksum, skip the
+	 * checksum word itself
+	 */
+	for (i = 0; i <= IXGBE_EEPROM_LAST_WORD; i++)
+		if (i != IXGBE_EEPROM_CHECKSUM)
+			checksum += local_buffer[i];
+
+	/*
+	 * Include all data from pointers 0x3, 0x6-0xE.  This excludes the
+	 * FW, PHY module, and PCIe Expansion/Option ROM pointers.
+	 */
+	for (i = IXGBE_PCIE_ANALOG_PTR_X550; i < IXGBE_FW_PTR; i++) {
+		if (i == IXGBE_PHY_PTR || i == IXGBE_OPTION_ROM_PTR)
+			continue;
+
+		pointer = local_buffer[i];
+
+		/* Skip pointer section if the pointer is invalid. */
+		if (pointer == 0xFFFF || pointer == 0 ||
+		    pointer >= hw->eeprom.word_size)
+			continue;
+
+		switch (i) {
+		case IXGBE_PCIE_GENERAL_PTR:
+			size = IXGBE_IXGBE_PCIE_GENERAL_SIZE;
+			break;
+		case IXGBE_PCIE_CONFIG0_PTR:
+		case IXGBE_PCIE_CONFIG1_PTR:
+			size = IXGBE_PCIE_CONFIG_SIZE;
+			break;
+		default:
+			size = 0;
+			break;
+		}
+
+		status = ixgbe_checksum_ptr_x550(hw, pointer, size, &checksum,
+						buffer, buffer_size);
+		if (status)
+			return status;
+	}
 
-	if (status)
-		return status;
+	checksum = (u16)IXGBE_EEPROM_SUM - checksum;
 
-	/* Configure Link Status Alarm and Temperature Threshold interrupts */
-	return ixgbe_enable_lasi_ext_t_x550em(hw);
+	return (s32)checksum;
 }
 
 /**
- *  ixgbe_led_on_t_x550em - Turns on the software controllable LEDs.
- *  @hw: pointer to hardware structure
- *  @led_idx: led number to turn on
+ * ixgbe_calc_eeprom_checksum_X550 - Calculates and returns the checksum
+ * @hw: pointer to hardware structure
+ *
+ * Returns a negative error code on error, or the 16-bit checksum
  **/
-static s32 ixgbe_led_on_t_x550em(struct ixgbe_hw *hw, u32 led_idx)
+s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw)
 {
-	u16 phy_data;
-
-	if (led_idx >= IXGBE_X557_MAX_LED_INDEX)
-		return IXGBE_ERR_PARAM;
-
-	/* To turn on the LED, set mode to ON. */
-	hw->phy.ops.read_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
-			     MDIO_MMD_VEND1, &phy_data);
-	phy_data |= IXGBE_X557_LED_MANUAL_SET_MASK;
-	hw->phy.ops.write_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
-			      MDIO_MMD_VEND1, phy_data);
-
-	return 0;
+	return ixgbe_calc_checksum_X550(hw, NULL, 0);
 }
 
 /**
- *  ixgbe_led_off_t_x550em - Turns off the software controllable LEDs.
- *  @hw: pointer to hardware structure
- *  @led_idx: led number to turn off
+ * ixgbe_validate_eeprom_checksum_X550 - Validate EEPROM checksum
+ * @hw: pointer to hardware structure
+ * @checksum_val: calculated checksum
+ *
+ * Performs checksum calculation and validates the EEPROM checksum.  If the
+ * caller does not need checksum_val, the value can be NULL.
  **/
-static s32 ixgbe_led_off_t_x550em(struct ixgbe_hw *hw, u32 led_idx)
+s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw, u16 *checksum_val)
 {
-	u16 phy_data;
+	s32 status;
+	u16 checksum;
+	u16 read_checksum = 0;
 
-	if (led_idx >= IXGBE_X557_MAX_LED_INDEX)
-		return IXGBE_ERR_PARAM;
+	DEBUGFUNC("ixgbe_validate_eeprom_checksum_X550");
 
-	/* To turn on the LED, set mode to ON. */
-	hw->phy.ops.read_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
-			     MDIO_MMD_VEND1, &phy_data);
-	phy_data &= ~IXGBE_X557_LED_MANUAL_SET_MASK;
-	hw->phy.ops.write_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
-			      MDIO_MMD_VEND1, phy_data);
+	/* Read the first word from the EEPROM. If this times out or fails, do
+	 * not continue or we could be in for a very long wait while every
+	 * EEPROM read fails
+	 */
+	status = hw->eeprom.ops.read(hw, 0, &checksum);
+	if (status) {
+		hw_dbg(hw, "EEPROM read failed\n");
+		return status;
+	}
+
+	status = hw->eeprom.ops.calc_checksum(hw);
+	if (status < 0)
+		return status;
+
+	checksum = (u16)(status & 0xffff);
+
+	status = ixgbe_read_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,
+					   &read_checksum);
+	if (status)
+		return status;
+
+	/* Verify read checksum from EEPROM is the same as
+	 * calculated checksum
+	 */
+	if (read_checksum != checksum) {
+		status = IXGBE_ERR_EEPROM_CHECKSUM;
+		ERROR_REPORT1(IXGBE_ERROR_INVALID_STATE,
+			     "Invalid EEPROM checksum");
+	}
+
+	/* If the user cares, return the calculated checksum */
+	if (checksum_val)
+		*checksum_val = checksum;
 
-	return 0;
+	return status;
 }
 
 /**
- *  ixgbe_set_fw_drv_ver_x550 - Sends driver version to firmware
- *  @hw: pointer to the HW structure
- *  @maj: driver version major number
- *  @min: driver version minor number
- *  @build: driver version build number
- *  @sub: driver version sub build number
- *  @len: length of driver_ver string
- *  @driver_ver: driver string
+ * ixgbe_update_eeprom_checksum_X550 - Updates the EEPROM checksum and flash
+ * @hw: pointer to hardware structure
  *
- *  Sends driver version number to firmware through the manageability
- *  block.  On success return 0
- *  else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring
- *  semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
+ * After writing EEPROM to shadow RAM using EEWR register, software calculates
+ * checksum and updates the EEPROM and instructs the hardware to update
+ * the flash.
  **/
-static s32 ixgbe_set_fw_drv_ver_x550(struct ixgbe_hw *hw, u8 maj, u8 min,
-				     u8 build, u8 sub, u16 len,
-				     const char *driver_ver)
+s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw)
 {
-	struct ixgbe_hic_drv_info2 fw_cmd;
-	s32 ret_val;
-	int i;
+	s32 status;
+	u16 checksum = 0;
 
-	if (!len || !driver_ver || (len > sizeof(fw_cmd.driver_string)))
-		return IXGBE_ERR_INVALID_ARGUMENT;
+	DEBUGFUNC("ixgbe_update_eeprom_checksum_X550");
 
-	fw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;
-	fw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN + len;
-	fw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;
-	fw_cmd.port_num = (u8)hw->bus.func;
-	fw_cmd.ver_maj = maj;
-	fw_cmd.ver_min = min;
-	fw_cmd.ver_build = build;
-	fw_cmd.ver_sub = sub;
-	fw_cmd.hdr.checksum = 0;
-	memcpy(fw_cmd.driver_string, driver_ver, len);
-	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,
-			      (FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));
+	/* Read the first word from the EEPROM. If this times out or fails, do
+	 * not continue or we could be in for a very long wait while every
+	 * EEPROM read fails
+	 */
+	status = ixgbe_read_ee_hostif_X550(hw, 0, &checksum);
+	if (status) {
+		hw_dbg(hw, "EEPROM read failed\n");
+		return status;
+	}
 
-	for (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {
-		ret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,
-						       sizeof(fw_cmd),
-						       IXGBE_HI_COMMAND_TIMEOUT,
-						       true);
-		if (ret_val)
-			continue;
+	status = ixgbe_calc_eeprom_checksum_X550(hw);
+	if (status < 0)
+		return status;
 
-		if (fw_cmd.hdr.cmd_or_resp.ret_status !=
-		    FW_CEM_RESP_STATUS_SUCCESS)
-			return IXGBE_ERR_HOST_INTERFACE_COMMAND;
-		return 0;
-	}
+	checksum = (u16)(status & 0xffff);
 
-	return ret_val;
+	status = ixgbe_write_ee_hostif_X550(hw, IXGBE_EEPROM_CHECKSUM,
+					    checksum);
+	if (status)
+		return status;
+
+	status = ixgbe_update_flash_X550(hw);
+
+	return status;
 }
 
-/** ixgbe_get_lcd_x550em - Determine lowest common denominator
- *  @hw: pointer to hardware structure
- *  @lcd_speed: pointer to lowest common link speed
+/**
+ * ixgbe_update_flash_X550 - Instruct HW to copy EEPROM to Flash device
+ * @hw: pointer to hardware structure
  *
- *  Determine lowest common link speed with link partner.
+ * Issue a shadow RAM dump to FW to copy EEPROM from shadow RAM to the flash.
  **/
-static s32 ixgbe_get_lcd_t_x550em(struct ixgbe_hw *hw,
-				  ixgbe_link_speed *lcd_speed)
+s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw)
 {
-	u16 an_lp_status;
-	s32 status;
-	u16 word = hw->eeprom.ctrl_word_3;
-
-	*lcd_speed = IXGBE_LINK_SPEED_UNKNOWN;
+	s32 status = IXGBE_SUCCESS;
+	union ixgbe_hic_hdr2 buffer;
 
-	status = hw->phy.ops.read_reg(hw, IXGBE_AUTO_NEG_LP_STATUS,
-				      MDIO_MMD_AN,
-				      &an_lp_status);
-	if (status)
-		return status;
+	DEBUGFUNC("ixgbe_update_flash_X550");
 
-	/* If link partner advertised 1G, return 1G */
-	if (an_lp_status & IXGBE_AUTO_NEG_LP_1000BASE_CAP) {
-		*lcd_speed = IXGBE_LINK_SPEED_1GB_FULL;
-		return status;
-	}
+	buffer.req.cmd = FW_SHADOW_RAM_DUMP_CMD;
+	buffer.req.buf_lenh = 0;
+	buffer.req.buf_lenl = FW_SHADOW_RAM_DUMP_LEN;
+	buffer.req.checksum = FW_DEFAULT_CHECKSUM;
 
-	/* If 10G disabled for LPLU via NVM D10GMP, then return no valid LCD */
-	if ((hw->bus.lan_id && (word & NVM_INIT_CTRL_3_D10GMP_PORT1)) ||
-	    (word & NVM_INIT_CTRL_3_D10GMP_PORT0))
-		return status;
+	status = ixgbe_host_interface_command(hw, (u32 *)&buffer,
+					      sizeof(buffer),
+					      IXGBE_HI_COMMAND_TIMEOUT, false);
 
-	/* Link partner not capable of lower speeds, return 10G */
-	*lcd_speed = IXGBE_LINK_SPEED_10GB_FULL;
 	return status;
 }
 
 /**
- * ixgbe_setup_fc_x550em - Set up flow control
+ * ixgbe_get_supported_physical_layer_X550em - Returns physical layer type
  * @hw: pointer to hardware structure
- */
-static s32 ixgbe_setup_fc_x550em(struct ixgbe_hw *hw)
+ *
+ * Determines physical layer capabilities of the current configuration.
+ **/
+u64 ixgbe_get_supported_physical_layer_X550em(struct ixgbe_hw *hw)
 {
-	bool pause, asm_dir;
-	u32 reg_val;
-	s32 rc = 0;
+	u64 physical_layer = IXGBE_PHYSICAL_LAYER_UNKNOWN;
+	u16 ext_ability = 0;
 
-	/* Validate the requested mode */
-	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
-		hw_err(hw, "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
-		return IXGBE_ERR_INVALID_LINK_SETTINGS;
-	}
+	DEBUGFUNC("ixgbe_get_supported_physical_layer_X550em");
 
-	/* 10gig parts do not have a word in the EEPROM to determine the
-	 * default flow control setting, so we explicitly set it to full.
-	 */
-	if (hw->fc.requested_mode == ixgbe_fc_default)
-		hw->fc.requested_mode = ixgbe_fc_full;
+	hw->phy.ops.identify(hw);
 
-	/* Determine PAUSE and ASM_DIR bits. */
-	switch (hw->fc.requested_mode) {
-	case ixgbe_fc_none:
-		pause = false;
-		asm_dir = false;
+	switch (hw->phy.type) {
+	case ixgbe_phy_x550em_kr:
+		if (hw->mac.type == ixgbe_mac_X550EM_a) {
+			if (hw->phy.nw_mng_if_sel &
+			    IXGBE_NW_MNG_IF_SEL_PHY_SPEED_2_5G) {
+				physical_layer =
+					IXGBE_PHYSICAL_LAYER_2500BASE_KX;
+				break;
+			} else if (hw->device_id ==
+				   IXGBE_DEV_ID_X550EM_A_KR_L) {
+				physical_layer =
+					IXGBE_PHYSICAL_LAYER_1000BASE_KX;
+				break;
+			}
+		}
+		/* fall through */
+	case ixgbe_phy_x550em_xfi:
+		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KR |
+				 IXGBE_PHYSICAL_LAYER_1000BASE_KX;
 		break;
-	case ixgbe_fc_tx_pause:
-		pause = false;
-		asm_dir = true;
+	case ixgbe_phy_x550em_kx4:
+		physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_KX4 |
+				 IXGBE_PHYSICAL_LAYER_1000BASE_KX;
 		break;
-	case ixgbe_fc_rx_pause:
-		/* Rx Flow control is enabled and Tx Flow control is
-		 * disabled by software override. Since there really
-		 * isn't a way to advertise that we are capable of RX
-		 * Pause ONLY, we will advertise that we support both
-		 * symmetric and asymmetric Rx PAUSE, as such we fall
-		 * through to the fc_full statement.  Later, we will
-		 * disable the adapter's ability to send PAUSE frames.
-		 */
-		fallthrough;
-	case ixgbe_fc_full:
-		pause = true;
-		asm_dir = true;
+	case ixgbe_phy_x550em_ext_t:
+		hw->phy.ops.read_reg(hw, IXGBE_MDIO_PHY_EXT_ABILITY,
+				     IXGBE_MDIO_PMA_PMD_DEV_TYPE,
+				     &ext_ability);
+		if (ext_ability & IXGBE_MDIO_PHY_10GBASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10GBASE_T;
+		if (ext_ability & IXGBE_MDIO_PHY_1000BASET_ABILITY)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
 		break;
-	default:
-		hw_err(hw, "Flow control param set incorrectly\n");
-		return IXGBE_ERR_CONFIG;
-	}
-
-	switch (hw->device_id) {
-	case IXGBE_DEV_ID_X550EM_X_KR:
-	case IXGBE_DEV_ID_X550EM_A_KR:
-	case IXGBE_DEV_ID_X550EM_A_KR_L:
-		rc = hw->mac.ops.read_iosf_sb_reg(hw,
-					    IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
-					    IXGBE_SB_IOSF_TARGET_KR_PHY,
-					    &reg_val);
-		if (rc)
-			return rc;
-
-		reg_val &= ~(IXGBE_KRM_AN_CNTL_1_SYM_PAUSE |
-			     IXGBE_KRM_AN_CNTL_1_ASM_PAUSE);
-		if (pause)
-			reg_val |= IXGBE_KRM_AN_CNTL_1_SYM_PAUSE;
-		if (asm_dir)
-			reg_val |= IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;
-		rc = hw->mac.ops.write_iosf_sb_reg(hw,
-					    IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
-					    IXGBE_SB_IOSF_TARGET_KR_PHY,
-					    reg_val);
-
-		/* This device does not fully support AN. */
-		hw->fc.disable_fc_autoneg = true;
+	case ixgbe_phy_fw:
+		if (hw->phy.speeds_supported & IXGBE_LINK_SPEED_1GB_FULL)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
+		if (hw->phy.speeds_supported & IXGBE_LINK_SPEED_100_FULL)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_100BASE_TX;
+		if (hw->phy.speeds_supported & IXGBE_LINK_SPEED_10_FULL)
+			physical_layer |= IXGBE_PHYSICAL_LAYER_10BASE_T;
 		break;
-	case IXGBE_DEV_ID_X550EM_X_XFI:
-		hw->fc.disable_fc_autoneg = true;
+	case ixgbe_phy_sgmii:
+		physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_KX;
+		break;
+	case ixgbe_phy_ext_1g_t:
+		physical_layer |= IXGBE_PHYSICAL_LAYER_1000BASE_T;
 		break;
 	default:
 		break;
 	}
-	return rc;
+
+	if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber)
+		physical_layer = ixgbe_get_supported_phy_sfp_layer_generic(hw);
+
+	return physical_layer;
 }
 
 /**
- *  ixgbe_fc_autoneg_backplane_x550em_a - Enable flow control IEEE clause 37
- *  @hw: pointer to hardware structure
+ * ixgbe_get_bus_info_x550em - Set PCI bus info
+ * @hw: pointer to hardware structure
+ *
+ * Sets bus link width and speed to unknown because X550em is
+ * not a PCI device.
  **/
-static void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw)
+s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw)
 {
-	u32 link_s1, lp_an_page_low, an_cntl_1;
-	s32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;
-	ixgbe_link_speed speed;
-	bool link_up;
-
-	/* AN should have completed when the cable was plugged in.
-	 * Look for reasons to bail out.  Bail out if:
-	 * - FC autoneg is disabled, or if
-	 * - link is not up.
-	 */
-	if (hw->fc.disable_fc_autoneg) {
-		hw_err(hw, "Flow control autoneg is disabled");
-		goto out;
-	}
-
-	hw->mac.ops.check_link(hw, &speed, &link_up, false);
-	if (!link_up) {
-		hw_err(hw, "The link is down");
-		goto out;
-	}
-
-	/* Check at auto-negotiation has completed */
-	status = hw->mac.ops.read_iosf_sb_reg(hw,
-					IXGBE_KRM_LINK_S1(hw->bus.lan_id),
-					IXGBE_SB_IOSF_TARGET_KR_PHY, &link_s1);
 
-	if (status || (link_s1 & IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE) == 0) {
-		hw_dbg(hw, "Auto-Negotiation did not complete\n");
-		status = IXGBE_ERR_FC_NOT_NEGOTIATED;
-		goto out;
-	}
-
-	/* Read the 10g AN autoc and LP ability registers and resolve
-	 * local flow control settings accordingly
-	 */
-	status = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &an_cntl_1);
-
-	if (status) {
-		hw_dbg(hw, "Auto-Negotiation did not complete\n");
-		goto out;
-	}
+	DEBUGFUNC("ixgbe_get_bus_info_x550em");
 
-	status = hw->mac.ops.read_iosf_sb_reg(hw,
-				IXGBE_KRM_LP_BASE_PAGE_HIGH(hw->bus.lan_id),
-				IXGBE_SB_IOSF_TARGET_KR_PHY, &lp_an_page_low);
-
-	if (status) {
-		hw_dbg(hw, "Auto-Negotiation did not complete\n");
-		goto out;
-	}
-
-	status = ixgbe_negotiate_fc(hw, an_cntl_1, lp_an_page_low,
-				    IXGBE_KRM_AN_CNTL_1_SYM_PAUSE,
-				    IXGBE_KRM_AN_CNTL_1_ASM_PAUSE,
-				    IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE,
-				    IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE);
+	hw->bus.width = ixgbe_bus_width_unknown;
+	hw->bus.speed = ixgbe_bus_speed_unknown;
 
-out:
-	if (!status) {
-		hw->fc.fc_was_autonegged = true;
-	} else {
-		hw->fc.fc_was_autonegged = false;
-		hw->fc.current_mode = hw->fc.requested_mode;
-	}
+	hw->mac.ops.set_lan_id(hw);
+
+	return IXGBE_SUCCESS;
 }
 
 /**
- *  ixgbe_fc_autoneg_fiber_x550em_a - passthrough FC settings
- *  @hw: pointer to hardware structure
+ * ixgbe_disable_rx_x550 - Disable RX unit
+ * @hw: pointer to hardware structure
+ *
+ * Enables the Rx DMA unit for x550
  **/
-static void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw)
+void ixgbe_disable_rx_x550(struct ixgbe_hw *hw)
 {
-	hw->fc.fc_was_autonegged = false;
-	hw->fc.current_mode = hw->fc.requested_mode;
+	u32 rxctrl, pfdtxgswc;
+	s32 status;
+	struct ixgbe_hic_disable_rxen fw_cmd;
+
+	DEBUGFUNC("ixgbe_enable_rx_dma_x550");
+
+	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
+	if (rxctrl & IXGBE_RXCTRL_RXEN) {
+		pfdtxgswc = IXGBE_READ_REG(hw, IXGBE_PFDTXGSWC);
+		if (pfdtxgswc & IXGBE_PFDTXGSWC_VT_LBEN) {
+			pfdtxgswc &= ~IXGBE_PFDTXGSWC_VT_LBEN;
+			IXGBE_WRITE_REG(hw, IXGBE_PFDTXGSWC, pfdtxgswc);
+			hw->mac.set_lben = true;
+		} else {
+			hw->mac.set_lben = false;
+		}
+
+		fw_cmd.hdr.cmd = FW_DISABLE_RXEN_CMD;
+		fw_cmd.hdr.buf_len = FW_DISABLE_RXEN_LEN;
+		fw_cmd.hdr.checksum = FW_DEFAULT_CHECKSUM;
+		fw_cmd.port_number = (u8)hw->bus.lan_id;
+
+		status = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,
+					sizeof(struct ixgbe_hic_disable_rxen),
+					IXGBE_HI_COMMAND_TIMEOUT, true);
+
+		/* If we fail - disable RX using register write */
+		if (status) {
+			rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
+			if (rxctrl & IXGBE_RXCTRL_RXEN) {
+				rxctrl &= ~IXGBE_RXCTRL_RXEN;
+				IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl);
+			}
+		}
+	}
 }
 
-/** ixgbe_enter_lplu_x550em - Transition to low power states
- *  @hw: pointer to hardware structure
+/**
+ * ixgbe_enter_lplu_x550em - Transition to low power states
+ * @hw: pointer to hardware structure
  *
- *  Configures Low Power Link Up on transition to low power states
- *  (from D0 to non-D0). Link is required to enter LPLU so avoid resetting
- *  the X557 PHY immediately prior to entering LPLU.
+ * Configures Low Power Link Up on transition to low power states
+ * (from D0 to non-D0). Link is required to enter LPLU so avoid resetting the
+ * X557 PHY immediately prior to entering LPLU.
  **/
-static s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
+s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
 {
 	u16 an_10g_cntl_reg, autoneg_reg, speed;
 	s32 status;
@@ -3028,45 +3746,52 @@ static s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
 	u32 save_autoneg;
 	bool link_up;
 
+	/* SW LPLU not required on later HW revisions. */
+	if ((hw->mac.type == ixgbe_mac_X550EM_x) &&
+	    (IXGBE_FUSES0_REV_MASK &
+	     IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0))))
+		return IXGBE_SUCCESS;
+
 	/* If blocked by MNG FW, then don't restart AN */
 	if (ixgbe_check_reset_blocked(hw))
-		return 0;
+		return IXGBE_SUCCESS;
 
 	status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	status = hw->eeprom.ops.read(hw, NVM_INIT_CTRL_3,
-				     &hw->eeprom.ctrl_word_3);
-	if (status)
+	status = ixgbe_read_eeprom(hw, NVM_INIT_CTRL_3, &hw->eeprom.ctrl_word_3);
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	/* If link is down, LPLU disabled in NVM, WoL disabled, or
-	 * manageability disabled, then force link down by entering
-	 * low power mode.
+	/* If link is down, LPLU disabled in NVM, WoL disabled, or manageability
+	 * disabled, then force link down by entering low power mode.
 	 */
 	if (!link_up || !(hw->eeprom.ctrl_word_3 & NVM_INIT_CTRL_3_LPLU) ||
 	    !(hw->wol_enabled || ixgbe_mng_present(hw)))
-		return ixgbe_set_copper_phy_power(hw, false);
+		return ixgbe_set_copper_phy_power(hw, FALSE);
 
 	/* Determine LCD */
 	status = ixgbe_get_lcd_t_x550em(hw, &lcd_speed);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* If no valid LCD link speed, then force link down and exit. */
 	if (lcd_speed == IXGBE_LINK_SPEED_UNKNOWN)
-		return ixgbe_set_copper_phy_power(hw, false);
+		return ixgbe_set_copper_phy_power(hw, FALSE);
 
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_STAT,
-				      MDIO_MMD_AN,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				      &speed);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	/* If no link now, speed is invalid so take link down */
 	status = ixgbe_ext_phy_t_x550em_get_link(hw, &link_up);
-	if (status)
+	if (status != IXGBE_SUCCESS)
 		return ixgbe_set_copper_phy_power(hw, false);
 
 	/* clear everything but the speed bits */
@@ -3081,22 +3806,25 @@ static s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
 
 	/* Clear AN completed indication */
 	status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_VENDOR_TX_ALARM,
-				      MDIO_MMD_AN,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
 				      &autoneg_reg);
-	if (status)
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
-	status = hw->phy.ops.read_reg(hw, MDIO_AN_10GBT_CTRL,
-				      MDIO_MMD_AN,
-				      &an_10g_cntl_reg);
-	if (status)
+	status = hw->phy.ops.read_reg(hw, IXGBE_MII_10GBASE_T_AUTONEG_CTRL_REG,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			     &an_10g_cntl_reg);
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	status = hw->phy.ops.read_reg(hw,
-				      IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,
-				      MDIO_MMD_AN,
-				      &autoneg_reg);
-	if (status)
+			     IXGBE_MII_AUTONEG_VENDOR_PROVISION_1_REG,
+			     IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+			     &autoneg_reg);
+
+	if (status != IXGBE_SUCCESS)
 		return status;
 
 	save_autoneg = hw->phy.autoneg_advertised;
@@ -3111,457 +3839,294 @@ static s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw)
 }
 
 /**
- * ixgbe_reset_phy_fw - Reset firmware-controlled PHYs
- * @hw: pointer to hardware structure
- */
-static s32 ixgbe_reset_phy_fw(struct ixgbe_hw *hw)
-{
-	u32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };
-	s32 rc;
-
-	if (hw->phy.reset_disable || ixgbe_check_reset_blocked(hw))
-		return 0;
-
-	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_PHY_SW_RESET, &store);
-	if (rc)
-		return rc;
-	memset(store, 0, sizeof(store));
-
-	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_INIT_PHY, &store);
-	if (rc)
-		return rc;
-
-	return ixgbe_setup_fw_link(hw);
-}
-
-/**
- * ixgbe_check_overtemp_fw - Check firmware-controlled PHYs for overtemp
- * @hw: pointer to hardware structure
- */
-static s32 ixgbe_check_overtemp_fw(struct ixgbe_hw *hw)
-{
-	u32 store[FW_PHY_ACT_DATA_COUNT] = { 0 };
-	s32 rc;
-
-	rc = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &store);
-	if (rc)
-		return rc;
-
-	if (store[0] & FW_PHY_ACT_GET_LINK_INFO_TEMP) {
-		ixgbe_shutdown_fw_phy(hw);
-		return IXGBE_ERR_OVERTEMP;
-	}
-	return 0;
-}
-
-/**
- * ixgbe_read_mng_if_sel_x550em - Read NW_MNG_IF_SEL register
+ * ixgbe_get_lcd_x550em - Determine lowest common denominator
  * @hw: pointer to hardware structure
+ * @lcd_speed: pointer to lowest common link speed
  *
- * Read NW_MNG_IF_SEL register and save field values.
- */
-static void ixgbe_read_mng_if_sel_x550em(struct ixgbe_hw *hw)
-{
-	/* Save NW management interface connected on board. This is used
-	 * to determine internal PHY mode.
-	 */
-	hw->phy.nw_mng_if_sel = IXGBE_READ_REG(hw, IXGBE_NW_MNG_IF_SEL);
-
-	/* If X552 (X550EM_a) and MDIO is connected to external PHY, then set
-	 * PHY address. This register field was has only been used for X552.
-	 */
-	if (hw->mac.type == ixgbe_mac_x550em_a &&
-	    hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_MDIO_ACT) {
-		hw->phy.mdio.prtad = (hw->phy.nw_mng_if_sel &
-				      IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD) >>
-				     IXGBE_NW_MNG_IF_SEL_MDIO_PHY_ADD_SHIFT;
-	}
-}
-
-/** ixgbe_init_phy_ops_X550em - PHY/SFP specific init
- *  @hw: pointer to hardware structure
- *
- *  Initialize any function pointers that were not able to be
- *  set during init_shared_code because the PHY/SFP type was
- *  not known.  Perform the SFP init if necessary.
- **/
-static s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw)
-{
-	struct ixgbe_phy_info *phy = &hw->phy;
-	s32 ret_val;
-
-	hw->mac.ops.set_lan_id(hw);
-
-	ixgbe_read_mng_if_sel_x550em(hw);
-
-	if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) {
-		phy->phy_semaphore_mask = IXGBE_GSSR_SHARED_I2C_SM;
-		ixgbe_setup_mux_ctl(hw);
-	}
-
-	/* Identify the PHY or SFP module */
-	ret_val = phy->ops.identify(hw);
-	if (ret_val == IXGBE_ERR_SFP_NOT_SUPPORTED ||
-	    ret_val == IXGBE_ERR_PHY_ADDR_INVALID)
-		return ret_val;
-
-	/* Setup function pointers based on detected hardware */
-	ixgbe_init_mac_link_ops_X550em(hw);
-	if (phy->sfp_type != ixgbe_sfp_type_unknown)
-		phy->ops.reset = NULL;
-
-	/* Set functions pointers based on phy type */
-	switch (hw->phy.type) {
-	case ixgbe_phy_x550em_kx4:
-		phy->ops.setup_link = NULL;
-		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
-		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
-		break;
-	case ixgbe_phy_x550em_kr:
-		phy->ops.setup_link = ixgbe_setup_kr_x550em;
-		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
-		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
-		break;
-	case ixgbe_phy_x550em_xfi:
-		/* link is managed by HW */
-		phy->ops.setup_link = NULL;
-		phy->ops.read_reg = ixgbe_read_phy_reg_x550em;
-		phy->ops.write_reg = ixgbe_write_phy_reg_x550em;
-		break;
-	case ixgbe_phy_x550em_ext_t:
-		/* Save NW management interface connected on board. This is used
-		 * to determine internal PHY mode
-		 */
-		phy->nw_mng_if_sel = IXGBE_READ_REG(hw, IXGBE_NW_MNG_IF_SEL);
-
-		/* If internal link mode is XFI, then setup iXFI internal link,
-		 * else setup KR now.
-		 */
-		phy->ops.setup_internal_link =
-					      ixgbe_setup_internal_phy_t_x550em;
-
-		/* setup SW LPLU only for first revision */
-		if (hw->mac.type == ixgbe_mac_X550EM_x &&
-		    !(IXGBE_READ_REG(hw, IXGBE_FUSES0_GROUP(0)) &
-		      IXGBE_FUSES0_REV_MASK))
-			phy->ops.enter_lplu = ixgbe_enter_lplu_t_x550em;
-
-		phy->ops.handle_lasi = ixgbe_handle_lasi_ext_t_x550em;
-		phy->ops.reset = ixgbe_reset_phy_t_X550em;
-		break;
-	case ixgbe_phy_sgmii:
-		phy->ops.setup_link = NULL;
-		break;
-	case ixgbe_phy_fw:
-		phy->ops.setup_link = ixgbe_setup_fw_link;
-		phy->ops.reset = ixgbe_reset_phy_fw;
-		break;
-	case ixgbe_phy_ext_1g_t:
-		phy->ops.setup_link = NULL;
-		phy->ops.read_reg = NULL;
-		phy->ops.write_reg = NULL;
-		phy->ops.reset = NULL;
-		break;
-	default:
-		break;
-	}
-
-	return ret_val;
-}
-
-/** ixgbe_get_media_type_X550em - Get media type
- *  @hw: pointer to hardware structure
- *
- *  Returns the media type (fiber, copper, backplane)
- *
- */
-static enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw)
-{
-	enum ixgbe_media_type media_type;
-
-	/* Detect if there is a copper PHY attached. */
-	switch (hw->device_id) {
-	case IXGBE_DEV_ID_X550EM_A_SGMII:
-	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
-		hw->phy.type = ixgbe_phy_sgmii;
-		fallthrough;
-	case IXGBE_DEV_ID_X550EM_X_KR:
-	case IXGBE_DEV_ID_X550EM_X_KX4:
-	case IXGBE_DEV_ID_X550EM_X_XFI:
-	case IXGBE_DEV_ID_X550EM_A_KR:
-	case IXGBE_DEV_ID_X550EM_A_KR_L:
-		media_type = ixgbe_media_type_backplane;
-		break;
-	case IXGBE_DEV_ID_X550EM_X_SFP:
-	case IXGBE_DEV_ID_X550EM_A_SFP:
-	case IXGBE_DEV_ID_X550EM_A_SFP_N:
-		media_type = ixgbe_media_type_fiber;
-		break;
-	case IXGBE_DEV_ID_X550EM_X_1G_T:
-	case IXGBE_DEV_ID_X550EM_X_10G_T:
-	case IXGBE_DEV_ID_X550EM_A_10G_T:
-	case IXGBE_DEV_ID_X550EM_A_1G_T:
-	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
-		media_type = ixgbe_media_type_copper;
-		break;
-	default:
-		media_type = ixgbe_media_type_unknown;
-		break;
-	}
-	return media_type;
-}
-
-/** ixgbe_init_ext_t_x550em - Start (unstall) the external Base T PHY.
- ** @hw: pointer to hardware structure
+ * Determine lowest common link speed with link partner.
  **/
-static s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw)
+s32 ixgbe_get_lcd_t_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *lcd_speed)
 {
+	u16 an_lp_status;
 	s32 status;
-	u16 reg;
-
-	status = hw->phy.ops.read_reg(hw,
-				      IXGBE_MDIO_TX_VENDOR_ALARMS_3,
-				      MDIO_MMD_PMAPMD,
-				      &reg);
-	if (status)
-		return status;
+	u16 word = hw->eeprom.ctrl_word_3;
 
-	/* If PHY FW reset completed bit is set then this is the first
-	 * SW instance after a power on so the PHY FW must be un-stalled.
-	 */
-	if (reg & IXGBE_MDIO_TX_VENDOR_ALARMS_3_RST_MASK) {
-		status = hw->phy.ops.read_reg(hw,
-					IXGBE_MDIO_GLOBAL_RES_PR_10,
-					MDIO_MMD_VEND1,
-					&reg);
-		if (status)
-			return status;
+	*lcd_speed = IXGBE_LINK_SPEED_UNKNOWN;
 
-		reg &= ~IXGBE_MDIO_POWER_UP_STALL;
+	status = hw->phy.ops.read_reg(hw, IXGBE_AUTO_NEG_LP_STATUS,
+				      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+				      &an_lp_status);
 
-		status = hw->phy.ops.write_reg(hw,
-					IXGBE_MDIO_GLOBAL_RES_PR_10,
-					MDIO_MMD_VEND1,
-					reg);
-		if (status)
-			return status;
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* If link partner advertised 1G, return 1G */
+	if (an_lp_status & IXGBE_AUTO_NEG_LP_1000BASE_CAP) {
+		*lcd_speed = IXGBE_LINK_SPEED_1GB_FULL;
+		return status;
 	}
 
+	/* If 10G disabled for LPLU via NVM D10GMP, then return no valid LCD */
+	if ((hw->bus.lan_id && (word & NVM_INIT_CTRL_3_D10GMP_PORT1)) ||
+	    (word & NVM_INIT_CTRL_3_D10GMP_PORT0))
+		return status;
+
+	/* Link partner not capable of lower speeds, return 10G */
+	*lcd_speed = IXGBE_LINK_SPEED_10GB_FULL;
 	return status;
 }
 
 /**
- * ixgbe_set_mdio_speed - Set MDIO clock speed
+ * ixgbe_setup_fc_X550em - Set up flow control
  * @hw: pointer to hardware structure
- */
-static void ixgbe_set_mdio_speed(struct ixgbe_hw *hw)
+ *
+ * Called at init time to set up flow control.
+ **/
+s32 ixgbe_setup_fc_X550em(struct ixgbe_hw *hw)
 {
-	u32 hlreg0;
+	s32 ret_val = IXGBE_SUCCESS;
+	u32 pause, asm_dir, reg_val;
+
+	DEBUGFUNC("ixgbe_setup_fc_X550em");
+
+	/* Validate the requested mode */
+	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			"ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
+		ret_val = IXGBE_ERR_INVALID_LINK_SETTINGS;
+		goto out;
+	}
+
+	/* 10gig parts do not have a word in the EEPROM to determine the
+	 * default flow control setting, so we explicitly set it to full.
+	 */
+	if (hw->fc.requested_mode == ixgbe_fc_default)
+		hw->fc.requested_mode = ixgbe_fc_full;
+
+	/* Determine PAUSE and ASM_DIR bits. */
+	switch (hw->fc.requested_mode) {
+	case ixgbe_fc_none:
+		pause = 0;
+		asm_dir = 0;
+		break;
+	case ixgbe_fc_tx_pause:
+		pause = 0;
+		asm_dir = 1;
+		break;
+	case ixgbe_fc_rx_pause:
+		/* Rx Flow control is enabled and Tx Flow control is
+		 * disabled by software override. Since there really
+		 * isn't a way to advertise that we are capable of RX
+		 * Pause ONLY, we will advertise that we support both
+		 * symmetric and asymmetric Rx PAUSE, as such we fall
+		 * through to the fc_full statement.  Later, we will
+		 * disable the adapter's ability to send PAUSE frames.
+		 */
+	case ixgbe_fc_full:
+		pause = 1;
+		asm_dir = 1;
+		break;
+	default:
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
+			"Flow control param set incorrectly\n");
+		ret_val = IXGBE_ERR_CONFIG;
+		goto out;
+	}
 
 	switch (hw->device_id) {
-	case IXGBE_DEV_ID_X550EM_X_10G_T:
-	case IXGBE_DEV_ID_X550EM_A_SGMII:
-	case IXGBE_DEV_ID_X550EM_A_SGMII_L:
-	case IXGBE_DEV_ID_X550EM_A_10G_T:
-	case IXGBE_DEV_ID_X550EM_A_SFP:
-		/* Config MDIO clock speed before the first MDIO PHY access */
-		hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
-		hlreg0 &= ~IXGBE_HLREG0_MDCSPD;
-		IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
+	case IXGBE_DEV_ID_X550EM_X_KR:
+	case IXGBE_DEV_ID_X550EM_A_KR:
+	case IXGBE_DEV_ID_X550EM_A_KR_L:
+		ret_val = hw->mac.ops.read_iosf_sb_reg(hw,
+					IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, &reg_val);
+		if (ret_val != IXGBE_SUCCESS)
+			goto out;
+		reg_val &= ~(IXGBE_KRM_AN_CNTL_1_SYM_PAUSE |
+			IXGBE_KRM_AN_CNTL_1_ASM_PAUSE);
+		if (pause)
+			reg_val |= IXGBE_KRM_AN_CNTL_1_SYM_PAUSE;
+		if (asm_dir)
+			reg_val |= IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;
+		ret_val = hw->mac.ops.write_iosf_sb_reg(hw,
+					IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, reg_val);
+
+		/* This device does not fully support AN. */
+		hw->fc.disable_fc_autoneg = true;
 		break;
-	case IXGBE_DEV_ID_X550EM_A_1G_T:
-	case IXGBE_DEV_ID_X550EM_A_1G_T_L:
-		/* Select fast MDIO clock speed for these devices */
-		hlreg0 = IXGBE_READ_REG(hw, IXGBE_HLREG0);
-		hlreg0 |= IXGBE_HLREG0_MDCSPD;
-		IXGBE_WRITE_REG(hw, IXGBE_HLREG0, hlreg0);
+	case IXGBE_DEV_ID_X550EM_X_XFI:
+		hw->fc.disable_fc_autoneg = true;
 		break;
 	default:
 		break;
 	}
+
+out:
+	return ret_val;
 }
 
-/**  ixgbe_reset_hw_X550em - Perform hardware reset
- **  @hw: pointer to hardware structure
- **
- **  Resets the hardware by resetting the transmit and receive units, masks
- **  and clears all interrupts, perform a PHY reset, and perform a link (MAC)
- **  reset.
+/**
+ * ixgbe_fc_autoneg_backplane_x550em_a - Enable flow control IEEE clause 37
+ * @hw: pointer to hardware structure
+ *
+ * Enable flow control according to IEEE clause 37.
  **/
-static s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw)
+void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw)
 {
-	ixgbe_link_speed link_speed;
-	s32 status;
-	u32 ctrl = 0;
-	u32 i;
-	bool link_up = false;
-	u32 swfw_mask = hw->phy.phy_semaphore_mask;
-
-	/* Call adapter stop to disable Tx/Rx and clear interrupts */
-	status = hw->mac.ops.stop_adapter(hw);
-	if (status)
-		return status;
-
-	/* flush pending Tx transactions */
-	ixgbe_clear_tx_pending(hw);
-
-	/* PHY ops must be identified and initialized prior to reset */
-	status = hw->phy.ops.init(hw);
-	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED ||
-	    status == IXGBE_ERR_PHY_ADDR_INVALID)
-		return status;
+	u32 link_s1, lp_an_page_low, an_cntl_1;
+	s32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;
+	ixgbe_link_speed speed;
+	bool link_up;
 
-	/* start the external PHY */
-	if (hw->phy.type == ixgbe_phy_x550em_ext_t) {
-		status = ixgbe_init_ext_t_x550em(hw);
-		if (status)
-			return status;
+	/* AN should have completed when the cable was plugged in.
+	 * Look for reasons to bail out.  Bail out if:
+	 * - FC autoneg is disabled, or if
+	 * - link is not up.
+	 */
+	if (hw->fc.disable_fc_autoneg) {
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			     "Flow control autoneg is disabled");
+		goto out;
 	}
 
-	/* Setup SFP module if there is one present. */
-	if (hw->phy.sfp_setup_needed) {
-		status = hw->mac.ops.setup_sfp(hw);
-		hw->phy.sfp_setup_needed = false;
+	hw->mac.ops.check_link(hw, &speed, &link_up, false);
+	if (!link_up) {
+		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE, "The link is down");
+		goto out;
 	}
 
-	if (status == IXGBE_ERR_SFP_NOT_SUPPORTED)
-		return status;
+	/* Check at auto-negotiation has completed */
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+					IXGBE_KRM_LINK_S1(hw->bus.lan_id),
+					IXGBE_SB_IOSF_TARGET_KR_PHY, &link_s1);
 
-	/* Reset PHY */
-	if (!hw->phy.reset_disable && hw->phy.ops.reset)
-		hw->phy.ops.reset(hw);
+	if (status != IXGBE_SUCCESS ||
+	    (link_s1 & IXGBE_KRM_LINK_S1_MAC_AN_COMPLETE) == 0) {
+		hw_dbg(hw, "Auto-Negotiation did not complete\n");
+		status = IXGBE_ERR_FC_NOT_NEGOTIATED;
+		goto out;
+	}
 
-mac_reset_top:
-	/* Issue global reset to the MAC.  Needs to be SW reset if link is up.
-	 * If link reset is used when link is up, it might reset the PHY when
-	 * mng is using it.  If link is down or the flag to force full link
-	 * reset is set, then perform link reset.
+	/* Read the 10g AN autoc and LP ability registers and resolve
+	 * local flow control settings accordingly
 	 */
-	ctrl = IXGBE_CTRL_LNK_RST;
-
-	if (!hw->force_full_reset) {
-		hw->mac.ops.check_link(hw, &link_speed, &link_up, false);
-		if (link_up)
-			ctrl = IXGBE_CTRL_RST;
-	}
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &an_cntl_1);
 
-	status = hw->mac.ops.acquire_swfw_sync(hw, swfw_mask);
-	if (status) {
-		hw_dbg(hw, "semaphore failed with %d", status);
-		return IXGBE_ERR_SWFW_SYNC;
+	if (status != IXGBE_SUCCESS) {
+		hw_dbg(hw, "Auto-Negotiation did not complete\n");
+		goto out;
 	}
 
-	ctrl |= IXGBE_READ_REG(hw, IXGBE_CTRL);
-	IXGBE_WRITE_REG(hw, IXGBE_CTRL, ctrl);
-	IXGBE_WRITE_FLUSH(hw);
-	hw->mac.ops.release_swfw_sync(hw, swfw_mask);
-	usleep_range(1000, 1200);
-
-	/* Poll for reset bit to self-clear meaning reset is complete */
-	for (i = 0; i < 10; i++) {
-		ctrl = IXGBE_READ_REG(hw, IXGBE_CTRL);
-		if (!(ctrl & IXGBE_CTRL_RST_MASK))
-			break;
-		udelay(1);
-	}
+	status = hw->mac.ops.read_iosf_sb_reg(hw,
+				IXGBE_KRM_LP_BASE_PAGE_HIGH(hw->bus.lan_id),
+				IXGBE_SB_IOSF_TARGET_KR_PHY, &lp_an_page_low);
 
-	if (ctrl & IXGBE_CTRL_RST_MASK) {
-		status = IXGBE_ERR_RESET_FAILED;
-		hw_dbg(hw, "Reset polling failed to complete.\n");
+	if (status != IXGBE_SUCCESS) {
+		hw_dbg(hw, "Auto-Negotiation did not complete\n");
+		goto out;
 	}
 
-	msleep(50);
+	status = ixgbe_negotiate_fc(hw, an_cntl_1, lp_an_page_low,
+				    IXGBE_KRM_AN_CNTL_1_SYM_PAUSE,
+				    IXGBE_KRM_AN_CNTL_1_ASM_PAUSE,
+				    IXGBE_KRM_LP_BASE_PAGE_HIGH_SYM_PAUSE,
+				    IXGBE_KRM_LP_BASE_PAGE_HIGH_ASM_PAUSE);
 
-	/* Double resets are required for recovery from certain error
-	 * clear the multicast table.  Also reset num_rar_entries to 128,
-	 * since we modify this value when programming the SAN MAC address.
-	 */
-	if (hw->mac.flags & IXGBE_FLAGS_DOUBLE_RESET_REQUIRED) {
-		hw->mac.flags &= ~IXGBE_FLAGS_DOUBLE_RESET_REQUIRED;
-		goto mac_reset_top;
+out:
+	if (status == IXGBE_SUCCESS) {
+		hw->fc.fc_was_autonegged = true;
+	} else {
+		hw->fc.fc_was_autonegged = false;
+		hw->fc.current_mode = hw->fc.requested_mode;
 	}
-
-	/* Store the permanent mac address */
-	hw->mac.ops.get_mac_addr(hw, hw->mac.perm_addr);
-
-	/* Store MAC address from RAR0, clear receive address registers, and
-	 * clear the multicast table.  Also reset num_rar_entries to 128,
-	 * since we modify this value when programming the SAN MAC address.
-	 */
-	hw->mac.num_rar_entries = 128;
-	hw->mac.ops.init_rx_addrs(hw);
-
-	ixgbe_set_mdio_speed(hw);
-
-	if (hw->device_id == IXGBE_DEV_ID_X550EM_X_SFP)
-		ixgbe_setup_mux_ctl(hw);
-
-	return status;
 }
 
-/** ixgbe_set_ethertype_anti_spoofing_X550 - Enable/Disable Ethertype
- *	anti-spoofing
- *  @hw:  pointer to hardware structure
- *  @enable: enable or disable switch for Ethertype anti-spoofing
- *  @vf: Virtual Function pool - VF Pool to set for Ethertype anti-spoofing
+/**
+ * ixgbe_fc_autoneg_fiber_x550em_a - passthrough FC settings
+ * @hw: pointer to hardware structure
+ *
  **/
-static void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw,
-						   bool enable, int vf)
+void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw)
 {
-	int vf_target_reg = vf >> 3;
-	int vf_target_shift = vf % 8 + IXGBE_SPOOF_ETHERTYPEAS_SHIFT;
-	u32 pfvfspoof;
-
-	pfvfspoof = IXGBE_READ_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg));
-	if (enable)
-		pfvfspoof |= BIT(vf_target_shift);
-	else
-		pfvfspoof &= ~BIT(vf_target_shift);
-
-	IXGBE_WRITE_REG(hw, IXGBE_PFVFSPOOF(vf_target_reg), pfvfspoof);
+	hw->fc.fc_was_autonegged = false;
+	hw->fc.current_mode = hw->fc.requested_mode;
 }
 
-/** ixgbe_set_source_address_pruning_X550 - Enable/Disbale src address pruning
- *  @hw: pointer to hardware structure
- *  @enable: enable or disable source address pruning
- *  @pool: Rx pool to set source address pruning for
+/**
+ * ixgbe_fc_autoneg_sgmii_x550em_a - Enable flow control IEEE clause 37
+ * @hw: pointer to hardware structure
+ *
+ * Enable flow control according to IEEE clause 37.
  **/
-static void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw,
-						  bool enable,
-						  unsigned int pool)
+void ixgbe_fc_autoneg_sgmii_x550em_a(struct ixgbe_hw *hw)
 {
-	u64 pfflp;
+	s32 status = IXGBE_ERR_FC_NOT_NEGOTIATED;
+	u32 info[FW_PHY_ACT_DATA_COUNT] = { 0 };
+	ixgbe_link_speed speed;
+	bool link_up;
+
+	/* AN should have completed when the cable was plugged in.
+	 * Look for reasons to bail out.  Bail out if:
+	 * - FC autoneg is disabled, or if
+	 * - link is not up.
+	 */
+	if (hw->fc.disable_fc_autoneg) {
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			     "Flow control autoneg is disabled");
+		goto out;
+	}
 
-	/* max rx pool is 63 */
-	if (pool > 63)
-		return;
+	hw->mac.ops.check_link(hw, &speed, &link_up, false);
+	if (!link_up) {
+		ERROR_REPORT1(IXGBE_ERROR_SOFTWARE, "The link is down");
+		goto out;
+	}
 
-	pfflp = (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPL);
-	pfflp |= (u64)IXGBE_READ_REG(hw, IXGBE_PFFLPH) << 32;
+	/* Check if auto-negotiation has completed */
+	status = ixgbe_fw_phy_activity(hw, FW_PHY_ACT_GET_LINK_INFO, &info);
+	if (status != IXGBE_SUCCESS ||
+	    !(info[0] & FW_PHY_ACT_GET_LINK_INFO_AN_COMPLETE)) {
+		hw_dbg(hw, "Auto-Negotiation did not complete\n");
+		status = IXGBE_ERR_FC_NOT_NEGOTIATED;
+		goto out;
+	}
 
-	if (enable)
-		pfflp |= (1ULL << pool);
-	else
-		pfflp &= ~(1ULL << pool);
+	/* Negotiate the flow control */
+	status = ixgbe_negotiate_fc(hw, info[0], info[0],
+				    FW_PHY_ACT_GET_LINK_INFO_FC_RX,
+				    FW_PHY_ACT_GET_LINK_INFO_FC_TX,
+				    FW_PHY_ACT_GET_LINK_INFO_LP_FC_RX,
+				    FW_PHY_ACT_GET_LINK_INFO_LP_FC_TX);
 
-	IXGBE_WRITE_REG(hw, IXGBE_PFFLPL, (u32)pfflp);
-	IXGBE_WRITE_REG(hw, IXGBE_PFFLPH, (u32)(pfflp >> 32));
+out:
+	if (status == IXGBE_SUCCESS) {
+		hw->fc.fc_was_autonegged = true;
+	} else {
+		hw->fc.fc_was_autonegged = false;
+		hw->fc.current_mode = hw->fc.requested_mode;
+	}
 }
 
 /**
- *  ixgbe_setup_fc_backplane_x550em_a - Set up flow control
- *  @hw: pointer to hardware structure
+ * ixgbe_setup_fc_backplane_x550em_a - Set up flow control
+ * @hw: pointer to hardware structure
  *
- *  Called at init time to set up flow control.
+ * Called at init time to set up flow control.
  **/
-static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
+s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
 {
-	s32 status = 0;
+	s32 status = IXGBE_SUCCESS;
 	u32 an_cntl = 0;
 
+	DEBUGFUNC("ixgbe_setup_fc_backplane_x550em_a");
+
 	/* Validate the requested mode */
 	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
-		hw_err(hw, "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
+		ERROR_REPORT1(IXGBE_ERROR_UNSUPPORTED,
+			      "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
 		return IXGBE_ERR_INVALID_LINK_SETTINGS;
 	}
 
@@ -3576,7 +4141,7 @@ static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
 					IXGBE_KRM_AN_CNTL_1(hw->bus.lan_id),
 					IXGBE_SB_IOSF_TARGET_KR_PHY, &an_cntl);
 
-	if (status) {
+	if (status != IXGBE_SUCCESS) {
 		hw_dbg(hw, "Auto-Negotiation did not complete\n");
 		return status;
 	}
@@ -3618,7 +4183,8 @@ static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
 			   IXGBE_KRM_AN_CNTL_1_ASM_PAUSE;
 		break;
 	default:
-		hw_err(hw, "Flow control param set incorrectly\n");
+		ERROR_REPORT1(IXGBE_ERROR_ARGUMENT,
+			      "Flow control param set incorrectly\n");
 		return IXGBE_ERR_CONFIG;
 	}
 
@@ -3637,7 +4203,7 @@ static s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw)
  * @hw: pointer to hardware structure
  * @state: set mux if 1, clear if 0
  */
-static void ixgbe_set_mux(struct ixgbe_hw *hw, u8 state)
+STATIC void ixgbe_set_mux(struct ixgbe_hw *hw, u8 state)
 {
 	u32 esdp;
 
@@ -3658,11 +4224,13 @@ static void ixgbe_set_mux(struct ixgbe_hw *hw, u8 state)
  * @mask: Mask to specify which semaphore to acquire
  *
  * Acquires the SWFW semaphore and sets the I2C MUX
- */
-static s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
+ **/
+s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
 {
 	s32 status;
 
+	DEBUGFUNC("ixgbe_acquire_swfw_sync_X550em");
+
 	status = ixgbe_acquire_swfw_sync_X540(hw, mask);
 	if (status)
 		return status;
@@ -3670,7 +4238,7 @@ static s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
 	if (mask & IXGBE_GSSR_I2C_MASK)
 		ixgbe_set_mux(hw, 1);
 
-	return 0;
+	return IXGBE_SUCCESS;
 }
 
 /**
@@ -3679,9 +4247,11 @@ static s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
  * @mask: Mask to specify which semaphore to release
  *
  * Releases the SWFW semaphore and sets the I2C MUX
- */
-static void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
+ **/
+void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
 {
+	DEBUGFUNC("ixgbe_release_swfw_sync_X550em");
+
 	if (mask & IXGBE_GSSR_I2C_MASK)
 		ixgbe_set_mux(hw, 0);
 
@@ -3689,51 +4259,68 @@ static void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask)
 }
 
 /**
- * ixgbe_acquire_swfw_sync_x550em_a - Acquire SWFW semaphore
+ * ixgbe_acquire_swfw_sync_X550a - Acquire SWFW semaphore
  * @hw: pointer to hardware structure
  * @mask: Mask to specify which semaphore to acquire
  *
- * Acquires the SWFW semaphore and get the shared PHY token as needed
+ * Acquires the SWFW semaphore and get the shared phy token as needed
  */
-static s32 ixgbe_acquire_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+STATIC s32 ixgbe_acquire_swfw_sync_X550a(struct ixgbe_hw *hw, u32 mask)
 {
 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
 	int retries = FW_PHY_TOKEN_RETRIES;
-	s32 status;
+	s32 status = IXGBE_SUCCESS;
+
+	DEBUGFUNC("ixgbe_acquire_swfw_sync_X550a");
 
 	while (--retries) {
-		status = 0;
+		status = IXGBE_SUCCESS;
 		if (hmask)
 			status = ixgbe_acquire_swfw_sync_X540(hw, hmask);
-		if (status)
+		if (status) {
+			hw_dbg(hw, "Could not acquire SWFW semaphore, Status = %d\n",
+				  status);
 			return status;
+		}
 		if (!(mask & IXGBE_GSSR_TOKEN_SM))
-			return 0;
+			return IXGBE_SUCCESS;
 
 		status = ixgbe_get_phy_token(hw);
-		if (!status)
-			return 0;
+		if (status == IXGBE_ERR_TOKEN_RETRY)
+			hw_dbg(hw, "Could not acquire PHY token, Status = %d\n",
+				  status);
+
+		if (status == IXGBE_SUCCESS)
+			return IXGBE_SUCCESS;
+
 		if (hmask)
 			ixgbe_release_swfw_sync_X540(hw, hmask);
-		if (status != IXGBE_ERR_TOKEN_RETRY)
+
+		if (status != IXGBE_ERR_TOKEN_RETRY) {
+			hw_dbg(hw, "Unable to retry acquiring the PHY token, Status = %d\n",
+				  status);
 			return status;
-		msleep(FW_PHY_TOKEN_DELAY);
+		}
 	}
 
+	hw_dbg(hw, "Semaphore acquisition retries failed!: PHY ID = 0x%08X\n",
+		  hw->phy.id);
 	return status;
 }
 
 /**
- * ixgbe_release_swfw_sync_x550em_a - Release SWFW semaphore
+ * ixgbe_release_swfw_sync_X550a - Release SWFW semaphore
  * @hw: pointer to hardware structure
  * @mask: Mask to specify which semaphore to release
  *
- * Release the SWFW semaphore and puts the shared PHY token as needed
+ * Releases the SWFW semaphore and puts the shared phy token as needed
  */
-static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
+STATIC void ixgbe_release_swfw_sync_X550a(struct ixgbe_hw *hw, u32 mask)
 {
 	u32 hmask = mask & ~IXGBE_GSSR_TOKEN_SM;
 
+	DEBUGFUNC("ixgbe_release_swfw_sync_X550a");
+
 	if (mask & IXGBE_GSSR_TOKEN_SM)
 		ixgbe_put_phy_token(hw);
 
@@ -3742,7 +4329,7 @@ static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
 }
 
 /**
- * ixgbe_read_phy_reg_x550a - Reads specified PHY register
+ * ixgbe_read_phy_reg_x550a  - Reads specified PHY register
  * @hw: pointer to hardware structure
  * @reg_addr: 32 bit address of PHY register to read
  * @device_type: 5 bit device type
@@ -3751,12 +4338,14 @@ static void ixgbe_release_swfw_sync_x550em_a(struct ixgbe_hw *hw, u32 mask)
  * Reads a value from a specified PHY register using the SWFW lock and PHY
  * Token. The PHY Token is needed since the MDIO is shared between to MAC
  * instances.
- */
-static s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
-				    u32 device_type, u16 *phy_data)
+ **/
+s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+			       u32 device_type, u16 *phy_data)
 {
-	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
 	s32 status;
+	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
+
+	DEBUGFUNC("ixgbe_read_phy_reg_x550a");
 
 	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
 		return IXGBE_ERR_SWFW_SYNC;
@@ -3777,321 +4366,280 @@ static s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
  *
  * Writes a value to specified PHY register using the SWFW lock and PHY Token.
  * The PHY Token is needed since the MDIO is shared between to MAC instances.
- */
-static s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
-				     u32 device_type, u16 phy_data)
+ **/
+s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+				u32 device_type, u16 phy_data)
 {
-	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
 	s32 status;
+	u32 mask = hw->phy.phy_semaphore_mask | IXGBE_GSSR_TOKEN_SM;
 
-	if (hw->mac.ops.acquire_swfw_sync(hw, mask))
-		return IXGBE_ERR_SWFW_SYNC;
+	DEBUGFUNC("ixgbe_write_phy_reg_x550a");
 
-	status = ixgbe_write_phy_reg_mdi(hw, reg_addr, device_type, phy_data);
-	hw->mac.ops.release_swfw_sync(hw, mask);
+	if (hw->mac.ops.acquire_swfw_sync(hw, mask) == IXGBE_SUCCESS) {
+		status = hw->phy.ops.write_reg_mdi(hw, reg_addr, device_type,
+						 phy_data);
+		hw->mac.ops.release_swfw_sync(hw, mask);
+	} else {
+		status = IXGBE_ERR_SWFW_SYNC;
+	}
 
 	return status;
 }
 
-#define X550_COMMON_MAC \
-	.init_hw			= &ixgbe_init_hw_generic, \
-	.start_hw			= &ixgbe_start_hw_X540, \
-	.clear_hw_cntrs			= &ixgbe_clear_hw_cntrs_generic, \
-	.enable_rx_dma			= &ixgbe_enable_rx_dma_generic, \
-	.get_mac_addr			= &ixgbe_get_mac_addr_generic, \
-	.get_device_caps		= &ixgbe_get_device_caps_generic, \
-	.stop_adapter			= &ixgbe_stop_adapter_generic, \
-	.set_lan_id			= &ixgbe_set_lan_id_multi_port_pcie, \
-	.read_analog_reg8		= NULL, \
-	.write_analog_reg8		= NULL, \
-	.set_rxpba			= &ixgbe_set_rxpba_generic, \
-	.check_link			= &ixgbe_check_mac_link_generic, \
-	.blink_led_start		= &ixgbe_blink_led_start_X540, \
-	.blink_led_stop			= &ixgbe_blink_led_stop_X540, \
-	.set_rar			= &ixgbe_set_rar_generic, \
-	.clear_rar			= &ixgbe_clear_rar_generic, \
-	.set_vmdq			= &ixgbe_set_vmdq_generic, \
-	.set_vmdq_san_mac		= &ixgbe_set_vmdq_san_mac_generic, \
-	.clear_vmdq			= &ixgbe_clear_vmdq_generic, \
-	.init_rx_addrs			= &ixgbe_init_rx_addrs_generic, \
-	.update_mc_addr_list		= &ixgbe_update_mc_addr_list_generic, \
-	.enable_mc			= &ixgbe_enable_mc_generic, \
-	.disable_mc			= &ixgbe_disable_mc_generic, \
-	.clear_vfta			= &ixgbe_clear_vfta_generic, \
-	.set_vfta			= &ixgbe_set_vfta_generic, \
-	.fc_enable			= &ixgbe_fc_enable_generic, \
-	.set_fw_drv_ver			= &ixgbe_set_fw_drv_ver_x550, \
-	.init_uta_tables		= &ixgbe_init_uta_tables_generic, \
-	.set_mac_anti_spoofing		= &ixgbe_set_mac_anti_spoofing, \
-	.set_vlan_anti_spoofing		= &ixgbe_set_vlan_anti_spoofing, \
-	.set_source_address_pruning	= \
-				&ixgbe_set_source_address_pruning_X550, \
-	.set_ethertype_anti_spoofing	= \
-				&ixgbe_set_ethertype_anti_spoofing_X550, \
-	.disable_rx_buff		= &ixgbe_disable_rx_buff_generic, \
-	.enable_rx_buff			= &ixgbe_enable_rx_buff_generic, \
-	.get_thermal_sensor_data	= NULL, \
-	.init_thermal_sensor_thresh	= NULL, \
-	.fw_recovery_mode		= &ixgbe_fw_recovery_mode_X550, \
-	.enable_rx			= &ixgbe_enable_rx_generic, \
-	.disable_rx			= &ixgbe_disable_rx_x550, \
-
-static const struct ixgbe_mac_operations mac_ops_X550 = {
-	X550_COMMON_MAC
-	.led_on			= ixgbe_led_on_generic,
-	.led_off		= ixgbe_led_off_generic,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.reset_hw		= &ixgbe_reset_hw_X540,
-	.get_media_type		= &ixgbe_get_media_type_X540,
-	.get_san_mac_addr	= &ixgbe_get_san_mac_addr_generic,
-	.get_wwn_prefix		= &ixgbe_get_wwn_prefix_generic,
-	.setup_link		= &ixgbe_setup_mac_link_X540,
-	.get_link_capabilities	= &ixgbe_get_copper_link_capabilities_generic,
-	.get_bus_info		= &ixgbe_get_bus_info_generic,
-	.setup_sfp		= NULL,
-	.acquire_swfw_sync	= &ixgbe_acquire_swfw_sync_X540,
-	.release_swfw_sync	= &ixgbe_release_swfw_sync_X540,
-	.init_swfw_sync		= &ixgbe_init_swfw_sync_X540,
-	.prot_autoc_read	= prot_autoc_read_generic,
-	.prot_autoc_write	= prot_autoc_write_generic,
-	.setup_fc		= ixgbe_setup_fc_generic,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-};
+/**
+ * ixgbe_handle_lasi_ext_t_x550em - Handle external Base T PHY interrupt
+ * @hw: pointer to hardware structure
+ *
+ * Handle external Base T PHY interrupt. If high temperature
+ * failure alarm then return error, else if link status change
+ * then setup internal/external PHY link
+ *
+ * Return IXGBE_ERR_OVERTEMP if interrupt is high temperature
+ * failure alarm, else return PHY access status.
+ */
+s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw)
+{
+	bool lsc;
+	u32 status;
 
-static const struct ixgbe_mac_operations mac_ops_X550EM_x = {
-	X550_COMMON_MAC
-	.led_on			= ixgbe_led_on_t_x550em,
-	.led_off		= ixgbe_led_off_t_x550em,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.reset_hw		= &ixgbe_reset_hw_X550em,
-	.get_media_type		= &ixgbe_get_media_type_X550em,
-	.get_san_mac_addr	= NULL,
-	.get_wwn_prefix		= NULL,
-	.setup_link		= &ixgbe_setup_mac_link_X540,
-	.get_link_capabilities	= &ixgbe_get_link_capabilities_X550em,
-	.get_bus_info		= &ixgbe_get_bus_info_X550em,
-	.setup_sfp		= ixgbe_setup_sfp_modules_X550em,
-	.acquire_swfw_sync	= &ixgbe_acquire_swfw_sync_X550em,
-	.release_swfw_sync	= &ixgbe_release_swfw_sync_X550em,
-	.init_swfw_sync		= &ixgbe_init_swfw_sync_X540,
-	.setup_fc		= NULL, /* defined later */
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.read_iosf_sb_reg	= ixgbe_read_iosf_sb_reg_x550,
-	.write_iosf_sb_reg	= ixgbe_write_iosf_sb_reg_x550,
-};
+	status = ixgbe_get_lasi_ext_t_x550em(hw, &lsc);
 
-static const struct ixgbe_mac_operations mac_ops_X550EM_x_fw = {
-	X550_COMMON_MAC
-	.led_on			= NULL,
-	.led_off		= NULL,
-	.init_led_link_act	= NULL,
-	.reset_hw		= &ixgbe_reset_hw_X550em,
-	.get_media_type		= &ixgbe_get_media_type_X550em,
-	.get_san_mac_addr	= NULL,
-	.get_wwn_prefix		= NULL,
-	.setup_link		= &ixgbe_setup_mac_link_X540,
-	.get_link_capabilities	= &ixgbe_get_link_capabilities_X550em,
-	.get_bus_info		= &ixgbe_get_bus_info_X550em,
-	.setup_sfp		= ixgbe_setup_sfp_modules_X550em,
-	.acquire_swfw_sync	= &ixgbe_acquire_swfw_sync_X550em,
-	.release_swfw_sync	= &ixgbe_release_swfw_sync_X550em,
-	.init_swfw_sync		= &ixgbe_init_swfw_sync_X540,
-	.setup_fc		= NULL,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.read_iosf_sb_reg	= ixgbe_read_iosf_sb_reg_x550,
-	.write_iosf_sb_reg	= ixgbe_write_iosf_sb_reg_x550,
-};
+	if (status != IXGBE_SUCCESS)
+		return status;
 
-static const struct ixgbe_mac_operations mac_ops_x550em_a = {
-	X550_COMMON_MAC
-	.led_on			= ixgbe_led_on_t_x550em,
-	.led_off		= ixgbe_led_off_t_x550em,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.reset_hw		= ixgbe_reset_hw_X550em,
-	.get_media_type		= ixgbe_get_media_type_X550em,
-	.get_san_mac_addr	= NULL,
-	.get_wwn_prefix		= NULL,
-	.setup_link		= &ixgbe_setup_mac_link_X540,
-	.get_link_capabilities	= ixgbe_get_link_capabilities_X550em,
-	.get_bus_info		= ixgbe_get_bus_info_X550em,
-	.setup_sfp		= ixgbe_setup_sfp_modules_X550em,
-	.acquire_swfw_sync	= ixgbe_acquire_swfw_sync_x550em_a,
-	.release_swfw_sync	= ixgbe_release_swfw_sync_x550em_a,
-	.setup_fc		= ixgbe_setup_fc_x550em,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.read_iosf_sb_reg	= ixgbe_read_iosf_sb_reg_x550a,
-	.write_iosf_sb_reg	= ixgbe_write_iosf_sb_reg_x550a,
-};
+	if (lsc)
+		return ixgbe_setup_internal_phy(hw);
 
-static const struct ixgbe_mac_operations mac_ops_x550em_a_fw = {
-	X550_COMMON_MAC
-	.led_on			= ixgbe_led_on_generic,
-	.led_off		= ixgbe_led_off_generic,
-	.init_led_link_act	= ixgbe_init_led_link_act_generic,
-	.reset_hw		= ixgbe_reset_hw_X550em,
-	.get_media_type		= ixgbe_get_media_type_X550em,
-	.get_san_mac_addr	= NULL,
-	.get_wwn_prefix		= NULL,
-	.setup_link		= NULL, /* defined later */
-	.get_link_capabilities	= ixgbe_get_link_capabilities_X550em,
-	.get_bus_info		= ixgbe_get_bus_info_X550em,
-	.setup_sfp		= ixgbe_setup_sfp_modules_X550em,
-	.acquire_swfw_sync	= ixgbe_acquire_swfw_sync_x550em_a,
-	.release_swfw_sync	= ixgbe_release_swfw_sync_x550em_a,
-	.setup_fc		= ixgbe_setup_fc_x550em,
-	.fc_autoneg		= ixgbe_fc_autoneg,
-	.read_iosf_sb_reg	= ixgbe_read_iosf_sb_reg_x550a,
-	.write_iosf_sb_reg	= ixgbe_write_iosf_sb_reg_x550a,
-};
+	return IXGBE_SUCCESS;
+}
 
-#define X550_COMMON_EEP \
-	.read			= &ixgbe_read_ee_hostif_X550, \
-	.read_buffer		= &ixgbe_read_ee_hostif_buffer_X550, \
-	.write			= &ixgbe_write_ee_hostif_X550, \
-	.write_buffer		= &ixgbe_write_ee_hostif_buffer_X550, \
-	.validate_checksum	= &ixgbe_validate_eeprom_checksum_X550, \
-	.update_checksum	= &ixgbe_update_eeprom_checksum_X550, \
-	.calc_checksum		= &ixgbe_calc_eeprom_checksum_X550, \
-
-static const struct ixgbe_eeprom_operations eeprom_ops_X550 = {
-	X550_COMMON_EEP
-	.init_params		= &ixgbe_init_eeprom_params_X550,
-};
+/**
+ * ixgbe_setup_mac_link_t_X550em - Sets the auto advertised link speed
+ * @hw: pointer to hardware structure
+ * @speed: new link speed
+ * @autoneg_wait_to_complete: true when waiting for completion is needed
+ *
+ * Setup internal/external PHY link speed based on link speed, then set
+ * external PHY auto advertised link speed.
+ *
+ * Returns error status for any failure
+ **/
+s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw,
+				  ixgbe_link_speed speed,
+				  bool autoneg_wait_to_complete)
+{
+	s32 status;
+	ixgbe_link_speed force_speed;
 
-static const struct ixgbe_eeprom_operations eeprom_ops_X550EM_x = {
-	X550_COMMON_EEP
-	.init_params		= &ixgbe_init_eeprom_params_X540,
-};
+	DEBUGFUNC("ixgbe_setup_mac_link_t_X550em");
 
-#define X550_COMMON_PHY	\
-	.identify_sfp		= &ixgbe_identify_module_generic, \
-	.reset			= NULL, \
-	.setup_link_speed	= &ixgbe_setup_phy_link_speed_generic, \
-	.read_i2c_byte		= &ixgbe_read_i2c_byte_generic, \
-	.write_i2c_byte		= &ixgbe_write_i2c_byte_generic, \
-	.read_i2c_sff8472	= &ixgbe_read_i2c_sff8472_generic, \
-	.read_i2c_eeprom	= &ixgbe_read_i2c_eeprom_generic, \
-	.write_i2c_eeprom	= &ixgbe_write_i2c_eeprom_generic, \
-	.setup_link		= &ixgbe_setup_phy_link_generic, \
-	.set_phy_power		= NULL,
-
-static const struct ixgbe_phy_operations phy_ops_X550 = {
-	X550_COMMON_PHY
-	.check_overtemp		= &ixgbe_tn_check_overtemp,
-	.init			= NULL,
-	.identify		= &ixgbe_identify_phy_generic,
-	.read_reg		= &ixgbe_read_phy_reg_generic,
-	.write_reg		= &ixgbe_write_phy_reg_generic,
-};
+	/* Setup internal/external PHY link speed to iXFI (10G), unless
+	 * only 1G is auto advertised then setup KX link.
+	 */
+	if (speed & IXGBE_LINK_SPEED_10GB_FULL)
+		force_speed = IXGBE_LINK_SPEED_10GB_FULL;
+	else
+		force_speed = IXGBE_LINK_SPEED_1GB_FULL;
 
-static const struct ixgbe_phy_operations phy_ops_X550EM_x = {
-	X550_COMMON_PHY
-	.check_overtemp		= &ixgbe_tn_check_overtemp,
-	.init			= &ixgbe_init_phy_ops_X550em,
-	.identify		= &ixgbe_identify_phy_x550em,
-	.read_reg		= &ixgbe_read_phy_reg_generic,
-	.write_reg		= &ixgbe_write_phy_reg_generic,
-};
+	/* If X552 and internal link mode is XFI, then setup XFI internal link.
+	 */
+	if (hw->mac.type == ixgbe_mac_X550EM_x &&
+	    !(hw->phy.nw_mng_if_sel & IXGBE_NW_MNG_IF_SEL_INT_PHY_MODE)) {
+		status = ixgbe_setup_ixfi_x550em(hw, &force_speed);
 
-static const struct ixgbe_phy_operations phy_ops_x550em_x_fw = {
-	X550_COMMON_PHY
-	.check_overtemp		= NULL,
-	.init			= ixgbe_init_phy_ops_X550em,
-	.identify		= ixgbe_identify_phy_x550em,
-	.read_reg		= NULL,
-	.write_reg		= NULL,
-	.read_reg_mdi		= NULL,
-	.write_reg_mdi		= NULL,
-};
+		if (status != IXGBE_SUCCESS)
+			return status;
+	}
 
-static const struct ixgbe_phy_operations phy_ops_x550em_a = {
-	X550_COMMON_PHY
-	.check_overtemp		= &ixgbe_tn_check_overtemp,
-	.init			= &ixgbe_init_phy_ops_X550em,
-	.identify		= &ixgbe_identify_phy_x550em,
-	.read_reg		= &ixgbe_read_phy_reg_x550a,
-	.write_reg		= &ixgbe_write_phy_reg_x550a,
-	.read_reg_mdi		= &ixgbe_read_phy_reg_mdi,
-	.write_reg_mdi		= &ixgbe_write_phy_reg_mdi,
-};
+	return hw->phy.ops.setup_link_speed(hw, speed, autoneg_wait_to_complete);
+}
 
-static const struct ixgbe_phy_operations phy_ops_x550em_a_fw = {
-	X550_COMMON_PHY
-	.check_overtemp		= ixgbe_check_overtemp_fw,
-	.init			= ixgbe_init_phy_ops_X550em,
-	.identify		= ixgbe_identify_phy_fw,
-	.read_reg		= NULL,
-	.write_reg		= NULL,
-	.read_reg_mdi		= NULL,
-	.write_reg_mdi		= NULL,
-};
+/**
+ * ixgbe_check_link_t_X550em - Determine link and speed status
+ * @hw: pointer to hardware structure
+ * @speed: pointer to link speed
+ * @link_up: true when link is up
+ * @link_up_wait_to_complete: bool used to wait for link up or not
+ *
+ * Check that both the MAC and X557 external PHY have link.
+ **/
+s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+			      bool *link_up, bool link_up_wait_to_complete)
+{
+	u32 status;
+	u16 i, autoneg_status = 0;
 
-static const struct ixgbe_link_operations link_ops_x550em_x = {
-	.read_link		= &ixgbe_read_i2c_combined_generic,
-	.read_link_unlocked	= &ixgbe_read_i2c_combined_generic_unlocked,
-	.write_link		= &ixgbe_write_i2c_combined_generic,
-	.write_link_unlocked	= &ixgbe_write_i2c_combined_generic_unlocked,
-};
+	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_copper)
+		return IXGBE_ERR_CONFIG;
 
-static const u32 ixgbe_mvals_X550[IXGBE_MVALS_IDX_LIMIT] = {
-	IXGBE_MVALS_INIT(X550)
-};
+	status = ixgbe_check_mac_link_generic(hw, speed, link_up,
+					      link_up_wait_to_complete);
 
-static const u32 ixgbe_mvals_X550EM_x[IXGBE_MVALS_IDX_LIMIT] = {
-	IXGBE_MVALS_INIT(X550EM_x)
-};
+	/* If check link fails or MAC link is not up, then return */
+	if (status != IXGBE_SUCCESS || !(*link_up))
+		return status;
 
-static const u32 ixgbe_mvals_x550em_a[IXGBE_MVALS_IDX_LIMIT] = {
-	IXGBE_MVALS_INIT(X550EM_a)
-};
+	/* MAC link is up, so check external PHY link.
+	 * X557 PHY. Link status is latching low, and can only be used to detect
+	 * link drop, and not the current status of the link without performing
+	 * back-to-back reads.
+	 */
+	for (i = 0; i < 2; i++) {
+		status = hw->phy.ops.read_reg(hw, IXGBE_MDIO_AUTO_NEG_STATUS,
+					      IXGBE_MDIO_AUTO_NEG_DEV_TYPE,
+					      &autoneg_status);
 
-const struct ixgbe_info ixgbe_X550_info = {
-	.mac			= ixgbe_mac_X550,
-	.get_invariants		= &ixgbe_get_invariants_X540,
-	.mac_ops		= &mac_ops_X550,
-	.eeprom_ops		= &eeprom_ops_X550,
-	.phy_ops		= &phy_ops_X550,
-	.mbx_ops		= &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_X550,
-};
+		if (status != IXGBE_SUCCESS)
+			return status;
+	}
 
-const struct ixgbe_info ixgbe_X550EM_x_info = {
-	.mac			= ixgbe_mac_X550EM_x,
-	.get_invariants		= &ixgbe_get_invariants_X550_x,
-	.mac_ops		= &mac_ops_X550EM_x,
-	.eeprom_ops		= &eeprom_ops_X550EM_x,
-	.phy_ops		= &phy_ops_X550EM_x,
-	.mbx_ops		= &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_X550EM_x,
-	.link_ops		= &link_ops_x550em_x,
-};
+	/* If external PHY link is not up, then indicate link not up */
+	if (!(autoneg_status & IXGBE_MDIO_AUTO_NEG_LINK_STATUS))
+		*link_up = false;
 
-const struct ixgbe_info ixgbe_x550em_x_fw_info = {
-	.mac			= ixgbe_mac_X550EM_x,
-	.get_invariants		= ixgbe_get_invariants_X550_x_fw,
-	.mac_ops		= &mac_ops_X550EM_x_fw,
-	.eeprom_ops		= &eeprom_ops_X550EM_x,
-	.phy_ops		= &phy_ops_x550em_x_fw,
-	.mbx_ops		= &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_X550EM_x,
-};
+	return IXGBE_SUCCESS;
+}
 
-const struct ixgbe_info ixgbe_x550em_a_info = {
-	.mac			= ixgbe_mac_x550em_a,
-	.get_invariants		= &ixgbe_get_invariants_X550_a,
-	.mac_ops		= &mac_ops_x550em_a,
-	.eeprom_ops		= &eeprom_ops_X550EM_x,
-	.phy_ops		= &phy_ops_x550em_a,
-	.mbx_ops		= &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_x550em_a,
-};
+/**
+ * ixgbe_reset_phy_t_X550em - Performs X557 PHY reset and enables LASI
+ * @hw: pointer to hardware structure
+ **/
+s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw)
+{
+	s32 status;
+
+	status = ixgbe_reset_phy_generic(hw);
+
+	if (status != IXGBE_SUCCESS)
+		return status;
+
+	/* Configure Link Status Alarm and Temperature Threshold interrupts */
+	return ixgbe_enable_lasi_ext_t_x550em(hw);
+}
+
+/**
+ * ixgbe_led_on_t_X550em - Turns on the software controllable LEDs.
+ * @hw: pointer to hardware structure
+ * @led_idx: led number to turn on
+ **/
+s32 ixgbe_led_on_t_X550em(struct ixgbe_hw *hw, u32 led_idx)
+{
+	u16 phy_data;
+
+	DEBUGFUNC("ixgbe_led_on_t_X550em");
+
+	if (led_idx >= IXGBE_X557_MAX_LED_INDEX)
+		return IXGBE_ERR_PARAM;
+
+	/* To turn on the LED, set mode to ON. */
+	ixgbe_read_phy_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
+			   IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE, &phy_data);
+	phy_data |= IXGBE_X557_LED_MANUAL_SET_MASK;
+	ixgbe_write_phy_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
+			    IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE, phy_data);
+
+	/* Some designs have the LEDs wired to the MAC */
+	return ixgbe_led_on_generic(hw, led_idx);
+}
+
+/**
+ * ixgbe_led_off_t_X550em - Turns off the software controllable LEDs.
+ * @hw: pointer to hardware structure
+ * @led_idx: led number to turn off
+ **/
+s32 ixgbe_led_off_t_X550em(struct ixgbe_hw *hw, u32 led_idx)
+{
+	u16 phy_data;
+
+	DEBUGFUNC("ixgbe_led_off_t_X550em");
+
+	if (led_idx >= IXGBE_X557_MAX_LED_INDEX)
+		return IXGBE_ERR_PARAM;
+
+	/* To turn on the LED, set mode to ON. */
+	ixgbe_read_phy_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
+			   IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE, &phy_data);
+	phy_data &= ~IXGBE_X557_LED_MANUAL_SET_MASK;
+	ixgbe_write_phy_reg(hw, IXGBE_X557_LED_PROVISIONING + led_idx,
+			    IXGBE_MDIO_VENDOR_SPECIFIC_1_DEV_TYPE, phy_data);
+
+	/* Some designs have the LEDs wired to the MAC */
+	return ixgbe_led_off_generic(hw, led_idx);
+}
+
+/**
+ * ixgbe_set_fw_drv_ver_x550 - Sends driver version to firmware
+ * @hw: pointer to the HW structure
+ * @maj: driver version major number
+ * @min: driver version minor number
+ * @build: driver version build number
+ * @sub: driver version sub build number
+ * @len: length of driver_ver string
+ * @driver_ver: driver string
+ *
+ * Sends driver version number to firmware through the manageability
+ * block.  On success return IXGBE_SUCCESS
+ * else returns IXGBE_ERR_SWFW_SYNC when encountering an error acquiring
+ * semaphore or IXGBE_ERR_HOST_INTERFACE_COMMAND when command fails.
+ **/
+s32 ixgbe_set_fw_drv_ver_x550(struct ixgbe_hw *hw, u8 maj, u8 min,
+			      u8 build, u8 sub, u16 len, const char *driver_ver)
+{
+	struct ixgbe_hic_drv_info2 fw_cmd;
+	s32 ret_val = IXGBE_SUCCESS;
+	int i;
+
+	DEBUGFUNC("ixgbe_set_fw_drv_ver_x550");
+
+	if ((len == 0) || (driver_ver == NULL) ||
+	   (len > sizeof(fw_cmd.driver_string)))
+		return IXGBE_ERR_INVALID_ARGUMENT;
+
+	fw_cmd.hdr.cmd = FW_CEM_CMD_DRIVER_INFO;
+	fw_cmd.hdr.buf_len = FW_CEM_CMD_DRIVER_INFO_LEN + len;
+	fw_cmd.hdr.cmd_or_resp.cmd_resv = FW_CEM_CMD_RESERVED;
+	fw_cmd.port_num = (u8)hw->bus.func;
+	fw_cmd.ver_maj = maj;
+	fw_cmd.ver_min = min;
+	fw_cmd.ver_build = build;
+	fw_cmd.ver_sub = sub;
+	fw_cmd.hdr.checksum = 0;
+	memcpy(fw_cmd.driver_string, driver_ver, len);
+	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,
+				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));
+
+	for (i = 0; i <= FW_CEM_MAX_RETRIES; i++) {
+		ret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,
+						       sizeof(fw_cmd),
+						       IXGBE_HI_COMMAND_TIMEOUT,
+						       true);
+		if (ret_val != IXGBE_SUCCESS)
+			continue;
+
+		if (fw_cmd.hdr.cmd_or_resp.ret_status ==
+		    FW_CEM_RESP_STATUS_SUCCESS)
+			ret_val = IXGBE_SUCCESS;
+		else
+			ret_val = IXGBE_ERR_HOST_INTERFACE_COMMAND;
+
+		break;
+	}
+
+	return ret_val;
+}
+
+/**
+ * ixgbe_fw_recovery_mode_X550 - Check FW NVM recovery mode
+ * @hw: pointer t hardware structure
+ *
+ * Returns true if in FW NVM recovery mode.
+ **/
+bool ixgbe_fw_recovery_mode_X550(struct ixgbe_hw *hw)
+{
+	u32 fwsm;
+
+	fwsm = IXGBE_READ_REG(hw, IXGBE_FWSM_BY_MAC(hw));
+
+	return !!(fwsm & IXGBE_FWSM_FW_NVM_RECOVERY_MODE);
+}
 
-const struct ixgbe_info ixgbe_x550em_a_fw_info = {
-	.mac			= ixgbe_mac_x550em_a,
-	.get_invariants		= ixgbe_get_invariants_X550_a_fw,
-	.mac_ops		= &mac_ops_x550em_a_fw,
-	.eeprom_ops		= &eeprom_ops_X550EM_x,
-	.phy_ops		= &phy_ops_x550em_a_fw,
-	.mbx_ops		= &mbx_ops_generic,
-	.mvals			= ixgbe_mvals_x550em_a,
-};
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.h b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.h
new file mode 100644
index 000000000000..7ff921608b0d
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _IXGBE_X550_H_
+#define _IXGBE_X550_H_
+
+#include "ixgbe_type.h"
+
+s32 ixgbe_dmac_config_X550(struct ixgbe_hw *hw);
+s32 ixgbe_dmac_config_tcs_X550(struct ixgbe_hw *hw);
+s32 ixgbe_dmac_update_tcs_X550(struct ixgbe_hw *hw);
+
+s32 ixgbe_get_bus_info_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_init_eeprom_params_X550(struct ixgbe_hw *hw);
+s32 ixgbe_update_eeprom_checksum_X550(struct ixgbe_hw *hw);
+s32 ixgbe_calc_eeprom_checksum_X550(struct ixgbe_hw *hw);
+s32 ixgbe_calc_checksum_X550(struct ixgbe_hw *hw, u16 *buffer, u32 buffer_size);
+s32 ixgbe_validate_eeprom_checksum_X550(struct ixgbe_hw *hw, u16 *checksum_val);
+s32 ixgbe_update_flash_X550(struct ixgbe_hw *hw);
+s32 ixgbe_write_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
+				      u16 offset, u16 words, u16 *data);
+s32 ixgbe_write_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset,
+			       u16 data);
+s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,
+				     u16 offset, u16 words, u16 *data);
+s32 ixgbe_read_ee_hostif_X550(struct ixgbe_hw *hw, u16 offset,
+u16				*data);
+s32 ixgbe_write_ee_hostif_data_X550(struct ixgbe_hw *hw, u16 offset,
+				    u16 data);
+void ixgbe_set_source_address_pruning_X550(struct ixgbe_hw *hw, bool enable,
+					   unsigned int pool);
+void ixgbe_set_ethertype_anti_spoofing_X550(struct ixgbe_hw *hw,
+					    bool enable, int vf);
+s32 ixgbe_write_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
+				 u32 device_type, u32 data);
+s32 ixgbe_read_iosf_sb_reg_x550(struct ixgbe_hw *hw, u32 reg_addr,
+	u32 device_type, u32 *data);
+s32 ixgbe_set_fw_drv_ver_x550(struct ixgbe_hw *hw, u8 maj, u8 min,
+			      u8 build, u8 ver, u16 len, const char *str);
+s32 ixgbe_get_phy_token(struct ixgbe_hw *);
+s32 ixgbe_put_phy_token(struct ixgbe_hw *);
+s32 ixgbe_write_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+	u32 device_type, u32 data);
+s32 ixgbe_read_iosf_sb_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+	u32 device_type, u32 *data);
+void ixgbe_disable_mdd_X550(struct ixgbe_hw *hw);
+void ixgbe_enable_mdd_X550(struct ixgbe_hw *hw);
+void ixgbe_mdd_event_X550(struct ixgbe_hw *hw, u32 *vf_bitmap);
+void ixgbe_restore_mdd_vf_X550(struct ixgbe_hw *hw, u32 vf);
+enum ixgbe_media_type ixgbe_get_media_type_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_sfp_modules_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_get_link_capabilities_X550em(struct ixgbe_hw *hw,
+				       ixgbe_link_speed *speed, bool *autoneg);
+void ixgbe_init_mac_link_ops_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_reset_hw_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_init_phy_ops_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_kr_x550em(struct ixgbe_hw *hw);
+s32 ixgbe_init_ext_t_x550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_internal_phy_t_x550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_phy_loopback_x550em(struct ixgbe_hw *hw);
+u64 ixgbe_get_supported_physical_layer_X550em(struct ixgbe_hw *hw);
+void ixgbe_disable_rx_x550(struct ixgbe_hw *hw);
+s32 ixgbe_get_lcd_t_x550em(struct ixgbe_hw *hw, ixgbe_link_speed *lcd_speed);
+s32 ixgbe_enter_lplu_t_x550em(struct ixgbe_hw *hw);
+s32 ixgbe_acquire_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask);
+void ixgbe_release_swfw_sync_X550em(struct ixgbe_hw *hw, u32 mask);
+s32 ixgbe_setup_fc_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_mac_link_sfp_x550em(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete);
+s32 ixgbe_setup_mac_link_sfp_x550a(struct ixgbe_hw *hw,
+				    ixgbe_link_speed speed,
+				    bool autoneg_wait_to_complete);
+s32 ixgbe_read_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+			       u32 device_type, u16 *phy_data);
+s32 ixgbe_write_phy_reg_x550a(struct ixgbe_hw *hw, u32 reg_addr,
+				u32 device_type, u16 phy_data);
+s32 ixgbe_setup_fc_fiber_x550em_a(struct ixgbe_hw *hw);
+s32 ixgbe_setup_fc_backplane_x550em_a(struct ixgbe_hw *hw);
+s32 ixgbe_setup_fc_sgmii_x550em_a(struct ixgbe_hw *hw);
+void ixgbe_fc_autoneg_fiber_x550em_a(struct ixgbe_hw *hw);
+void ixgbe_fc_autoneg_backplane_x550em_a(struct ixgbe_hw *hw);
+void ixgbe_fc_autoneg_sgmii_x550em_a(struct ixgbe_hw *hw);
+s32 ixgbe_handle_lasi_ext_t_x550em(struct ixgbe_hw *hw);
+s32 ixgbe_setup_mac_link_t_X550em(struct ixgbe_hw *hw,
+				  ixgbe_link_speed speed,
+				  bool autoneg_wait_to_complete);
+s32 ixgbe_check_link_t_X550em(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
+			      bool *link_up, bool link_up_wait_to_complete);
+s32 ixgbe_reset_phy_t_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_identify_sfp_module_X550em(struct ixgbe_hw *hw);
+s32 ixgbe_led_on_t_X550em(struct ixgbe_hw *hw, u32 led_idx);
+s32 ixgbe_led_off_t_X550em(struct ixgbe_hw *hw, u32 led_idx);
+bool ixgbe_fw_recovery_mode_X550(struct ixgbe_hw *hw);
+#endif /* _IXGBE_X550_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
index 3771857cf887..8ae8f1bab5b5 100644
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_xsk.c
@@ -1,57 +1,169 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright(c) 2018 Intel Corporation. */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
 
+#include "ixgbe.h"
+
+#ifdef HAVE_XDP_SUPPORT
 #include <linux/bpf_trace.h>
-#include <net/xdp_sock_drv.h>
+#endif
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+#include <net/xdp_sock.h>
+#endif
+#ifdef HAVE_XDP_BUFF_RXQ
 #include <net/xdp.h>
+#endif
 
-#include "ixgbe.h"
 #include "ixgbe_txrx_common.h"
 
-struct xsk_buff_pool *ixgbe_xsk_pool(struct ixgbe_adapter *adapter,
-				     struct ixgbe_ring *ring)
+#ifdef HAVE_AF_XDP_ZC_SUPPORT
+struct xdp_umem *ixgbe_xsk_umem(struct ixgbe_adapter *adapter,
+				struct ixgbe_ring *ring)
 {
 	bool xdp_on = READ_ONCE(adapter->xdp_prog);
 	int qid = ring->ring_idx;
 
-	if (!xdp_on || !test_bit(qid, adapter->af_xdp_zc_qps))
+	if (!adapter->xsk_umems || !adapter->xsk_umems[qid] ||
+	    qid >= adapter->num_xsk_umems || !xdp_on)
 		return NULL;
 
-	return xsk_get_pool_from_qid(adapter->netdev, qid);
+	return adapter->xsk_umems[qid];
+}
+
+static int ixgbe_alloc_xsk_umems(struct ixgbe_adapter *adapter)
+{
+	if (adapter->xsk_umems)
+		return 0;
+
+	adapter->num_xsk_umems_used = 0;
+	adapter->num_xsk_umems = adapter->num_rx_queues;
+	adapter->xsk_umems = kcalloc(adapter->num_xsk_umems,
+				     sizeof(*adapter->xsk_umems),
+				     GFP_KERNEL);
+	if (!adapter->xsk_umems) {
+		adapter->num_xsk_umems = 0;
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int ixgbe_add_xsk_umem(struct ixgbe_adapter *adapter,
+			      struct xdp_umem *umem,
+			      u16 qid)
+{
+	int err;
+
+	err = ixgbe_alloc_xsk_umems(adapter);
+	if (err)
+		return err;
+
+	adapter->xsk_umems[qid] = umem;
+	adapter->num_xsk_umems_used++;
+
+	return 0;
 }
 
-static int ixgbe_xsk_pool_enable(struct ixgbe_adapter *adapter,
-				 struct xsk_buff_pool *pool,
+static void ixgbe_remove_xsk_umem(struct ixgbe_adapter *adapter, u16 qid)
+{
+	adapter->xsk_umems[qid] = NULL;
+	adapter->num_xsk_umems_used--;
+
+	if (adapter->num_xsk_umems == 0) {
+		kfree(adapter->xsk_umems);
+		adapter->xsk_umems = NULL;
+		adapter->num_xsk_umems = 0;
+	}
+}
+
+static int ixgbe_xsk_umem_dma_map(struct ixgbe_adapter *adapter,
+				  struct xdp_umem *umem)
+{
+	struct device *dev = &adapter->pdev->dev;
+	unsigned int i, j;
+	dma_addr_t dma;
+
+	for (i = 0; i < umem->npgs; i++) {
+		dma = dma_map_page_attrs(dev, umem->pgs[i], 0, PAGE_SIZE,
+					 DMA_BIDIRECTIONAL, IXGBE_RX_DMA_ATTR);
+		if (dma_mapping_error(dev, dma))
+			goto out_unmap;
+
+		umem->pages[i].dma = dma;
+	}
+
+	return 0;
+
+out_unmap:
+	for (j = 0; j < i; j++) {
+		dma_unmap_page_attrs(dev, umem->pages[i].dma, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, IXGBE_RX_DMA_ATTR);
+		umem->pages[i].dma = 0;
+	}
+
+	return -1;
+}
+
+static void ixgbe_xsk_umem_dma_unmap(struct ixgbe_adapter *adapter,
+				     struct xdp_umem *umem)
+{
+	struct device *dev = &adapter->pdev->dev;
+	unsigned int i;
+
+	for (i = 0; i < umem->npgs; i++) {
+		dma_unmap_page_attrs(dev, umem->pages[i].dma, PAGE_SIZE,
+				     DMA_BIDIRECTIONAL, IXGBE_RX_DMA_ATTR);
+
+		umem->pages[i].dma = 0;
+	}
+}
+
+static int ixgbe_xsk_umem_enable(struct ixgbe_adapter *adapter,
+				 struct xdp_umem *umem,
 				 u16 qid)
 {
-	struct net_device *netdev = adapter->netdev;
+	struct xdp_umem_fq_reuse *reuseq;
 	bool if_running;
 	int err;
 
 	if (qid >= adapter->num_rx_queues)
 		return -EINVAL;
 
-	if (qid >= netdev->real_num_rx_queues ||
-	    qid >= netdev->real_num_tx_queues)
-		return -EINVAL;
+	if (adapter->xsk_umems) {
+		if (qid >= adapter->num_xsk_umems)
+			return -EINVAL;
+		if (adapter->xsk_umems[qid])
+			return -EBUSY;
+	}
+
+	reuseq = xsk_reuseq_prepare(adapter->rx_ring[0]->count);
+	if (!reuseq)
+		return -ENOMEM;
+
+	xsk_reuseq_free(xsk_reuseq_swap(umem, reuseq));
 
-	err = xsk_pool_dma_map(pool, &adapter->pdev->dev, IXGBE_RX_DMA_ATTR);
+	err = ixgbe_xsk_umem_dma_map(adapter, umem);
 	if (err)
 		return err;
 
 	if_running = netif_running(adapter->netdev) &&
-		     ixgbe_enabled_xdp_adapter(adapter);
+		     READ_ONCE(adapter->xdp_prog);
 
 	if (if_running)
 		ixgbe_txrx_ring_disable(adapter, qid);
 
-	set_bit(qid, adapter->af_xdp_zc_qps);
+	err = ixgbe_add_xsk_umem(adapter, umem, qid);
+	if (err)
+		return err;
 
 	if (if_running) {
 		ixgbe_txrx_ring_enable(adapter, qid);
 
 		/* Kick start the NAPI context so that receiving will start */
+#ifdef HAVE_NDO_XSK_WAKEUP
 		err = ixgbe_xsk_wakeup(adapter->netdev, qid, XDP_WAKEUP_RX);
+#else
+		err = ixgbe_xsk_async_xmit(adapter->netdev, qid);
+#endif
 		if (err)
 			return err;
 	}
@@ -59,23 +171,22 @@ static int ixgbe_xsk_pool_enable(struct ixgbe_adapter *adapter,
 	return 0;
 }
 
-static int ixgbe_xsk_pool_disable(struct ixgbe_adapter *adapter, u16 qid)
+static int ixgbe_xsk_umem_disable(struct ixgbe_adapter *adapter, u16 qid)
 {
-	struct xsk_buff_pool *pool;
 	bool if_running;
 
-	pool = xsk_get_pool_from_qid(adapter->netdev, qid);
-	if (!pool)
+	if (!adapter->xsk_umems || qid >= adapter->num_xsk_umems ||
+	    !adapter->xsk_umems[qid])
 		return -EINVAL;
 
 	if_running = netif_running(adapter->netdev) &&
-		     ixgbe_enabled_xdp_adapter(adapter);
+		     READ_ONCE(adapter->xdp_prog);
 
 	if (if_running)
 		ixgbe_txrx_ring_disable(adapter, qid);
 
-	clear_bit(qid, adapter->af_xdp_zc_qps);
-	xsk_pool_dma_unmap(pool, IXGBE_RX_DMA_ATTR);
+	ixgbe_xsk_umem_dma_unmap(adapter, adapter->xsk_umems[qid]);
+	ixgbe_remove_xsk_umem(adapter, qid);
 
 	if (if_running)
 		ixgbe_txrx_ring_enable(adapter, qid);
@@ -83,12 +194,11 @@ static int ixgbe_xsk_pool_disable(struct ixgbe_adapter *adapter, u16 qid)
 	return 0;
 }
 
-int ixgbe_xsk_pool_setup(struct ixgbe_adapter *adapter,
-			 struct xsk_buff_pool *pool,
+int ixgbe_xsk_umem_setup(struct ixgbe_adapter *adapter, struct xdp_umem *umem,
 			 u16 qid)
 {
-	return pool ? ixgbe_xsk_pool_enable(adapter, pool, qid) :
-		ixgbe_xsk_pool_disable(adapter, qid);
+	return umem ? ixgbe_xsk_umem_enable(adapter, umem, qid) :
+		ixgbe_xsk_umem_disable(adapter, qid);
 }
 
 static int ixgbe_run_xdp_zc(struct ixgbe_adapter *adapter,
@@ -103,7 +213,7 @@ static int ixgbe_run_xdp_zc(struct ixgbe_adapter *adapter,
 	rcu_read_lock();
 	xdp_prog = READ_ONCE(rx_ring->xdp_prog);
 	act = bpf_prog_run_xdp(xdp_prog, xdp);
-
+	xdp->handle += xdp->data - xdp->data_hard_start;
 	switch (act) {
 	case XDP_PASS:
 		break;
@@ -121,10 +231,10 @@ static int ixgbe_run_xdp_zc(struct ixgbe_adapter *adapter,
 		break;
 	default:
 		bpf_warn_invalid_xdp_action(act);
-		fallthrough;
+		/* fallthrough */
 	case XDP_ABORTED:
 		trace_xdp_exception(rx_ring->netdev, xdp_prog, act);
-		fallthrough; /* handle aborts by dropping packet */
+		/* fallthrough -- handle aborts by dropping packet */
 	case XDP_DROP:
 		result = IXGBE_XDP_CONSUMED;
 		break;
@@ -133,16 +243,146 @@ static int ixgbe_run_xdp_zc(struct ixgbe_adapter *adapter,
 	return result;
 }
 
-bool ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
+static struct
+ixgbe_rx_buffer *ixgbe_get_rx_buffer_zc(struct ixgbe_ring *rx_ring,
+					unsigned int size)
+{
+	struct ixgbe_rx_buffer *bi;
+
+	bi = &rx_ring->rx_buffer_info[rx_ring->next_to_clean];
+
+	/* we are reusing so sync this buffer for CPU use */
+	dma_sync_single_range_for_cpu(rx_ring->dev,
+				      bi->dma, 0,
+				      size,
+				      DMA_BIDIRECTIONAL);
+
+	return bi;
+}
+
+static void ixgbe_reuse_rx_buffer_zc(struct ixgbe_ring *rx_ring,
+				     struct ixgbe_rx_buffer *obi)
+{
+	unsigned long mask = (unsigned long)rx_ring->xsk_umem->chunk_mask;
+	u64 hr = rx_ring->xsk_umem->headroom + XDP_PACKET_HEADROOM;
+	u16 nta = rx_ring->next_to_alloc;
+	struct ixgbe_rx_buffer *nbi;
+
+	nbi = &rx_ring->rx_buffer_info[rx_ring->next_to_alloc];
+	/* update, and store next to alloc */
+	nta++;
+	rx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;
+
+	/* transfer page from old buffer to new buffer */
+	nbi->dma = obi->dma & mask;
+	nbi->dma += hr;
+
+	nbi->addr = (void *)((unsigned long)obi->addr & mask);
+	nbi->addr += hr;
+
+	nbi->handle = obi->handle & mask;
+	nbi->handle += rx_ring->xsk_umem->headroom;
+
+	obi->addr = NULL;
+	obi->skb = NULL;
+}
+
+void ixgbe_zca_free(struct zero_copy_allocator *alloc, unsigned long handle)
+{
+	struct ixgbe_rx_buffer *bi;
+	struct ixgbe_ring *rx_ring;
+	u64 hr, mask;
+	u16 nta;
+
+	rx_ring = container_of(alloc, struct ixgbe_ring, zca);
+	hr = rx_ring->xsk_umem->headroom + XDP_PACKET_HEADROOM;
+	mask = rx_ring->xsk_umem->chunk_mask;
+
+	nta = rx_ring->next_to_alloc;
+	bi = rx_ring->rx_buffer_info;
+
+	nta++;
+	rx_ring->next_to_alloc = (nta < rx_ring->count) ? nta : 0;
+
+	handle &= mask;
+
+	bi->dma = xdp_umem_get_dma(rx_ring->xsk_umem, handle);
+	bi->dma += hr;
+
+	bi->addr = xdp_umem_get_data(rx_ring->xsk_umem, handle);
+	bi->addr += hr;
+
+	bi->handle = (u64)handle + rx_ring->xsk_umem->headroom;
+}
+
+static bool ixgbe_alloc_buffer_zc(struct ixgbe_ring *rx_ring,
+				  struct ixgbe_rx_buffer *bi)
+{
+	struct xdp_umem *umem = rx_ring->xsk_umem;
+	void *addr = bi->addr;
+	u64 handle, hr;
+
+	if (addr)
+		return true;
+
+	if (!xsk_umem_peek_addr(umem, &handle)) {
+		rx_ring->rx_stats.alloc_rx_page_failed++;
+		return false;
+	}
+
+	hr = umem->headroom + XDP_PACKET_HEADROOM;
+
+	bi->dma = xdp_umem_get_dma(umem, handle);
+	bi->dma += hr;
+
+	bi->addr = xdp_umem_get_data(umem, handle);
+	bi->addr += hr;
+
+	bi->handle = handle + umem->headroom;
+
+	xsk_umem_release_addr(umem);
+	return true;
+}
+
+static bool ixgbe_alloc_buffer_slow_zc(struct ixgbe_ring *rx_ring,
+				       struct ixgbe_rx_buffer *bi)
+{
+	struct xdp_umem *umem = rx_ring->xsk_umem;
+	u64 handle, hr;
+
+	if (!xsk_umem_peek_addr_rq(umem, &handle)) {
+		rx_ring->rx_stats.alloc_rx_page_failed++;
+		return false;
+	}
+
+	handle &= rx_ring->xsk_umem->chunk_mask;
+
+	hr = umem->headroom + XDP_PACKET_HEADROOM;
+
+	bi->dma = xdp_umem_get_dma(umem, handle);
+	bi->dma += hr;
+
+	bi->addr = xdp_umem_get_data(umem, handle);
+	bi->addr += hr;
+
+	bi->handle = handle + umem->headroom;
+
+	xsk_umem_release_addr_rq(umem);
+	return true;
+}
+
+static __always_inline bool
+__ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 cleaned_count,
+			    bool alloc(struct ixgbe_ring *rx_ring,
+				       struct ixgbe_rx_buffer *bi))
 {
 	union ixgbe_adv_rx_desc *rx_desc;
 	struct ixgbe_rx_buffer *bi;
 	u16 i = rx_ring->next_to_use;
-	dma_addr_t dma;
 	bool ok = true;
 
 	/* nothing to do */
-	if (!count)
+	if (!cleaned_count)
 		return true;
 
 	rx_desc = IXGBE_RX_DESC(rx_ring, i);
@@ -150,18 +390,21 @@ bool ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
 	i -= rx_ring->count;
 
 	do {
-		bi->xdp = xsk_buff_alloc(rx_ring->xsk_pool);
-		if (!bi->xdp) {
+		if (!alloc(rx_ring, bi)) {
 			ok = false;
 			break;
 		}
 
-		dma = xsk_buff_xdp_get_dma(bi->xdp);
+		/* sync the buffer for use by the device */
+		dma_sync_single_range_for_device(rx_ring->dev, bi->dma,
+						 bi->page_offset,
+						 rx_ring->rx_buf_len,
+						 DMA_BIDIRECTIONAL);
 
 		/* Refresh the desc even if buffer_addrs didn't change
 		 * because each write-back erases this info.
 		 */
-		rx_desc->read.pkt_addr = cpu_to_le64(dma);
+		rx_desc->read.pkt_addr = cpu_to_le64(bi->dma);
 
 		rx_desc++;
 		bi++;
@@ -175,14 +418,17 @@ bool ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
 		/* clear the length for the next_to_use descriptor */
 		rx_desc->wb.upper.length = 0;
 
-		count--;
-	} while (count);
+		cleaned_count--;
+	} while (cleaned_count);
 
 	i += rx_ring->count;
 
 	if (rx_ring->next_to_use != i) {
 		rx_ring->next_to_use = i;
 
+		/* update next to alloc since we have filled the ring */
+		rx_ring->next_to_alloc = i;
+
 		/* Force memory writes to complete before letting h/w
 		 * know there are new descriptors to fetch.  (Only
 		 * applicable for weak-ordered memory model archs,
@@ -195,27 +441,40 @@ bool ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
 	return ok;
 }
 
+void ixgbe_alloc_rx_buffers_zc(struct ixgbe_ring *rx_ring, u16 count)
+{
+	__ixgbe_alloc_rx_buffers_zc(rx_ring, count,
+				    ixgbe_alloc_buffer_slow_zc);
+}
+
+static bool ixgbe_alloc_rx_buffers_fast_zc(struct ixgbe_ring *rx_ring,
+					   u16 count)
+{
+	return __ixgbe_alloc_rx_buffers_zc(rx_ring, count,
+					   ixgbe_alloc_buffer_zc);
+}
+
 static struct sk_buff *ixgbe_construct_skb_zc(struct ixgbe_ring *rx_ring,
-					      struct ixgbe_rx_buffer *bi)
+					      struct ixgbe_rx_buffer *bi,
+					      struct xdp_buff *xdp)
 {
-	unsigned int metasize = bi->xdp->data - bi->xdp->data_meta;
-	unsigned int datasize = bi->xdp->data_end - bi->xdp->data;
+	unsigned int metasize = xdp->data - xdp->data_meta;
+	unsigned int datasize = xdp->data_end - xdp->data;
 	struct sk_buff *skb;
 
 	/* allocate a skb to store the frags */
 	skb = __napi_alloc_skb(&rx_ring->q_vector->napi,
-			       bi->xdp->data_end - bi->xdp->data_hard_start,
+			       xdp->data_end - xdp->data_hard_start,
 			       GFP_ATOMIC | __GFP_NOWARN);
 	if (unlikely(!skb))
 		return NULL;
 
-	skb_reserve(skb, bi->xdp->data - bi->xdp->data_hard_start);
-	memcpy(__skb_put(skb, datasize), bi->xdp->data, datasize);
+	skb_reserve(skb, xdp->data - xdp->data_hard_start);
+	memcpy(__skb_put(skb, datasize), xdp->data, datasize);
 	if (metasize)
 		skb_metadata_set(skb, metasize);
 
-	xsk_buff_free(bi->xdp);
-	bi->xdp = NULL;
+	ixgbe_reuse_rx_buffer_zc(rx_ring, bi);
 	return skb;
 }
 
@@ -238,6 +497,9 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 	unsigned int xdp_res, xdp_xmit = 0;
 	bool failure = false;
 	struct sk_buff *skb;
+	struct xdp_buff xdp;
+
+	xdp.rxq = &rx_ring->xdp_rxq;
 
 	while (likely(total_rx_packets < budget)) {
 		union ixgbe_adv_rx_desc *rx_desc;
@@ -247,8 +509,8 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 		/* return some buffers to hardware, one at a time is too slow */
 		if (cleaned_count >= IXGBE_RX_BUFFER_WRITE) {
 			failure = failure ||
-				  !ixgbe_alloc_rx_buffers_zc(rx_ring,
-							     cleaned_count);
+				  !ixgbe_alloc_rx_buffers_fast_zc(rx_ring,
+								 cleaned_count);
 			cleaned_count = 0;
 		}
 
@@ -263,40 +525,42 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 		 */
 		dma_rmb();
 
-		bi = &rx_ring->rx_buffer_info[rx_ring->next_to_clean];
+		bi = ixgbe_get_rx_buffer_zc(rx_ring, size);
 
 		if (unlikely(!ixgbe_test_staterr(rx_desc,
 						 IXGBE_RXD_STAT_EOP))) {
 			struct ixgbe_rx_buffer *next_bi;
 
-			xsk_buff_free(bi->xdp);
-			bi->xdp = NULL;
+			ixgbe_reuse_rx_buffer_zc(rx_ring, bi);
 			ixgbe_inc_ntc(rx_ring);
 			next_bi =
 			       &rx_ring->rx_buffer_info[rx_ring->next_to_clean];
-			next_bi->discard = true;
+			next_bi->skb = ERR_PTR(-EINVAL);
 			continue;
 		}
 
-		if (unlikely(bi->discard)) {
-			xsk_buff_free(bi->xdp);
-			bi->xdp = NULL;
-			bi->discard = false;
+		if (unlikely(bi->skb)) {
+			ixgbe_reuse_rx_buffer_zc(rx_ring, bi);
 			ixgbe_inc_ntc(rx_ring);
 			continue;
 		}
 
-		bi->xdp->data_end = bi->xdp->data + size;
-		xsk_buff_dma_sync_for_cpu(bi->xdp, rx_ring->xsk_pool);
-		xdp_res = ixgbe_run_xdp_zc(adapter, rx_ring, bi->xdp);
+		xdp.data = bi->addr;
+		xdp.data_meta = xdp.data;
+		xdp.data_hard_start = xdp.data - XDP_PACKET_HEADROOM;
+		xdp.data_end = xdp.data + size;
+		xdp.handle = bi->handle;
+
+		xdp_res = ixgbe_run_xdp_zc(adapter, rx_ring, &xdp);
 
 		if (xdp_res) {
-			if (xdp_res & (IXGBE_XDP_TX | IXGBE_XDP_REDIR))
+			if (xdp_res & (IXGBE_XDP_TX | IXGBE_XDP_REDIR)) {
 				xdp_xmit |= xdp_res;
-			else
-				xsk_buff_free(bi->xdp);
-
-			bi->xdp = NULL;
+				bi->addr = NULL;
+				bi->skb = NULL;
+			} else {
+				ixgbe_reuse_rx_buffer_zc(rx_ring, bi);
+			}
 			total_rx_packets++;
 			total_rx_bytes += size;
 
@@ -306,7 +570,7 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 		}
 
 		/* XDP_PASS path */
-		skb = ixgbe_construct_skb_zc(rx_ring, bi);
+		skb = ixgbe_construct_skb_zc(rx_ring, bi, &xdp);
 		if (!skb) {
 			rx_ring->rx_stats.alloc_rx_buff_failed++;
 			break;
@@ -322,7 +586,7 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 		total_rx_packets++;
 
 		ixgbe_process_skb_fields(rx_ring, rx_desc, skb);
-		ixgbe_rx_skb(q_vector, skb);
+		ixgbe_rx_skb(q_vector, rx_ring, rx_desc, skb);
 	}
 
 	if (xdp_xmit & IXGBE_XDP_REDIR)
@@ -345,42 +609,38 @@ int ixgbe_clean_rx_irq_zc(struct ixgbe_q_vector *q_vector,
 	q_vector->rx.total_packets += total_rx_packets;
 	q_vector->rx.total_bytes += total_rx_bytes;
 
-	if (xsk_uses_need_wakeup(rx_ring->xsk_pool)) {
-		if (failure || rx_ring->next_to_clean == rx_ring->next_to_use)
-			xsk_set_rx_need_wakeup(rx_ring->xsk_pool);
-		else
-			xsk_clear_rx_need_wakeup(rx_ring->xsk_pool);
-
-		return (int)total_rx_packets;
-	}
 	return failure ? budget : (int)total_rx_packets;
 }
 
 void ixgbe_xsk_clean_rx_ring(struct ixgbe_ring *rx_ring)
 {
-	struct ixgbe_rx_buffer *bi;
-	u16 i;
-
-	for (i = 0; i < rx_ring->count; i++) {
-		bi = &rx_ring->rx_buffer_info[i];
+	u16 i = rx_ring->next_to_clean;
+	struct ixgbe_rx_buffer *bi = &rx_ring->rx_buffer_info[i];
 
-		if (!bi->xdp)
-			continue;
-
-		xsk_buff_free(bi->xdp);
-		bi->xdp = NULL;
+	while (i != rx_ring->next_to_alloc) {
+		xsk_umem_fq_reuse(rx_ring->xsk_umem, bi->handle);
+		i++;
+		bi++;
+		if (i == rx_ring->count) {
+			i = 0;
+			bi = rx_ring->rx_buffer_info;
+		}
 	}
 }
 
 static bool ixgbe_xmit_zc(struct ixgbe_ring *xdp_ring, unsigned int budget)
 {
-	struct xsk_buff_pool *pool = xdp_ring->xsk_pool;
 	union ixgbe_adv_tx_desc *tx_desc = NULL;
 	struct ixgbe_tx_buffer *tx_bi;
 	bool work_done = true;
+#ifdef XSK_UMEM_RETURNS_XDP_DESC
 	struct xdp_desc desc;
+#endif
 	dma_addr_t dma;
 	u32 cmd_type;
+#ifndef XSK_UMEM_RETURNS_XDP_DESC
+	u32 len;
+#endif
 
 	while (budget-- > 0) {
 		if (unlikely(!ixgbe_desc_unused(xdp_ring)) ||
@@ -389,16 +649,29 @@ static bool ixgbe_xmit_zc(struct ixgbe_ring *xdp_ring, unsigned int budget)
 			break;
 		}
 
-		if (!xsk_tx_peek_desc(pool, &desc))
+#ifdef XSK_UMEM_RETURNS_XDP_DESC
+		if (!xsk_umem_consume_tx(xdp_ring->xsk_umem, &desc))
 			break;
 
-		dma = xsk_buff_raw_get_dma(pool, desc.addr);
-		xsk_buff_raw_dma_sync_for_device(pool, dma, desc.len);
+		dma = xdp_umem_get_dma(xdp_ring->xsk_umem, desc.addr);
+
+		dma_sync_single_for_device(xdp_ring->dev, dma, desc.len,
+					   DMA_BIDIRECTIONAL);
 
 		tx_bi = &xdp_ring->tx_buffer_info[xdp_ring->next_to_use];
 		tx_bi->bytecount = desc.len;
 		tx_bi->xdpf = NULL;
-		tx_bi->gso_segs = 1;
+#else
+		if (!xsk_umem_consume_tx(xdp_ring->xsk_umem, &dma, &len))
+			break;
+
+		dma_sync_single_for_device(xdp_ring->dev, dma, len,
+					   DMA_BIDIRECTIONAL);
+
+		tx_bi = &xdp_ring->tx_buffer_info[xdp_ring->next_to_use];
+		tx_bi->bytecount = len;
+		tx_bi->xdpf = NULL;
+#endif
 
 		tx_desc = IXGBE_TX_DESC(xdp_ring, xdp_ring->next_to_use);
 		tx_desc->read.buffer_addr = cpu_to_le64(dma);
@@ -407,10 +680,17 @@ static bool ixgbe_xmit_zc(struct ixgbe_ring *xdp_ring, unsigned int budget)
 		cmd_type = IXGBE_ADVTXD_DTYP_DATA |
 			   IXGBE_ADVTXD_DCMD_DEXT |
 			   IXGBE_ADVTXD_DCMD_IFCS;
+#ifdef XSK_UMEM_RETURNS_XDP_DESC
 		cmd_type |= desc.len | IXGBE_TXD_CMD;
 		tx_desc->read.cmd_type_len = cpu_to_le32(cmd_type);
 		tx_desc->read.olinfo_status =
 			cpu_to_le32(desc.len << IXGBE_ADVTXD_PAYLEN_SHIFT);
+#else
+		cmd_type |= len | IXGBE_TXD_CMD;
+		tx_desc->read.cmd_type_len = cpu_to_le32(cmd_type);
+		tx_desc->read.olinfo_status =
+			cpu_to_le32(len << IXGBE_ADVTXD_PAYLEN_SHIFT);
+#endif
 
 		xdp_ring->next_to_use++;
 		if (xdp_ring->next_to_use == xdp_ring->count)
@@ -419,7 +699,7 @@ static bool ixgbe_xmit_zc(struct ixgbe_ring *xdp_ring, unsigned int budget)
 
 	if (tx_desc) {
 		ixgbe_xdp_ring_update_tail(xdp_ring);
-		xsk_tx_release(pool);
+		xsk_umem_consume_tx_done(xdp_ring->xsk_umem);
 	}
 
 	return !!budget && work_done;
@@ -438,17 +718,19 @@ static void ixgbe_clean_xdp_tx_buffer(struct ixgbe_ring *tx_ring,
 bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector,
 			    struct ixgbe_ring *tx_ring, int napi_budget)
 {
-	u16 ntc = tx_ring->next_to_clean, ntu = tx_ring->next_to_use;
 	unsigned int total_packets = 0, total_bytes = 0;
-	struct xsk_buff_pool *pool = tx_ring->xsk_pool;
+	u32 i = tx_ring->next_to_clean, xsk_frames = 0;
+	unsigned int budget = q_vector->tx.work_limit;
+	struct xdp_umem *umem = tx_ring->xsk_umem;
 	union ixgbe_adv_tx_desc *tx_desc;
 	struct ixgbe_tx_buffer *tx_bi;
-	u32 xsk_frames = 0;
+	bool xmit_done;
 
-	tx_bi = &tx_ring->tx_buffer_info[ntc];
-	tx_desc = IXGBE_TX_DESC(tx_ring, ntc);
+	tx_bi = &tx_ring->tx_buffer_info[i];
+	tx_desc = IXGBE_TX_DESC(tx_ring, i);
+	i -= tx_ring->count;
 
-	while (ntc != ntu) {
+	do {
 		if (!(tx_desc->wb.status & cpu_to_le32(IXGBE_TXD_STAT_DD)))
 			break;
 
@@ -461,21 +743,26 @@ bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector,
 			xsk_frames++;
 
 		tx_bi->xdpf = NULL;
+		total_bytes += tx_bi->bytecount;
 
 		tx_bi++;
 		tx_desc++;
-		ntc++;
-		if (unlikely(ntc == tx_ring->count)) {
-			ntc = 0;
+		i++;
+		if (unlikely(!i)) {
+			i -= tx_ring->count;
 			tx_bi = tx_ring->tx_buffer_info;
 			tx_desc = IXGBE_TX_DESC(tx_ring, 0);
 		}
 
 		/* issue prefetch for next Tx descriptor */
 		prefetch(tx_desc);
-	}
 
-	tx_ring->next_to_clean = ntc;
+		/* update budget accounting */
+		budget--;
+	} while (likely(budget));
+
+	i += tx_ring->count;
+	tx_ring->next_to_clean = i;
 
 	u64_stats_update_begin(&tx_ring->syncp);
 	tx_ring->stats.bytes += total_bytes;
@@ -485,15 +772,17 @@ bool ixgbe_clean_xdp_tx_irq(struct ixgbe_q_vector *q_vector,
 	q_vector->tx.total_packets += total_packets;
 
 	if (xsk_frames)
-		xsk_tx_completed(pool, xsk_frames);
+		xsk_umem_complete_tx(umem, xsk_frames);
 
-	if (xsk_uses_need_wakeup(pool))
-		xsk_set_tx_need_wakeup(pool);
-
-	return ixgbe_xmit_zc(tx_ring, q_vector->tx.work_limit);
+	xmit_done = ixgbe_xmit_zc(tx_ring, q_vector->tx.work_limit);
+	return budget > 0 && xmit_done;
 }
 
-int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags)
+#ifdef HAVE_NDO_XSK_WAKEUP
+int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 __maybe_unused flags)
+#else
+int ixgbe_xsk_async_xmit(struct net_device *dev, u32 qid)
+#endif
 {
 	struct ixgbe_adapter *adapter = netdev_priv(dev);
 	struct ixgbe_ring *ring;
@@ -507,14 +796,10 @@ int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags)
 	if (qid >= adapter->num_xdp_queues)
 		return -ENXIO;
 
-	ring = adapter->xdp_ring[qid];
-
-	if (test_bit(__IXGBE_TX_DISABLED, &ring->state))
-		return -ENETDOWN;
-
-	if (!ring->xsk_pool)
+	if (!adapter->xsk_umems || !adapter->xsk_umems[qid])
 		return -ENXIO;
 
+	ring = adapter->xdp_ring[qid];
 	if (!napi_if_scheduled_mark_missed(&ring->q_vector->napi)) {
 		u64 eics = BIT_ULL(ring->q_vector->v_idx);
 
@@ -527,7 +812,7 @@ int ixgbe_xsk_wakeup(struct net_device *dev, u32 qid, u32 flags)
 void ixgbe_xsk_clean_tx_ring(struct ixgbe_ring *tx_ring)
 {
 	u16 ntc = tx_ring->next_to_clean, ntu = tx_ring->next_to_use;
-	struct xsk_buff_pool *pool = tx_ring->xsk_pool;
+	struct xdp_umem *umem = tx_ring->xsk_umem;
 	struct ixgbe_tx_buffer *tx_bi;
 	u32 xsk_frames = 0;
 
@@ -547,5 +832,6 @@ void ixgbe_xsk_clean_tx_ring(struct ixgbe_ring *tx_ring)
 	}
 
 	if (xsk_frames)
-		xsk_tx_completed(pool, xsk_frames);
+		xsk_umem_complete_tx(umem, xsk_frames);
 }
+#endif /* HAVE_AF_XDP_ZC_SUPPORT */
diff --git a/drivers/net/ethernet/intel/ixgbe/kcompat.c b/drivers/net/ethernet/intel/ixgbe/kcompat.c
new file mode 100644
index 000000000000..e1b604236cbc
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/kcompat.c
@@ -0,0 +1,2964 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#include "ixgbe.h"
+#include "kcompat.h"
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,8) ) || defined __VMKLNX__
+/* From lib/vsprintf.c */
+#include <asm/div64.h>
+
+static int skip_atoi(const char **s)
+{
+	int i=0;
+
+	while (isdigit(**s))
+		i = i*10 + *((*s)++) - '0';
+	return i;
+}
+
+#define _kc_ZEROPAD	1		/* pad with zero */
+#define _kc_SIGN	2		/* unsigned/signed long */
+#define _kc_PLUS	4		/* show plus */
+#define _kc_SPACE	8		/* space if plus */
+#define _kc_LEFT	16		/* left justified */
+#define _kc_SPECIAL	32		/* 0x */
+#define _kc_LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */
+
+static char * number(char * buf, char * end, long long num, int base, int size, int precision, int type)
+{
+	char c,sign,tmp[66];
+	const char *digits;
+	const char small_digits[] = "0123456789abcdefghijklmnopqrstuvwxyz";
+	const char large_digits[] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+	int i;
+
+	digits = (type & _kc_LARGE) ? large_digits : small_digits;
+	if (type & _kc_LEFT)
+		type &= ~_kc_ZEROPAD;
+	if (base < 2 || base > 36)
+		return 0;
+	c = (type & _kc_ZEROPAD) ? '0' : ' ';
+	sign = 0;
+	if (type & _kc_SIGN) {
+		if (num < 0) {
+			sign = '-';
+			num = -num;
+			size--;
+		} else if (type & _kc_PLUS) {
+			sign = '+';
+			size--;
+		} else if (type & _kc_SPACE) {
+			sign = ' ';
+			size--;
+		}
+	}
+	if (type & _kc_SPECIAL) {
+		if (base == 16)
+			size -= 2;
+		else if (base == 8)
+			size--;
+	}
+	i = 0;
+	if (num == 0)
+		tmp[i++]='0';
+	else while (num != 0)
+		tmp[i++] = digits[do_div(num,base)];
+	if (i > precision)
+		precision = i;
+	size -= precision;
+	if (!(type&(_kc_ZEROPAD+_kc_LEFT))) {
+		while(size-->0) {
+			if (buf <= end)
+				*buf = ' ';
+			++buf;
+		}
+	}
+	if (sign) {
+		if (buf <= end)
+			*buf = sign;
+		++buf;
+	}
+	if (type & _kc_SPECIAL) {
+		if (base==8) {
+			if (buf <= end)
+				*buf = '0';
+			++buf;
+		} else if (base==16) {
+			if (buf <= end)
+				*buf = '0';
+			++buf;
+			if (buf <= end)
+				*buf = digits[33];
+			++buf;
+		}
+	}
+	if (!(type & _kc_LEFT)) {
+		while (size-- > 0) {
+			if (buf <= end)
+				*buf = c;
+			++buf;
+		}
+	}
+	while (i < precision--) {
+		if (buf <= end)
+			*buf = '0';
+		++buf;
+	}
+	while (i-- > 0) {
+		if (buf <= end)
+			*buf = tmp[i];
+		++buf;
+	}
+	while (size-- > 0) {
+		if (buf <= end)
+			*buf = ' ';
+		++buf;
+	}
+	return buf;
+}
+
+int _kc_vsnprintf(char *buf, size_t size, const char *fmt, va_list args)
+{
+	int len;
+	unsigned long long num;
+	int i, base;
+	char *str, *end, c;
+	const char *s;
+
+	int flags;		/* flags to number() */
+
+	int field_width;	/* width of output field */
+	int precision;		/* min. # of digits for integers; max
+				   number of chars for from string */
+	int qualifier;		/* 'h', 'l', or 'L' for integer fields */
+				/* 'z' support added 23/7/1999 S.H.    */
+				/* 'z' changed to 'Z' --davidm 1/25/99 */
+
+	str = buf;
+	end = buf + size - 1;
+
+	if (end < buf - 1) {
+		end = ((void *) -1);
+		size = end - buf + 1;
+	}
+
+	for (; *fmt ; ++fmt) {
+		if (*fmt != '%') {
+			if (str <= end)
+				*str = *fmt;
+			++str;
+			continue;
+		}
+
+		/* process flags */
+		flags = 0;
+		repeat:
+			++fmt;		/* this also skips first '%' */
+			switch (*fmt) {
+				case '-': flags |= _kc_LEFT; goto repeat;
+				case '+': flags |= _kc_PLUS; goto repeat;
+				case ' ': flags |= _kc_SPACE; goto repeat;
+				case '#': flags |= _kc_SPECIAL; goto repeat;
+				case '0': flags |= _kc_ZEROPAD; goto repeat;
+			}
+
+		/* get field width */
+		field_width = -1;
+		if (isdigit(*fmt))
+			field_width = skip_atoi(&fmt);
+		else if (*fmt == '*') {
+			++fmt;
+			/* it's the next argument */
+			field_width = va_arg(args, int);
+			if (field_width < 0) {
+				field_width = -field_width;
+				flags |= _kc_LEFT;
+			}
+		}
+
+		/* get the precision */
+		precision = -1;
+		if (*fmt == '.') {
+			++fmt;
+			if (isdigit(*fmt))
+				precision = skip_atoi(&fmt);
+			else if (*fmt == '*') {
+				++fmt;
+				/* it's the next argument */
+				precision = va_arg(args, int);
+			}
+			if (precision < 0)
+				precision = 0;
+		}
+
+		/* get the conversion qualifier */
+		qualifier = -1;
+		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt =='Z') {
+			qualifier = *fmt;
+			++fmt;
+		}
+
+		/* default base */
+		base = 10;
+
+		switch (*fmt) {
+			case 'c':
+				if (!(flags & _kc_LEFT)) {
+					while (--field_width > 0) {
+						if (str <= end)
+							*str = ' ';
+						++str;
+					}
+				}
+				c = (unsigned char) va_arg(args, int);
+				if (str <= end)
+					*str = c;
+				++str;
+				while (--field_width > 0) {
+					if (str <= end)
+						*str = ' ';
+					++str;
+				}
+				continue;
+
+			case 's':
+				s = va_arg(args, char *);
+				if (!s)
+					s = "<NULL>";
+
+				len = strnlen(s, precision);
+
+				if (!(flags & _kc_LEFT)) {
+					while (len < field_width--) {
+						if (str <= end)
+							*str = ' ';
+						++str;
+					}
+				}
+				for (i = 0; i < len; ++i) {
+					if (str <= end)
+						*str = *s;
+					++str; ++s;
+				}
+				while (len < field_width--) {
+					if (str <= end)
+						*str = ' ';
+					++str;
+				}
+				continue;
+
+			case 'p':
+				if ('M' == *(fmt+1)) {
+					str = get_mac(str, end, va_arg(args, unsigned char *));
+					fmt++;
+				} else	{
+					if (field_width == -1) {
+						field_width = 2*sizeof(void *);
+						flags |= _kc_ZEROPAD;
+					}
+					str = number(str, end,
+							(unsigned long) va_arg(args, void *),
+							16, field_width, precision, flags);
+				}
+				continue;
+
+			case 'n':
+				/* FIXME:
+				* What does C99 say about the overflow case here? */
+				if (qualifier == 'l') {
+					long * ip = va_arg(args, long *);
+					*ip = (str - buf);
+				} else if (qualifier == 'Z') {
+					size_t * ip = va_arg(args, size_t *);
+					*ip = (str - buf);
+				} else {
+					int * ip = va_arg(args, int *);
+					*ip = (str - buf);
+				}
+				continue;
+
+			case '%':
+				if (str <= end)
+					*str = '%';
+				++str;
+				continue;
+
+				/* integer number formats - set up the flags and "break" */
+			case 'o':
+				base = 8;
+				break;
+
+			case 'X':
+				flags |= _kc_LARGE;
+			case 'x':
+				base = 16;
+				break;
+
+			case 'd':
+			case 'i':
+				flags |= _kc_SIGN;
+			case 'u':
+				break;
+
+			default:
+				if (str <= end)
+					*str = '%';
+				++str;
+				if (*fmt) {
+					if (str <= end)
+						*str = *fmt;
+					++str;
+				} else {
+					--fmt;
+				}
+				continue;
+		}
+		if (qualifier == 'L')
+			num = va_arg(args, long long);
+		else if (qualifier == 'l') {
+			num = va_arg(args, unsigned long);
+			if (flags & _kc_SIGN)
+				num = (signed long) num;
+		} else if (qualifier == 'Z') {
+			num = va_arg(args, size_t);
+		} else if (qualifier == 'h') {
+			num = (unsigned short) va_arg(args, int);
+			if (flags & _kc_SIGN)
+				num = (signed short) num;
+		} else {
+			num = va_arg(args, unsigned int);
+			if (flags & _kc_SIGN)
+				num = (signed int) num;
+		}
+		str = number(str, end, num, base,
+				field_width, precision, flags);
+	}
+	if (str <= end)
+		*str = '\0';
+	else if (size > 0)
+		/* don't write out a null byte if the buf size is zero */
+		*end = '\0';
+	/* the trailing null byte doesn't count towards the total
+	* ++str;
+	*/
+	return str-buf;
+}
+
+int _kc_snprintf(char * buf, size_t size, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = _kc_vsnprintf(buf,size,fmt,args);
+	va_end(args);
+	return i;
+}
+#endif /* < 2.4.8 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#if defined(CONFIG_HIGHMEM)
+
+#ifndef PCI_DRAM_OFFSET
+#define PCI_DRAM_OFFSET 0
+#endif
+
+u64
+_kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset,
+                 size_t size, int direction)
+{
+	return (((u64) (page - mem_map) << PAGE_SHIFT) + offset +
+		PCI_DRAM_OFFSET);
+}
+
+#else /* CONFIG_HIGHMEM */
+
+u64
+_kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset,
+                 size_t size, int direction)
+{
+	return pci_map_single(dev, (void *)page_address(page) + offset, size,
+			      direction);
+}
+
+#endif /* CONFIG_HIGHMEM */
+
+void
+_kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size,
+                   int direction)
+{
+	return pci_unmap_single(dev, dma_addr, size, direction);
+}
+
+#endif /* 2.4.13 => 2.4.3 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+int
+_kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask)
+{
+	if (!pci_dma_supported(dev, mask))
+		return -EIO;
+	dev->dma_mask = mask;
+	return 0;
+}
+
+int
+_kc_pci_request_regions(struct pci_dev *dev, char *res_name)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO) {
+			if (!request_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		} else if (pci_resource_flags(dev, i) & IORESOURCE_MEM) {
+			if (!request_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i), res_name)) {
+				pci_release_regions(dev);
+				return -EBUSY;
+			}
+		}
+	}
+	return 0;
+}
+
+void
+_kc_pci_release_regions(struct pci_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		if (pci_resource_len(dev, i) == 0)
+			continue;
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO)
+			release_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+
+		else if (pci_resource_flags(dev, i) & IORESOURCE_MEM)
+			release_mem_region(pci_resource_start(dev, i), pci_resource_len(dev, i));
+	}
+}
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+struct net_device *
+_kc_alloc_etherdev(int sizeof_priv)
+{
+	struct net_device *dev;
+	int alloc_size;
+
+	alloc_size = sizeof(*dev) + sizeof_priv + IFNAMSIZ + 31;
+	dev = kzalloc(alloc_size, GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	if (sizeof_priv)
+		dev->priv = (void *) (((unsigned long)(dev + 1) + 31) & ~31);
+	dev->name[0] = '\0';
+	ether_setup(dev);
+
+	return dev;
+}
+
+int
+_kc_is_valid_ether_addr(u8 *addr)
+{
+	const char zaddr[6] = { 0, };
+
+	return !(addr[0] & 1) && memcmp(addr, zaddr, 6);
+}
+
+#endif /* 2.4.3 => 2.4.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+int
+_kc_pci_set_power_state(struct pci_dev *dev, int state)
+{
+	return 0;
+}
+
+int
+_kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable)
+{
+	return 0;
+}
+
+#endif /* 2.4.6 => 2.4.3 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+void _kc_skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page,
+                            int off, int size)
+{
+	skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
+	frag->page = page;
+	frag->page_offset = off;
+	frag->size = size;
+	skb_shinfo(skb)->nr_frags = i + 1;
+}
+
+/*
+ * Original Copyright:
+ * find_next_bit.c: fallback find next bit implementation
+ *
+ * Copyright (C) 2004 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ */
+
+/**
+ * find_next_bit - find the next set bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The maximum size to search
+ */
+unsigned long find_next_bit(const unsigned long *addr, unsigned long size,
+                            unsigned long offset)
+{
+	const unsigned long *p = addr + BITOP_WORD(offset);
+	unsigned long result = offset & ~(BITS_PER_LONG-1);
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset %= BITS_PER_LONG;
+	if (offset) {
+		tmp = *(p++);
+		tmp &= (~0UL << offset);
+		if (size < BITS_PER_LONG)
+			goto found_first;
+		if (tmp)
+			goto found_middle;
+		size -= BITS_PER_LONG;
+		result += BITS_PER_LONG;
+	}
+	while (size & ~(BITS_PER_LONG-1)) {
+		if ((tmp = *(p++)))
+			goto found_middle;
+		result += BITS_PER_LONG;
+		size -= BITS_PER_LONG;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp &= (~0UL >> (BITS_PER_LONG - size));
+	if (tmp == 0UL)		/* Are any bits set? */
+		return result + size;	/* Nope. */
+found_middle:
+	return result + ffs(tmp);
+}
+
+size_t _kc_strlcpy(char *dest, const char *src, size_t size)
+{
+	size_t ret = strlen(src);
+
+	if (size) {
+		size_t len = (ret >= size) ? size - 1 : ret;
+		memcpy(dest, src, len);
+		dest[len] = '\0';
+	}
+	return ret;
+}
+
+#ifndef do_div
+#if BITS_PER_LONG == 32
+uint32_t __attribute__((weak)) _kc__div64_32(uint64_t *n, uint32_t base)
+{
+	uint64_t rem = *n;
+	uint64_t b = base;
+	uint64_t res, d = 1;
+	uint32_t high = rem >> 32;
+
+	/* Reduce the thing a bit first */
+	res = 0;
+	if (high >= base) {
+		high /= base;
+		res = (uint64_t) high << 32;
+		rem -= (uint64_t) (high*base) << 32;
+	}
+
+	while ((int64_t)b > 0 && b < rem) {
+		b = b+b;
+		d = d+d;
+	}
+
+	do {
+		if (rem >= b) {
+			rem -= b;
+			res += d;
+		}
+		b >>= 1;
+		d >>= 1;
+	} while (d);
+
+	*n = res;
+	return rem;
+}
+#endif /* BITS_PER_LONG == 32 */
+#endif /* do_div */
+#endif /* 2.6.0 => 2.4.6 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) )
+int _kc_scnprintf(char * buf, size_t size, const char *fmt, ...)
+{
+	va_list args;
+	int i;
+
+	va_start(args, fmt);
+	i = vsnprintf(buf, size, fmt, args);
+	va_end(args);
+	return (i >= size) ? (size - 1) : i;
+}
+#endif /* < 2.6.4 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) )
+DECLARE_BITMAP(_kcompat_node_online_map, MAX_NUMNODES) = {1};
+#endif /* < 2.6.10 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) )
+char *_kc_kstrdup(const char *s, unsigned int gfp)
+{
+	size_t len;
+	char *buf;
+
+	if (!s)
+		return NULL;
+
+	len = strlen(s) + 1;
+	buf = kmalloc(len, gfp);
+	if (buf)
+		memcpy(buf, s, len);
+	return buf;
+}
+#endif /* < 2.6.13 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) )
+void *_kc_kzalloc(size_t size, int flags)
+{
+	void *ret = kmalloc(size, flags);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+#endif /* <= 2.6.13 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) )
+int _kc_skb_pad(struct sk_buff *skb, int pad)
+{
+	int ntail;
+
+        /* If the skbuff is non linear tailroom is always zero.. */
+        if(!skb_cloned(skb) && skb_tailroom(skb) >= pad) {
+		memset(skb->data+skb->len, 0, pad);
+		return 0;
+        }
+
+	ntail = skb->data_len + pad - (skb->end - skb->tail);
+	if (likely(skb_cloned(skb) || ntail > 0)) {
+		if (pskb_expand_head(skb, 0, ntail, GFP_ATOMIC))
+			goto free_skb;
+	}
+
+#ifdef MAX_SKB_FRAGS
+	if (skb_is_nonlinear(skb) &&
+	    !__pskb_pull_tail(skb, skb->data_len))
+		goto free_skb;
+
+#endif
+	memset(skb->data + skb->len, 0, pad);
+        return 0;
+
+free_skb:
+	kfree_skb(skb);
+	return -ENOMEM;
+}
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,4)))
+int _kc_pci_save_state(struct pci_dev *pdev)
+{
+	struct adapter_struct *adapter = pci_get_drvdata(pdev);
+	int size = PCI_CONFIG_SPACE_LEN, i;
+	u16 pcie_cap_offset, pcie_link_status;
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) )
+	/* no ->dev for 2.4 kernels */
+	WARN_ON(pdev->dev.driver_data == NULL);
+#endif
+	pcie_cap_offset = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	if (pcie_cap_offset) {
+		if (!pci_read_config_word(pdev,
+		                          pcie_cap_offset + PCIE_LINK_STATUS,
+		                          &pcie_link_status))
+		size = PCIE_CONFIG_SPACE_LEN;
+	}
+	pci_config_space_ich8lan();
+#ifdef HAVE_PCI_ERS
+	if (adapter->config_space == NULL)
+#else
+	WARN_ON(adapter->config_space != NULL);
+#endif
+		adapter->config_space = kmalloc(size, GFP_KERNEL);
+	if (!adapter->config_space) {
+		printk(KERN_ERR "Out of memory in pci_save_state\n");
+		return -ENOMEM;
+	}
+	for (i = 0; i < (size / 4); i++)
+		pci_read_config_dword(pdev, i * 4, &adapter->config_space[i]);
+	return 0;
+}
+
+void _kc_pci_restore_state(struct pci_dev *pdev)
+{
+	struct adapter_struct *adapter = pci_get_drvdata(pdev);
+	int size = PCI_CONFIG_SPACE_LEN, i;
+	u16 pcie_cap_offset;
+	u16 pcie_link_status;
+
+	if (adapter->config_space != NULL) {
+		pcie_cap_offset = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+		if (pcie_cap_offset &&
+		    !pci_read_config_word(pdev,
+		                          pcie_cap_offset + PCIE_LINK_STATUS,
+		                          &pcie_link_status))
+			size = PCIE_CONFIG_SPACE_LEN;
+
+		pci_config_space_ich8lan();
+		for (i = 0; i < (size / 4); i++)
+		pci_write_config_dword(pdev, i * 4, adapter->config_space[i]);
+#ifndef HAVE_PCI_ERS
+		kfree(adapter->config_space);
+		adapter->config_space = NULL;
+#endif
+	}
+}
+#endif /* !(RHEL_RELEASE_CODE >= RHEL 5.4) */
+
+#ifdef HAVE_PCI_ERS
+void _kc_free_netdev(struct net_device *netdev)
+{
+	struct adapter_struct *adapter = netdev_priv(netdev);
+
+	kfree(adapter->config_space);
+#ifdef CONFIG_SYSFS
+	if (netdev->reg_state == NETREG_UNINITIALIZED) {
+		kfree((char *)netdev - netdev->padded);
+	} else {
+		BUG_ON(netdev->reg_state != NETREG_UNREGISTERED);
+		netdev->reg_state = NETREG_RELEASED;
+		class_device_put(&netdev->class_dev);
+	}
+#else
+	kfree((char *)netdev - netdev->padded);
+#endif
+}
+#endif
+
+void *_kc_kmemdup(const void *src, size_t len, unsigned gfp)
+{
+	void *p;
+
+	p = kzalloc(len, gfp);
+	if (p)
+		memcpy(p, src, len);
+	return p;
+}
+#endif /* <= 2.6.19 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) )
+struct pci_dev *_kc_netdev_to_pdev(struct net_device *netdev)
+{
+	return ((struct adapter_struct *)netdev_priv(netdev))->pdev;
+}
+#endif /* < 2.6.21 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) )
+/* hexdump code taken from lib/hexdump.c */
+static void _kc_hex_dump_to_buffer(const void *buf, size_t len, int rowsize,
+			int groupsize, unsigned char *linebuf,
+			size_t linebuflen, bool ascii)
+{
+	const u8 *ptr = buf;
+	u8 ch;
+	int j, lx = 0;
+	int ascii_column;
+
+	if (rowsize != 16 && rowsize != 32)
+		rowsize = 16;
+
+	if (!len)
+		goto nil;
+	if (len > rowsize)		/* limit to one line at a time */
+		len = rowsize;
+	if ((len % groupsize) != 0)	/* no mixed size output */
+		groupsize = 1;
+
+	switch (groupsize) {
+	case 8: {
+		const u64 *ptr8 = buf;
+		int ngroups = len / groupsize;
+
+		for (j = 0; j < ngroups; j++)
+			lx += scnprintf((char *)(linebuf + lx), linebuflen - lx,
+				"%s%16.16llx", j ? " " : "",
+				(unsigned long long)*(ptr8 + j));
+		ascii_column = 17 * ngroups + 2;
+		break;
+	}
+
+	case 4: {
+		const u32 *ptr4 = buf;
+		int ngroups = len / groupsize;
+
+		for (j = 0; j < ngroups; j++)
+			lx += scnprintf((char *)(linebuf + lx), linebuflen - lx,
+				"%s%8.8x", j ? " " : "", *(ptr4 + j));
+		ascii_column = 9 * ngroups + 2;
+		break;
+	}
+
+	case 2: {
+		const u16 *ptr2 = buf;
+		int ngroups = len / groupsize;
+
+		for (j = 0; j < ngroups; j++)
+			lx += scnprintf((char *)(linebuf + lx), linebuflen - lx,
+				"%s%4.4x", j ? " " : "", *(ptr2 + j));
+		ascii_column = 5 * ngroups + 2;
+		break;
+	}
+
+	default:
+		for (j = 0; (j < len) && (lx + 3) <= linebuflen; j++) {
+			ch = ptr[j];
+			linebuf[lx++] = hex_asc(ch >> 4);
+			linebuf[lx++] = hex_asc(ch & 0x0f);
+			linebuf[lx++] = ' ';
+		}
+		if (j)
+			lx--;
+
+		ascii_column = 3 * rowsize + 2;
+		break;
+	}
+	if (!ascii)
+		goto nil;
+
+	while (lx < (linebuflen - 1) && lx < (ascii_column - 1))
+		linebuf[lx++] = ' ';
+	for (j = 0; (j < len) && (lx + 2) < linebuflen; j++)
+		linebuf[lx++] = (isascii(ptr[j]) && isprint(ptr[j])) ? ptr[j]
+				: '.';
+nil:
+	linebuf[lx++] = '\0';
+}
+
+void _kc_print_hex_dump(const char *level,
+			const char *prefix_str, int prefix_type,
+			int rowsize, int groupsize,
+			const void *buf, size_t len, bool ascii)
+{
+	const u8 *ptr = buf;
+	int i, linelen, remaining = len;
+	unsigned char linebuf[200];
+
+	if (rowsize != 16 && rowsize != 32)
+		rowsize = 16;
+
+	for (i = 0; i < len; i += rowsize) {
+		linelen = min(remaining, rowsize);
+		remaining -= rowsize;
+		_kc_hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
+				linebuf, sizeof(linebuf), ascii);
+
+		switch (prefix_type) {
+		case DUMP_PREFIX_ADDRESS:
+			printk("%s%s%*p: %s\n", level, prefix_str,
+				(int)(2 * sizeof(void *)), ptr + i, linebuf);
+			break;
+		case DUMP_PREFIX_OFFSET:
+			printk("%s%s%.8x: %s\n", level, prefix_str, i, linebuf);
+			break;
+		default:
+			printk("%s%s%s\n", level, prefix_str, linebuf);
+			break;
+		}
+	}
+}
+
+#endif /* < 2.6.22 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) )
+int ixgbe_dcb_netlink_register(void)
+{
+	return 0;
+}
+
+int ixgbe_dcb_netlink_unregister(void)
+{
+	return 0;
+}
+
+int ixgbe_copy_dcb_cfg(struct ixgbe_adapter __always_unused *adapter, int __always_unused tc_max)
+{
+	return 0;
+}
+#endif /* < 2.6.23 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) )
+#ifdef NAPI
+struct net_device *napi_to_poll_dev(const struct napi_struct *napi)
+{
+	struct adapter_q_vector *q_vector = container_of(napi,
+	                                                struct adapter_q_vector,
+	                                                napi);
+	return &q_vector->poll_dev;
+}
+
+int __kc_adapter_clean(struct net_device *netdev, int *budget)
+{
+	int work_done;
+	int work_to_do = min(*budget, netdev->quota);
+	/* kcompat.h netif_napi_add puts napi struct in "fake netdev->priv" */
+	struct napi_struct *napi = netdev->priv;
+	work_done = napi->poll(napi, work_to_do);
+	*budget -= work_done;
+	netdev->quota -= work_done;
+	return (work_done >= work_to_do) ? 1 : 0;
+}
+#endif /* NAPI */
+#endif /* <= 2.6.24 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26) )
+void _kc_pci_disable_link_state(struct pci_dev *pdev, int state)
+{
+	struct pci_dev *parent = pdev->bus->self;
+	u16 link_state;
+	int pos;
+
+	if (!parent)
+		return;
+
+	pos = pci_find_capability(parent, PCI_CAP_ID_EXP);
+	if (pos) {
+		pci_read_config_word(parent, pos + PCI_EXP_LNKCTL, &link_state);
+		link_state &= ~state;
+		pci_write_config_word(parent, pos + PCI_EXP_LNKCTL, link_state);
+	}
+}
+#endif /* < 2.6.26 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) )
+#ifdef HAVE_TX_MQ
+void _kc_netif_tx_stop_all_queues(struct net_device *netdev)
+{
+	struct adapter_struct *adapter = netdev_priv(netdev);
+	int i;
+
+	netif_stop_queue(netdev);
+	if (netif_is_multiqueue(netdev))
+		for (i = 0; i < adapter->num_tx_queues; i++)
+			netif_stop_subqueue(netdev, i);
+}
+void _kc_netif_tx_wake_all_queues(struct net_device *netdev)
+{
+	struct adapter_struct *adapter = netdev_priv(netdev);
+	int i;
+
+	netif_wake_queue(netdev);
+	if (netif_is_multiqueue(netdev))
+		for (i = 0; i < adapter->num_tx_queues; i++)
+			netif_wake_subqueue(netdev, i);
+}
+void _kc_netif_tx_start_all_queues(struct net_device *netdev)
+{
+	struct adapter_struct *adapter = netdev_priv(netdev);
+	int i;
+
+	netif_start_queue(netdev);
+	if (netif_is_multiqueue(netdev))
+		for (i = 0; i < adapter->num_tx_queues; i++)
+			netif_start_subqueue(netdev, i);
+}
+#endif /* HAVE_TX_MQ */
+
+void __kc_warn_slowpath(const char *file, int line, const char *fmt, ...)
+{
+	va_list args;
+
+	printk(KERN_WARNING "------------[ cut here ]------------\n");
+	printk(KERN_WARNING "WARNING: at %s:%d \n", file, line);
+	va_start(args, fmt);
+	vprintk(fmt, args);
+	va_end(args);
+
+	dump_stack();
+}
+#endif /* __VMKLNX__ */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) )
+
+int
+_kc_pci_prepare_to_sleep(struct pci_dev *dev)
+{
+	pci_power_t target_state;
+	int error;
+
+	target_state = pci_choose_state(dev, PMSG_SUSPEND);
+
+	pci_enable_wake(dev, target_state, true);
+
+	error = pci_set_power_state(dev, target_state);
+
+	if (error)
+		pci_enable_wake(dev, target_state, false);
+
+	return error;
+}
+
+int
+_kc_pci_wake_from_d3(struct pci_dev *dev, bool enable)
+{
+	int err;
+
+	err = pci_enable_wake(dev, PCI_D3cold, enable);
+	if (err)
+		goto out;
+
+	err = pci_enable_wake(dev, PCI_D3hot, enable);
+
+out:
+	return err;
+}
+#endif /* < 2.6.28 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) )
+static void __kc_pci_set_master(struct pci_dev *pdev, bool enable)
+{
+	u16 old_cmd, cmd;
+
+	pci_read_config_word(pdev, PCI_COMMAND, &old_cmd);
+	if (enable)
+		cmd = old_cmd | PCI_COMMAND_MASTER;
+	else
+		cmd = old_cmd & ~PCI_COMMAND_MASTER;
+	if (cmd != old_cmd) {
+		dev_dbg(pci_dev_to_dev(pdev), "%s bus mastering\n",
+			enable ? "enabling" : "disabling");
+		pci_write_config_word(pdev, PCI_COMMAND, cmd);
+	}
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7) )
+	pdev->is_busmaster = enable;
+#endif
+}
+
+void _kc_pci_clear_master(struct pci_dev *dev)
+{
+	__kc_pci_set_master(dev, false);
+}
+#endif /* < 2.6.29 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34) )
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,0))
+int _kc_pci_num_vf(struct pci_dev __maybe_unused *dev)
+{
+	int num_vf = 0;
+#ifdef CONFIG_PCI_IOV
+	struct pci_dev *vfdev;
+
+	/* loop through all ethernet devices starting at PF dev */
+	vfdev = pci_get_class(PCI_CLASS_NETWORK_ETHERNET << 8, NULL);
+	while (vfdev) {
+		if (vfdev->is_virtfn && vfdev->physfn == dev)
+			num_vf++;
+
+		vfdev = pci_get_class(PCI_CLASS_NETWORK_ETHERNET << 8, vfdev);
+	}
+
+#endif
+	return num_vf;
+}
+#endif /* RHEL_RELEASE_CODE */
+#endif /* < 2.6.34 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) )
+#ifdef HAVE_TX_MQ
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0)))
+#ifndef CONFIG_NETDEVICES_MULTIQUEUE
+int _kc_netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)
+{
+	unsigned int real_num = dev->real_num_tx_queues;
+	struct Qdisc *qdisc;
+	int i;
+
+	if (txq < 1 || txq > dev->num_tx_queues)
+		return -EINVAL;
+
+	else if (txq > real_num)
+		dev->real_num_tx_queues = txq;
+	else if (txq < real_num) {
+		dev->real_num_tx_queues = txq;
+		for (i = txq; i < dev->num_tx_queues; i++) {
+			qdisc = netdev_get_tx_queue(dev, i)->qdisc;
+			if (qdisc) {
+				spin_lock_bh(qdisc_lock(qdisc));
+				qdisc_reset(qdisc);
+				spin_unlock_bh(qdisc_lock(qdisc));
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /* CONFIG_NETDEVICES_MULTIQUEUE */
+#endif /* !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0)) */
+#endif /* HAVE_TX_MQ */
+
+ssize_t _kc_simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
+				   const void __user *from, size_t count)
+{
+        loff_t pos = *ppos;
+        size_t res;
+
+        if (pos < 0)
+                return -EINVAL;
+        if (pos >= available || !count)
+                return 0;
+        if (count > available - pos)
+                count = available - pos;
+        res = copy_from_user(to + pos, from, count);
+        if (res == count)
+                return -EFAULT;
+        count -= res;
+        *ppos = pos + count;
+        return count;
+}
+
+#endif /* < 2.6.35 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) )
+static const u32 _kc_flags_dup_features =
+	(ETH_FLAG_LRO | ETH_FLAG_NTUPLE | ETH_FLAG_RXHASH);
+
+u32 _kc_ethtool_op_get_flags(struct net_device *dev)
+{
+	return dev->features & _kc_flags_dup_features;
+}
+
+int _kc_ethtool_op_set_flags(struct net_device *dev, u32 data, u32 supported)
+{
+	if (data & ~supported)
+		return -EINVAL;
+
+	dev->features = ((dev->features & ~_kc_flags_dup_features) |
+			 (data & _kc_flags_dup_features));
+	return 0;
+}
+#endif /* < 2.6.36 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39) )
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,0)))
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+#include <net/ip.h>
+#include <linux/pkt_sched.h>
+
+u16 ___kc_skb_tx_hash(struct net_device *dev, const struct sk_buff *skb,
+		      u16 num_tx_queues)
+{
+	u32 hash;
+	u16 qoffset = 0;
+	u16 qcount = num_tx_queues;
+
+	if (skb_rx_queue_recorded(skb)) {
+		hash = skb_get_rx_queue(skb);
+		while (unlikely(hash >= num_tx_queues))
+			hash -= num_tx_queues;
+		return hash;
+	}
+
+	if (netdev_get_num_tc(dev)) {
+		struct adapter_struct *kc_adapter = netdev_priv(dev);
+
+		if (skb->priority == TC_PRIO_CONTROL) {
+			qoffset = kc_adapter->dcb_tc - 1;
+		} else {
+			qoffset = skb->vlan_tci;
+			qoffset &= IXGBE_TX_FLAGS_VLAN_PRIO_MASK;
+			qoffset >>= 13;
+		}
+
+		qcount = kc_adapter->ring_feature[RING_F_RSS].indices;
+		qoffset *= qcount;
+	}
+
+	if (skb->sk && skb->sk->sk_hash)
+		hash = skb->sk->sk_hash;
+	else
+#ifdef NETIF_F_RXHASH
+		hash = (__force u16) skb->protocol ^ skb->rxhash;
+#else
+		hash = skb->protocol;
+#endif
+
+	hash = jhash_1word(hash, _kc_hashrnd);
+
+	return (u16) (((u64) hash * qcount) >> 32) + qoffset;
+}
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+
+u8 _kc_netdev_get_num_tc(struct net_device *dev)
+{
+	struct adapter_struct *kc_adapter = netdev_priv(dev);
+	if (kc_adapter->flags & IXGBE_FLAG_DCB_ENABLED)
+		return kc_adapter->dcb_tc;
+	else
+		return 0;
+}
+
+int _kc_netdev_set_num_tc(struct net_device *dev, u8 num_tc)
+{
+	struct adapter_struct *kc_adapter = netdev_priv(dev);
+
+	if (num_tc > IXGBE_DCB_MAX_TRAFFIC_CLASS)
+		return -EINVAL;
+
+	kc_adapter->dcb_tc = num_tc;
+
+	return 0;
+}
+
+u8 _kc_netdev_get_prio_tc_map(struct net_device __maybe_unused *dev, u8 __maybe_unused up)
+{
+	struct adapter_struct *kc_adapter = netdev_priv(dev);
+
+	return ixgbe_dcb_get_tc_from_up(&kc_adapter->dcb_cfg, 0, up);
+}
+
+#endif /* !(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,0)) */
+#endif /* < 2.6.39 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) )
+void _kc_skb_add_rx_frag(struct sk_buff *skb, int i, struct page *page,
+			 int off, int size, unsigned int truesize)
+{
+	skb_fill_page_desc(skb, i, page, off, size);
+	skb->len += size;
+	skb->data_len += size;
+	skb->truesize += truesize;
+}
+
+#if !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0))
+int _kc_simple_open(struct inode *inode, struct file *file)
+{
+        if (inode->i_private)
+                file->private_data = inode->i_private;
+
+        return 0;
+}
+#endif /* SLE_VERSION < 11,3,0 */
+
+#endif /* < 3.4.0 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) )
+static inline int __kc_pcie_cap_version(struct pci_dev *dev)
+{
+	int pos;
+	u16 reg16;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return 0;
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &reg16);
+	return reg16 & PCI_EXP_FLAGS_VERS;
+}
+
+static inline bool __kc_pcie_cap_has_devctl(const struct pci_dev __always_unused *dev)
+{
+	return true;
+}
+
+static inline bool __kc_pcie_cap_has_lnkctl(struct pci_dev *dev)
+{
+	int type = pci_pcie_type(dev);
+
+	return __kc_pcie_cap_version(dev) > 1 ||
+	       type == PCI_EXP_TYPE_ROOT_PORT ||
+	       type == PCI_EXP_TYPE_ENDPOINT ||
+	       type == PCI_EXP_TYPE_LEG_END;
+}
+
+static inline bool __kc_pcie_cap_has_sltctl(struct pci_dev *dev)
+{
+	int type = pci_pcie_type(dev);
+	int pos;
+	u16 pcie_flags_reg;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (!pos)
+		return false;
+	pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &pcie_flags_reg);
+
+	return __kc_pcie_cap_version(dev) > 1 ||
+	       type == PCI_EXP_TYPE_ROOT_PORT ||
+	       (type == PCI_EXP_TYPE_DOWNSTREAM &&
+		pcie_flags_reg & PCI_EXP_FLAGS_SLOT);
+}
+
+static inline bool __kc_pcie_cap_has_rtctl(struct pci_dev *dev)
+{
+	int type = pci_pcie_type(dev);
+
+	return __kc_pcie_cap_version(dev) > 1 ||
+	       type == PCI_EXP_TYPE_ROOT_PORT ||
+	       type == PCI_EXP_TYPE_RC_EC;
+}
+
+static bool __kc_pcie_capability_reg_implemented(struct pci_dev *dev, int pos)
+{
+	if (!pci_is_pcie(dev))
+		return false;
+
+	switch (pos) {
+	case PCI_EXP_FLAGS_TYPE:
+		return true;
+	case PCI_EXP_DEVCAP:
+	case PCI_EXP_DEVCTL:
+	case PCI_EXP_DEVSTA:
+		return __kc_pcie_cap_has_devctl(dev);
+	case PCI_EXP_LNKCAP:
+	case PCI_EXP_LNKCTL:
+	case PCI_EXP_LNKSTA:
+		return __kc_pcie_cap_has_lnkctl(dev);
+	case PCI_EXP_SLTCAP:
+	case PCI_EXP_SLTCTL:
+	case PCI_EXP_SLTSTA:
+		return __kc_pcie_cap_has_sltctl(dev);
+	case PCI_EXP_RTCTL:
+	case PCI_EXP_RTCAP:
+	case PCI_EXP_RTSTA:
+		return __kc_pcie_cap_has_rtctl(dev);
+	case PCI_EXP_DEVCAP2:
+	case PCI_EXP_DEVCTL2:
+	case PCI_EXP_LNKCAP2:
+	case PCI_EXP_LNKCTL2:
+	case PCI_EXP_LNKSTA2:
+		return __kc_pcie_cap_version(dev) > 1;
+	default:
+		return false;
+	}
+}
+
+/*
+ * Note that these accessor functions are only for the "PCI Express
+ * Capability" (see PCIe spec r3.0, sec 7.8).  They do not apply to the
+ * other "PCI Express Extended Capabilities" (AER, VC, ACS, MFVC, etc.)
+ */
+int __kc_pcie_capability_read_word(struct pci_dev *dev, int pos, u16 *val)
+{
+	int ret;
+
+	*val = 0;
+	if (pos & 1)
+		return -EINVAL;
+
+	if (__kc_pcie_capability_reg_implemented(dev, pos)) {
+		ret = pci_read_config_word(dev, pci_pcie_cap(dev) + pos, val);
+		/*
+		 * Reset *val to 0 if pci_read_config_word() fails, it may
+		 * have been written as 0xFFFF if hardware error happens
+		 * during pci_read_config_word().
+		 */
+		if (ret)
+			*val = 0;
+		return ret;
+	}
+
+	/*
+	 * For Functions that do not implement the Slot Capabilities,
+	 * Slot Status, and Slot Control registers, these spaces must
+	 * be hardwired to 0b, with the exception of the Presence Detect
+	 * State bit in the Slot Status register of Downstream Ports,
+	 * which must be hardwired to 1b.  (PCIe Base Spec 3.0, sec 7.8)
+	 */
+	if (pci_is_pcie(dev) && pos == PCI_EXP_SLTSTA &&
+	    pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM) {
+		*val = PCI_EXP_SLTSTA_PDS;
+	}
+
+	return 0;
+}
+
+int __kc_pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val)
+{
+	int ret;
+
+	*val = 0;
+	if (pos & 3)
+		return -EINVAL;
+
+	if (__kc_pcie_capability_reg_implemented(dev, pos)) {
+		ret = pci_read_config_dword(dev, pci_pcie_cap(dev) + pos, val);
+		/*
+		 * Reset *val to 0 if pci_read_config_dword() fails, it may
+		 * have been written as 0xFFFFFFFF if hardware error happens
+		 * during pci_read_config_dword().
+		 */
+		if (ret)
+			*val = 0;
+		return ret;
+	}
+
+	if (pci_is_pcie(dev) && pos == PCI_EXP_SLTSTA &&
+	    pci_pcie_type(dev) == PCI_EXP_TYPE_DOWNSTREAM) {
+		*val = PCI_EXP_SLTSTA_PDS;
+	}
+
+	return 0;
+}
+
+int __kc_pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val)
+{
+	if (pos & 1)
+		return -EINVAL;
+
+	if (!__kc_pcie_capability_reg_implemented(dev, pos))
+		return 0;
+
+	return pci_write_config_word(dev, pci_pcie_cap(dev) + pos, val);
+}
+
+int __kc_pcie_capability_clear_and_set_word(struct pci_dev *dev, int pos,
+					    u16 clear, u16 set)
+{
+	int ret;
+	u16 val;
+
+	ret = __kc_pcie_capability_read_word(dev, pos, &val);
+	if (!ret) {
+		val &= ~clear;
+		val |= set;
+		ret = __kc_pcie_capability_write_word(dev, pos, val);
+	}
+
+	return ret;
+}
+
+int __kc_pcie_capability_clear_word(struct pci_dev *dev, int pos,
+					     u16 clear)
+{
+	return __kc_pcie_capability_clear_and_set_word(dev, pos, clear, 0);
+}
+#endif /* < 3.7.0 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0) )
+#ifdef CONFIG_XPS
+#if NR_CPUS < 64
+#define _KC_MAX_XPS_CPUS	NR_CPUS
+#else
+#define _KC_MAX_XPS_CPUS	64
+#endif
+
+/*
+ * netdev_queue sysfs structures and functions.
+ */
+struct _kc_netdev_queue_attribute {
+	struct attribute attr;
+	ssize_t (*show)(struct netdev_queue *queue,
+	    struct _kc_netdev_queue_attribute *attr, char *buf);
+	ssize_t (*store)(struct netdev_queue *queue,
+	    struct _kc_netdev_queue_attribute *attr, const char *buf, size_t len);
+};
+
+#define to_kc_netdev_queue_attr(_attr) container_of(_attr,		\
+    struct _kc_netdev_queue_attribute, attr)
+
+int __kc_netif_set_xps_queue(struct net_device *dev, const struct cpumask *mask,
+			     u16 index)
+{
+	struct netdev_queue *txq = netdev_get_tx_queue(dev, index);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) )
+	/* Redhat requires some odd extended netdev structures */
+	struct netdev_tx_queue_extended *txq_ext =
+					netdev_extended(dev)->_tx_ext + index;
+	struct kobj_type *ktype = txq_ext->kobj.ktype;
+#else
+	struct kobj_type *ktype = txq->kobj.ktype;
+#endif
+	struct _kc_netdev_queue_attribute *xps_attr;
+	struct attribute *attr = NULL;
+	int i, len, err;
+#define _KC_XPS_BUFLEN	(DIV_ROUND_UP(_KC_MAX_XPS_CPUS, 32) * 9)
+	char buf[_KC_XPS_BUFLEN];
+
+	if (!ktype)
+		return -ENOMEM;
+
+	/* attempt to locate the XPS attribute in the Tx queue */
+	for (i = 0; (attr = ktype->default_attrs[i]); i++) {
+		if (!strcmp("xps_cpus", attr->name))
+			break;
+	}
+
+	/* if we did not find it return an error */
+	if (!attr)
+		return -EINVAL;
+
+	/* copy the mask into a string */
+	len = bitmap_scnprintf(buf, _KC_XPS_BUFLEN,
+			       cpumask_bits(mask), _KC_MAX_XPS_CPUS);
+	if (!len)
+		return -ENOMEM;
+
+	xps_attr = to_kc_netdev_queue_attr(attr);
+
+	/* Store the XPS value using the SYSFS store call */
+	err = xps_attr->store(txq, xps_attr, buf, len);
+
+	/* we only had an error on err < 0 */
+	return (err < 0) ? err : 0;
+}
+#endif /* CONFIG_XPS */
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+static inline int kc_get_xps_queue(struct net_device *dev, struct sk_buff *skb)
+{
+#ifdef CONFIG_XPS
+	struct xps_dev_maps *dev_maps;
+	struct xps_map *map;
+	int queue_index = -1;
+
+	rcu_read_lock();
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) )
+	/* Redhat requires some odd extended netdev structures */
+	dev_maps = rcu_dereference(netdev_extended(dev)->xps_maps);
+#else
+	dev_maps = rcu_dereference(dev->xps_maps);
+#endif
+	if (dev_maps) {
+		map = rcu_dereference(
+		    dev_maps->cpu_map[raw_smp_processor_id()]);
+		if (map) {
+			if (map->len == 1)
+				queue_index = map->queues[0];
+			else {
+				u32 hash;
+				if (skb->sk && skb->sk->sk_hash)
+					hash = skb->sk->sk_hash;
+				else
+					hash = (__force u16) skb->protocol ^
+					    skb->rxhash;
+				hash = jhash_1word(hash, _kc_hashrnd);
+				queue_index = map->queues[
+				    ((u64)hash * map->len) >> 32];
+			}
+			if (unlikely(queue_index >= dev->real_num_tx_queues))
+				queue_index = -1;
+		}
+	}
+	rcu_read_unlock();
+
+	return queue_index;
+#else
+	struct adapter_struct *kc_adapter = netdev_priv(dev);
+	int queue_index = -1;
+
+	if (kc_adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE) {
+		queue_index = skb_rx_queue_recorded(skb) ?
+					   skb_get_rx_queue(skb) :
+					   smp_processor_id();
+		while (unlikely(queue_index >= dev->real_num_tx_queues))
+			queue_index -= dev->real_num_tx_queues;
+		return queue_index;
+	}
+
+	return -1;
+#endif
+}
+
+u16 __kc_netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)
+{
+	struct sock *sk = skb->sk;
+	int queue_index = sk_tx_queue_get(sk);
+	int new_index;
+
+	if (queue_index >= 0 && queue_index < dev->real_num_tx_queues) {
+#ifdef CONFIG_XPS
+		if (!skb->ooo_okay)
+#endif
+			return queue_index;
+	}
+
+	new_index = kc_get_xps_queue(dev, skb);
+	if (new_index < 0)
+		new_index = skb_tx_hash(dev, skb);
+
+	if (queue_index != new_index && sk) {
+		struct dst_entry *dst =
+			    rcu_dereference(sk->sk_dst_cache);
+
+		if (dst && skb_dst(skb) == dst)
+			sk_tx_queue_set(sk, new_index);
+
+	}
+
+	return new_index;
+}
+
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+#endif /* 3.9.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+#ifdef HAVE_FDB_OPS
+#ifdef USE_CONST_DEV_UC_CHAR
+int __kc_ndo_dflt_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
+			  struct net_device *dev, const unsigned char *addr,
+			  u16 flags)
+#else
+int __kc_ndo_dflt_fdb_add(struct ndmsg *ndm, struct net_device *dev,
+			  unsigned char *addr, u16 flags)
+#endif
+{
+	int err = -EINVAL;
+
+	/* If aging addresses are supported device will need to
+	 * implement its own handler for this.
+	 */
+	if (ndm->ndm_state && !(ndm->ndm_state & NUD_PERMANENT)) {
+		pr_info("%s: FDB only supports static addresses\n", dev->name);
+		return err;
+	}
+
+	if (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))
+		err = dev_uc_add_excl(dev, addr);
+	else if (is_multicast_ether_addr(addr))
+		err = dev_mc_add_excl(dev, addr);
+
+	/* Only return duplicate errors if NLM_F_EXCL is set */
+	if (err == -EEXIST && !(flags & NLM_F_EXCL))
+		err = 0;
+
+	return err;
+}
+
+#ifdef USE_CONST_DEV_UC_CHAR
+#ifdef HAVE_FDB_DEL_NLATTR
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],
+			  struct net_device *dev, const unsigned char *addr)
+#else
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct net_device *dev,
+			  const unsigned char *addr)
+#endif
+#else
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct net_device *dev,
+			  unsigned char *addr)
+#endif
+{
+	int err = -EINVAL;
+
+	/* If aging addresses are supported device will need to
+	 * implement its own handler for this.
+	 */
+	if (!(ndm->ndm_state & NUD_PERMANENT)) {
+		pr_info("%s: FDB only supports static addresses\n", dev->name);
+		return err;
+	}
+
+	if (is_unicast_ether_addr(addr) || is_link_local_ether_addr(addr))
+		err = dev_uc_del(dev, addr);
+	else if (is_multicast_ether_addr(addr))
+		err = dev_mc_del(dev, addr);
+
+	return err;
+}
+
+#endif /* HAVE_FDB_OPS */
+#ifdef CONFIG_PCI_IOV
+int __kc_pci_vfs_assigned(struct pci_dev __maybe_unused *dev)
+{
+	unsigned int vfs_assigned = 0;
+#ifdef HAVE_PCI_DEV_FLAGS_ASSIGNED
+	int pos;
+	struct pci_dev *vfdev;
+	unsigned short dev_id;
+
+	/* only search if we are a PF */
+	if (!dev->is_physfn)
+		return 0;
+
+	/* find SR-IOV capability */
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);
+	if (!pos)
+		return 0;
+
+	/*
+	 * determine the device ID for the VFs, the vendor ID will be the
+	 * same as the PF so there is no need to check for that one
+	 */
+	pci_read_config_word(dev, pos + PCI_SRIOV_VF_DID, &dev_id);
+
+	/* loop through all the VFs to see if we own any that are assigned */
+	vfdev = pci_get_device(dev->vendor, dev_id, NULL);
+	while (vfdev) {
+		/*
+		 * It is considered assigned if it is a virtual function with
+		 * our dev as the physical function and the assigned bit is set
+		 */
+		if (vfdev->is_virtfn && (vfdev->physfn == dev) &&
+		    (vfdev->dev_flags & PCI_DEV_FLAGS_ASSIGNED))
+			vfs_assigned++;
+
+		vfdev = pci_get_device(dev->vendor, dev_id, vfdev);
+	}
+
+#endif /* HAVE_PCI_DEV_FLAGS_ASSIGNED */
+	return vfs_assigned;
+}
+
+#endif /* CONFIG_PCI_IOV */
+#endif /* 3.10.0 */
+
+static const unsigned char __maybe_unused pcie_link_speed[] = {
+	PCI_SPEED_UNKNOWN,      /* 0 */
+	PCIE_SPEED_2_5GT,       /* 1 */
+	PCIE_SPEED_5_0GT,       /* 2 */
+	PCIE_SPEED_8_0GT,       /* 3 */
+	PCIE_SPEED_16_0GT,      /* 4 */
+	PCI_SPEED_UNKNOWN,      /* 5 */
+	PCI_SPEED_UNKNOWN,      /* 6 */
+	PCI_SPEED_UNKNOWN,      /* 7 */
+	PCI_SPEED_UNKNOWN,      /* 8 */
+	PCI_SPEED_UNKNOWN,      /* 9 */
+	PCI_SPEED_UNKNOWN,      /* A */
+	PCI_SPEED_UNKNOWN,      /* B */
+	PCI_SPEED_UNKNOWN,      /* C */
+	PCI_SPEED_UNKNOWN,      /* D */
+	PCI_SPEED_UNKNOWN,      /* E */
+	PCI_SPEED_UNKNOWN       /* F */
+};
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0) )
+int __kc_pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
+			       enum pcie_link_width *width)
+{
+	int ret;
+
+	*speed = PCI_SPEED_UNKNOWN;
+	*width = PCIE_LNK_WIDTH_UNKNOWN;
+
+	while (dev) {
+		u16 lnksta;
+		enum pci_bus_speed next_speed;
+		enum pcie_link_width next_width;
+
+		ret = pcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);
+		if (ret)
+			return ret;
+
+		next_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];
+		next_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>
+			PCI_EXP_LNKSTA_NLW_SHIFT;
+
+		if (next_speed < *speed)
+			*speed = next_speed;
+
+		if (next_width < *width)
+			*width = next_width;
+
+		dev = dev->bus->self;
+	}
+
+	return 0;
+}
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,7))
+int _kc_pci_wait_for_pending_transaction(struct pci_dev *dev)
+{
+	int i;
+	u16 status;
+
+	/* Wait for Transaction Pending bit clean */
+	for (i = 0; i < 4; i++) {
+		if (i)
+			msleep((1 << (i - 1)) * 100);
+
+		pcie_capability_read_word(dev, PCI_EXP_DEVSTA, &status);
+		if (!(status & PCI_EXP_DEVSTA_TRPND))
+			return 1;
+	}
+
+	return 0;
+}
+#endif /* <RHEL6.7 */
+
+#endif /* <3.12 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) )
+int __kc_dma_set_mask_and_coherent(struct device *dev, u64 mask)
+{
+	int err = dma_set_mask(dev, mask);
+
+	if (!err)
+		/* coherent mask for the same size will always succeed if
+		 * dma_set_mask does. However we store the error anyways, due
+		 * to some kernels which use gcc's warn_unused_result on their
+		 * definition of dma_set_coherent_mask.
+		 */
+		err = dma_set_coherent_mask(dev, mask);
+	return err;
+}
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0))
+static bool _kc_pci_bus_read_dev_vendor_id(struct pci_bus *bus, int devfn,
+					   u32 *l, int crs_timeout)
+{
+	int delay = 1;
+
+	if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+		return false;
+
+	/* some broken boards return 0 or ~0 if a slot is empty: */
+	if (*l == 0xffffffff || *l == 0x00000000 ||
+	    *l == 0x0000ffff || *l == 0xffff0000)
+		return false;
+
+	/* Configuration request Retry Status */
+	while (*l == 0xffff0001) {
+		if (!crs_timeout)
+			return false;
+
+		msleep(delay);
+		delay *= 2;
+		if (pci_bus_read_config_dword(bus, devfn, PCI_VENDOR_ID, l))
+			return false;
+		/* Card hasn't responded in 60 seconds?  Must be stuck. */
+		if (delay > crs_timeout) {
+			printk(KERN_WARNING "pci %04x:%02x:%02x.%d: not "
+			       "responding\n", pci_domain_nr(bus),
+			       bus->number, PCI_SLOT(devfn),
+			       PCI_FUNC(devfn));
+			return false;
+		}
+	}
+
+	return true;
+}
+
+bool _kc_pci_device_is_present(struct pci_dev *pdev)
+{
+	u32 v;
+
+	return _kc_pci_bus_read_dev_vendor_id(pdev->bus, pdev->devfn, &v, 0);
+}
+#endif /* <RHEL7.0 */
+#endif /* 3.13.0 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) )
+/******************************************************************************
+ * ripped from linux/net/ipv6/exthdrs_core.c, GPL2, no direct copyright,
+ * inferred copyright from kernel
+ */
+int __kc_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+		       int target, unsigned short *fragoff, int *flags)
+{
+	unsigned int start = skb_network_offset(skb) + sizeof(struct ipv6hdr);
+	u8 nexthdr = ipv6_hdr(skb)->nexthdr;
+	unsigned int len;
+	bool found;
+
+#define __KC_IP6_FH_F_FRAG	BIT(0)
+#define __KC_IP6_FH_F_AUTH	BIT(1)
+#define __KC_IP6_FH_F_SKIP_RH	BIT(2)
+
+	if (fragoff)
+		*fragoff = 0;
+
+	if (*offset) {
+		struct ipv6hdr _ip6, *ip6;
+
+		ip6 = skb_header_pointer(skb, *offset, sizeof(_ip6), &_ip6);
+		if (!ip6 || (ip6->version != 6)) {
+			printk(KERN_ERR "IPv6 header not found\n");
+			return -EBADMSG;
+		}
+		start = *offset + sizeof(struct ipv6hdr);
+		nexthdr = ip6->nexthdr;
+	}
+	len = skb->len - start;
+
+	do {
+		struct ipv6_opt_hdr _hdr, *hp;
+		unsigned int hdrlen;
+		found = (nexthdr == target);
+
+		if ((!ipv6_ext_hdr(nexthdr)) || nexthdr == NEXTHDR_NONE) {
+			if (target < 0 || found)
+				break;
+			return -ENOENT;
+		}
+
+		hp = skb_header_pointer(skb, start, sizeof(_hdr), &_hdr);
+		if (!hp)
+			return -EBADMSG;
+
+		if (nexthdr == NEXTHDR_ROUTING) {
+			struct ipv6_rt_hdr _rh, *rh;
+
+			rh = skb_header_pointer(skb, start, sizeof(_rh),
+						&_rh);
+			if (!rh)
+				return -EBADMSG;
+
+			if (flags && (*flags & __KC_IP6_FH_F_SKIP_RH) &&
+			    rh->segments_left == 0)
+				found = false;
+		}
+
+		if (nexthdr == NEXTHDR_FRAGMENT) {
+			unsigned short _frag_off;
+			__be16 *fp;
+
+			if (flags)	/* Indicate that this is a fragment */
+				*flags |= __KC_IP6_FH_F_FRAG;
+			fp = skb_header_pointer(skb,
+						start+offsetof(struct frag_hdr,
+							       frag_off),
+						sizeof(_frag_off),
+						&_frag_off);
+			if (!fp)
+				return -EBADMSG;
+
+			_frag_off = ntohs(*fp) & ~0x7;
+			if (_frag_off) {
+				if (target < 0 &&
+				    ((!ipv6_ext_hdr(hp->nexthdr)) ||
+				     hp->nexthdr == NEXTHDR_NONE)) {
+					if (fragoff)
+						*fragoff = _frag_off;
+					return hp->nexthdr;
+				}
+				return -ENOENT;
+			}
+			hdrlen = 8;
+		} else if (nexthdr == NEXTHDR_AUTH) {
+			if (flags && (*flags & __KC_IP6_FH_F_AUTH) && (target < 0))
+				break;
+			hdrlen = (hp->hdrlen + 2) << 2;
+		} else
+			hdrlen = ipv6_optlen(hp);
+
+		if (!found) {
+			nexthdr = hp->nexthdr;
+			len -= hdrlen;
+			start += hdrlen;
+		}
+	} while (!found);
+
+	*offset = start;
+	return nexthdr;
+}
+
+int __kc_pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
+			       int minvec, int maxvec)
+{
+        int nvec = maxvec;
+        int rc;
+
+        if (maxvec < minvec)
+                return -ERANGE;
+
+        do {
+                rc = pci_enable_msix(dev, entries, nvec);
+                if (rc < 0) {
+                        return rc;
+                } else if (rc > 0) {
+                        if (rc < minvec)
+                                return -ENOSPC;
+                        nvec = rc;
+                }
+        } while (rc);
+
+        return nvec;
+}
+#endif /* 3.14.0 */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0))
+char *_kc_devm_kstrdup(struct device *dev, const char *s, gfp_t gfp)
+{
+	size_t size;
+	char *buf;
+
+	if (!s)
+		return NULL;
+
+	size = strlen(s) + 1;
+	buf = devm_kzalloc(dev, size, gfp);
+	if (buf)
+		memcpy(buf, s, size);
+	return buf;
+}
+
+void __kc_netdev_rss_key_fill(void *buffer, size_t len)
+{
+	/* Set of random keys generated using kernel random number generator */
+	static const u8 seed[NETDEV_RSS_KEY_LEN] = {0xE6, 0xFA, 0x35, 0x62,
+				0x95, 0x12, 0x3E, 0xA3, 0xFB, 0x46, 0xC1, 0x5F,
+				0xB1, 0x43, 0x82, 0x5B, 0x6A, 0x49, 0x50, 0x95,
+				0xCD, 0xAB, 0xD8, 0x11, 0x8F, 0xC5, 0xBD, 0xBC,
+				0x6A, 0x4A, 0xB2, 0xD4, 0x1F, 0xFE, 0xBC, 0x41,
+				0xBF, 0xAC, 0xB2, 0x9A, 0x8F, 0x70, 0xE9, 0x2A,
+				0xD7, 0xB2, 0x80, 0xB6, 0x5B, 0xAA, 0x9D, 0x20};
+
+	BUG_ON(len > NETDEV_RSS_KEY_LEN);
+	memcpy(buffer, seed, len);
+}
+#endif /* 3.15.0 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0) )
+#ifdef HAVE_SET_RX_MODE
+#ifdef NETDEV_HW_ADDR_T_UNICAST
+int __kc_hw_addr_sync_dev(struct netdev_hw_addr_list *list,
+		struct net_device *dev,
+		int (*sync)(struct net_device *, const unsigned char *),
+		int (*unsync)(struct net_device *, const unsigned char *))
+{
+	struct netdev_hw_addr *ha, *tmp;
+	int err;
+
+	/* first go through and flush out any stale entries */
+	list_for_each_entry_safe(ha, tmp, &list->list, list) {
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+		if (!ha->synced || ha->refcount != 1)
+#else
+		if (!ha->sync_cnt || ha->refcount != 1)
+#endif
+			continue;
+
+		if (unsync && unsync(dev, ha->addr))
+			continue;
+
+		list_del_rcu(&ha->list);
+		kfree_rcu(ha, rcu_head);
+		list->count--;
+	}
+
+	/* go through and sync new entries to the list */
+	list_for_each_entry_safe(ha, tmp, &list->list, list) {
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+		if (ha->synced)
+#else
+		if (ha->sync_cnt)
+#endif
+			continue;
+
+		err = sync(dev, ha->addr);
+		if (err)
+			return err;
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+		ha->synced = true;
+#else
+		ha->sync_cnt++;
+#endif
+		ha->refcount++;
+	}
+
+	return 0;
+}
+
+void __kc_hw_addr_unsync_dev(struct netdev_hw_addr_list *list,
+		struct net_device *dev,
+		int (*unsync)(struct net_device *, const unsigned char *))
+{
+	struct netdev_hw_addr *ha, *tmp;
+
+	list_for_each_entry_safe(ha, tmp, &list->list, list) {
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+		if (!ha->synced)
+#else
+		if (!ha->sync_cnt)
+#endif
+			continue;
+
+		if (unsync && unsync(dev, ha->addr))
+			continue;
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+		ha->synced = false;
+#else
+		ha->sync_cnt--;
+#endif
+		if (--ha->refcount)
+			continue;
+
+		list_del_rcu(&ha->list);
+		kfree_rcu(ha, rcu_head);
+		list->count--;
+	}
+}
+
+#endif /* NETDEV_HW_ADDR_T_UNICAST  */
+#ifndef NETDEV_HW_ADDR_T_MULTICAST
+int __kc_dev_addr_sync_dev(struct dev_addr_list **list, int *count,
+		struct net_device *dev,
+		int (*sync)(struct net_device *, const unsigned char *),
+		int (*unsync)(struct net_device *, const unsigned char *))
+{
+	struct dev_addr_list *da, **next = list;
+	int err;
+
+	/* first go through and flush out any stale entries */
+	while ((da = *next) != NULL) {
+		if (da->da_synced && da->da_users == 1) {
+			if (!unsync || !unsync(dev, da->da_addr)) {
+				*next = da->next;
+				kfree(da);
+				(*count)--;
+				continue;
+			}
+		}
+		next = &da->next;
+	}
+
+	/* go through and sync new entries to the list */
+	for (da = *list; da != NULL; da = da->next) {
+		if (da->da_synced)
+			continue;
+
+		err = sync(dev, da->da_addr);
+		if (err)
+			return err;
+
+		da->da_synced++;
+		da->da_users++;
+	}
+
+	return 0;
+}
+
+void __kc_dev_addr_unsync_dev(struct dev_addr_list **list, int *count,
+		struct net_device *dev,
+		int (*unsync)(struct net_device *, const unsigned char *))
+{
+	struct dev_addr_list *da;
+
+	while ((da = *list) != NULL) {
+		if (da->da_synced) {
+			if (!unsync || !unsync(dev, da->da_addr)) {
+				da->da_synced--;
+				if (--da->da_users == 0) {
+					*list = da->next;
+					kfree(da);
+					(*count)--;
+					continue;
+				}
+			}
+		}
+		list = &da->next;
+	}
+}
+#endif /* NETDEV_HW_ADDR_T_MULTICAST  */
+#endif /* HAVE_SET_RX_MODE */
+void *__kc_devm_kmemdup(struct device *dev, const void *src, size_t len,
+			gfp_t gfp)
+{
+	void *p;
+
+	p = devm_kzalloc(dev, len, gfp);
+	if (p)
+		memcpy(p, src, len);
+
+	return p;
+}
+#endif /* 3.16.0 */
+
+/******************************************************************************/
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(3,17,0)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5)))
+#endif /* <3.17.0 && RHEL_RELEASE_CODE < RHEL7.5 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0) )
+#ifndef NO_PTP_SUPPORT
+static void __kc_sock_efree(struct sk_buff *skb)
+{
+	sock_put(skb->sk);
+}
+
+struct sk_buff *__kc_skb_clone_sk(struct sk_buff *skb)
+{
+	struct sock *sk = skb->sk;
+	struct sk_buff *clone;
+
+	if (!sk || !atomic_inc_not_zero(&sk->sk_refcnt))
+		return NULL;
+
+	clone = skb_clone(skb, GFP_ATOMIC);
+	if (!clone) {
+		sock_put(sk);
+		return NULL;
+	}
+
+	clone->sk = sk;
+	clone->destructor = __kc_sock_efree;
+
+	return clone;
+}
+
+void __kc_skb_complete_tx_timestamp(struct sk_buff *skb,
+				    struct skb_shared_hwtstamps *hwtstamps)
+{
+	struct sock_exterr_skb *serr;
+	struct sock *sk = skb->sk;
+	int err;
+
+	sock_hold(sk);
+
+	*skb_hwtstamps(skb) = *hwtstamps;
+
+	serr = SKB_EXT_ERR(skb);
+	memset(serr, 0, sizeof(*serr));
+	serr->ee.ee_errno = ENOMSG;
+	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
+
+	err = sock_queue_err_skb(sk, skb);
+	if (err)
+		kfree_skb(skb);
+
+	sock_put(sk);
+}
+#endif
+
+/* include headers needed for get_headlen function */
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#include <scsi/fc/fc_fcoe.h>
+#endif
+#ifdef HAVE_SCTP
+#include <linux/sctp.h>
+#endif
+
+u32 __kc_eth_get_headlen(const struct net_device __always_unused *dev,
+			 unsigned char *data, unsigned int max_len)
+{
+	union {
+		unsigned char *network;
+		/* l2 headers */
+		struct ethhdr *eth;
+		struct vlan_hdr *vlan;
+		/* l3 headers */
+		struct iphdr *ipv4;
+		struct ipv6hdr *ipv6;
+	} hdr;
+	__be16 proto;
+	u8 nexthdr = 0;	/* default to not TCP */
+	u8 hlen;
+
+	/* this should never happen, but better safe than sorry */
+	if (max_len < ETH_HLEN)
+		return max_len;
+
+	/* initialize network frame pointer */
+	hdr.network = data;
+
+	/* set first protocol and move network header forward */
+	proto = hdr.eth->h_proto;
+	hdr.network += ETH_HLEN;
+
+again:
+	switch (proto) {
+	/* handle any vlan tag if present */
+	case __constant_htons(ETH_P_8021AD):
+	case __constant_htons(ETH_P_8021Q):
+		if ((hdr.network - data) > (max_len - VLAN_HLEN))
+			return max_len;
+
+		proto = hdr.vlan->h_vlan_encapsulated_proto;
+		hdr.network += VLAN_HLEN;
+		goto again;
+	/* handle L3 protocols */
+	case __constant_htons(ETH_P_IP):
+		if ((hdr.network - data) > (max_len - sizeof(struct iphdr)))
+			return max_len;
+
+		/* access ihl as a u8 to avoid unaligned access on ia64 */
+		hlen = (hdr.network[0] & 0x0F) << 2;
+
+		/* verify hlen meets minimum size requirements */
+		if (hlen < sizeof(struct iphdr))
+			return hdr.network - data;
+
+		/* record next protocol if header is present */
+		if (!(hdr.ipv4->frag_off & htons(IP_OFFSET)))
+			nexthdr = hdr.ipv4->protocol;
+
+		hdr.network += hlen;
+		break;
+#ifdef NETIF_F_TSO6
+	case __constant_htons(ETH_P_IPV6):
+		if ((hdr.network - data) > (max_len - sizeof(struct ipv6hdr)))
+			return max_len;
+
+		/* record next protocol */
+		nexthdr = hdr.ipv6->nexthdr;
+		hdr.network += sizeof(struct ipv6hdr);
+		break;
+#endif /* NETIF_F_TSO6 */
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+	case __constant_htons(ETH_P_FCOE):
+		hdr.network += FCOE_HEADER_LEN;
+		break;
+#endif
+	default:
+		return hdr.network - data;
+	}
+
+	/* finally sort out L4 */
+	switch (nexthdr) {
+	case IPPROTO_TCP:
+		if ((hdr.network - data) > (max_len - sizeof(struct tcphdr)))
+			return max_len;
+
+		/* access doff as a u8 to avoid unaligned access on ia64 */
+		hdr.network += max_t(u8, sizeof(struct tcphdr),
+				     (hdr.network[12] & 0xF0) >> 2);
+
+		break;
+	case IPPROTO_UDP:
+	case IPPROTO_UDPLITE:
+		hdr.network += sizeof(struct udphdr);
+		break;
+#ifdef HAVE_SCTP
+	case IPPROTO_SCTP:
+		hdr.network += sizeof(struct sctphdr);
+		break;
+#endif
+	}
+
+	/*
+	 * If everything has gone correctly hdr.network should be the
+	 * data section of the packet and will be the end of the header.
+	 * If not then it probably represents the end of the last recognized
+	 * header.
+	 */
+	return min_t(unsigned int, hdr.network - data, max_len);
+}
+
+#endif /* < 3.18.0 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) )
+#ifdef HAVE_NET_GET_RANDOM_ONCE
+static u8 __kc_netdev_rss_key[NETDEV_RSS_KEY_LEN];
+
+void __kc_netdev_rss_key_fill(void *buffer, size_t len)
+{
+	BUG_ON(len > sizeof(__kc_netdev_rss_key));
+	net_get_random_once(__kc_netdev_rss_key, sizeof(__kc_netdev_rss_key));
+	memcpy(buffer, __kc_netdev_rss_key, len);
+}
+#endif
+
+int _kc_bitmap_print_to_pagebuf(bool list, char *buf,
+				const unsigned long *maskp,
+				int nmaskbits)
+{
+	ptrdiff_t len = PTR_ALIGN(buf + PAGE_SIZE - 1, PAGE_SIZE) - buf - 2;
+	int n = 0;
+
+	if (len > 1) {
+		n = list ? bitmap_scnlistprintf(buf, len, maskp, nmaskbits) :
+			   bitmap_scnprintf(buf, len, maskp, nmaskbits);
+		buf[n++] = '\n';
+		buf[n] = '\0';
+	}
+	return n;
+}
+#endif
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0) )
+#if !((RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,8) && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)) && \
+      (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2)) && \
+      (SLE_VERSION_CODE > SLE_VERSION(12,1,0)))
+unsigned int _kc_cpumask_local_spread(unsigned int i, int node)
+{
+	int cpu;
+
+	/* Wrap: we always want a cpu. */
+	i %= num_online_cpus();
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) )
+	/* Kernels prior to 2.6.28 do not have for_each_cpu or
+	 * cpumask_of_node, so just use for_each_online_cpu()
+	 */
+	for_each_online_cpu(cpu)
+		if (i-- == 0)
+			return cpu;
+
+	return 0;
+#else
+	if (node == -1) {
+		for_each_cpu(cpu, cpu_online_mask)
+			if (i-- == 0)
+				return cpu;
+	} else {
+		/* NUMA first. */
+		for_each_cpu_and(cpu, cpumask_of_node(node), cpu_online_mask)
+			if (i-- == 0)
+				return cpu;
+
+		for_each_cpu(cpu, cpu_online_mask) {
+			/* Skip NUMA nodes, done above. */
+			if (cpumask_test_cpu(cpu, cpumask_of_node(node)))
+				continue;
+
+			if (i-- == 0)
+				return cpu;
+		}
+	}
+#endif /* KERNEL_VERSION >= 2.6.28 */
+	BUG();
+}
+#endif
+#endif
+
+/******************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,2,0)))
+/**
+ * _kc_skb_flow_dissect_flow_keys - parse SKB to fill _kc_flow_keys
+ * @skb: SKB used to fille _kc_flow_keys
+ * @flow: _kc_flow_keys to set with SKB fields
+ * @flags: currently unused flags
+ *
+ * The purpose of using kcompat for this function is so the caller doesn't have
+ * to care about which kernel version they are on, which prevents a larger than
+ * normal #ifdef mess created by using a HAVE_* flag for this case. This is also
+ * done for 4.2 kernels to simplify calling skb_flow_dissect_flow_keys()
+ * because in 4.2 kernels skb_flow_dissect_flow_keys() exists, but only has 2
+ * arguments. Recent kernels have skb_flow_dissect_flow_keys() that has 3
+ * arguments.
+ *
+ * The caller needs to understand that this function was only implemented as a
+ * bare-minimum replacement for recent versions of skb_flow_dissect_flow_keys()
+ * and this function is in no way similar to skb_flow_dissect_flow_keys(). An
+ * example use can be found in the ice driver, specifically ice_arfs.c.
+ *
+ * This function is treated as a whitelist of supported fields the SKB can
+ * parse. If new functionality is added make sure to keep this format (i.e. only
+ * check for fields that are explicity wanted).
+ *
+ * Current whitelist:
+ *
+ * TCPv4, TCPv6, UDPv4, UDPv6
+ *
+ * If any unexpected protocol or other field is found this function memsets the
+ * flow passed in back to 0 and returns false. Otherwise the flow is populated
+ * and returns true.
+ */
+bool
+_kc_skb_flow_dissect_flow_keys(const struct sk_buff *skb,
+			       struct _kc_flow_keys *flow,
+			       unsigned int __always_unused flags)
+{
+	memset(flow, 0, sizeof(*flow));
+
+	flow->basic.n_proto = skb->protocol;
+	switch (flow->basic.n_proto) {
+	case htons(ETH_P_IP):
+		flow->basic.ip_proto = ip_hdr(skb)->protocol;
+		flow->addrs.v4addrs.src = ip_hdr(skb)->saddr;
+		flow->addrs.v4addrs.dst = ip_hdr(skb)->daddr;
+		break;
+	case htons(ETH_P_IPV6):
+		flow->basic.ip_proto = ipv6_hdr(skb)->nexthdr;
+		memcpy(&flow->addrs.v6addrs.src, &ipv6_hdr(skb)->saddr,
+		       sizeof(struct in6_addr));
+		memcpy(&flow->addrs.v6addrs.dst, &ipv6_hdr(skb)->daddr,
+		       sizeof(struct in6_addr));
+		break;
+	default:
+		netdev_dbg(skb->dev, "%s: Unsupported/unimplemented layer 3 protocol %04x\n", __func__, htons(flow->basic.n_proto));
+		goto unsupported;
+	}
+
+	switch (flow->basic.ip_proto) {
+	case IPPROTO_TCP:
+	{
+		struct tcphdr *tcph;
+
+		tcph = tcp_hdr(skb);
+		flow->ports.src = tcph->source;
+		flow->ports.dst = tcph->dest;
+		break;
+	}
+	case IPPROTO_UDP:
+	{
+		struct udphdr *udph;
+
+		udph = udp_hdr(skb);
+		flow->ports.src = udph->source;
+		flow->ports.dst = udph->dest;
+		break;
+	}
+	default:
+		netdev_dbg(skb->dev, "%s: Unsupported/unimplemented layer 4 protocol %02x\n", __func__, flow->basic.ip_proto);
+		return false;
+	}
+
+	return true;
+
+unsupported:
+	memset(flow, 0, sizeof(*flow));
+	return false;
+}
+#endif /* ! >= RHEL7.4 && ! >= SLES12.2 */
+#endif /* 4.3.0 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) )
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3)))
+#ifdef CONFIG_SPARC
+#include <asm/idprom.h>
+#include <asm/prom.h>
+#endif
+int _kc_eth_platform_get_mac_address(struct device *dev __maybe_unused,
+				     u8 *mac_addr __maybe_unused)
+{
+#if (((LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)) && defined(CONFIG_OF) && \
+      !defined(HAVE_STRUCT_DEVICE_OF_NODE) || !defined(CONFIG_OF)) && \
+     !defined(CONFIG_SPARC))
+	return -ENODEV;
+#else
+	const unsigned char *addr;
+	struct device_node *dp;
+
+	if (dev_is_pci(dev))
+		dp = pci_device_to_OF_node(to_pci_dev(dev));
+	else
+#if defined(HAVE_STRUCT_DEVICE_OF_NODE) && defined(CONFIG_OF)
+		dp = dev->of_node;
+#else
+		dp = NULL;
+#endif
+
+	addr = NULL;
+	if (dp)
+		addr = of_get_mac_address(dp);
+#ifdef CONFIG_SPARC
+	/* Kernel hasn't implemented arch_get_platform_mac_address, but we
+	 * should handle the SPARC case here since it was supported
+	 * originally. This is replaced by arch_get_platform_mac_address()
+	 * upstream.
+	 */
+	if (!addr)
+		addr = idprom->id_ethaddr;
+#endif
+	if (!addr)
+		return -ENODEV;
+
+	ether_addr_copy(mac_addr, addr);
+	return 0;
+#endif
+}
+#endif /* !(RHEL_RELEASE >= 7.3) */
+#endif /* < 4.5.0 */
+
+/*****************************************************************************/
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)) || \
+     (SLE_VERSION_CODE && (SLE_VERSION_CODE <= SLE_VERSION(12,3,0))) || \
+     (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE <= RHEL_RELEASE_VERSION(7,5))))
+const char *_kc_phy_speed_to_str(int speed)
+{
+	switch (speed) {
+	case SPEED_10:
+		return "10Mbps";
+	case SPEED_100:
+		return "100Mbps";
+	case SPEED_1000:
+		return "1Gbps";
+	case SPEED_2500:
+		return "2.5Gbps";
+	case SPEED_5000:
+		return "5Gbps";
+	case SPEED_10000:
+		return "10Gbps";
+	case SPEED_14000:
+		return "14Gbps";
+	case SPEED_20000:
+		return "20Gbps";
+	case SPEED_25000:
+		return "25Gbps";
+	case SPEED_40000:
+		return "40Gbps";
+	case SPEED_50000:
+		return "50Gbps";
+	case SPEED_56000:
+		return "56Gbps";
+#ifdef SPEED_100000
+	case SPEED_100000:
+		return "100Gbps";
+#endif
+	case SPEED_UNKNOWN:
+		return "Unknown";
+	default:
+		return "Unsupported (update phy-core.c)";
+	}
+}
+#endif /* (LINUX < 4.14.0) || (SLES <= 12.3.0) || (RHEL <= 7.5) */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0) )
+void _kc_ethtool_intersect_link_masks(struct ethtool_link_ksettings *dst,
+				      struct ethtool_link_ksettings *src)
+{
+	unsigned int size = BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS);
+	unsigned int idx = 0;
+
+	for (; idx < size; idx++) {
+		dst->link_modes.supported[idx] &=
+			src->link_modes.supported[idx];
+		dst->link_modes.advertising[idx] &=
+			src->link_modes.advertising[idx];
+	}
+}
+#endif /* 4.15.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,17,0))
+/* PCIe link information */
+#define PCIE_SPEED2STR(speed) \
+	((speed) == PCIE_SPEED_16_0GT ? "16 GT/s" : \
+	 (speed) == PCIE_SPEED_8_0GT ? "8 GT/s" : \
+	 (speed) == PCIE_SPEED_5_0GT ? "5 GT/s" : \
+	 (speed) == PCIE_SPEED_2_5GT ? "2.5 GT/s" : \
+	 "Unknown speed")
+
+/* PCIe speed to Mb/s reduced by encoding overhead */
+#define PCIE_SPEED2MBS_ENC(speed) \
+	((speed) == PCIE_SPEED_16_0GT ? 16000*128/130 : \
+	 (speed) == PCIE_SPEED_8_0GT  ?  8000*128/130 : \
+	 (speed) == PCIE_SPEED_5_0GT  ?  5000*8/10 : \
+	 (speed) == PCIE_SPEED_2_5GT  ?  2500*8/10 : \
+	 0)
+
+static u32
+_kc_pcie_bandwidth_available(struct pci_dev *dev,
+			     struct pci_dev **limiting_dev,
+			     enum pci_bus_speed *speed,
+			     enum pcie_link_width *width)
+{
+	u16 lnksta;
+	enum pci_bus_speed next_speed;
+	enum pcie_link_width next_width;
+	u32 bw, next_bw;
+
+	if (speed)
+		*speed = PCI_SPEED_UNKNOWN;
+	if (width)
+		*width = PCIE_LNK_WIDTH_UNKNOWN;
+
+	bw = 0;
+
+	while (dev) {
+		pcie_capability_read_word(dev, PCI_EXP_LNKSTA, &lnksta);
+
+		next_speed = pcie_link_speed[lnksta & PCI_EXP_LNKSTA_CLS];
+		next_width = (lnksta & PCI_EXP_LNKSTA_NLW) >>
+			PCI_EXP_LNKSTA_NLW_SHIFT;
+
+		next_bw = next_width * PCIE_SPEED2MBS_ENC(next_speed);
+
+		/* Check if current device limits the total bandwidth */
+		if (!bw || next_bw <= bw) {
+			bw = next_bw;
+
+			if (limiting_dev)
+				*limiting_dev = dev;
+			if (speed)
+				*speed = next_speed;
+			if (width)
+				*width = next_width;
+		}
+
+		dev = pci_upstream_bridge(dev);
+	}
+
+	return bw;
+}
+
+static enum pci_bus_speed _kc_pcie_get_speed_cap(struct pci_dev *dev)
+{
+	u32 lnkcap2, lnkcap;
+
+	/*
+	 * PCIe r4.0 sec 7.5.3.18 recommends using the Supported Link
+	 * Speeds Vector in Link Capabilities 2 when supported, falling
+	 * back to Max Link Speed in Link Capabilities otherwise.
+	 */
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP2, &lnkcap2);
+	if (lnkcap2) { /* PCIe r3.0-compliant */
+		if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_16_0GB)
+			return PCIE_SPEED_16_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_8_0GB)
+			return PCIE_SPEED_8_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_5_0GB)
+			return PCIE_SPEED_5_0GT;
+		else if (lnkcap2 & PCI_EXP_LNKCAP2_SLS_2_5GB)
+			return PCIE_SPEED_2_5GT;
+		return PCI_SPEED_UNKNOWN;
+	}
+
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
+	if (lnkcap) {
+		if (lnkcap & PCI_EXP_LNKCAP_SLS_16_0GB)
+			return PCIE_SPEED_16_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_8_0GB)
+			return PCIE_SPEED_8_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_5_0GB)
+			return PCIE_SPEED_5_0GT;
+		else if (lnkcap & PCI_EXP_LNKCAP_SLS_2_5GB)
+			return PCIE_SPEED_2_5GT;
+	}
+
+	return PCI_SPEED_UNKNOWN;
+}
+
+static enum pcie_link_width _kc_pcie_get_width_cap(struct pci_dev *dev)
+{
+	u32 lnkcap;
+
+	pcie_capability_read_dword(dev, PCI_EXP_LNKCAP, &lnkcap);
+	if (lnkcap)
+		return (lnkcap & PCI_EXP_LNKCAP_MLW) >> 4;
+
+	return PCIE_LNK_WIDTH_UNKNOWN;
+}
+
+static u32
+_kc_pcie_bandwidth_capable(struct pci_dev *dev, enum pci_bus_speed *speed,
+			   enum pcie_link_width *width)
+{
+	*speed = _kc_pcie_get_speed_cap(dev);
+	*width = _kc_pcie_get_width_cap(dev);
+
+	if (*speed == PCI_SPEED_UNKNOWN || *width == PCIE_LNK_WIDTH_UNKNOWN)
+		return 0;
+
+	return *width * PCIE_SPEED2MBS_ENC(*speed);
+}
+
+void _kc_pcie_print_link_status(struct pci_dev *dev) {
+	enum pcie_link_width width, width_cap;
+	enum pci_bus_speed speed, speed_cap;
+	struct pci_dev *limiting_dev = NULL;
+	u32 bw_avail, bw_cap;
+
+	bw_cap = _kc_pcie_bandwidth_capable(dev, &speed_cap, &width_cap);
+	bw_avail = _kc_pcie_bandwidth_available(dev, &limiting_dev, &speed,
+						&width);
+
+	if (bw_avail >= bw_cap)
+		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth (%s x%d link)\n",
+			 bw_cap / 1000, bw_cap % 1000,
+			 PCIE_SPEED2STR(speed_cap), width_cap);
+	else
+		pci_info(dev, "%u.%03u Gb/s available PCIe bandwidth, limited by %s x%d link at %s (capable of %u.%03u Gb/s with %s x%d link)\n",
+			 bw_avail / 1000, bw_avail % 1000,
+			 PCIE_SPEED2STR(speed), width,
+			 limiting_dev ? pci_name(limiting_dev) : "<unknown>",
+			 bw_cap / 1000, bw_cap % 1000,
+			 PCIE_SPEED2STR(speed_cap), width_cap);
+}
+#endif /* 4.17.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0))
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,1)))
+#define HAVE_NDO_FDB_ADD_EXTACK
+#else /* !RHEL || RHEL < 8.1 */
+#ifdef HAVE_TC_SETUP_CLSFLOWER
+#define FLOW_DISSECTOR_MATCH(__rule, __type, __out)				\
+	const struct flow_match *__m = &(__rule)->match;			\
+	struct flow_dissector *__d = (__m)->dissector;				\
+										\
+	(__out)->key = skb_flow_dissector_target(__d, __type, (__m)->key);	\
+	(__out)->mask = skb_flow_dissector_target(__d, __type, (__m)->mask);	\
+
+void flow_rule_match_basic(const struct flow_rule *rule,
+			   struct flow_match_basic *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_BASIC, out);
+}
+
+void flow_rule_match_control(const struct flow_rule *rule,
+			     struct flow_match_control *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_CONTROL, out);
+}
+
+void flow_rule_match_eth_addrs(const struct flow_rule *rule,
+			       struct flow_match_eth_addrs *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ETH_ADDRS, out);
+}
+
+#ifdef HAVE_TC_FLOWER_ENC
+void flow_rule_match_enc_keyid(const struct flow_rule *rule,
+			       struct flow_match_enc_keyid *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_KEYID, out);
+}
+
+void flow_rule_match_enc_ports(const struct flow_rule *rule,
+			       struct flow_match_ports *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_PORTS, out);
+}
+
+void flow_rule_match_enc_control(const struct flow_rule *rule,
+				 struct flow_match_control *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_CONTROL, out);
+}
+
+void flow_rule_match_enc_ipv4_addrs(const struct flow_rule *rule,
+				    struct flow_match_ipv4_addrs *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS, out);
+}
+
+void flow_rule_match_enc_ipv6_addrs(const struct flow_rule *rule,
+				    struct flow_match_ipv6_addrs *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS, out);
+}
+#endif
+
+#ifndef HAVE_TC_FLOWER_VLAN_IN_TAGS
+void flow_rule_match_vlan(const struct flow_rule *rule,
+			  struct flow_match_vlan *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_VLAN, out);
+}
+#endif
+
+void flow_rule_match_ipv4_addrs(const struct flow_rule *rule,
+				struct flow_match_ipv4_addrs *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_IPV4_ADDRS, out);
+}
+
+void flow_rule_match_ipv6_addrs(const struct flow_rule *rule,
+				struct flow_match_ipv6_addrs *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_IPV6_ADDRS, out);
+}
+
+void flow_rule_match_ports(const struct flow_rule *rule,
+			   struct flow_match_ports *out)
+{
+	FLOW_DISSECTOR_MATCH(rule, FLOW_DISSECTOR_KEY_PORTS, out);
+}
+#endif /* HAVE_TC_SETUP_CLSFLOWER */
+#endif /* !RHEL || RHEL < 8.1 */
+#endif /* 5.1.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,3,0))
+#if (!(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2))))
+#ifdef HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO
+int _kc_flow_block_cb_setup_simple(struct flow_block_offload *f,
+				   struct list_head __always_unused *driver_list,
+				   tc_setup_cb_t *cb,
+				   void *cb_ident, void *cb_priv,
+				   bool ingress_only)
+{
+	if (ingress_only &&
+	    f->binder_type != TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS)
+		return -EOPNOTSUPP;
+
+	/* Note: Upstream has driver_block_list, but older kernels do not */
+	switch (f->command) {
+	case TC_BLOCK_BIND:
+#ifdef HAVE_TCF_BLOCK_CB_REGISTER_EXTACK
+		return tcf_block_cb_register(f->block, cb, cb_ident, cb_priv,
+					     f->extack);
+#else
+		return tcf_block_cb_register(f->block, cb, cb_ident, cb_priv);
+#endif
+	case TC_BLOCK_UNBIND:
+		tcf_block_cb_unregister(f->block, cb, cb_ident);
+		return 0;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif /* HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO */
+#endif /* !RHEL >= 8.2 */
+#endif /* 5.3.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0))
+u64 _kc_pci_get_dsn(struct pci_dev *dev)
+{
+	u32 dword;
+	u64 dsn;
+	int pos;
+
+	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DSN);
+	if (!pos)
+		return 0;
+
+	/*
+	 * The Device Serial Number is two dwords offset 4 bytes from the
+	 * capability position. The specification says that the first dword is
+	 * the lower half, and the second dword is the upper half.
+	 */
+	pos += 4;
+	pci_read_config_dword(dev, pos, &dword);
+	dsn = (u64)dword;
+	pci_read_config_dword(dev, pos + 4, &dword);
+	dsn |= ((u64)dword) << 32;
+
+	return dsn;
+}
+#endif /* 5.7.0 */
diff --git a/drivers/net/ethernet/intel/ixgbe/kcompat.h b/drivers/net/ethernet/intel/ixgbe/kcompat.h
new file mode 100644
index 000000000000..2596852ca443
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/kcompat.h
@@ -0,0 +1,7336 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+#ifndef _KCOMPAT_H_
+#define _KCOMPAT_H_
+
+#ifndef LINUX_VERSION_CODE
+#include <linux/version.h>
+#else
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
+#endif
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/if_vlan.h>
+#include <linux/in.h>
+#include <linux/if_link.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <linux/list.h>
+#include <linux/mii.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/pci.h>
+#include <linux/sched.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/tcp.h>
+#include <linux/types.h>
+#include <linux/udp.h>
+#include <linux/vmalloc.h>
+
+#ifndef GCC_VERSION
+#define GCC_VERSION (__GNUC__ * 10000		\
+		     + __GNUC_MINOR__ * 100	\
+		     + __GNUC_PATCHLEVEL__)
+#endif /* GCC_VERSION */
+
+/* Backport macros for controlling GCC diagnostics */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,18,0) )
+
+/* Compilers before gcc-4.6 do not understand "#pragma GCC diagnostic push" */
+#if GCC_VERSION >= 40600
+#define __diag_str1(s)		#s
+#define __diag_str(s)		__diag_str1(s)
+#define __diag(s)		_Pragma(__diag_str(GCC diagnostic s))
+#else
+#define __diag(s)
+#endif /* GCC_VERSION >= 4.6 */
+#define __diag_push()	__diag(push)
+#define __diag_pop()	__diag(pop)
+#endif /* LINUX_VERSION < 4.18.0 */
+
+#ifndef NSEC_PER_MSEC
+#define NSEC_PER_MSEC 1000000L
+#endif
+#include <net/ipv6.h>
+/* UTS_RELEASE is in a different header starting in kernel 2.6.18 */
+#ifndef UTS_RELEASE
+/* utsrelease.h changed locations in 2.6.33 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33) )
+#include <linux/utsrelease.h>
+#else
+#include <generated/utsrelease.h>
+#endif
+#endif
+
+/* NAPI enable/disable flags here */
+#define NAPI
+
+#define adapter_struct ixgbe_adapter
+#define adapter_q_vector ixgbe_q_vector
+
+/* and finally set defines so that the code sees the changes */
+#ifdef NAPI
+#else
+#endif /* NAPI */
+
+/* Dynamic LTR and deeper C-State support disable/enable */
+
+/* packet split disable/enable */
+#ifdef DISABLE_PACKET_SPLIT
+#ifndef CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+#define CONFIG_IXGBE_DISABLE_PACKET_SPLIT
+#endif
+#endif /* DISABLE_PACKET_SPLIT */
+
+/* MSI compatibility code for all kernels and drivers */
+#ifdef DISABLE_PCI_MSI
+#undef CONFIG_PCI_MSI
+#endif
+#ifndef CONFIG_PCI_MSI
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8) )
+struct msix_entry {
+	u16 vector; /* kernel uses to write allocated vector */
+	u16 entry;  /* driver uses to specify entry, OS writes */
+};
+#endif
+#undef pci_enable_msi
+#define pci_enable_msi(a) -ENOTSUPP
+#undef pci_disable_msi
+#define pci_disable_msi(a) do {} while (0)
+#undef pci_enable_msix
+#define pci_enable_msix(a, b, c) -ENOTSUPP
+#undef pci_disable_msix
+#define pci_disable_msix(a) do {} while (0)
+#define msi_remove_pci_irq_vectors(a) do {} while (0)
+#endif /* CONFIG_PCI_MSI */
+#ifdef DISABLE_PM
+#undef CONFIG_PM
+#endif
+
+#ifdef DISABLE_NET_POLL_CONTROLLER
+#undef CONFIG_NET_POLL_CONTROLLER
+#endif
+
+#ifndef PMSG_SUSPEND
+#define PMSG_SUSPEND 3
+#endif
+
+/* generic boolean compatibility */
+#undef TRUE
+#undef FALSE
+#define TRUE true
+#define FALSE false
+#ifdef GCC_VERSION
+#if ( GCC_VERSION < 3000 )
+#define _Bool char
+#endif
+#else
+#define _Bool char
+#endif
+
+#ifndef BIT
+#define BIT(nr)         (1UL << (nr))
+#endif
+
+#undef __always_unused
+#define __always_unused __attribute__((__unused__))
+
+#undef __maybe_unused
+#define __maybe_unused __attribute__((__unused__))
+
+/* kernels less than 2.4.14 don't have this */
+#ifndef ETH_P_8021Q
+#define ETH_P_8021Q 0x8100
+#endif
+
+#ifndef module_param
+#define module_param(v,t,p) MODULE_PARM(v, "i");
+#endif
+
+#ifndef DMA_64BIT_MASK
+#define DMA_64BIT_MASK  0xffffffffffffffffULL
+#endif
+
+#ifndef DMA_32BIT_MASK
+#define DMA_32BIT_MASK  0x00000000ffffffffULL
+#endif
+
+#ifndef PCI_CAP_ID_EXP
+#define PCI_CAP_ID_EXP 0x10
+#endif
+
+#ifndef uninitialized_var
+#define uninitialized_var(x) x = x
+#endif
+
+#ifndef PCIE_LINK_STATE_L0S
+#define PCIE_LINK_STATE_L0S 1
+#endif
+#ifndef PCIE_LINK_STATE_L1
+#define PCIE_LINK_STATE_L1 2
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#if !defined(HAVE_FREE_NETDEV) && ( LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0) )
+#define free_netdev(x)	kfree(x)
+#endif
+
+#ifdef HAVE_POLL_CONTROLLER
+#define CONFIG_NET_POLL_CONTROLLER
+#endif
+
+#ifndef SKB_DATAREF_SHIFT
+/* if we do not have the infrastructure to detect if skb_header is cloned
+   just return false in all cases */
+#define skb_header_cloned(x) 0
+#endif
+
+#ifndef NETIF_F_GSO
+#define gso_size tso_size
+#define gso_segs tso_segs
+#endif
+
+#ifndef NETIF_F_GRO
+#define vlan_gro_receive(_napi, _vlgrp, _vlan, _skb) \
+		vlan_hwaccel_receive_skb(_skb, _vlgrp, _vlan)
+#define napi_gro_receive(_napi, _skb) netif_receive_skb(_skb)
+#endif
+
+#ifndef NETIF_F_SCTP_CSUM
+#define NETIF_F_SCTP_CSUM 0
+#endif
+
+#ifndef NETIF_F_LRO
+#define NETIF_F_LRO BIT(15)
+#endif
+
+#ifndef NETIF_F_NTUPLE
+#define NETIF_F_NTUPLE BIT(27)
+#endif
+
+#ifndef NETIF_F_ALL_FCOE
+#define NETIF_F_ALL_FCOE	(NETIF_F_FCOE_CRC | NETIF_F_FCOE_MTU | \
+				 NETIF_F_FSO)
+#endif
+
+#ifndef IPPROTO_SCTP
+#define IPPROTO_SCTP 132
+#endif
+
+#ifndef IPPROTO_UDPLITE
+#define IPPROTO_UDPLITE 136
+#endif
+
+#ifndef CHECKSUM_PARTIAL
+#define CHECKSUM_PARTIAL CHECKSUM_HW
+#define CHECKSUM_COMPLETE CHECKSUM_HW
+#endif
+
+#ifndef __read_mostly
+#define __read_mostly
+#endif
+
+#ifndef MII_RESV1
+#define MII_RESV1		0x17		/* Reserved...		*/
+#endif
+
+#ifndef unlikely
+#define unlikely(_x) _x
+#define likely(_x) _x
+#endif
+
+#ifndef WARN_ON
+#define WARN_ON(x)
+#endif
+
+#ifndef PCI_DEVICE
+#define PCI_DEVICE(vend,dev) \
+	.vendor = (vend), .device = (dev), \
+	.subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+#endif
+
+#ifndef node_online
+#define node_online(node) ((node) == 0)
+#endif
+
+#ifndef cpu_online
+#define cpu_online(cpuid) test_bit((cpuid), &cpu_online_map)
+#endif
+
+#ifndef _LINUX_RANDOM_H
+#include <linux/random.h>
+#endif
+
+#ifndef BITS_PER_TYPE
+#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)
+#endif
+
+#ifndef BITS_TO_LONGS
+#define BITS_TO_LONGS(bits) (((bits)+BITS_PER_LONG-1)/BITS_PER_LONG)
+#endif
+
+#ifndef DECLARE_BITMAP
+#define DECLARE_BITMAP(name,bits) long name[BITS_TO_LONGS(bits)]
+#endif
+
+#ifndef VLAN_HLEN
+#define VLAN_HLEN 4
+#endif
+
+#ifndef VLAN_ETH_HLEN
+#define VLAN_ETH_HLEN 18
+#endif
+
+#ifndef VLAN_ETH_FRAME_LEN
+#define VLAN_ETH_FRAME_LEN 1518
+#endif
+
+#ifndef DCA_GET_TAG_TWO_ARGS
+#define dca3_get_tag(a,b) dca_get_tag(b)
+#endif
+
+#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+#if defined(__i386__) || defined(__x86_64__)
+#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+#endif
+#endif
+
+/* taken from 2.6.24 definition in linux/kernel.h */
+#ifndef IS_ALIGNED
+#define IS_ALIGNED(x,a)         (((x) % ((typeof(x))(a))) == 0)
+#endif
+
+#ifdef IS_ENABLED
+#undef IS_ENABLED
+#undef __ARG_PLACEHOLDER_1
+#undef config_enabled
+#undef _config_enabled
+#undef __config_enabled
+#undef ___config_enabled
+#endif
+
+#define __ARG_PLACEHOLDER_1 0,
+#define config_enabled(cfg) _config_enabled(cfg)
+#define _config_enabled(value) __config_enabled(__ARG_PLACEHOLDER_##value)
+#define __config_enabled(arg1_or_junk) ___config_enabled(arg1_or_junk 1, 0)
+#define ___config_enabled(__ignored, val, ...) val
+
+#define IS_ENABLED(option) \
+	(config_enabled(option) || config_enabled(option##_MODULE))
+
+#if !defined(NETIF_F_HW_VLAN_TX) && !defined(NETIF_F_HW_VLAN_CTAG_TX)
+struct _kc_vlan_ethhdr {
+	unsigned char	h_dest[ETH_ALEN];
+	unsigned char	h_source[ETH_ALEN];
+	__be16		h_vlan_proto;
+	__be16		h_vlan_TCI;
+	__be16		h_vlan_encapsulated_proto;
+};
+#define vlan_ethhdr _kc_vlan_ethhdr
+struct _kc_vlan_hdr {
+	__be16		h_vlan_TCI;
+	__be16		h_vlan_encapsulated_proto;
+};
+#define vlan_hdr _kc_vlan_hdr
+#define vlan_tx_tag_present(_skb) 0
+#define vlan_tx_tag_get(_skb) 0
+#endif /* NETIF_F_HW_VLAN_TX && NETIF_F_HW_VLAN_CTAG_TX */
+
+#ifndef VLAN_PRIO_SHIFT
+#define VLAN_PRIO_SHIFT 13
+#endif
+
+#ifndef PCI_EXP_LNKSTA_CLS_2_5GB
+#define PCI_EXP_LNKSTA_CLS_2_5GB 0x0001
+#endif
+
+#ifndef PCI_EXP_LNKSTA_CLS_5_0GB
+#define PCI_EXP_LNKSTA_CLS_5_0GB 0x0002
+#endif
+
+#ifndef PCI_EXP_LNKSTA_CLS_8_0GB
+#define PCI_EXP_LNKSTA_CLS_8_0GB 0x0003
+#endif
+
+#ifndef PCI_EXP_LNKSTA_NLW_X1
+#define PCI_EXP_LNKSTA_NLW_X1 0x0010
+#endif
+
+#ifndef PCI_EXP_LNKSTA_NLW_X2
+#define PCI_EXP_LNKSTA_NLW_X2 0x0020
+#endif
+
+#ifndef PCI_EXP_LNKSTA_NLW_X4
+#define PCI_EXP_LNKSTA_NLW_X4 0x0040
+#endif
+
+#ifndef PCI_EXP_LNKSTA_NLW_X8
+#define PCI_EXP_LNKSTA_NLW_X8 0x0080
+#endif
+
+#ifndef __GFP_COLD
+#define __GFP_COLD 0
+#endif
+
+#ifndef __GFP_COMP
+#define __GFP_COMP 0
+#endif
+
+#ifndef IP_OFFSET
+#define IP_OFFSET 0x1FFF /* "Fragment Offset" part */
+#endif
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
+
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+	u32 cmd;
+	char driver[32];
+	char version[32];
+	char fw_version[32];
+	char bus_info[32];
+	char reserved1[32];
+	char reserved2[16];
+	u32 n_stats;
+	u32 testinfo_len;
+	u32 eedump_len;
+	u32 regdump_len;
+};
+
+struct ethtool_stats {
+	u32 cmd;
+	u32 n_stats;
+	u64 data[0];
+};
+#endif /* ETHTOOL_GSTATS */
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#endif /* ETHTOOL_PHYS_ID */
+
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+	ETH_SS_TEST             = 0,
+	ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+	u32 cmd;            /* ETHTOOL_GSTRINGS */
+	u32 string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+	u32 len;            /* number of strings in the string set */
+	u8 data[0];
+};
+#endif /* ETHTOOL_GSTRINGS */
+
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+	ETH_TEST_FL_OFFLINE	= BIT(0),
+	ETH_TEST_FL_FAILED	= BIT(1),
+};
+struct ethtool_test {
+	u32 cmd;
+	u32 flags;
+	u32 reserved;
+	u32 len;
+	u64 data[0];
+};
+#endif /* ETHTOOL_TEST */
+
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+	u32 cmd;
+	u32 magic;
+	u32 offset;
+	u32 len;
+	u8 data[0];
+};
+
+struct ethtool_value {
+	u32 cmd;
+	u32 data;
+};
+#endif /* ETHTOOL_GEEPROM */
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* ETHTOOL_GLINK */
+
+#ifndef ETHTOOL_GWOL
+#define ETHTOOL_GWOL 0x5
+#define ETHTOOL_SWOL 0x6
+#define SOPASS_MAX      6
+struct ethtool_wolinfo {
+	u32 cmd;
+	u32 supported;
+	u32 wolopts;
+	u8 sopass[SOPASS_MAX]; /* SecureOn(tm) password */
+};
+#endif /* ETHTOOL_GWOL */
+
+#ifndef ETHTOOL_GREGS
+#define ETHTOOL_GREGS		0x00000004 /* Get NIC registers */
+#define ethtool_regs _kc_ethtool_regs
+/* for passing big chunks of data */
+struct _kc_ethtool_regs {
+	u32 cmd;
+	u32 version; /* driver-specific, indicates different chips/revs */
+	u32 len; /* bytes */
+	u8 data[0];
+};
+#endif /* ETHTOOL_GREGS */
+
+#ifndef ETHTOOL_GMSGLVL
+#define ETHTOOL_GMSGLVL		0x00000007 /* Get driver message level */
+#endif
+#ifndef ETHTOOL_SMSGLVL
+#define ETHTOOL_SMSGLVL		0x00000008 /* Set driver msg level, priv. */
+#endif
+#ifndef ETHTOOL_NWAY_RST
+#define ETHTOOL_NWAY_RST	0x00000009 /* Restart autonegotiation, priv */
+#endif
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK		0x0000000a /* Get link status */
+#endif
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM		0x0000000b /* Get EEPROM data */
+#endif
+#ifndef ETHTOOL_SEEPROM
+#define ETHTOOL_SEEPROM		0x0000000c /* Set EEPROM data */
+#endif
+#ifndef ETHTOOL_GCOALESCE
+#define ETHTOOL_GCOALESCE	0x0000000e /* Get coalesce config */
+/* for configuring coalescing parameters of chip */
+#define ethtool_coalesce _kc_ethtool_coalesce
+struct _kc_ethtool_coalesce {
+	u32	cmd;	/* ETHTOOL_{G,S}COALESCE */
+
+	/* How many usecs to delay an RX interrupt after
+	 * a packet arrives.  If 0, only rx_max_coalesced_frames
+	 * is used.
+	 */
+	u32	rx_coalesce_usecs;
+
+	/* How many packets to delay an RX interrupt after
+	 * a packet arrives.  If 0, only rx_coalesce_usecs is
+	 * used.  It is illegal to set both usecs and max frames
+	 * to zero as this would cause RX interrupts to never be
+	 * generated.
+	 */
+	u32	rx_max_coalesced_frames;
+
+	/* Same as above two parameters, except that these values
+	 * apply while an IRQ is being serviced by the host.  Not
+	 * all cards support this feature and the values are ignored
+	 * in that case.
+	 */
+	u32	rx_coalesce_usecs_irq;
+	u32	rx_max_coalesced_frames_irq;
+
+	/* How many usecs to delay a TX interrupt after
+	 * a packet is sent.  If 0, only tx_max_coalesced_frames
+	 * is used.
+	 */
+	u32	tx_coalesce_usecs;
+
+	/* How many packets to delay a TX interrupt after
+	 * a packet is sent.  If 0, only tx_coalesce_usecs is
+	 * used.  It is illegal to set both usecs and max frames
+	 * to zero as this would cause TX interrupts to never be
+	 * generated.
+	 */
+	u32	tx_max_coalesced_frames;
+
+	/* Same as above two parameters, except that these values
+	 * apply while an IRQ is being serviced by the host.  Not
+	 * all cards support this feature and the values are ignored
+	 * in that case.
+	 */
+	u32	tx_coalesce_usecs_irq;
+	u32	tx_max_coalesced_frames_irq;
+
+	/* How many usecs to delay in-memory statistics
+	 * block updates.  Some drivers do not have an in-memory
+	 * statistic block, and in such cases this value is ignored.
+	 * This value must not be zero.
+	 */
+	u32	stats_block_coalesce_usecs;
+
+	/* Adaptive RX/TX coalescing is an algorithm implemented by
+	 * some drivers to improve latency under low packet rates and
+	 * improve throughput under high packet rates.  Some drivers
+	 * only implement one of RX or TX adaptive coalescing.  Anything
+	 * not implemented by the driver causes these values to be
+	 * silently ignored.
+	 */
+	u32	use_adaptive_rx_coalesce;
+	u32	use_adaptive_tx_coalesce;
+
+	/* When the packet rate (measured in packets per second)
+	 * is below pkt_rate_low, the {rx,tx}_*_low parameters are
+	 * used.
+	 */
+	u32	pkt_rate_low;
+	u32	rx_coalesce_usecs_low;
+	u32	rx_max_coalesced_frames_low;
+	u32	tx_coalesce_usecs_low;
+	u32	tx_max_coalesced_frames_low;
+
+	/* When the packet rate is below pkt_rate_high but above
+	 * pkt_rate_low (both measured in packets per second) the
+	 * normal {rx,tx}_* coalescing parameters are used.
+	 */
+
+	/* When the packet rate is (measured in packets per second)
+	 * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+	 * used.
+	 */
+	u32	pkt_rate_high;
+	u32	rx_coalesce_usecs_high;
+	u32	rx_max_coalesced_frames_high;
+	u32	tx_coalesce_usecs_high;
+	u32	tx_max_coalesced_frames_high;
+
+	/* How often to do adaptive coalescing packet rate sampling,
+	 * measured in seconds.  Must not be zero.
+	 */
+	u32	rate_sample_interval;
+};
+#endif /* ETHTOOL_GCOALESCE */
+
+#ifndef ETHTOOL_SCOALESCE
+#define ETHTOOL_SCOALESCE	0x0000000f /* Set coalesce config. */
+#endif
+#ifndef ETHTOOL_GRINGPARAM
+#define ETHTOOL_GRINGPARAM	0x00000010 /* Get ring parameters */
+/* for configuring RX/TX ring parameters */
+#define ethtool_ringparam _kc_ethtool_ringparam
+struct _kc_ethtool_ringparam {
+	u32	cmd;	/* ETHTOOL_{G,S}RINGPARAM */
+
+	/* Read only attributes.  These indicate the maximum number
+	 * of pending RX/TX ring entries the driver will allow the
+	 * user to set.
+	 */
+	u32	rx_max_pending;
+	u32	rx_mini_max_pending;
+	u32	rx_jumbo_max_pending;
+	u32	tx_max_pending;
+
+	/* Values changeable by the user.  The valid values are
+	 * in the range 1 to the "*_max_pending" counterpart above.
+	 */
+	u32	rx_pending;
+	u32	rx_mini_pending;
+	u32	rx_jumbo_pending;
+	u32	tx_pending;
+};
+#endif /* ETHTOOL_GRINGPARAM */
+
+#ifndef ETHTOOL_SRINGPARAM
+#define ETHTOOL_SRINGPARAM	0x00000011 /* Set ring parameters, priv. */
+#endif
+#ifndef ETHTOOL_GPAUSEPARAM
+#define ETHTOOL_GPAUSEPARAM	0x00000012 /* Get pause parameters */
+/* for configuring link flow control parameters */
+#define ethtool_pauseparam _kc_ethtool_pauseparam
+struct _kc_ethtool_pauseparam {
+	u32	cmd;	/* ETHTOOL_{G,S}PAUSEPARAM */
+
+	/* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+	 * being true) the user may set 'autoneg' here non-zero to have the
+	 * pause parameters be auto-negotiated too.  In such a case, the
+	 * {rx,tx}_pause values below determine what capabilities are
+	 * advertised.
+	 *
+	 * If 'autoneg' is zero or the link is not being auto-negotiated,
+	 * then {rx,tx}_pause force the driver to use/not-use pause
+	 * flow control.
+	 */
+	u32	autoneg;
+	u32	rx_pause;
+	u32	tx_pause;
+};
+#endif /* ETHTOOL_GPAUSEPARAM */
+
+#ifndef ETHTOOL_SPAUSEPARAM
+#define ETHTOOL_SPAUSEPARAM	0x00000013 /* Set pause parameters. */
+#endif
+#ifndef ETHTOOL_GRXCSUM
+#define ETHTOOL_GRXCSUM		0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SRXCSUM
+#define ETHTOOL_SRXCSUM		0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GTXCSUM
+#define ETHTOOL_GTXCSUM		0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STXCSUM
+#define ETHTOOL_STXCSUM		0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GSG
+#define ETHTOOL_GSG		0x00000018 /* Get scatter-gather enable
+					    * (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SSG
+#define ETHTOOL_SSG		0x00000019 /* Set scatter-gather enable
+					    * (ethtool_value). */
+#endif
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST		0x0000001a /* execute NIC self-test, priv. */
+#endif
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS	0x0000001b /* get specified string set */
+#endif
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID		0x0000001c /* identify the NIC */
+#endif
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS		0x0000001d /* get NIC-specific statistics */
+#endif
+#ifndef ETHTOOL_GTSO
+#define ETHTOOL_GTSO		0x0000001e /* Get TSO enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STSO
+#define ETHTOOL_STSO		0x0000001f /* Set TSO enable (ethtool_value) */
+#endif
+
+#ifndef ETHTOOL_BUSINFO_LEN
+#define ETHTOOL_BUSINFO_LEN	32
+#endif
+
+#ifndef WAKE_FILTER
+#define WAKE_FILTER	BIT(7)
+#endif
+
+#ifndef SPEED_2500
+#define SPEED_2500 2500
+#endif
+#ifndef SPEED_5000
+#define SPEED_5000 5000
+#endif
+#ifndef SPEED_14000
+#define SPEED_14000 14000
+#endif
+#ifndef SPEED_25000
+#define SPEED_25000 25000
+#endif
+#ifndef SPEED_50000
+#define SPEED_50000 50000
+#endif
+#ifndef SPEED_56000
+#define SPEED_56000 56000
+#endif
+#ifndef SPEED_100000
+#define SPEED_100000 100000
+#endif
+
+#ifndef RHEL_RELEASE_VERSION
+#define RHEL_RELEASE_VERSION(a,b) (((a) << 8) + (b))
+#endif
+#ifndef AX_RELEASE_VERSION
+#define AX_RELEASE_VERSION(a,b) (((a) << 8) + (b))
+#endif
+
+#ifndef AX_RELEASE_CODE
+#define AX_RELEASE_CODE 0
+#endif
+
+#if (AX_RELEASE_CODE && AX_RELEASE_CODE == AX_RELEASE_VERSION(3,0))
+#define RHEL_RELEASE_CODE RHEL_RELEASE_VERSION(5,0)
+#elif (AX_RELEASE_CODE && AX_RELEASE_CODE == AX_RELEASE_VERSION(3,1))
+#define RHEL_RELEASE_CODE RHEL_RELEASE_VERSION(5,1)
+#elif (AX_RELEASE_CODE && AX_RELEASE_CODE == AX_RELEASE_VERSION(3,2))
+#define RHEL_RELEASE_CODE RHEL_RELEASE_VERSION(5,3)
+#endif
+
+#ifndef RHEL_RELEASE_CODE
+/* NOTE: RHEL_RELEASE_* introduced in RHEL4.5 */
+#define RHEL_RELEASE_CODE 0
+#endif
+
+/* RHEL 7 didn't backport the parameter change in
+ * create_singlethread_workqueue.
+ * If/when RH corrects this we will want to tighten up the version check.
+ */
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,0))
+#undef create_singlethread_workqueue
+#define create_singlethread_workqueue(name)	\
+	alloc_ordered_workqueue("%s", WQ_MEM_RECLAIM, name)
+#endif
+
+/* Ubuntu Release ABI is the 4th digit of their kernel version. You can find
+ * it in /usr/src/linux/$(uname -r)/include/generated/utsrelease.h for new
+ * enough versions of Ubuntu. Otherwise you can simply see it in the output of
+ * uname as the 4th digit of the kernel. The UTS_UBUNTU_RELEASE_ABI is not in
+ * the linux-source package, but in the linux-headers package. It begins to
+ * appear in later releases of 14.04 and 14.10.
+ *
+ * Ex:
+ * <Ubuntu 14.04.1>
+ *  $uname -r
+ *  3.13.0-45-generic
+ * ABI is 45
+ *
+ * <Ubuntu 14.10>
+ *  $uname -r
+ *  3.16.0-23-generic
+ * ABI is 23
+ */
+#ifndef UTS_UBUNTU_RELEASE_ABI
+#define UTS_UBUNTU_RELEASE_ABI 0
+#define UBUNTU_VERSION_CODE 0
+#else
+/* Ubuntu does not provide actual release version macro, so we use the kernel
+ * version plus the ABI to generate a unique version code specific to Ubuntu.
+ * In addition, we mask the lower 8 bits of LINUX_VERSION_CODE in order to
+ * ignore differences in sublevel which are not important since we have the
+ * ABI value. Otherwise, it becomes impossible to correlate ABI to version for
+ * ordering checks.
+ */
+#define UBUNTU_VERSION_CODE (((~0xFF & LINUX_VERSION_CODE) << 8) + \
+			     UTS_UBUNTU_RELEASE_ABI)
+
+#if UTS_UBUNTU_RELEASE_ABI > 255
+#error UTS_UBUNTU_RELEASE_ABI is too large...
+#endif /* UTS_UBUNTU_RELEASE_ABI > 255 */
+
+#if ( LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0) )
+/* Our version code scheme does not make sense for non 3.x or newer kernels,
+ * and we have no support in kcompat for this scenario. Thus, treat this as a
+ * non-Ubuntu kernel. Possibly might be better to error here.
+ */
+#define UTS_UBUNTU_RELEASE_ABI 0
+#define UBUNTU_VERSION_CODE 0
+#endif
+
+#endif
+
+/* Note that the 3rd digit is always zero, and will be ignored. This is
+ * because Ubuntu kernels are based on x.y.0-ABI values, and while their linux
+ * version codes are 3 digit, this 3rd digit is superseded by the ABI value.
+ */
+#define UBUNTU_VERSION(a,b,c,d) ((KERNEL_VERSION(a,b,0) << 8) + (d))
+
+/* SuSE version macros are the same as Linux kernel version macro */
+#ifndef SLE_VERSION
+#define SLE_VERSION(a,b,c)	KERNEL_VERSION(a,b,c)
+#endif
+#define SLE_LOCALVERSION(a,b,c)	KERNEL_VERSION(a,b,c)
+#ifdef CONFIG_SUSE_KERNEL
+#if ( LINUX_VERSION_CODE == KERNEL_VERSION(2,6,27) )
+/* SLES11 GA is 2.6.27 based */
+#define SLE_VERSION_CODE SLE_VERSION(11,0,0)
+#elif ( LINUX_VERSION_CODE == KERNEL_VERSION(2,6,32) )
+/* SLES11 SP1 is 2.6.32 based */
+#define SLE_VERSION_CODE SLE_VERSION(11,1,0)
+#elif ( LINUX_VERSION_CODE == KERNEL_VERSION(3,0,13) )
+/* SLES11 SP2 GA is 3.0.13-0.27 */
+#define SLE_VERSION_CODE SLE_VERSION(11,2,0)
+#elif ((LINUX_VERSION_CODE == KERNEL_VERSION(3,0,76)))
+/* SLES11 SP3 GA is 3.0.76-0.11 */
+#define SLE_VERSION_CODE SLE_VERSION(11,3,0)
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(3,0,101))
+  #if (SLE_LOCALVERSION_CODE < SLE_LOCALVERSION(0,8,0))
+  /* some SLES11sp2 update kernels up to 3.0.101-0.7.x */
+  #define SLE_VERSION_CODE SLE_VERSION(11,2,0)
+  #elif (SLE_LOCALVERSION_CODE < SLE_LOCALVERSION(63,0,0))
+  /* most SLES11sp3 update kernels */
+  #define SLE_VERSION_CODE SLE_VERSION(11,3,0)
+  #else
+  /* SLES11 SP4 GA (3.0.101-63) and update kernels 3.0.101-63+ */
+  #define SLE_VERSION_CODE SLE_VERSION(11,4,0)
+  #endif
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(3,12,28))
+/* SLES12 GA is 3.12.28-4
+ * kernel updates 3.12.xx-<33 through 52>[.yy] */
+#define SLE_VERSION_CODE SLE_VERSION(12,0,0)
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(3,12,49))
+/* SLES12 SP1 GA is 3.12.49-11
+ * updates 3.12.xx-60.yy where xx={51..} */
+#define SLE_VERSION_CODE SLE_VERSION(12,1,0)
+#elif ((LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,21) && \
+       (LINUX_VERSION_CODE <= KERNEL_VERSION(4,4,59))) || \
+       (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,74) && \
+        LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) && \
+        SLE_LOCALVERSION_CODE >= KERNEL_VERSION(92,0,0) && \
+        SLE_LOCALVERSION_CODE <  KERNEL_VERSION(93,0,0)))
+/* SLES12 SP2 GA is 4.4.21-69.
+ * SLES12 SP2 updates before SLES12 SP3 are: 4.4.{21,38,49,59}
+ * SLES12 SP2 updates after SLES12 SP3 are: 4.4.{74,90,103,114,120}
+ * but they all use a SLE_LOCALVERSION_CODE matching 92.nn.y */
+#define SLE_VERSION_CODE SLE_VERSION(12,2,0)
+#elif ((LINUX_VERSION_CODE == KERNEL_VERSION(4,4,73) || \
+        LINUX_VERSION_CODE == KERNEL_VERSION(4,4,82) || \
+        LINUX_VERSION_CODE == KERNEL_VERSION(4,4,92)) || \
+       (LINUX_VERSION_CODE == KERNEL_VERSION(4,4,103) && \
+       (SLE_LOCALVERSION_CODE == KERNEL_VERSION(6,33,0) || \
+        SLE_LOCALVERSION_CODE == KERNEL_VERSION(6,38,0))) || \
+       (LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,114) && \
+        LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0) && \
+        SLE_LOCALVERSION_CODE >= KERNEL_VERSION(94,0,0) && \
+        SLE_LOCALVERSION_CODE <  KERNEL_VERSION(95,0,0)) )
+/* SLES12 SP3 GM is 4.4.73-5 and update kernels are 4.4.82-6.3.
+ * SLES12 SP3 updates not conflicting with SP2 are: 4.4.{82,92}
+ * SLES12 SP3 updates conflicting with SP2 are:
+ *   - 4.4.103-6.33.1, 4.4.103-6.38.1
+ *   - 4.4.{114,120}-94.nn.y */
+#define SLE_VERSION_CODE SLE_VERSION(12,3,0)
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(4,12,14) && \
+       (SLE_LOCALVERSION_CODE == KERNEL_VERSION(94,41,0) || \
+       (SLE_LOCALVERSION_CODE >= KERNEL_VERSION(95,0,0) && \
+        SLE_LOCALVERSION_CODE < KERNEL_VERSION(96,0,0))))
+/* SLES12 SP4 GM is 4.12.14-94.41 and update kernel is 4.12.14-95.x. */
+#define SLE_VERSION_CODE SLE_VERSION(12,4,0)
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(4,12,14) && \
+       (SLE_LOCALVERSION_CODE == KERNEL_VERSION(23,0,0) || \
+        SLE_LOCALVERSION_CODE == KERNEL_VERSION(2,0,0) || \
+        SLE_LOCALVERSION_CODE == KERNEL_VERSION(136,0,0) || \
+        (SLE_LOCALVERSION_CODE >= KERNEL_VERSION(25,0,0) && \
+	 SLE_LOCALVERSION_CODE < KERNEL_VERSION(26,0,0)) || \
+	(SLE_LOCALVERSION_CODE >= KERNEL_VERSION(150,0,0) && \
+	 SLE_LOCALVERSION_CODE < KERNEL_VERSION(151,0,0))))
+/* SLES15 Beta1 is 4.12.14-2
+ * SLES15 GM is 4.12.14-23 and update kernel is 4.12.14-{25,136},
+ * and 4.12.14-150.14.
+ */
+#define SLE_VERSION_CODE SLE_VERSION(15,0,0)
+#elif (LINUX_VERSION_CODE == KERNEL_VERSION(4,12,14) && \
+       SLE_LOCALVERSION_CODE >= KERNEL_VERSION(25,23,0))
+/* SLES15 SP1 Beta1 is 4.12.14-25.23 */
+#define SLE_VERSION_CODE SLE_VERSION(15,1,0)
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5,3,13))
+/* SLES15 SP2 Beta1 is 5.3.13 */
+#define SLE_VERSION_CODE SLE_VERSION(15,2,0)
+
+/* new SLES kernels must be added here with >= based on kernel
+ * the idea is to order from newest to oldest and just catch all
+ * of them using the >=
+ */
+#endif /* LINUX_VERSION_CODE == KERNEL_VERSION(x,y,z) */
+#endif /* CONFIG_SUSE_KERNEL */
+#ifndef SLE_VERSION_CODE
+#define SLE_VERSION_CODE 0
+#endif /* SLE_VERSION_CODE */
+#ifndef SLE_LOCALVERSION_CODE
+#define SLE_LOCALVERSION_CODE 0
+#endif /* SLE_LOCALVERSION_CODE */
+
+/*
+ * ADQ depends on __TC_MQPRIO_MODE_MAX and related kernel code
+ * added around 4.15. Some distributions (e.g. Oracle Linux 7.7)
+ * have done a partial back-port of that to their kernels based
+ * on older mainline kernels that did not include all the necessary
+ * kernel enablement to support ADQ.
+ * Undefine __TC_MQPRIO_MODE_MAX for all OSV distributions with
+ * kernels based on mainline kernels older than 4.15 except for
+ * RHEL, SLES and Ubuntu which are known to have good back-ports.
+ */
+#if (!RHEL_RELEASE_CODE && !SLE_VERSION_CODE && !UBUNTU_VERSION_CODE)
+  #if (LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
+  #undef __TC_MQPRIO_MODE_MAX
+  #endif /*  LINUX_VERSION_CODE == KERNEL_VERSION(4,15,0) */
+#endif /* if (NOT RHEL && NOT SLES && NOT UBUNTU) */
+
+#ifdef __KLOCWORK__
+/* The following are not compiled into the binary driver; they are here
+ * only to tune Klocwork scans to workaround false-positive issues.
+ */
+#ifdef ARRAY_SIZE
+#undef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+#define memcpy(dest, src, len)	memcpy_s(dest, len, src, len)
+#define memset(dest, ch, len)	memset_s(dest, len, ch, len)
+
+static inline int _kc_test_and_clear_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = BIT_MASK(nr);
+	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
+	unsigned long old;
+	unsigned long flags = 0;
+
+	_atomic_spin_lock_irqsave(p, flags);
+	old = *p;
+	*p = old & ~mask;
+	_atomic_spin_unlock_irqrestore(p, flags);
+
+	return (old & mask) != 0;
+}
+#define test_and_clear_bit(nr, addr) _kc_test_and_clear_bit(nr, addr)
+
+static inline int _kc_test_and_set_bit(int nr, volatile unsigned long *addr)
+{
+	unsigned long mask = BIT_MASK(nr);
+	unsigned long *p = ((unsigned long *)addr) + BIT_WORD(nr);
+	unsigned long old;
+	unsigned long flags = 0;
+
+	_atomic_spin_lock_irqsave(p, flags);
+	old = *p;
+	*p = old | mask;
+	_atomic_spin_unlock_irqrestore(p, flags);
+
+	return (old & mask) != 0;
+}
+#define test_and_set_bit(nr, addr) _kc_test_and_set_bit(nr, addr)
+
+#ifdef CONFIG_DYNAMIC_DEBUG
+#undef dev_dbg
+#define dev_dbg(dev, format, arg...) dev_printk(KERN_DEBUG, dev, format, ##arg)
+#undef pr_debug
+#define pr_debug(format, arg...) printk(KERN_DEBUG format, ##arg)
+#endif /* CONFIG_DYNAMIC_DEBUG */
+
+#undef hlist_for_each_entry_safe
+#define hlist_for_each_entry_safe(pos, n, head, member)			     \
+	for (n = NULL, pos = hlist_entry_safe((head)->first, typeof(*(pos)), \
+					      member);			     \
+	     pos;							     \
+	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
+
+#ifdef uninitialized_var
+#undef uninitialized_var
+#define uninitialized_var(x) x = *(&(x))
+#endif
+#endif /* __KLOCWORK__ */
+
+/* Older versions of GCC will trigger -Wformat-nonliteral warnings for const
+ * char * strings. Unfortunately, the implementation of do_trace_printk does
+ * this, in order to add a storage attribute to the memory. This was fixed in
+ * GCC 5.1, but we still use older distributions built with GCC 4.x.
+ *
+ * The string pointer is only passed as a const char * to the __trace_bprintk
+ * function. Since that function has the __printf attribute, it will trigger
+ * the warnings. We can't remove the attribute, so instead we'll use the
+ * __diag macro to disable -Wformat-nonliteral around the call to
+ * __trace_bprintk.
+ */
+#if GCC_VERSION < 50100
+#define __trace_bprintk(ip, fmt, args...) ({		\
+	int err;					\
+	__diag_push();					\
+	__diag(ignored "-Wformat-nonliteral");		\
+	err = __trace_bprintk(ip, fmt, ##args);		\
+	__diag_pop();					\
+	err;						\
+})
+#endif /* GCC_VERSION < 5.1.0 */
+
+/* Newer kernels removed <linux/pci-aspm.h> */
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,3)))
+#define HAVE_PCI_ASPM_H
+#endif
+
+/*****************************************************************************/
+/* 2.4.3 => 2.4.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,3) )
+
+/**************************************/
+/* PCI DRIVER API */
+
+#ifndef pci_set_dma_mask
+#define pci_set_dma_mask _kc_pci_set_dma_mask
+int _kc_pci_set_dma_mask(struct pci_dev *dev, dma_addr_t mask);
+#endif
+
+#ifndef pci_request_regions
+#define pci_request_regions _kc_pci_request_regions
+int _kc_pci_request_regions(struct pci_dev *pdev, char *res_name);
+#endif
+
+#ifndef pci_release_regions
+#define pci_release_regions _kc_pci_release_regions
+void _kc_pci_release_regions(struct pci_dev *pdev);
+#endif
+
+/**************************************/
+/* NETWORK DRIVER API */
+
+#ifndef alloc_etherdev
+#define alloc_etherdev _kc_alloc_etherdev
+struct net_device * _kc_alloc_etherdev(int sizeof_priv);
+#endif
+
+#ifndef is_valid_ether_addr
+#define is_valid_ether_addr _kc_is_valid_ether_addr
+int _kc_is_valid_ether_addr(u8 *addr);
+#endif
+
+/**************************************/
+/* MISCELLANEOUS */
+
+#ifndef INIT_TQUEUE
+#define INIT_TQUEUE(_tq, _routine, _data)		\
+	do {						\
+		INIT_LIST_HEAD(&(_tq)->list);		\
+		(_tq)->sync = 0;			\
+		(_tq)->routine = _routine;		\
+		(_tq)->data = _data;			\
+	} while (0)
+#endif
+
+#endif /* 2.4.3 => 2.4.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,5) )
+/* Generic MII registers. */
+#define MII_BMCR            0x00        /* Basic mode control register */
+#define MII_BMSR            0x01        /* Basic mode status register  */
+#define MII_PHYSID1         0x02        /* PHYS ID 1                   */
+#define MII_PHYSID2         0x03        /* PHYS ID 2                   */
+#define MII_ADVERTISE       0x04        /* Advertisement control reg   */
+#define MII_LPA             0x05        /* Link partner ability reg    */
+#define MII_EXPANSION       0x06        /* Expansion register          */
+/* Basic mode control register. */
+#define BMCR_FULLDPLX           0x0100  /* Full duplex                 */
+#define BMCR_ANENABLE           0x1000  /* Enable auto negotiation     */
+/* Basic mode status register. */
+#define BMSR_ERCAP              0x0001  /* Ext-reg capability          */
+#define BMSR_ANEGCAPABLE        0x0008  /* Able to do auto-negotiation */
+#define BMSR_10HALF             0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL             0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF            0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL            0x4000  /* Can do 100mbps, full-duplex */
+/* Advertisement control register. */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_ALL (ADVERTISE_10HALF | ADVERTISE_10FULL | \
+                       ADVERTISE_100HALF | ADVERTISE_100FULL)
+/* Expansion register for auto-negotiation. */
+#define EXPANSION_ENABLENPAGE   0x0004  /* This enables npage words    */
+#endif
+
+/*****************************************************************************/
+/* 2.4.6 => 2.4.3 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,6) )
+
+#ifndef pci_set_power_state
+#define pci_set_power_state _kc_pci_set_power_state
+int _kc_pci_set_power_state(struct pci_dev *dev, int state);
+#endif
+
+#ifndef pci_enable_wake
+#define pci_enable_wake _kc_pci_enable_wake
+int _kc_pci_enable_wake(struct pci_dev *pdev, u32 state, int enable);
+#endif
+
+#ifndef pci_disable_device
+#define pci_disable_device _kc_pci_disable_device
+void _kc_pci_disable_device(struct pci_dev *pdev);
+#endif
+
+/* PCI PM entry point syntax changed, so don't support suspend/resume */
+#undef CONFIG_PM
+
+#endif /* 2.4.6 => 2.4.3 */
+
+#ifndef HAVE_PCI_SET_MWI
+#define pci_set_mwi(X) pci_write_config_word(X, \
+			       PCI_COMMAND, adapter->hw.bus.pci_cmd_word | \
+			       PCI_COMMAND_INVALIDATE);
+#define pci_clear_mwi(X) pci_write_config_word(X, \
+			       PCI_COMMAND, adapter->hw.bus.pci_cmd_word & \
+			       ~PCI_COMMAND_INVALIDATE);
+#endif
+
+/*****************************************************************************/
+/* 2.4.10 => 2.4.9 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,10) )
+
+/**************************************/
+/* MODULE API */
+
+#ifndef MODULE_LICENSE
+	#define MODULE_LICENSE(X)
+#endif
+
+/**************************************/
+/* OTHER */
+
+#undef min
+#define min(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x < _y ? _x : _y; })
+
+#undef max
+#define max(x,y) ({ \
+	const typeof(x) _x = (x);	\
+	const typeof(y) _y = (y);	\
+	(void) (&_x == &_y);		\
+	_x > _y ? _x : _y; })
+
+#define min_t(type,x,y) ({ \
+	type _x = (x); \
+	type _y = (y); \
+	_x < _y ? _x : _y; })
+
+#define max_t(type,x,y) ({ \
+	type _x = (x); \
+	type _y = (y); \
+	_x > _y ? _x : _y; })
+
+#ifndef list_for_each_safe
+#define list_for_each_safe(pos, n, head) \
+	for (pos = (head)->next, n = pos->next; pos != (head); \
+		pos = n, n = pos->next)
+#endif
+
+#ifndef ____cacheline_aligned_in_smp
+#ifdef CONFIG_SMP
+#define ____cacheline_aligned_in_smp ____cacheline_aligned
+#else
+#define ____cacheline_aligned_in_smp
+#endif /* CONFIG_SMP */
+#endif
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,8) )
+int _kc_snprintf(char * buf, size_t size, const char *fmt, ...);
+#define snprintf(buf, size, fmt, args...) _kc_snprintf(buf, size, fmt, ##args)
+int _kc_vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+#define vsnprintf(buf, size, fmt, args) _kc_vsnprintf(buf, size, fmt, args)
+#else /* 2.4.8 => 2.4.9 */
+int snprintf(char * buf, size_t size, const char *fmt, ...);
+int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+#endif
+#endif /* 2.4.10 -> 2.4.6 */
+
+
+/*****************************************************************************/
+/* 2.4.12 => 2.4.10 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,12) )
+#ifndef HAVE_NETIF_MSG
+#define HAVE_NETIF_MSG 1
+enum {
+	NETIF_MSG_DRV		= 0x0001,
+	NETIF_MSG_PROBE		= 0x0002,
+	NETIF_MSG_LINK		= 0x0004,
+	NETIF_MSG_TIMER		= 0x0008,
+	NETIF_MSG_IFDOWN	= 0x0010,
+	NETIF_MSG_IFUP		= 0x0020,
+	NETIF_MSG_RX_ERR	= 0x0040,
+	NETIF_MSG_TX_ERR	= 0x0080,
+	NETIF_MSG_TX_QUEUED	= 0x0100,
+	NETIF_MSG_INTR		= 0x0200,
+	NETIF_MSG_TX_DONE	= 0x0400,
+	NETIF_MSG_RX_STATUS	= 0x0800,
+	NETIF_MSG_PKTDATA	= 0x1000,
+	NETIF_MSG_HW		= 0x2000,
+	NETIF_MSG_WOL		= 0x4000,
+};
+
+#define netif_msg_drv(p)	((p)->msg_enable & NETIF_MSG_DRV)
+#define netif_msg_probe(p)	((p)->msg_enable & NETIF_MSG_PROBE)
+#define netif_msg_link(p)	((p)->msg_enable & NETIF_MSG_LINK)
+#define netif_msg_timer(p)	((p)->msg_enable & NETIF_MSG_TIMER)
+#define netif_msg_ifdown(p)	((p)->msg_enable & NETIF_MSG_IFDOWN)
+#define netif_msg_ifup(p)	((p)->msg_enable & NETIF_MSG_IFUP)
+#define netif_msg_rx_err(p)	((p)->msg_enable & NETIF_MSG_RX_ERR)
+#define netif_msg_tx_err(p)	((p)->msg_enable & NETIF_MSG_TX_ERR)
+#define netif_msg_tx_queued(p)	((p)->msg_enable & NETIF_MSG_TX_QUEUED)
+#define netif_msg_intr(p)	((p)->msg_enable & NETIF_MSG_INTR)
+#define netif_msg_tx_done(p)	((p)->msg_enable & NETIF_MSG_TX_DONE)
+#define netif_msg_rx_status(p)	((p)->msg_enable & NETIF_MSG_RX_STATUS)
+#define netif_msg_pktdata(p)	((p)->msg_enable & NETIF_MSG_PKTDATA)
+#endif /* !HAVE_NETIF_MSG */
+#endif /* 2.4.12 => 2.4.10 */
+
+/*****************************************************************************/
+/* 2.4.13 => 2.4.12 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,13) )
+
+/**************************************/
+/* PCI DMA MAPPING */
+
+#ifndef virt_to_page
+	#define virt_to_page(v) (mem_map + (virt_to_phys(v) >> PAGE_SHIFT))
+#endif
+
+#ifndef pci_map_page
+#define pci_map_page _kc_pci_map_page
+u64 _kc_pci_map_page(struct pci_dev *dev, struct page *page, unsigned long offset, size_t size, int direction);
+#endif
+
+#ifndef pci_unmap_page
+#define pci_unmap_page _kc_pci_unmap_page
+void _kc_pci_unmap_page(struct pci_dev *dev, u64 dma_addr, size_t size, int direction);
+#endif
+
+/* pci_set_dma_mask takes dma_addr_t, which is only 32-bits prior to 2.4.13 */
+
+#undef DMA_32BIT_MASK
+#define DMA_32BIT_MASK	0xffffffff
+#undef DMA_64BIT_MASK
+#define DMA_64BIT_MASK	0xffffffff
+
+/**************************************/
+/* OTHER */
+
+#ifndef cpu_relax
+#define cpu_relax()	rep_nop()
+#endif
+
+struct vlan_ethhdr {
+	unsigned char h_dest[ETH_ALEN];
+	unsigned char h_source[ETH_ALEN];
+	unsigned short h_vlan_proto;
+	unsigned short h_vlan_TCI;
+	unsigned short h_vlan_encapsulated_proto;
+};
+#endif /* 2.4.13 => 2.4.12 */
+
+/*****************************************************************************/
+/* 2.4.17 => 2.4.12 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,17) )
+
+#ifndef __devexit_p
+	#define __devexit_p(x) &(x)
+#endif
+
+#endif /* 2.4.17 => 2.4.13 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18) )
+#define NETIF_MSG_HW	0x2000
+#define NETIF_MSG_WOL	0x4000
+
+#ifndef netif_msg_hw
+#define netif_msg_hw(p)		((p)->msg_enable & NETIF_MSG_HW)
+#endif
+#ifndef netif_msg_wol
+#define netif_msg_wol(p)	((p)->msg_enable & NETIF_MSG_WOL)
+#endif
+#endif /* 2.4.18 */
+
+/*****************************************************************************/
+
+/*****************************************************************************/
+/* 2.4.20 => 2.4.19 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,20) )
+
+/* we won't support NAPI on less than 2.4.20 */
+#ifdef NAPI
+#undef NAPI
+#endif
+
+#endif /* 2.4.20 => 2.4.19 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#define pci_name(x)	((x)->slot_name)
+
+#ifndef SUPPORTED_10000baseT_Full
+#define SUPPORTED_10000baseT_Full	BIT(12)
+#endif
+#ifndef ADVERTISED_10000baseT_Full
+#define ADVERTISED_10000baseT_Full	BIT(12)
+#endif
+#endif
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#endif
+
+/*****************************************************************************/
+/*****************************************************************************/
+/* 2.4.23 => 2.4.22 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23) )
+/*****************************************************************************/
+#ifdef NAPI
+#ifndef netif_poll_disable
+#define netif_poll_disable(x) _kc_netif_poll_disable(x)
+static inline void _kc_netif_poll_disable(struct net_device *netdev)
+{
+	while (test_and_set_bit(__LINK_STATE_RX_SCHED, &netdev->state)) {
+		/* No hurry */
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(1);
+	}
+}
+#endif
+#ifndef netif_poll_enable
+#define netif_poll_enable(x) _kc_netif_poll_enable(x)
+static inline void _kc_netif_poll_enable(struct net_device *netdev)
+{
+	clear_bit(__LINK_STATE_RX_SCHED, &netdev->state);
+}
+#endif
+#endif /* NAPI */
+#ifndef netif_tx_disable
+#define netif_tx_disable(x) _kc_netif_tx_disable(x)
+static inline void _kc_netif_tx_disable(struct net_device *dev)
+{
+	spin_lock_bh(&dev->xmit_lock);
+	netif_stop_queue(dev);
+	spin_unlock_bh(&dev->xmit_lock);
+}
+#endif
+#else /* 2.4.23 => 2.4.22 */
+#define HAVE_SCTP
+#endif /* 2.4.23 => 2.4.22 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25) || \
+    ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) ) )
+#define ETHTOOL_OPS_COMPAT
+#endif /* 2.6.4 => 2.6.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27) )
+#define __user
+#endif /* < 2.4.27 */
+
+/*****************************************************************************/
+/* 2.5.71 => 2.4.x */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,71) )
+#define sk_protocol protocol
+#define pci_get_device pci_find_device
+#endif /* 2.5.70 => 2.4.x */
+
+/*****************************************************************************/
+/* < 2.4.27 or 2.6.0 <= 2.6.5 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27) || \
+    ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5) ) )
+
+#ifndef netif_msg_init
+#define netif_msg_init _kc_netif_msg_init
+static inline u32 _kc_netif_msg_init(int debug_value, int default_msg_enable_bits)
+{
+	/* use default */
+	if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
+		return default_msg_enable_bits;
+	if (debug_value == 0) /* no output */
+		return 0;
+	/* set low N bits */
+	return (1 << debug_value) -1;
+}
+#endif
+
+#endif /* < 2.4.27 or 2.6.0 <= 2.6.5 */
+/*****************************************************************************/
+#if (( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27) ) || \
+     (( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) ) && \
+      ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3) )))
+#define netdev_priv(x) x->priv
+#endif
+
+/*****************************************************************************/
+/* <= 2.5.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) )
+#include <linux/rtnetlink.h>
+#undef pci_register_driver
+#define pci_register_driver pci_module_init
+
+/*
+ * Most of the dma compat code is copied/modifed from the 2.4.37
+ * /include/linux/libata-compat.h header file
+ */
+/* These definitions mirror those in pci.h, so they can be used
+ * interchangeably with their PCI_ counterparts */
+enum dma_data_direction {
+	DMA_BIDIRECTIONAL = 0,
+	DMA_TO_DEVICE = 1,
+	DMA_FROM_DEVICE = 2,
+	DMA_NONE = 3,
+};
+
+struct device {
+	struct pci_dev pdev;
+};
+
+static inline struct pci_dev *to_pci_dev (struct device *dev)
+{
+	return (struct pci_dev *) dev;
+}
+static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
+{
+	return (struct device *) pdev;
+}
+#define pdev_printk(lvl, pdev, fmt, args...) 	\
+	printk("%s %s: " fmt, lvl, pci_name(pdev), ## args)
+#define dev_err(dev, fmt, args...)            \
+	pdev_printk(KERN_ERR, to_pci_dev(dev), fmt, ## args)
+#define dev_info(dev, fmt, args...)            \
+	pdev_printk(KERN_INFO, to_pci_dev(dev), fmt, ## args)
+#define dev_warn(dev, fmt, args...)            \
+	pdev_printk(KERN_WARNING, to_pci_dev(dev), fmt, ## args)
+#define dev_notice(dev, fmt, args...)            \
+	pdev_printk(KERN_NOTICE, to_pci_dev(dev), fmt, ## args)
+#define dev_dbg(dev, fmt, args...) \
+	pdev_printk(KERN_DEBUG, to_pci_dev(dev), fmt, ## args)
+
+/* NOTE: dangerous! we ignore the 'gfp' argument */
+#define dma_alloc_coherent(dev,sz,dma,gfp) \
+	pci_alloc_consistent(to_pci_dev(dev),(sz),(dma))
+#define dma_free_coherent(dev,sz,addr,dma_addr) \
+	pci_free_consistent(to_pci_dev(dev),(sz),(addr),(dma_addr))
+
+#define dma_map_page(dev,a,b,c,d) \
+	pci_map_page(to_pci_dev(dev),(a),(b),(c),(d))
+#define dma_unmap_page(dev,a,b,c) \
+	pci_unmap_page(to_pci_dev(dev),(a),(b),(c))
+
+#define dma_map_single(dev,a,b,c) \
+	pci_map_single(to_pci_dev(dev),(a),(b),(c))
+#define dma_unmap_single(dev,a,b,c) \
+	pci_unmap_single(to_pci_dev(dev),(a),(b),(c))
+
+#define dma_map_sg(dev, sg, nents, dir) \
+	pci_map_sg(to_pci_dev(dev), (sg), (nents), (dir)
+#define dma_unmap_sg(dev, sg, nents, dir) \
+	pci_unmap_sg(to_pci_dev(dev), (sg), (nents), (dir)
+
+#define dma_sync_single(dev,a,b,c) \
+	pci_dma_sync_single(to_pci_dev(dev),(a),(b),(c))
+
+/* for range just sync everything, that's all the pci API can do */
+#define dma_sync_single_range(dev,addr,off,sz,dir) \
+	pci_dma_sync_single(to_pci_dev(dev),(addr),(off)+(sz),(dir))
+
+#define dma_set_mask(dev,mask) \
+	pci_set_dma_mask(to_pci_dev(dev),(mask))
+
+/* hlist_* code - double linked lists */
+struct hlist_head {
+	struct hlist_node *first;
+};
+
+struct hlist_node {
+	struct hlist_node *next, **pprev;
+};
+
+static inline void __hlist_del(struct hlist_node *n)
+{
+	struct hlist_node *next = n->next;
+	struct hlist_node **pprev = n->pprev;
+	*pprev = next;
+	if (next)
+	next->pprev = pprev;
+}
+
+static inline void hlist_del(struct hlist_node *n)
+{
+	__hlist_del(n);
+	n->next = NULL;
+	n->pprev = NULL;
+}
+
+static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
+{
+	struct hlist_node *first = h->first;
+	n->next = first;
+	if (first)
+		first->pprev = &n->next;
+	h->first = n;
+	n->pprev = &h->first;
+}
+
+static inline int hlist_empty(const struct hlist_head *h)
+{
+	return !h->first;
+}
+#define HLIST_HEAD_INIT { .first = NULL }
+#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
+#define INIT_HLIST_HEAD(ptr) ((ptr)->first = NULL)
+static inline void INIT_HLIST_NODE(struct hlist_node *h)
+{
+	h->next = NULL;
+	h->pprev = NULL;
+}
+
+#ifndef might_sleep
+#define might_sleep()
+#endif
+#else
+static inline struct device *pci_dev_to_dev(struct pci_dev *pdev)
+{
+	return &pdev->dev;
+}
+#endif /* <= 2.5.0 */
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.23 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28) )
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#undef INIT_WORK
+#define INIT_WORK(a,b) INIT_TQUEUE(a,(void (*)(void *))b,a)
+#undef container_of
+#define container_of list_entry
+#define schedule_work schedule_task
+#define flush_scheduled_work flush_scheduled_tasks
+#define cancel_work_sync(x) flush_scheduled_work()
+
+#endif /* 2.5.28 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.0 => 2.5.28 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+#ifndef read_barrier_depends
+#define read_barrier_depends() rmb()
+#endif
+
+#ifndef rcu_head
+struct __kc_callback_head {
+	struct __kc_callback_head *next;
+	void (*func)(struct callback_head *head);
+};
+#define rcu_head __kc_callback_head
+#endif
+
+#undef get_cpu
+#define get_cpu() smp_processor_id()
+#undef put_cpu
+#define put_cpu() do { } while(0)
+#define MODULE_INFO(version, _version)
+#ifndef CONFIG_E1000_DISABLE_PACKET_SPLIT
+#define CONFIG_E1000_DISABLE_PACKET_SPLIT 1
+#endif
+#ifndef CONFIG_IGB_DISABLE_PACKET_SPLIT
+#define CONFIG_IGB_DISABLE_PACKET_SPLIT 1
+#endif
+#ifndef CONFIG_IGC_DISABLE_PACKET_SPLIT
+#define CONFIG_IGC_DISABLE_PACKET_SPLIT 1
+#endif
+
+#define dma_set_coherent_mask(dev,mask) 1
+
+#undef dev_put
+#define dev_put(dev) __dev_put(dev)
+
+#ifndef skb_fill_page_desc
+#define skb_fill_page_desc _kc_skb_fill_page_desc
+void _kc_skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size);
+#endif
+
+#undef ALIGN
+#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
+
+#ifndef page_count
+#define page_count(p) atomic_read(&(p)->count)
+#endif
+
+#ifdef MAX_NUMNODES
+#undef MAX_NUMNODES
+#endif
+#define MAX_NUMNODES 1
+
+/* find_first_bit and find_next bit are not defined for most
+ * 2.4 kernels (except for the redhat 2.4.21 kernels
+ */
+#include <linux/bitops.h>
+#define BITOP_WORD(nr)          ((nr) / BITS_PER_LONG)
+#undef find_next_bit
+#define find_next_bit _kc_find_next_bit
+unsigned long _kc_find_next_bit(const unsigned long *addr, unsigned long size,
+				unsigned long offset);
+#define find_first_bit(addr, size) find_next_bit((addr), (size), 0)
+
+#ifndef netdev_name
+static inline const char *_kc_netdev_name(const struct net_device *dev)
+{
+	if (strchr(dev->name, '%'))
+		return "(unregistered net_device)";
+	return dev->name;
+}
+#define netdev_name(netdev)	_kc_netdev_name(netdev)
+#endif /* netdev_name */
+
+#ifndef strlcpy
+#define strlcpy _kc_strlcpy
+size_t _kc_strlcpy(char *dest, const char *src, size_t size);
+#endif /* strlcpy */
+
+#ifndef do_div
+#if BITS_PER_LONG == 64
+# define do_div(n,base) ({					\
+	uint32_t __base = (base);				\
+	uint32_t __rem;						\
+	__rem = ((uint64_t)(n)) % __base;			\
+	(n) = ((uint64_t)(n)) / __base;				\
+	__rem;							\
+ })
+#elif BITS_PER_LONG == 32
+uint32_t _kc__div64_32(uint64_t *dividend, uint32_t divisor);
+# define do_div(n,base) ({				\
+	uint32_t __base = (base);			\
+	uint32_t __rem;					\
+	if (likely(((n) >> 32) == 0)) {			\
+		__rem = (uint32_t)(n) % __base;		\
+		(n) = (uint32_t)(n) / __base;		\
+	} else 						\
+		__rem = _kc__div64_32(&(n), __base);	\
+	__rem;						\
+ })
+#else /* BITS_PER_LONG == ?? */
+# error do_div() does not yet support the C64
+#endif /* BITS_PER_LONG */
+#endif /* do_div */
+
+#ifndef NSEC_PER_SEC
+#define NSEC_PER_SEC	1000000000L
+#endif
+
+#undef HAVE_I2C_SUPPORT
+#else /* 2.6.0 */
+
+#endif /* 2.6.0 => 2.5.28 */
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3) )
+#define dma_pool pci_pool
+#define dma_pool_destroy pci_pool_destroy
+#define dma_pool_alloc pci_pool_alloc
+#define dma_pool_free pci_pool_free
+
+#define dma_pool_create(name,dev,size,align,allocation) \
+       pci_pool_create((name),to_pci_dev(dev),(size),(align),(allocation))
+#endif /* < 2.6.3 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) )
+#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
+#endif /* 2.6.4 => 2.6.0 */
+
+/*****************************************************************************/
+/* 2.6.5 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5) )
+#define dma_sync_single_for_cpu		dma_sync_single
+#define dma_sync_single_for_device	dma_sync_single
+#define dma_sync_single_range_for_cpu		dma_sync_single_range
+#define dma_sync_single_range_for_device	dma_sync_single_range
+#ifndef pci_dma_mapping_error
+#define pci_dma_mapping_error _kc_pci_dma_mapping_error
+static inline int _kc_pci_dma_mapping_error(dma_addr_t dma_addr)
+{
+	return dma_addr == 0;
+}
+#endif
+#endif /* 2.6.5 => 2.6.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) )
+int _kc_scnprintf(char * buf, size_t size, const char *fmt, ...);
+#define scnprintf(buf, size, fmt, args...) _kc_scnprintf(buf, size, fmt, ##args)
+#endif /* < 2.6.4 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,6) )
+/* taken from 2.6 include/linux/bitmap.h */
+#undef bitmap_zero
+#define bitmap_zero _kc_bitmap_zero
+static inline void _kc_bitmap_zero(unsigned long *dst, int nbits)
+{
+        if (nbits <= BITS_PER_LONG)
+                *dst = 0UL;
+        else {
+                int len = BITS_TO_LONGS(nbits) * sizeof(unsigned long);
+                memset(dst, 0, len);
+        }
+}
+#define page_to_nid(x) 0
+
+#endif /* < 2.6.6 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7) )
+#undef if_mii
+#define if_mii _kc_if_mii
+static inline struct mii_ioctl_data *_kc_if_mii(struct ifreq *rq)
+{
+	return (struct mii_ioctl_data *) &rq->ifr_ifru;
+}
+
+#ifndef __force
+#define __force
+#endif
+#endif /* < 2.6.7 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8) )
+#ifndef PCI_EXP_DEVCTL
+#define PCI_EXP_DEVCTL 8
+#endif
+#ifndef PCI_EXP_DEVCTL_CERE
+#define PCI_EXP_DEVCTL_CERE 0x0001
+#endif
+#define PCI_EXP_FLAGS		2	/* Capabilities register */
+#define PCI_EXP_FLAGS_VERS	0x000f	/* Capability version */
+#define PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+#define  PCI_EXP_TYPE_ENDPOINT	0x0	/* Express Endpoint */
+#define  PCI_EXP_TYPE_LEG_END	0x1	/* Legacy Endpoint */
+#define  PCI_EXP_TYPE_ROOT_PORT 0x4	/* Root Port */
+#define  PCI_EXP_TYPE_DOWNSTREAM 0x6	/* Downstream Port */
+#define PCI_EXP_FLAGS_SLOT	0x0100	/* Slot implemented */
+#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+#define PCI_EXP_DEVSTA		10	/* Device Status */
+#define msleep(x)	do { set_current_state(TASK_UNINTERRUPTIBLE); \
+				schedule_timeout((x * HZ)/1000 + 2); \
+			} while (0)
+
+#endif /* < 2.6.8 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9))
+#include <net/dsfield.h>
+#define __iomem
+
+#ifndef kcalloc
+#define kcalloc(n, size, flags) _kc_kzalloc(((n) * (size)), flags)
+void *_kc_kzalloc(size_t size, int flags);
+#endif
+#define MSEC_PER_SEC    1000L
+static inline unsigned int _kc_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+	return (MSEC_PER_SEC / HZ) * j;
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+	return (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);
+#else
+	return (j * MSEC_PER_SEC) / HZ;
+#endif
+}
+static inline unsigned long _kc_msecs_to_jiffies(const unsigned int m)
+{
+	if (m > _kc_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+	return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+	return m * (HZ / MSEC_PER_SEC);
+#else
+	return (m * HZ + MSEC_PER_SEC - 1) / MSEC_PER_SEC;
+#endif
+}
+
+#define msleep_interruptible _kc_msleep_interruptible
+static inline unsigned long _kc_msleep_interruptible(unsigned int msecs)
+{
+	unsigned long timeout = _kc_msecs_to_jiffies(msecs) + 1;
+
+	while (timeout && !signal_pending(current)) {
+		__set_current_state(TASK_INTERRUPTIBLE);
+		timeout = schedule_timeout(timeout);
+	}
+	return _kc_jiffies_to_msecs(timeout);
+}
+
+/* Basic mode control register. */
+#define BMCR_SPEED1000		0x0040  /* MSB of Speed (1000)         */
+
+#ifndef __le16
+#define __le16 u16
+#endif
+#ifndef __le32
+#define __le32 u32
+#endif
+#ifndef __le64
+#define __le64 u64
+#endif
+#ifndef __be16
+#define __be16 u16
+#endif
+#ifndef __be32
+#define __be32 u32
+#endif
+#ifndef __be64
+#define __be64 u64
+#endif
+
+static inline struct vlan_ethhdr *vlan_eth_hdr(const struct sk_buff *skb)
+{
+	return (struct vlan_ethhdr *)skb->mac.raw;
+}
+
+/* Wake-On-Lan options. */
+#define WAKE_PHY		BIT(0)
+#define WAKE_UCAST		BIT(1)
+#define WAKE_MCAST		BIT(2)
+#define WAKE_BCAST		BIT(3)
+#define WAKE_ARP		BIT(4)
+#define WAKE_MAGIC		BIT(5)
+#define WAKE_MAGICSECURE	BIT(6) /* only meaningful if WAKE_MAGIC */
+
+#define skb_header_pointer _kc_skb_header_pointer
+static inline void *_kc_skb_header_pointer(const struct sk_buff *skb,
+					    int offset, int len, void *buffer)
+{
+	int hlen = skb_headlen(skb);
+
+	if (hlen - offset >= len)
+		return skb->data + offset;
+
+#ifdef MAX_SKB_FRAGS
+	if (skb_copy_bits(skb, offset, buffer, len) < 0)
+		return NULL;
+
+	return buffer;
+#else
+	return NULL;
+#endif
+
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK 0
+#endif
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY 1
+#endif
+#ifndef NETDEV_TX_LOCKED
+#define NETDEV_TX_LOCKED -1
+#endif
+}
+
+#ifndef __bitwise
+#define __bitwise
+#endif
+#endif /* < 2.6.9 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) )
+#ifdef module_param_array_named
+#undef module_param_array_named
+#define module_param_array_named(name, array, type, nump, perm)          \
+	static struct kparam_array __param_arr_##name                    \
+	= { ARRAY_SIZE(array), nump, param_set_##type, param_get_##type, \
+	    sizeof(array[0]), array };                                   \
+	module_param_call(name, param_array_set, param_array_get,        \
+			  &__param_arr_##name, perm)
+#endif /* module_param_array_named */
+/*
+ * num_online is broken for all < 2.6.10 kernels.  This is needed to support
+ * Node module parameter of ixgbe.
+ */
+#undef num_online_nodes
+#define num_online_nodes(n) 1
+extern DECLARE_BITMAP(_kcompat_node_online_map, MAX_NUMNODES);
+#undef node_online_map
+#define node_online_map _kcompat_node_online_map
+#define pci_get_class pci_find_class
+#endif /* < 2.6.10 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11) )
+#define PCI_D0      0
+#define PCI_D1      1
+#define PCI_D2      2
+#define PCI_D3hot   3
+#define PCI_D3cold  4
+typedef int pci_power_t;
+#define pci_choose_state(pdev,state) state
+#define PMSG_SUSPEND 3
+#define PCI_EXP_LNKCTL	16
+
+#undef NETIF_F_LLTX
+
+#ifndef ARCH_HAS_PREFETCH
+#define prefetch(X)
+#endif
+
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN 2
+#endif
+
+#define KC_USEC_PER_SEC	1000000L
+#define usecs_to_jiffies _kc_usecs_to_jiffies
+static inline unsigned int _kc_jiffies_to_usecs(const unsigned long j)
+{
+#if HZ <= KC_USEC_PER_SEC && !(KC_USEC_PER_SEC % HZ)
+	return (KC_USEC_PER_SEC / HZ) * j;
+#elif HZ > KC_USEC_PER_SEC && !(HZ % KC_USEC_PER_SEC)
+	return (j + (HZ / KC_USEC_PER_SEC) - 1)/(HZ / KC_USEC_PER_SEC);
+#else
+	return (j * KC_USEC_PER_SEC) / HZ;
+#endif
+}
+static inline unsigned long _kc_usecs_to_jiffies(const unsigned int m)
+{
+	if (m > _kc_jiffies_to_usecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+#if HZ <= KC_USEC_PER_SEC && !(KC_USEC_PER_SEC % HZ)
+	return (m + (KC_USEC_PER_SEC / HZ) - 1) / (KC_USEC_PER_SEC / HZ);
+#elif HZ > KC_USEC_PER_SEC && !(HZ % KC_USEC_PER_SEC)
+	return m * (HZ / KC_USEC_PER_SEC);
+#else
+	return (m * HZ + KC_USEC_PER_SEC - 1) / KC_USEC_PER_SEC;
+#endif
+}
+
+#define PCI_EXP_LNKCAP		12	/* Link Capabilities */
+#define PCI_EXP_LNKSTA		18	/* Link Status */
+#define PCI_EXP_SLTCAP		20	/* Slot Capabilities */
+#define PCI_EXP_SLTCTL		24	/* Slot Control */
+#define PCI_EXP_SLTSTA		26	/* Slot Status */
+#define PCI_EXP_RTCTL		28	/* Root Control */
+#define PCI_EXP_RTCAP		30	/* Root Capabilities */
+#define PCI_EXP_RTSTA		32	/* Root Status */
+#endif /* < 2.6.11 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12) )
+#include <linux/reboot.h>
+#define USE_REBOOT_NOTIFIER
+
+/* Generic MII registers. */
+#define MII_CTRL1000        0x09        /* 1000BASE-T control          */
+#define MII_STAT1000        0x0a        /* 1000BASE-T status           */
+/* Advertisement control register. */
+#define ADVERTISE_PAUSE_CAP     0x0400  /* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM    0x0800  /* Try for asymmetric pause     */
+/* Link partner ability register. */
+#define LPA_PAUSE_CAP		0x0400	/* Can pause                   */
+#define LPA_PAUSE_ASYM		0x0800	/* Can pause asymetrically     */
+/* 1000BASE-T Control register */
+#define ADVERTISE_1000FULL      0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF	0x0100  /* Advertise 1000BASE-T half duplex */
+/* 1000BASE-T Status register */
+#define LPA_1000LOCALRXOK	0x2000	/* Link partner local receiver status */
+#define LPA_1000REMRXOK		0x1000	/* Link partner remote receiver status */
+
+#ifndef is_zero_ether_addr
+#define is_zero_ether_addr _kc_is_zero_ether_addr
+static inline int _kc_is_zero_ether_addr(const u8 *addr)
+{
+	return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+#endif /* is_zero_ether_addr */
+#ifndef is_multicast_ether_addr
+#define is_multicast_ether_addr _kc_is_multicast_ether_addr
+static inline int _kc_is_multicast_ether_addr(const u8 *addr)
+{
+	return addr[0] & 0x01;
+}
+#endif /* is_multicast_ether_addr */
+#endif /* < 2.6.12 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) )
+#ifndef kstrdup
+#define kstrdup _kc_kstrdup
+char *_kc_kstrdup(const char *s, unsigned int gfp);
+#endif
+#endif /* < 2.6.13 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) )
+#define pm_message_t u32
+#ifndef kzalloc
+#define kzalloc _kc_kzalloc
+void *_kc_kzalloc(size_t size, int flags);
+#endif
+
+/* Generic MII registers. */
+#define MII_ESTATUS	    0x0f	/* Extended Status */
+/* Basic mode status register. */
+#define BMSR_ESTATEN		0x0100	/* Extended Status in R15 */
+/* Extended status register. */
+#define ESTATUS_1000_TFULL	0x2000	/* Can do 1000BT Full */
+#define ESTATUS_1000_THALF	0x1000	/* Can do 1000BT Half */
+
+#define SUPPORTED_Pause	        BIT(13)
+#define SUPPORTED_Asym_Pause	BIT(14)
+#define ADVERTISED_Pause	BIT(13)
+#define ADVERTISED_Asym_Pause	BIT(14)
+
+#if (!(RHEL_RELEASE_CODE && \
+       (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(4,3)) && \
+       (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,0))))
+#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2,6,9)) && !defined(gfp_t))
+#define gfp_t unsigned
+#else
+typedef unsigned gfp_t;
+#endif
+#endif /* !RHEL4.3->RHEL5.0 */
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9) )
+#ifdef CONFIG_X86_64
+#define dma_sync_single_range_for_cpu(dev, addr, off, sz, dir)       \
+	dma_sync_single_for_cpu((dev), (addr), (off) + (sz), (dir))
+#define dma_sync_single_range_for_device(dev, addr, off, sz, dir)    \
+	dma_sync_single_for_device((dev), (addr), (off) + (sz), (dir))
+#endif
+#endif
+#endif /* < 2.6.14 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15) )
+#ifndef kfree_rcu
+/* this is placed here due to a lack of rcu_barrier in previous kernels */
+#define kfree_rcu(_ptr, _offset) kfree(_ptr)
+#endif /* kfree_rcu */
+#ifndef vmalloc_node
+#define vmalloc_node(a,b) vmalloc(a)
+#endif /* vmalloc_node*/
+
+#define setup_timer(_timer, _function, _data) \
+do { \
+	(_timer)->function = _function; \
+	(_timer)->data = _data; \
+	init_timer(_timer); \
+} while (0)
+#ifndef device_can_wakeup
+#define device_can_wakeup(dev)	(1)
+#endif
+#ifndef device_set_wakeup_enable
+#define device_set_wakeup_enable(dev, val)	do{}while(0)
+#endif
+#ifndef device_init_wakeup
+#define device_init_wakeup(dev,val) do {} while (0)
+#endif
+static inline unsigned _kc_compare_ether_addr(const u8 *addr1, const u8 *addr2)
+{
+	const u16 *a = (const u16 *) addr1;
+	const u16 *b = (const u16 *) addr2;
+
+	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | (a[2] ^ b[2])) != 0;
+}
+#undef compare_ether_addr
+#define compare_ether_addr(addr1, addr2) _kc_compare_ether_addr(addr1, addr2)
+#endif /* < 2.6.15 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) )
+#undef DEFINE_MUTEX
+#define DEFINE_MUTEX(x)	DECLARE_MUTEX(x)
+#define mutex_lock(x)	down_interruptible(x)
+#define mutex_unlock(x)	up(x)
+
+#ifndef ____cacheline_internodealigned_in_smp
+#ifdef CONFIG_SMP
+#define ____cacheline_internodealigned_in_smp ____cacheline_aligned_in_smp
+#else
+#define ____cacheline_internodealigned_in_smp
+#endif /* CONFIG_SMP */
+#endif /* ____cacheline_internodealigned_in_smp */
+#undef HAVE_PCI_ERS
+#else /* 2.6.16 and above */
+#undef HAVE_PCI_ERS
+#define HAVE_PCI_ERS
+#if ( SLE_VERSION_CODE && SLE_VERSION_CODE == SLE_VERSION(10,4,0) )
+#ifdef device_can_wakeup
+#undef device_can_wakeup
+#endif /* device_can_wakeup */
+#define device_can_wakeup(dev) 1
+#endif /* SLE_VERSION(10,4,0) */
+#endif /* < 2.6.16 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17) )
+#ifndef dev_notice
+#define dev_notice(dev, fmt, args...)            \
+	dev_printk(KERN_NOTICE, dev, fmt, ## args)
+#endif
+
+#ifndef first_online_node
+#define first_online_node 0
+#endif
+#ifndef NET_SKB_PAD
+#define NET_SKB_PAD 16
+#endif
+#endif /* < 2.6.17 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) )
+
+#ifndef IRQ_HANDLED
+#define irqreturn_t void
+#define IRQ_HANDLED
+#define IRQ_NONE
+#endif
+
+#ifndef IRQF_PROBE_SHARED
+#ifdef SA_PROBEIRQ
+#define IRQF_PROBE_SHARED SA_PROBEIRQ
+#else
+#define IRQF_PROBE_SHARED 0
+#endif
+#endif
+
+#ifndef IRQF_SHARED
+#define IRQF_SHARED SA_SHIRQ
+#endif
+
+#ifndef ARRAY_SIZE
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+#ifndef skb_is_gso
+#ifdef NETIF_F_TSO
+#define skb_is_gso _kc_skb_is_gso
+static inline int _kc_skb_is_gso(const struct sk_buff *skb)
+{
+	return skb_shinfo(skb)->gso_size;
+}
+#else
+#define skb_is_gso(a) 0
+#endif
+#endif
+
+#ifndef resource_size_t
+#define resource_size_t unsigned long
+#endif
+
+#ifdef skb_pad
+#undef skb_pad
+#endif
+#define skb_pad(x,y) _kc_skb_pad(x, y)
+int _kc_skb_pad(struct sk_buff *skb, int pad);
+#ifdef skb_padto
+#undef skb_padto
+#endif
+#define skb_padto(x,y) _kc_skb_padto(x, y)
+static inline int _kc_skb_padto(struct sk_buff *skb, unsigned int len)
+{
+	unsigned int size = skb->len;
+	if(likely(size >= len))
+		return 0;
+	return _kc_skb_pad(skb, len - size);
+}
+
+#ifndef DECLARE_PCI_UNMAP_ADDR
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME) \
+	dma_addr_t ADDR_NAME
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME) \
+	u32 LEN_NAME
+#define pci_unmap_addr(PTR, ADDR_NAME) \
+	((PTR)->ADDR_NAME)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL) \
+	(((PTR)->ADDR_NAME) = (VAL))
+#define pci_unmap_len(PTR, LEN_NAME) \
+	((PTR)->LEN_NAME)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL) \
+	(((PTR)->LEN_NAME) = (VAL))
+#endif /* DECLARE_PCI_UNMAP_ADDR */
+#endif /* < 2.6.18 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) )
+enum pcie_link_width {
+	PCIE_LNK_WIDTH_RESRV    = 0x00,
+	PCIE_LNK_X1             = 0x01,
+	PCIE_LNK_X2             = 0x02,
+	PCIE_LNK_X4             = 0x04,
+	PCIE_LNK_X8             = 0x08,
+	PCIE_LNK_X12            = 0x0C,
+	PCIE_LNK_X16            = 0x10,
+	PCIE_LNK_X32            = 0x20,
+	PCIE_LNK_WIDTH_UNKNOWN  = 0xFF,
+};
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,0)))
+#define i_private u.generic_ip
+#endif /* >= RHEL 5.0 */
+
+#ifndef DIV_ROUND_UP
+#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#endif
+#ifndef __ALIGN_MASK
+#define __ALIGN_MASK(x, mask) (((x) + (mask)) & ~(mask))
+#endif
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) )
+#if (!((RHEL_RELEASE_CODE && \
+        ((RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(4,4) && \
+          RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,0)) || \
+         (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(5,0))))))
+typedef irqreturn_t (*irq_handler_t)(int, void*, struct pt_regs *);
+#endif
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,0))
+#undef CONFIG_INET_LRO
+#undef CONFIG_INET_LRO_MODULE
+#undef CONFIG_FCOE
+#undef CONFIG_FCOE_MODULE
+#endif
+typedef irqreturn_t (*new_handler_t)(int, void*);
+static inline irqreturn_t _kc_request_irq(unsigned int irq, new_handler_t handler, unsigned long flags, const char *devname, void *dev_id)
+#else /* 2.4.x */
+typedef void (*irq_handler_t)(int, void*, struct pt_regs *);
+typedef void (*new_handler_t)(int, void*);
+static inline int _kc_request_irq(unsigned int irq, new_handler_t handler, unsigned long flags, const char *devname, void *dev_id)
+#endif /* >= 2.5.x */
+{
+	irq_handler_t new_handler = (irq_handler_t) handler;
+	return request_irq(irq, new_handler, flags, devname, dev_id);
+}
+
+#undef request_irq
+#define request_irq(irq, handler, flags, devname, dev_id) _kc_request_irq((irq), (handler), (flags), (devname), (dev_id))
+
+#define irq_handler_t new_handler_t
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11) )
+#ifndef skb_checksum_help
+static inline int __kc_skb_checksum_help(struct sk_buff *skb)
+{
+	return skb_checksum_help(skb, 0);
+}
+#define skb_checksum_help(skb) __kc_skb_checksum_help((skb))
+#endif
+#endif /* < 2.6.19 && >= 2.6.11 */
+
+/* pci_restore_state and pci_save_state handles MSI/PCIE from 2.6.19 */
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,4)))
+#define PCIE_CONFIG_SPACE_LEN 256
+#define PCI_CONFIG_SPACE_LEN 64
+#define PCIE_LINK_STATUS 0x12
+#define pci_config_space_ich8lan() do {} while(0)
+#undef pci_save_state
+int _kc_pci_save_state(struct pci_dev *);
+#define pci_save_state(pdev) _kc_pci_save_state(pdev)
+#undef pci_restore_state
+void _kc_pci_restore_state(struct pci_dev *);
+#define pci_restore_state(pdev) _kc_pci_restore_state(pdev)
+#endif /* !(RHEL_RELEASE_CODE >= RHEL 5.4) */
+
+#ifdef HAVE_PCI_ERS
+#undef free_netdev
+void _kc_free_netdev(struct net_device *);
+#define free_netdev(netdev) _kc_free_netdev(netdev)
+#endif
+static inline int pci_enable_pcie_error_reporting(struct pci_dev __always_unused *dev)
+{
+	return 0;
+}
+#define pci_disable_pcie_error_reporting(dev) do {} while (0)
+#define pci_cleanup_aer_uncorrect_error_status(dev) do {} while (0)
+
+void *_kc_kmemdup(const void *src, size_t len, unsigned gfp);
+#define kmemdup(src, len, gfp) _kc_kmemdup(src, len, gfp)
+#ifndef bool
+#define bool _Bool
+#define true 1
+#define false 0
+#endif
+#else /* 2.6.19 */
+#include <linux/aer.h>
+#include <linux/pci_hotplug.h>
+
+#define NEW_SKB_CSUM_HELP
+#endif /* < 2.6.19 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20) )
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,28) )
+#undef INIT_WORK
+#define INIT_WORK(_work, _func) \
+do { \
+	INIT_LIST_HEAD(&(_work)->entry); \
+	(_work)->pending = 0; \
+	(_work)->func = (void (*)(void *))_func; \
+	(_work)->data = _work; \
+	init_timer(&(_work)->timer); \
+} while (0)
+#endif
+
+#ifndef PCI_VDEVICE
+#define PCI_VDEVICE(ven, dev)        \
+	PCI_VENDOR_ID_##ven, (dev),  \
+	PCI_ANY_ID, PCI_ANY_ID, 0, 0
+#endif
+
+#ifndef PCI_VENDOR_ID_INTEL
+#define PCI_VENDOR_ID_INTEL 0x8086
+#endif
+
+#ifndef round_jiffies
+#define round_jiffies(x) x
+#endif
+
+#define csum_offset csum
+
+#define HAVE_EARLY_VMALLOC_NODE
+#define dev_to_node(dev) -1
+#undef set_dev_node
+/* remove compiler warning with b=b, for unused variable */
+#define set_dev_node(a, b) do { (b) = (b); } while(0)
+
+#if (!(RHEL_RELEASE_CODE && \
+       (((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(4,7)) && \
+         (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,0))) || \
+        (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,6)))) && \
+     !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(10,2,0)))
+typedef __u16 __bitwise __sum16;
+typedef __u32 __bitwise __wsum;
+#endif
+
+#if (!(RHEL_RELEASE_CODE && \
+       (((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(4,7)) && \
+         (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,0))) || \
+        (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,4)))) && \
+     !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(10,2,0)))
+static inline __wsum csum_unfold(__sum16 n)
+{
+	return (__force __wsum)n;
+}
+#endif
+
+#else /* < 2.6.20 */
+#define HAVE_DEVICE_NUMA_NODE
+#endif /* < 2.6.20 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) )
+#define to_net_dev(class) container_of(class, struct net_device, class_dev)
+#define NETDEV_CLASS_DEV
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(5,5)))
+#define vlan_group_get_device(vg, id) (vg->vlan_devices[id])
+#define vlan_group_set_device(vg, id, dev)		\
+	do {						\
+		if (vg) vg->vlan_devices[id] = dev;	\
+	} while (0)
+#endif /* !(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(5,5)) */
+#define pci_channel_offline(pdev) (pdev->error_state && \
+	pdev->error_state != pci_channel_io_normal)
+#define pci_request_selected_regions(pdev, bars, name) \
+        pci_request_regions(pdev, name)
+#define pci_release_selected_regions(pdev, bars) pci_release_regions(pdev);
+
+#ifndef __aligned
+#define __aligned(x)			__attribute__((aligned(x)))
+#endif
+
+struct pci_dev *_kc_netdev_to_pdev(struct net_device *netdev);
+#define netdev_to_dev(netdev)	\
+	pci_dev_to_dev(_kc_netdev_to_pdev(netdev))
+#define devm_kzalloc(dev, size, flags) kzalloc(size, flags)
+#define devm_kfree(dev, p) kfree(p)
+#else /* 2.6.21 */
+static inline struct device *netdev_to_dev(struct net_device *netdev)
+{
+	return &netdev->dev;
+}
+
+#endif /* < 2.6.21 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) )
+#define tcp_hdr(skb) (skb->h.th)
+#define tcp_hdrlen(skb) (skb->h.th->doff << 2)
+#define skb_transport_offset(skb) (skb->h.raw - skb->data)
+#define skb_transport_header(skb) (skb->h.raw)
+#define ipv6_hdr(skb) (skb->nh.ipv6h)
+#define ip_hdr(skb) (skb->nh.iph)
+#define skb_network_offset(skb) (skb->nh.raw - skb->data)
+#define skb_network_header(skb) (skb->nh.raw)
+#define skb_tail_pointer(skb) skb->tail
+#define skb_reset_tail_pointer(skb) \
+	do { \
+		skb->tail = skb->data; \
+	} while (0)
+#define skb_set_tail_pointer(skb, offset) \
+	do { \
+		skb->tail = skb->data + offset; \
+	} while (0)
+#define skb_copy_to_linear_data(skb, from, len) \
+				memcpy(skb->data, from, len)
+#define skb_copy_to_linear_data_offset(skb, offset, from, len) \
+				memcpy(skb->data + offset, from, len)
+#define skb_network_header_len(skb) (skb->h.raw - skb->nh.raw)
+#define pci_register_driver pci_module_init
+#define skb_mac_header(skb) skb->mac.raw
+
+#ifdef NETIF_F_MULTI_QUEUE
+#ifndef alloc_etherdev_mq
+#define alloc_etherdev_mq(_a, _b) alloc_etherdev(_a)
+#endif
+#endif /* NETIF_F_MULTI_QUEUE */
+
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN 4
+#endif
+#define cancel_work_sync(x) flush_scheduled_work()
+#ifndef udp_hdr
+#define udp_hdr _udp_hdr
+static inline struct udphdr *_udp_hdr(const struct sk_buff *skb)
+{
+	return (struct udphdr *)skb_transport_header(skb);
+}
+#endif
+
+#ifdef cpu_to_be16
+#undef cpu_to_be16
+#endif
+#define cpu_to_be16(x) __constant_htons(x)
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(5,1)))
+enum {
+	DUMP_PREFIX_NONE,
+	DUMP_PREFIX_ADDRESS,
+	DUMP_PREFIX_OFFSET
+};
+#endif /* !(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(5,1)) */
+#ifndef hex_asc
+#define hex_asc(x)	"0123456789abcdef"[x]
+#endif
+#include <linux/ctype.h>
+void _kc_print_hex_dump(const char *level, const char *prefix_str,
+			int prefix_type, int rowsize, int groupsize,
+			const void *buf, size_t len, bool ascii);
+#define print_hex_dump(lvl, s, t, r, g, b, l, a) \
+		_kc_print_hex_dump(lvl, s, t, r, g, b, l, a)
+#ifndef ADVERTISED_2500baseX_Full
+#define ADVERTISED_2500baseX_Full BIT(15)
+#endif
+#ifndef SUPPORTED_2500baseX_Full
+#define SUPPORTED_2500baseX_Full BIT(15)
+#endif
+
+#ifndef ETH_P_PAUSE
+#define ETH_P_PAUSE 0x8808
+#endif
+
+static inline int compound_order(struct page *page)
+{
+	return 0;
+}
+
+#define __must_be_array(a) 0
+
+#ifndef SKB_WITH_OVERHEAD
+#define SKB_WITH_OVERHEAD(X) \
+	((X) - SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
+#endif
+#else /* 2.6.22 */
+#define ETH_TYPE_TRANS_SETS_DEV
+#define HAVE_NETDEV_STATS_IN_NETDEV
+#endif /* < 2.6.22 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22) )
+#undef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev) do { } while (0)
+#endif /* > 2.6.22 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) )
+#define netif_subqueue_stopped(_a, _b) 0
+#ifndef PTR_ALIGN
+#define PTR_ALIGN(p, a)         ((typeof(p))ALIGN((unsigned long)(p), (a)))
+#endif
+
+#ifndef CONFIG_PM_SLEEP
+#define CONFIG_PM_SLEEP	CONFIG_PM
+#endif
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13) )
+#define HAVE_ETHTOOL_GET_PERM_ADDR
+#endif /* 2.6.14 through 2.6.22 */
+
+static inline int __kc_skb_cow_head(struct sk_buff *skb, unsigned int headroom)
+{
+	int delta = 0;
+
+	if (headroom > (skb->data - skb->head))
+		delta = headroom - (skb->data - skb->head);
+
+	if (delta || skb_header_cloned(skb))
+		return pskb_expand_head(skb, ALIGN(delta, NET_SKB_PAD), 0,
+					GFP_ATOMIC);
+	return 0;
+}
+#define skb_cow_head(s, h) __kc_skb_cow_head((s), (h))
+#endif /* < 2.6.23 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) )
+#ifndef ETH_FLAG_LRO
+#define ETH_FLAG_LRO NETIF_F_LRO
+#endif
+
+#ifndef ACCESS_ONCE
+#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
+#endif
+
+/* if GRO is supported then the napi struct must already exist */
+#ifndef NETIF_F_GRO
+/* NAPI API changes in 2.6.24 break everything */
+struct napi_struct {
+	/* used to look up the real NAPI polling routine */
+	int (*poll)(struct napi_struct *, int);
+	struct net_device *dev;
+	int weight;
+};
+#endif
+
+#ifdef NAPI
+int __kc_adapter_clean(struct net_device *, int *);
+/* The following definitions are multi-queue aware, and thus we have a driver
+ * define list which determines which drivers support multiple queues, and
+ * thus need these stronger defines. If a driver does not support multi-queue
+ * functionality, you don't need to add it to this list.
+ */
+struct net_device *napi_to_poll_dev(const struct napi_struct *napi);
+
+static inline void __kc_mq_netif_napi_add(struct net_device *dev, struct napi_struct *napi,
+					  int (*poll)(struct napi_struct *, int), int weight)
+{
+	struct net_device *poll_dev = napi_to_poll_dev(napi);
+	poll_dev->poll = __kc_adapter_clean;
+	poll_dev->priv = napi;
+	poll_dev->weight = weight;
+	set_bit(__LINK_STATE_RX_SCHED, &poll_dev->state);
+	set_bit(__LINK_STATE_START, &poll_dev->state);
+	dev_hold(poll_dev);
+	napi->poll = poll;
+	napi->weight = weight;
+	napi->dev = dev;
+}
+#define netif_napi_add __kc_mq_netif_napi_add
+
+static inline void __kc_mq_netif_napi_del(struct napi_struct *napi)
+{
+	struct net_device *poll_dev = napi_to_poll_dev(napi);
+	WARN_ON(!test_bit(__LINK_STATE_RX_SCHED, &poll_dev->state));
+	dev_put(poll_dev);
+	memset(poll_dev, 0, sizeof(struct net_device));
+}
+
+#define netif_napi_del __kc_mq_netif_napi_del
+
+static inline bool __kc_mq_napi_schedule_prep(struct napi_struct *napi)
+{
+	return netif_running(napi->dev) &&
+		netif_rx_schedule_prep(napi_to_poll_dev(napi));
+}
+#define napi_schedule_prep __kc_mq_napi_schedule_prep
+
+static inline void __kc_mq_napi_schedule(struct napi_struct *napi)
+{
+	if (napi_schedule_prep(napi))
+		__netif_rx_schedule(napi_to_poll_dev(napi));
+}
+#define napi_schedule __kc_mq_napi_schedule
+
+#define napi_enable(_napi) netif_poll_enable(napi_to_poll_dev(_napi))
+#define napi_disable(_napi) netif_poll_disable(napi_to_poll_dev(_napi))
+#ifdef CONFIG_SMP
+static inline void napi_synchronize(const struct napi_struct *n)
+{
+	struct net_device *dev = napi_to_poll_dev(n);
+
+	while (test_bit(__LINK_STATE_RX_SCHED, &dev->state)) {
+		/* No hurry. */
+		msleep(1);
+	}
+}
+#else
+#define napi_synchronize(n)	barrier()
+#endif /* CONFIG_SMP */
+#define __napi_schedule(_napi) __netif_rx_schedule(napi_to_poll_dev(_napi))
+static inline void _kc_napi_complete(struct napi_struct *napi)
+{
+#ifdef NETIF_F_GRO
+	napi_gro_flush(napi);
+#endif
+	netif_rx_complete(napi_to_poll_dev(napi));
+}
+#define napi_complete _kc_napi_complete
+#else /* NAPI */
+
+/* The following definitions are only used if we don't support NAPI at all. */
+
+static inline __kc_netif_napi_add(struct net_device *dev, struct napi_struct *napi,
+				  int (*poll)(struct napi_struct *, int), int weight)
+{
+	dev->poll = poll;
+	dev->weight = weight;
+	napi->poll = poll;
+	napi->weight = weight;
+	napi->dev = dev;
+}
+#define netif_napi_del(_a) do {} while (0)
+#endif /* NAPI */
+
+#undef dev_get_by_name
+#define dev_get_by_name(_a, _b) dev_get_by_name(_b)
+#define __netif_subqueue_stopped(_a, _b) netif_subqueue_stopped(_a, _b)
+#ifndef DMA_BIT_MASK
+#define DMA_BIT_MASK(n)	(((n) == 64) ? DMA_64BIT_MASK : ((1ULL<<(n))-1))
+#endif
+
+#ifdef NETIF_F_TSO6
+#define skb_is_gso_v6 _kc_skb_is_gso_v6
+static inline int _kc_skb_is_gso_v6(const struct sk_buff *skb)
+{
+	return skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6;
+}
+#endif /* NETIF_F_TSO6 */
+
+#ifndef KERN_CONT
+#define KERN_CONT	""
+#endif
+#ifndef pr_err
+#define pr_err(fmt, arg...) \
+	printk(KERN_ERR fmt, ##arg)
+#endif
+
+#ifndef rounddown_pow_of_two
+#define rounddown_pow_of_two(n) \
+	__builtin_constant_p(n) ? ( \
+		(n == 1) ? 0 : \
+		(1UL << ilog2(n))) : \
+		(1UL << (fls_long(n) - 1))
+#endif
+
+#else /* < 2.6.24 */
+#define HAVE_ETHTOOL_GET_SSET_COUNT
+#define HAVE_NETDEV_NAPI_LIST
+#endif /* < 2.6.24 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,24) )
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0) )
+#define INCLUDE_PM_QOS_PARAMS_H
+#include <linux/pm_qos_params.h>
+#else /* >= 3.2.0 */
+#include <linux/pm_qos.h>
+#endif /* else >= 3.2.0 */
+#endif /* > 2.6.24 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25) )
+#define PM_QOS_CPU_DMA_LATENCY	1
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18) )
+#include <linux/latency.h>
+#define PM_QOS_DEFAULT_VALUE	INFINITE_LATENCY
+#define pm_qos_add_requirement(pm_qos_class, name, value) \
+		set_acceptable_latency(name, value)
+#define pm_qos_remove_requirement(pm_qos_class, name) \
+		remove_acceptable_latency(name)
+#define pm_qos_update_requirement(pm_qos_class, name, value) \
+		modify_acceptable_latency(name, value)
+#else
+#define PM_QOS_DEFAULT_VALUE	-1
+#define pm_qos_add_requirement(pm_qos_class, name, value)
+#define pm_qos_remove_requirement(pm_qos_class, name)
+#define pm_qos_update_requirement(pm_qos_class, name, value) { \
+	if (value != PM_QOS_DEFAULT_VALUE) { \
+		printk(KERN_WARNING "%s: unable to set PM QoS requirement\n", \
+			pci_name(adapter->pdev)); \
+	} \
+}
+
+#endif /* > 2.6.18 */
+
+#define pci_enable_device_mem(pdev) pci_enable_device(pdev)
+
+#ifndef DEFINE_PCI_DEVICE_TABLE
+#define DEFINE_PCI_DEVICE_TABLE(_table) struct pci_device_id _table[]
+#endif /* DEFINE_PCI_DEVICE_TABLE */
+
+#ifndef strict_strtol
+#define strict_strtol(s, b, r) _kc_strict_strtol(s, b, r)
+static inline int _kc_strict_strtol(const char *buf, unsigned int base, long *res)
+{
+	/* adapted from strict_strtoul() in 2.6.25 */
+	char *tail;
+	long val;
+	size_t len;
+
+	*res = 0;
+	len = strlen(buf);
+	if (!len)
+		return -EINVAL;
+	val = simple_strtol(buf, &tail, base);
+	if (tail == buf)
+		return -EINVAL;
+	if ((*tail == '\0') ||
+	    ((len == (size_t)(tail - buf) + 1) && (*tail == '\n'))) {
+		*res = val;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+#endif
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) )
+#ifndef IXGBE_PROCFS
+#define IXGBE_PROCFS
+#endif /* IXGBE_PROCFS */
+#endif /* >= 2.6.0 */
+
+#else /* < 2.6.25 */
+
+#if IS_ENABLED(CONFIG_SYSFS)
+#ifndef IXGBE_SYSFS
+#define IXGBE_SYSFS
+#endif /* IXGBE_SYSFS */
+#endif /* CONFIG_SYSFS */
+#if IS_ENABLED(CONFIG_HWMON)
+#ifndef IXGBE_HWMON
+#define IXGBE_HWMON
+#endif /* IXGBE_HWMON */
+#endif /* CONFIG_HWMON */
+
+#endif /* < 2.6.25 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26) )
+#ifndef clamp_t
+#define clamp_t(type, val, min, max) ({		\
+	type __val = (val);			\
+	type __min = (min);			\
+	type __max = (max);			\
+	__val = __val < __min ? __min : __val;	\
+	__val > __max ? __max : __val; })
+#endif /* clamp_t */
+#undef kzalloc_node
+#define kzalloc_node(_size, _flags, _node) kzalloc(_size, _flags)
+
+void _kc_pci_disable_link_state(struct pci_dev *dev, int state);
+#define pci_disable_link_state(p, s) _kc_pci_disable_link_state(p, s)
+#else /* < 2.6.26 */
+#define NETDEV_CAN_SET_GSO_MAX_SIZE
+#ifdef HAVE_PCI_ASPM_H
+#include <linux/pci-aspm.h>
+#endif
+#define HAVE_NETDEV_VLAN_FEATURES
+#ifndef PCI_EXP_LNKCAP_ASPMS
+#define PCI_EXP_LNKCAP_ASPMS 0x00000c00 /* ASPM Support */
+#endif /* PCI_EXP_LNKCAP_ASPMS */
+#endif /* < 2.6.26 */
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27) )
+static inline void _kc_ethtool_cmd_speed_set(struct ethtool_cmd *ep,
+					     __u32 speed)
+{
+	ep->speed = (__u16)speed;
+	/* ep->speed_hi = (__u16)(speed >> 16); */
+}
+#define ethtool_cmd_speed_set _kc_ethtool_cmd_speed_set
+
+static inline __u32 _kc_ethtool_cmd_speed(struct ethtool_cmd *ep)
+{
+	/* no speed_hi before 2.6.27, and probably no need for it yet */
+	return (__u32)ep->speed;
+}
+#define ethtool_cmd_speed _kc_ethtool_cmd_speed
+
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15) )
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)) && defined(CONFIG_PM))
+#define ANCIENT_PM 1
+#elif ((LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23)) && \
+       (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)) && \
+       defined(CONFIG_PM_SLEEP))
+#define NEWER_PM 1
+#endif
+#if defined(ANCIENT_PM) || defined(NEWER_PM)
+#undef device_set_wakeup_enable
+#define device_set_wakeup_enable(dev, val) \
+	do { \
+		u16 pmc = 0; \
+		int pm = pci_find_capability(adapter->pdev, PCI_CAP_ID_PM); \
+		if (pm) { \
+			pci_read_config_word(adapter->pdev, pm + PCI_PM_PMC, \
+				&pmc); \
+		} \
+		(dev)->power.can_wakeup = !!(pmc >> 11); \
+		(dev)->power.should_wakeup = (val && (pmc >> 11)); \
+	} while (0)
+#endif /* 2.6.15-2.6.22 and CONFIG_PM or 2.6.23-2.6.25 and CONFIG_PM_SLEEP */
+#endif /* 2.6.15 through 2.6.27 */
+#ifndef netif_napi_del
+#define netif_napi_del(_a) do {} while (0)
+#ifdef NAPI
+#ifdef CONFIG_NETPOLL
+#undef netif_napi_del
+#define netif_napi_del(_a) list_del(&(_a)->dev_list);
+#endif
+#endif
+#endif /* netif_napi_del */
+#ifdef dma_mapping_error
+#undef dma_mapping_error
+#endif
+#define dma_mapping_error(dev, dma_addr) pci_dma_mapping_error(dma_addr)
+
+#ifdef CONFIG_NETDEVICES_MULTIQUEUE
+#define HAVE_TX_MQ
+#endif
+
+#ifndef DMA_ATTR_WEAK_ORDERING
+#define DMA_ATTR_WEAK_ORDERING 0
+#endif
+
+#ifdef HAVE_TX_MQ
+void _kc_netif_tx_stop_all_queues(struct net_device *);
+void _kc_netif_tx_wake_all_queues(struct net_device *);
+void _kc_netif_tx_start_all_queues(struct net_device *);
+#define netif_tx_stop_all_queues(a) _kc_netif_tx_stop_all_queues(a)
+#define netif_tx_wake_all_queues(a) _kc_netif_tx_wake_all_queues(a)
+#define netif_tx_start_all_queues(a) _kc_netif_tx_start_all_queues(a)
+#undef netif_stop_subqueue
+#define netif_stop_subqueue(_ndev,_qi) do { \
+	if (netif_is_multiqueue((_ndev))) \
+		netif_stop_subqueue((_ndev), (_qi)); \
+	else \
+		netif_stop_queue((_ndev)); \
+	} while (0)
+#undef netif_start_subqueue
+#define netif_start_subqueue(_ndev,_qi) do { \
+	if (netif_is_multiqueue((_ndev))) \
+		netif_start_subqueue((_ndev), (_qi)); \
+	else \
+		netif_start_queue((_ndev)); \
+	} while (0)
+#else /* HAVE_TX_MQ */
+#define netif_tx_stop_all_queues(a) netif_stop_queue(a)
+#define netif_tx_wake_all_queues(a) netif_wake_queue(a)
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12) )
+#define netif_tx_start_all_queues(a) netif_start_queue(a)
+#else
+#define netif_tx_start_all_queues(a) do {} while (0)
+#endif
+#define netif_stop_subqueue(_ndev,_qi) netif_stop_queue((_ndev))
+#define netif_start_subqueue(_ndev,_qi) netif_start_queue((_ndev))
+#endif /* HAVE_TX_MQ */
+#ifndef NETIF_F_MULTI_QUEUE
+#define NETIF_F_MULTI_QUEUE 0
+#define netif_is_multiqueue(a) 0
+#define netif_wake_subqueue(a, b)
+#endif /* NETIF_F_MULTI_QUEUE */
+
+#ifndef __WARN_printf
+void __kc_warn_slowpath(const char *file, const int line,
+		const char *fmt, ...) __attribute__((format(printf, 3, 4)));
+#define __WARN_printf(arg...) __kc_warn_slowpath(__FILE__, __LINE__, arg)
+#endif /* __WARN_printf */
+
+#ifndef WARN
+#define WARN(condition, format...) ({						\
+	int __ret_warn_on = !!(condition);				\
+	if (unlikely(__ret_warn_on))					\
+		__WARN_printf(format);					\
+	unlikely(__ret_warn_on);					\
+})
+#endif /* WARN */
+#undef HAVE_IXGBE_DEBUG_FS
+#undef HAVE_IGB_DEBUG_FS
+#else /* < 2.6.27 */
+#define ethtool_cmd_speed_set _kc_ethtool_cmd_speed_set
+static inline void _kc_ethtool_cmd_speed_set(struct ethtool_cmd *ep,
+					     __u32 speed)
+{
+	ep->speed = (__u16)(speed & 0xFFFF);
+	ep->speed_hi = (__u16)(speed >> 16);
+}
+#define HAVE_TX_MQ
+#define HAVE_NETDEV_SELECT_QUEUE
+#ifdef CONFIG_DEBUG_FS
+#define HAVE_IXGBE_DEBUG_FS
+#define HAVE_IGB_DEBUG_FS
+#endif /* CONFIG_DEBUG_FS */
+#endif /* < 2.6.27 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28) )
+#define pci_ioremap_bar(pdev, bar)	ioremap(pci_resource_start(pdev, bar), \
+					        pci_resource_len(pdev, bar))
+#define pci_wake_from_d3 _kc_pci_wake_from_d3
+#define pci_prepare_to_sleep _kc_pci_prepare_to_sleep
+int _kc_pci_wake_from_d3(struct pci_dev *dev, bool enable);
+int _kc_pci_prepare_to_sleep(struct pci_dev *dev);
+#define netdev_alloc_page(a) alloc_page(GFP_ATOMIC)
+#ifndef __skb_queue_head_init
+static inline void __kc_skb_queue_head_init(struct sk_buff_head *list)
+{
+	list->prev = list->next = (struct sk_buff *)list;
+	list->qlen = 0;
+}
+#define __skb_queue_head_init(_q) __kc_skb_queue_head_init(_q)
+#endif
+
+#define PCI_EXP_DEVCAP2		36	/* Device Capabilities 2 */
+#define PCI_EXP_DEVCTL2		40	/* Device Control 2 */
+
+#define PCI_EXP_DEVCAP_FLR	0x10000000 /* Function Level Reset */
+#define PCI_EXP_DEVCTL_BCR_FLR	0x8000 /* Bridge Configuration Retry / FLR */
+
+#endif /* < 2.6.28 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29) )
+#ifndef swap
+#define swap(a, b) \
+	do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)
+#endif
+#define pci_request_selected_regions_exclusive(pdev, bars, name) \
+		pci_request_selected_regions(pdev, bars, name)
+#ifndef CONFIG_NR_CPUS
+#define CONFIG_NR_CPUS 1
+#endif /* CONFIG_NR_CPUS */
+#ifndef pcie_aspm_enabled
+#define pcie_aspm_enabled()   (1)
+#endif /* pcie_aspm_enabled */
+
+#define  PCI_EXP_SLTSTA_PDS	0x0040	/* Presence Detect State */
+
+#ifndef PCI_EXP_LNKSTA_CLS
+#define  PCI_EXP_LNKSTA_CLS    0x000f  /* Current Link Speed */
+#endif
+#ifndef PCI_EXP_LNKSTA_NLW
+#define  PCI_EXP_LNKSTA_NLW    0x03f0  /* Negotiated Link Width */
+#endif
+
+#ifndef pci_clear_master
+void _kc_pci_clear_master(struct pci_dev *dev);
+#define pci_clear_master(dev)	_kc_pci_clear_master(dev)
+#endif
+
+#ifndef PCI_EXP_LNKCTL_ASPMC
+#define  PCI_EXP_LNKCTL_ASPMC	0x0003	/* ASPM Control */
+#endif
+
+#ifndef PCI_EXP_LNKCAP_MLW
+#define PCI_EXP_LNKCAP_MLW	0x000003f0 /* Maximum Link Width */
+#endif
+
+#else /* < 2.6.29 */
+#ifndef HAVE_NET_DEVICE_OPS
+#define HAVE_NET_DEVICE_OPS
+#endif
+#ifdef CONFIG_DCB
+#define HAVE_PFC_MODE_ENABLE
+#endif /* CONFIG_DCB */
+#endif /* < 2.6.29 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30) )
+#define NO_PTP_SUPPORT
+#define skb_rx_queue_recorded(a) false
+#define skb_get_rx_queue(a) 0
+#define skb_record_rx_queue(a, b) do {} while (0)
+#define skb_tx_hash(n, s) ___kc_skb_tx_hash((n), (s), (n)->real_num_tx_queues)
+#undef CONFIG_FCOE
+#undef CONFIG_FCOE_MODULE
+#ifndef CONFIG_PCI_IOV
+#undef pci_enable_sriov
+#define pci_enable_sriov(a, b) -ENOTSUPP
+#undef pci_disable_sriov
+#define pci_disable_sriov(a) do {} while (0)
+#endif /* CONFIG_PCI_IOV */
+#ifndef pr_cont
+#define pr_cont(fmt, ...) \
+	printk(KERN_CONT fmt, ##__VA_ARGS__)
+#endif /* pr_cont */
+static inline void _kc_synchronize_irq(unsigned int a)
+{
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28) )
+	synchronize_irq();
+#else /* < 2.5.28 */
+	synchronize_irq(a);
+#endif /* < 2.5.28 */
+}
+#undef synchronize_irq
+#define synchronize_irq(a) _kc_synchronize_irq(a)
+
+#define PCI_EXP_LNKCTL2		48	/* Link Control 2 */
+
+#ifdef nr_cpus_node
+#undef nr_cpus_node
+#define nr_cpus_node(node) cpumask_weight(cpumask_of_node(node))
+#endif
+
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,5))
+#define HAVE_PCI_DEV_IS_VIRTFN_BIT
+#endif /* RHEL >= 5.5 */
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,5)))
+static inline bool pci_is_root_bus(struct pci_bus *pbus)
+{
+	return !(pbus->parent);
+}
+#endif
+
+#else /* < 2.6.30 */
+#define HAVE_ASPM_QUIRKS
+#define HAVE_PCI_DEV_IS_VIRTFN_BIT
+#endif /* < 2.6.30 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31) )
+#define ETH_P_1588 0x88F7
+#define ETH_P_FIP  0x8914
+#ifndef netdev_uc_count
+#define netdev_uc_count(dev) ((dev)->uc_count)
+#endif
+#ifndef netdev_for_each_uc_addr
+#define netdev_for_each_uc_addr(uclist, dev) \
+	for (uclist = dev->uc_list; uclist; uclist = uclist->next)
+#endif
+#ifndef PORT_OTHER
+#define PORT_OTHER 0xff
+#endif
+#ifndef MDIO_PHY_ID_PRTAD
+#define MDIO_PHY_ID_PRTAD 0x03e0
+#endif
+#ifndef MDIO_PHY_ID_DEVAD
+#define MDIO_PHY_ID_DEVAD 0x001f
+#endif
+#ifndef skb_dst
+#define skb_dst(s) ((s)->dst)
+#endif
+
+#ifndef SUPPORTED_1000baseKX_Full
+#define SUPPORTED_1000baseKX_Full	BIT(17)
+#endif
+#ifndef SUPPORTED_10000baseKX4_Full
+#define SUPPORTED_10000baseKX4_Full	BIT(18)
+#endif
+#ifndef SUPPORTED_10000baseKR_Full
+#define SUPPORTED_10000baseKR_Full	BIT(19)
+#endif
+
+#ifndef ADVERTISED_1000baseKX_Full
+#define ADVERTISED_1000baseKX_Full	BIT(17)
+#endif
+#ifndef ADVERTISED_10000baseKX4_Full
+#define ADVERTISED_10000baseKX4_Full	BIT(18)
+#endif
+#ifndef ADVERTISED_10000baseKR_Full
+#define ADVERTISED_10000baseKR_Full	BIT(19)
+#endif
+
+static inline unsigned long dev_trans_start(struct net_device *dev)
+{
+	return dev->trans_start;
+}
+#else /* < 2.6.31 */
+#ifndef HAVE_NETDEV_STORAGE_ADDRESS
+#define HAVE_NETDEV_STORAGE_ADDRESS
+#endif
+#ifndef HAVE_NETDEV_HW_ADDR
+#define HAVE_NETDEV_HW_ADDR
+#endif
+#ifndef HAVE_TRANS_START_IN_QUEUE
+#define HAVE_TRANS_START_IN_QUEUE
+#endif
+#ifndef HAVE_INCLUDE_LINUX_MDIO_H
+#define HAVE_INCLUDE_LINUX_MDIO_H
+#endif
+#include <linux/mdio.h>
+#endif /* < 2.6.31 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32) )
+#undef netdev_tx_t
+#define netdev_tx_t int
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef NETIF_F_FCOE_MTU
+#define NETIF_F_FCOE_MTU       BIT(26)
+#endif
+#endif /* CONFIG_FCOE || CONFIG_FCOE_MODULE */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+static inline int _kc_pm_runtime_get_sync()
+{
+	return 1;
+}
+#define pm_runtime_get_sync(dev)	_kc_pm_runtime_get_sync()
+#else /* 2.6.0 => 2.6.32 */
+static inline int _kc_pm_runtime_get_sync(struct device __always_unused *dev)
+{
+	return 1;
+}
+#ifndef pm_runtime_get_sync
+#define pm_runtime_get_sync(dev)	_kc_pm_runtime_get_sync(dev)
+#endif
+#endif /* 2.6.0 => 2.6.32 */
+#ifndef pm_runtime_put
+#define pm_runtime_put(dev)		do {} while (0)
+#endif
+#ifndef pm_runtime_put_sync
+#define pm_runtime_put_sync(dev)	do {} while (0)
+#endif
+#ifndef pm_runtime_resume
+#define pm_runtime_resume(dev)		do {} while (0)
+#endif
+#ifndef pm_schedule_suspend
+#define pm_schedule_suspend(dev, t)	do {} while (0)
+#endif
+#ifndef pm_runtime_set_suspended
+#define pm_runtime_set_suspended(dev)	do {} while (0)
+#endif
+#ifndef pm_runtime_disable
+#define pm_runtime_disable(dev)		do {} while (0)
+#endif
+#ifndef pm_runtime_put_noidle
+#define pm_runtime_put_noidle(dev)	do {} while (0)
+#endif
+#ifndef pm_runtime_set_active
+#define pm_runtime_set_active(dev)	do {} while (0)
+#endif
+#ifndef pm_runtime_enable
+#define pm_runtime_enable(dev)	do {} while (0)
+#endif
+#ifndef pm_runtime_get_noresume
+#define pm_runtime_get_noresume(dev)	do {} while (0)
+#endif
+#else /* < 2.6.32 */
+#if (RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,2)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)))
+#define HAVE_RHEL6_NET_DEVICE_EXTENDED
+#endif /* RHEL >= 6.2 && RHEL < 7.0 */
+#if (RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,6)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)))
+#define HAVE_RHEL6_NET_DEVICE_OPS_EXT
+#define HAVE_NDO_SET_FEATURES
+#endif /* RHEL >= 6.6 && RHEL < 7.0 */
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef HAVE_NETDEV_OPS_FCOE_ENABLE
+#define HAVE_NETDEV_OPS_FCOE_ENABLE
+#endif
+#endif /* CONFIG_FCOE || CONFIG_FCOE_MODULE */
+#ifdef CONFIG_DCB
+#ifndef HAVE_DCBNL_OPS_GETAPP
+#define HAVE_DCBNL_OPS_GETAPP
+#endif
+#endif /* CONFIG_DCB */
+#include <linux/pm_runtime.h>
+/* IOV bad DMA target work arounds require at least this kernel rev support */
+#define HAVE_PCIE_TYPE
+#endif /* < 2.6.32 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33) )
+#ifndef pci_pcie_cap
+#define pci_pcie_cap(pdev) pci_find_capability(pdev, PCI_CAP_ID_EXP)
+#endif
+#ifndef IPV4_FLOW
+#define IPV4_FLOW 0x10
+#endif /* IPV4_FLOW */
+#ifndef IPV6_FLOW
+#define IPV6_FLOW 0x11
+#endif /* IPV6_FLOW */
+/* Features back-ported to RHEL6 or SLES11 SP1 after 2.6.32 */
+#if ( (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0)) || \
+      (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,1,0)) )
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef HAVE_NETDEV_OPS_FCOE_GETWWN
+#define HAVE_NETDEV_OPS_FCOE_GETWWN
+#endif
+#endif /* CONFIG_FCOE || CONFIG_FCOE_MODULE */
+#endif /* RHEL6 or SLES11 SP1 */
+#ifndef __percpu
+#define __percpu
+#endif /* __percpu */
+
+#ifndef PORT_DA
+#define PORT_DA PORT_OTHER
+#endif /* PORT_DA */
+#ifndef PORT_NONE
+#define PORT_NONE PORT_OTHER
+#endif
+
+#if ((RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,3)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0))))
+#if !defined(CONFIG_X86_32) && !defined(CONFIG_NEED_DMA_MAP_STATE)
+#undef DEFINE_DMA_UNMAP_ADDR
+#define DEFINE_DMA_UNMAP_ADDR(ADDR_NAME)	dma_addr_t ADDR_NAME
+#undef DEFINE_DMA_UNMAP_LEN
+#define DEFINE_DMA_UNMAP_LEN(LEN_NAME)		__u32 LEN_NAME
+#undef dma_unmap_addr
+#define dma_unmap_addr(PTR, ADDR_NAME)		((PTR)->ADDR_NAME)
+#undef dma_unmap_addr_set
+#define dma_unmap_addr_set(PTR, ADDR_NAME, VAL)	(((PTR)->ADDR_NAME) = (VAL))
+#undef dma_unmap_len
+#define dma_unmap_len(PTR, LEN_NAME)		((PTR)->LEN_NAME)
+#undef dma_unmap_len_set
+#define dma_unmap_len_set(PTR, LEN_NAME, VAL)	(((PTR)->LEN_NAME) = (VAL))
+#endif /* CONFIG_X86_64 && !CONFIG_NEED_DMA_MAP_STATE */
+#endif /* RHEL_RELEASE_CODE */
+
+#if (!(RHEL_RELEASE_CODE && \
+       (((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,8)) && \
+         (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,0))) || \
+        ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1)) && \
+         (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0))))))
+static inline bool pci_is_pcie(struct pci_dev *dev)
+{
+	return !!pci_pcie_cap(dev);
+}
+#endif /* RHEL_RELEASE_CODE */
+
+#if (!(RHEL_RELEASE_CODE && \
+      (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,2))))
+#define sk_tx_queue_get(_sk) (-1)
+#define sk_tx_queue_set(_sk, _tx_queue) do {} while(0)
+#endif /* !(RHEL >= 6.2) */
+
+#if (RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)))
+#define HAVE_RHEL6_ETHTOOL_OPS_EXT_STRUCT
+#define HAVE_ETHTOOL_GRXFHINDIR_SIZE
+#define HAVE_ETHTOOL_SET_PHYS_ID
+#define HAVE_ETHTOOL_GET_TS_INFO
+#if (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,5))
+#define HAVE_ETHTOOL_GSRSSH
+#define HAVE_RHEL6_SRIOV_CONFIGURE
+#define HAVE_RXFH_NONCONST
+#endif /* RHEL > 6.5 */
+#endif /* RHEL >= 6.4 && RHEL < 7.0 */
+
+#else /* < 2.6.33 */
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef HAVE_NETDEV_OPS_FCOE_GETWWN
+#define HAVE_NETDEV_OPS_FCOE_GETWWN
+#endif
+#endif /* CONFIG_FCOE || CONFIG_FCOE_MODULE */
+#endif /* < 2.6.33 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34) )
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,0))
+#ifndef pci_num_vf
+#define pci_num_vf(pdev) _kc_pci_num_vf(pdev)
+int _kc_pci_num_vf(struct pci_dev *dev);
+#endif
+#endif /* RHEL_RELEASE_CODE */
+
+#ifndef dev_is_pci
+#define dev_is_pci(d) ((d)->bus == &pci_bus_type)
+#endif
+
+#ifndef ETH_FLAG_NTUPLE
+#define ETH_FLAG_NTUPLE NETIF_F_NTUPLE
+#endif
+
+#ifndef netdev_mc_count
+#define netdev_mc_count(dev) ((dev)->mc_count)
+#endif
+#ifndef netdev_mc_empty
+#define netdev_mc_empty(dev) (netdev_mc_count(dev) == 0)
+#endif
+#ifndef netdev_for_each_mc_addr
+#define netdev_for_each_mc_addr(mclist, dev) \
+	for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+#ifndef netdev_uc_count
+#define netdev_uc_count(dev) ((dev)->uc.count)
+#endif
+#ifndef netdev_uc_empty
+#define netdev_uc_empty(dev) (netdev_uc_count(dev) == 0)
+#endif
+#ifndef netdev_for_each_uc_addr
+#define netdev_for_each_uc_addr(ha, dev) \
+	list_for_each_entry(ha, &dev->uc.list, list)
+#endif
+#ifndef dma_set_coherent_mask
+#define dma_set_coherent_mask(dev,mask) \
+	pci_set_consistent_dma_mask(to_pci_dev(dev),(mask))
+#endif
+#ifndef pci_dev_run_wake
+#define pci_dev_run_wake(pdev)	(0)
+#endif
+
+/* netdev logging taken from include/linux/netdevice.h */
+#ifndef netdev_name
+static inline const char *_kc_netdev_name(const struct net_device *dev)
+{
+	if (dev->reg_state != NETREG_REGISTERED)
+		return "(unregistered net_device)";
+	return dev->name;
+}
+#define netdev_name(netdev)	_kc_netdev_name(netdev)
+#endif /* netdev_name */
+
+#undef netdev_printk
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+#define netdev_printk(level, netdev, format, args...)		\
+do {								\
+	struct pci_dev *pdev = _kc_netdev_to_pdev(netdev);	\
+	printk(level "%s: " format, pci_name(pdev), ##args);	\
+} while(0)
+#elif ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) )
+#define netdev_printk(level, netdev, format, args...)		\
+do {								\
+	struct pci_dev *pdev = _kc_netdev_to_pdev(netdev);	\
+	struct device *dev = pci_dev_to_dev(pdev);		\
+	dev_printk(level, dev, "%s: " format,			\
+		   netdev_name(netdev), ##args);		\
+} while(0)
+#else /* 2.6.21 => 2.6.34 */
+#define netdev_printk(level, netdev, format, args...)		\
+	dev_printk(level, (netdev)->dev.parent,			\
+		   "%s: " format,				\
+		   netdev_name(netdev), ##args)
+#endif /* <2.6.0 <2.6.21 <2.6.34 */
+#undef netdev_emerg
+#define netdev_emerg(dev, format, args...)			\
+	netdev_printk(KERN_EMERG, dev, format, ##args)
+#undef netdev_alert
+#define netdev_alert(dev, format, args...)			\
+	netdev_printk(KERN_ALERT, dev, format, ##args)
+#undef netdev_crit
+#define netdev_crit(dev, format, args...)			\
+	netdev_printk(KERN_CRIT, dev, format, ##args)
+#undef netdev_err
+#define netdev_err(dev, format, args...)			\
+	netdev_printk(KERN_ERR, dev, format, ##args)
+#undef netdev_warn
+#define netdev_warn(dev, format, args...)			\
+	netdev_printk(KERN_WARNING, dev, format, ##args)
+#undef netdev_notice
+#define netdev_notice(dev, format, args...)			\
+	netdev_printk(KERN_NOTICE, dev, format, ##args)
+#undef netdev_info
+#define netdev_info(dev, format, args...)			\
+	netdev_printk(KERN_INFO, dev, format, ##args)
+#undef netdev_dbg
+#if defined(DEBUG)
+#define netdev_dbg(__dev, format, args...)			\
+	netdev_printk(KERN_DEBUG, __dev, format, ##args)
+#elif defined(CONFIG_DYNAMIC_DEBUG)
+#define netdev_dbg(__dev, format, args...)			\
+do {								\
+	dynamic_dev_dbg((__dev)->dev.parent, "%s: " format,	\
+			netdev_name(__dev), ##args);		\
+} while (0)
+#else /* DEBUG */
+#define netdev_dbg(__dev, format, args...)			\
+({								\
+	if (0)							\
+		netdev_printk(KERN_DEBUG, __dev, format, ##args); \
+	0;							\
+})
+#endif /* DEBUG */
+
+#undef netif_printk
+#define netif_printk(priv, type, level, dev, fmt, args...)	\
+do {								\
+	if (netif_msg_##type(priv))				\
+		netdev_printk(level, (dev), fmt, ##args);	\
+} while (0)
+
+#undef netif_emerg
+#define netif_emerg(priv, type, dev, fmt, args...)		\
+	netif_level(emerg, priv, type, dev, fmt, ##args)
+#undef netif_alert
+#define netif_alert(priv, type, dev, fmt, args...)		\
+	netif_level(alert, priv, type, dev, fmt, ##args)
+#undef netif_crit
+#define netif_crit(priv, type, dev, fmt, args...)		\
+	netif_level(crit, priv, type, dev, fmt, ##args)
+#undef netif_err
+#define netif_err(priv, type, dev, fmt, args...)		\
+	netif_level(err, priv, type, dev, fmt, ##args)
+#undef netif_warn
+#define netif_warn(priv, type, dev, fmt, args...)		\
+	netif_level(warn, priv, type, dev, fmt, ##args)
+#undef netif_notice
+#define netif_notice(priv, type, dev, fmt, args...)		\
+	netif_level(notice, priv, type, dev, fmt, ##args)
+#undef netif_info
+#define netif_info(priv, type, dev, fmt, args...)		\
+	netif_level(info, priv, type, dev, fmt, ##args)
+#undef netif_dbg
+#define netif_dbg(priv, type, dev, fmt, args...)		\
+	netif_level(dbg, priv, type, dev, fmt, ##args)
+
+#ifdef SET_SYSTEM_SLEEP_PM_OPS
+#define HAVE_SYSTEM_SLEEP_PM_OPS
+#endif
+
+#ifndef for_each_set_bit
+#define for_each_set_bit(bit, addr, size) \
+	for ((bit) = find_first_bit((addr), (size)); \
+		(bit) < (size); \
+		(bit) = find_next_bit((addr), (size), (bit) + 1))
+#endif /* for_each_set_bit */
+
+#ifndef DEFINE_DMA_UNMAP_ADDR
+#define DEFINE_DMA_UNMAP_ADDR DECLARE_PCI_UNMAP_ADDR
+#define DEFINE_DMA_UNMAP_LEN DECLARE_PCI_UNMAP_LEN
+#define dma_unmap_addr pci_unmap_addr
+#define dma_unmap_addr_set pci_unmap_addr_set
+#define dma_unmap_len pci_unmap_len
+#define dma_unmap_len_set pci_unmap_len_set
+#endif /* DEFINE_DMA_UNMAP_ADDR */
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,3))
+#ifdef IGB_HWMON
+#ifdef CONFIG_DEBUG_LOCK_ALLOC
+#define sysfs_attr_init(attr)				\
+	do {						\
+		static struct lock_class_key __key;	\
+		(attr)->key = &__key;			\
+	} while (0)
+#else
+#define sysfs_attr_init(attr) do {} while (0)
+#endif /* CONFIG_DEBUG_LOCK_ALLOC */
+#endif /* IGB_HWMON */
+#endif /* RHEL_RELEASE_CODE */
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+static inline bool _kc_pm_runtime_suspended()
+{
+	return false;
+}
+#define pm_runtime_suspended(dev)	_kc_pm_runtime_suspended()
+#else /* 2.6.0 => 2.6.34 */
+static inline bool _kc_pm_runtime_suspended(struct device __always_unused *dev)
+{
+	return false;
+}
+#ifndef pm_runtime_suspended
+#define pm_runtime_suspended(dev)	_kc_pm_runtime_suspended(dev)
+#endif
+#endif /* 2.6.0 => 2.6.34 */
+
+#ifndef pci_bus_speed
+/* override pci_bus_speed introduced in 2.6.19 with an expanded enum type */
+enum _kc_pci_bus_speed {
+	_KC_PCIE_SPEED_2_5GT		= 0x14,
+	_KC_PCIE_SPEED_5_0GT		= 0x15,
+	_KC_PCIE_SPEED_8_0GT		= 0x16,
+	_KC_PCI_SPEED_UNKNOWN		= 0xff,
+};
+#define pci_bus_speed		_kc_pci_bus_speed
+#define PCIE_SPEED_2_5GT	_KC_PCIE_SPEED_2_5GT
+#define PCIE_SPEED_5_0GT	_KC_PCIE_SPEED_5_0GT
+#define PCIE_SPEED_8_0GT	_KC_PCIE_SPEED_8_0GT
+#define PCI_SPEED_UNKNOWN	_KC_PCI_SPEED_UNKNOWN
+#endif /* pci_bus_speed */
+
+#else /* < 2.6.34 */
+#define HAVE_SYSTEM_SLEEP_PM_OPS
+#ifndef HAVE_SET_RX_MODE
+#define HAVE_SET_RX_MODE
+#endif
+
+#endif /* < 2.6.34 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) )
+ssize_t _kc_simple_write_to_buffer(void *to, size_t available, loff_t *ppos,
+				   const void __user *from, size_t count);
+#define simple_write_to_buffer _kc_simple_write_to_buffer
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)))
+static inline struct pci_dev *pci_physfn(struct pci_dev *dev)
+{
+#ifdef HAVE_PCI_DEV_IS_VIRTFN_BIT
+#ifdef CONFIG_PCI_IOV
+	if (dev->is_virtfn)
+		dev = dev->physfn;
+#endif /* CONFIG_PCI_IOV */
+#endif /* HAVE_PCI_DEV_IS_VIRTFN_BIT */
+	return dev;
+}
+#endif /* ! RHEL >= 6.4 */
+
+#ifndef PCI_EXP_LNKSTA_NLW_SHIFT
+#define PCI_EXP_LNKSTA_NLW_SHIFT 4
+#endif
+
+#ifndef numa_node_id
+#define numa_node_id() 0
+#endif
+#ifndef numa_mem_id
+#define numa_mem_id numa_node_id
+#endif
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0)))
+#ifdef HAVE_TX_MQ
+#include <net/sch_generic.h>
+#ifndef CONFIG_NETDEVICES_MULTIQUEUE
+int _kc_netif_set_real_num_tx_queues(struct net_device *, unsigned int);
+#else /* CONFIG_NETDEVICES_MULTI_QUEUE */
+static inline int _kc_netif_set_real_num_tx_queues(struct net_device *dev,
+						   unsigned int txq)
+{
+	dev->egress_subqueue_count = txq;
+	return 0;
+}
+#endif /* CONFIG_NETDEVICES_MULTI_QUEUE */
+#else /* HAVE_TX_MQ */
+static inline int _kc_netif_set_real_num_tx_queues(struct net_device __always_unused *dev,
+						   unsigned int __always_unused txq)
+{
+	return 0;
+}
+#endif /* HAVE_TX_MQ */
+#define netif_set_real_num_tx_queues(dev, txq) \
+	_kc_netif_set_real_num_tx_queues(dev, txq)
+#endif /* !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0)) */
+#ifndef ETH_FLAG_RXHASH
+#define ETH_FLAG_RXHASH (1<<28)
+#endif /* ETH_FLAG_RXHASH */
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,0))
+#define HAVE_IRQ_AFFINITY_HINT
+#endif
+struct device_node;
+#else /* < 2.6.35 */
+#define HAVE_STRUCT_DEVICE_OF_NODE
+#define HAVE_PM_QOS_REQUEST_LIST
+#define HAVE_IRQ_AFFINITY_HINT
+#include <linux/of.h>
+#endif /* < 2.6.35 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) )
+int _kc_ethtool_op_set_flags(struct net_device *, u32, u32);
+#define ethtool_op_set_flags _kc_ethtool_op_set_flags
+u32 _kc_ethtool_op_get_flags(struct net_device *);
+#define ethtool_op_get_flags _kc_ethtool_op_get_flags
+
+enum {
+	WQ_UNBOUND = 0,
+	WQ_RESCUER = 0,
+};
+
+#ifdef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+#ifdef NET_IP_ALIGN
+#undef NET_IP_ALIGN
+#endif
+#define NET_IP_ALIGN 0
+#endif /* CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS */
+
+#ifdef NET_SKB_PAD
+#undef NET_SKB_PAD
+#endif
+
+#if (L1_CACHE_BYTES > 32)
+#define NET_SKB_PAD L1_CACHE_BYTES
+#else
+#define NET_SKB_PAD 32
+#endif
+
+static inline struct sk_buff *_kc_netdev_alloc_skb_ip_align(struct net_device *dev,
+							    unsigned int length)
+{
+	struct sk_buff *skb;
+
+	skb = alloc_skb(length + NET_SKB_PAD + NET_IP_ALIGN, GFP_ATOMIC);
+	if (skb) {
+#if (NET_IP_ALIGN + NET_SKB_PAD)
+		skb_reserve(skb, NET_IP_ALIGN + NET_SKB_PAD);
+#endif
+		skb->dev = dev;
+	}
+	return skb;
+}
+
+#ifdef netdev_alloc_skb_ip_align
+#undef netdev_alloc_skb_ip_align
+#endif
+#define netdev_alloc_skb_ip_align(n, l) _kc_netdev_alloc_skb_ip_align(n, l)
+
+#undef netif_level
+#define netif_level(level, priv, type, dev, fmt, args...)	\
+do {								\
+	if (netif_msg_##type(priv))				\
+		netdev_##level(dev, fmt, ##args);		\
+} while (0)
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,3)))
+#undef usleep_range
+#define usleep_range(min, max)	msleep(DIV_ROUND_UP(min, 1000))
+#endif
+
+#define u64_stats_update_begin(a) do { } while(0)
+#define u64_stats_update_end(a) do { } while(0)
+#define u64_stats_fetch_begin(a) do { } while(0)
+#define u64_stats_fetch_retry_bh(a,b) (0)
+#define u64_stats_fetch_begin_bh(a) (0)
+
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,1))
+#define HAVE_8021P_SUPPORT
+#endif
+
+/* RHEL6.4 and SLES11sp2 backported skb_tx_timestamp */
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(11,2,0)))
+static inline void skb_tx_timestamp(struct sk_buff __always_unused *skb)
+{
+	return;
+}
+#endif
+
+#else /* < 2.6.36 */
+
+#define msleep(x)	do { if (x > 20)				\
+				msleep(x);				\
+			     else					\
+				usleep_range(1000 * x, 2000 * x);	\
+			} while (0)
+
+#define HAVE_PM_QOS_REQUEST_ACTIVE
+#define HAVE_8021P_SUPPORT
+#define HAVE_NDO_GET_STATS64
+#endif /* < 2.6.36 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,37) )
+#define HAVE_NON_CONST_PCI_DRIVER_NAME
+#ifndef netif_set_real_num_tx_queues
+static inline int _kc_netif_set_real_num_tx_queues(struct net_device *dev,
+						   unsigned int txq)
+{
+	netif_set_real_num_tx_queues(dev, txq);
+	return 0;
+}
+#define netif_set_real_num_tx_queues(dev, txq) \
+	_kc_netif_set_real_num_tx_queues(dev, txq)
+#endif
+#ifndef netif_set_real_num_rx_queues
+static inline int __kc_netif_set_real_num_rx_queues(struct net_device __always_unused *dev,
+						    unsigned int __always_unused rxq)
+{
+	return 0;
+}
+#define netif_set_real_num_rx_queues(dev, rxq) \
+	__kc_netif_set_real_num_rx_queues((dev), (rxq))
+#endif
+#ifndef ETHTOOL_RXNTUPLE_ACTION_CLEAR
+#define ETHTOOL_RXNTUPLE_ACTION_CLEAR (-2)
+#endif
+#ifndef VLAN_N_VID
+#define VLAN_N_VID	VLAN_GROUP_ARRAY_LEN
+#endif /* VLAN_N_VID */
+#ifndef ETH_FLAG_TXVLAN
+#define ETH_FLAG_TXVLAN BIT(7)
+#endif /* ETH_FLAG_TXVLAN */
+#ifndef ETH_FLAG_RXVLAN
+#define ETH_FLAG_RXVLAN BIT(8)
+#endif /* ETH_FLAG_RXVLAN */
+
+#define WQ_MEM_RECLAIM WQ_RESCUER
+
+static inline void _kc_skb_checksum_none_assert(struct sk_buff *skb)
+{
+	WARN_ON(skb->ip_summed != CHECKSUM_NONE);
+}
+#define skb_checksum_none_assert(skb) _kc_skb_checksum_none_assert(skb)
+
+static inline void *_kc_vzalloc_node(unsigned long size, int node)
+{
+	void *addr = vmalloc_node(size, node);
+	if (addr)
+		memset(addr, 0, size);
+	return addr;
+}
+#define vzalloc_node(_size, _node) _kc_vzalloc_node(_size, _node)
+
+static inline void *_kc_vzalloc(unsigned long size)
+{
+	void *addr = vmalloc(size);
+	if (addr)
+		memset(addr, 0, size);
+	return addr;
+}
+#define vzalloc(_size) _kc_vzalloc(_size)
+
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(5,7)) || \
+     (RHEL_RELEASE_CODE == RHEL_RELEASE_VERSION(6,0)))
+static inline __be16 vlan_get_protocol(const struct sk_buff *skb)
+{
+	if (vlan_tx_tag_present(skb) ||
+	    skb->protocol != cpu_to_be16(ETH_P_8021Q))
+		return skb->protocol;
+
+	if (skb_headlen(skb) < sizeof(struct vlan_ethhdr))
+		return 0;
+
+	return ((struct vlan_ethhdr*)skb->data)->h_vlan_encapsulated_proto;
+}
+#endif /* !RHEL5.7+ || RHEL6.0 */
+
+#ifdef HAVE_HW_TIME_STAMP
+#define SKBTX_HW_TSTAMP BIT(0)
+#define SKBTX_IN_PROGRESS BIT(2)
+#define SKB_SHARED_TX_IS_UNION
+#endif
+
+#ifndef device_wakeup_enable
+#define device_wakeup_enable(dev)	device_set_wakeup_enable(dev, true)
+#endif
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,4,18) )
+#ifndef HAVE_VLAN_RX_REGISTER
+#define HAVE_VLAN_RX_REGISTER
+#endif
+#endif /* > 2.4.18 */
+#endif /* < 2.6.37 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,38) )
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22) )
+#define skb_checksum_start_offset(skb) skb_transport_offset(skb)
+#else /* 2.6.22 -> 2.6.37 */
+static inline int _kc_skb_checksum_start_offset(const struct sk_buff *skb)
+{
+        return skb->csum_start - skb_headroom(skb);
+}
+#define skb_checksum_start_offset(skb) _kc_skb_checksum_start_offset(skb)
+#endif /* 2.6.22 -> 2.6.37 */
+#if IS_ENABLED(CONFIG_DCB)
+#ifndef IEEE_8021QAZ_MAX_TCS
+#define IEEE_8021QAZ_MAX_TCS 8
+#endif
+#ifndef DCB_CAP_DCBX_HOST
+#define DCB_CAP_DCBX_HOST		0x01
+#endif
+#ifndef DCB_CAP_DCBX_LLD_MANAGED
+#define DCB_CAP_DCBX_LLD_MANAGED	0x02
+#endif
+#ifndef DCB_CAP_DCBX_VER_CEE
+#define DCB_CAP_DCBX_VER_CEE		0x04
+#endif
+#ifndef DCB_CAP_DCBX_VER_IEEE
+#define DCB_CAP_DCBX_VER_IEEE		0x08
+#endif
+#ifndef DCB_CAP_DCBX_STATIC
+#define DCB_CAP_DCBX_STATIC		0x10
+#endif
+#endif /* CONFIG_DCB */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,2))
+#define CONFIG_XPS
+#endif /* RHEL_RELEASE_VERSION(6,2) */
+#endif /* < 2.6.38 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39) )
+#ifndef TC_BITMASK
+#define TC_BITMASK 15
+#endif
+#ifndef NETIF_F_RXCSUM
+#define NETIF_F_RXCSUM		BIT(29)
+#endif
+#ifndef skb_queue_reverse_walk_safe
+#define skb_queue_reverse_walk_safe(queue, skb, tmp)				\
+		for (skb = (queue)->prev, tmp = skb->prev;			\
+		     skb != (struct sk_buff *)(queue);				\
+		     skb = tmp, tmp = skb->prev)
+#endif
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef FCOE_MTU
+#define FCOE_MTU	2158
+#endif
+#endif
+#if IS_ENABLED(CONFIG_DCB)
+#ifndef IEEE_8021QAZ_APP_SEL_ETHERTYPE
+#define IEEE_8021QAZ_APP_SEL_ETHERTYPE	1
+#endif
+#endif
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)))
+#define kstrtoul(a, b, c)  ((*(c)) = simple_strtoul((a), NULL, (b)), 0)
+#define kstrtouint(a, b, c)  ((*(c)) = simple_strtoul((a), NULL, (b)), 0)
+#define kstrtou32(a, b, c)  ((*(c)) = simple_strtoul((a), NULL, (b)), 0)
+#endif /* !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)) */
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,0)))
+u16 ___kc_skb_tx_hash(struct net_device *, const struct sk_buff *, u16);
+#define __skb_tx_hash(n, s, q) ___kc_skb_tx_hash((n), (s), (q))
+u8 _kc_netdev_get_num_tc(struct net_device *dev);
+#define netdev_get_num_tc(dev) _kc_netdev_get_num_tc(dev)
+int _kc_netdev_set_num_tc(struct net_device *dev, u8 num_tc);
+#define netdev_set_num_tc(dev, tc) _kc_netdev_set_num_tc((dev), (tc))
+#define netdev_reset_tc(dev) _kc_netdev_set_num_tc((dev), 0)
+#define netdev_set_tc_queue(dev, tc, cnt, off) do {} while (0)
+u8 _kc_netdev_get_prio_tc_map(struct net_device *dev, u8 up);
+#define netdev_get_prio_tc_map(dev, up) _kc_netdev_get_prio_tc_map(dev, up)
+#define netdev_set_prio_tc_map(dev, up, tc) do {} while (0)
+#else /* RHEL6.1 or greater */
+#ifndef HAVE_MQPRIO
+#define HAVE_MQPRIO
+#endif /* HAVE_MQPRIO */
+#if IS_ENABLED(CONFIG_DCB)
+#ifndef HAVE_DCBNL_IEEE
+#define HAVE_DCBNL_IEEE
+#ifndef IEEE_8021QAZ_TSA_STRICT
+#define IEEE_8021QAZ_TSA_STRICT		0
+#endif
+#ifndef IEEE_8021QAZ_TSA_ETS
+#define IEEE_8021QAZ_TSA_ETS		2
+#endif
+#ifndef IEEE_8021QAZ_APP_SEL_ETHERTYPE
+#define IEEE_8021QAZ_APP_SEL_ETHERTYPE	1
+#endif
+#endif
+#endif /* CONFIG_DCB */
+#endif /* !(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,0)) */
+
+#ifndef udp_csum
+#define udp_csum __kc_udp_csum
+static inline __wsum __kc_udp_csum(struct sk_buff *skb)
+{
+	__wsum csum = csum_partial(skb_transport_header(skb),
+				   sizeof(struct udphdr), skb->csum);
+
+	for (skb = skb_shinfo(skb)->frag_list; skb; skb = skb->next) {
+		csum = csum_add(csum, skb->csum);
+	}
+	return csum;
+}
+#endif /* udp_csum */
+#else /* < 2.6.39 */
+#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)
+#ifndef HAVE_NETDEV_OPS_FCOE_DDP_TARGET
+#define HAVE_NETDEV_OPS_FCOE_DDP_TARGET
+#endif
+#endif /* CONFIG_FCOE || CONFIG_FCOE_MODULE */
+#ifndef HAVE_MQPRIO
+#define HAVE_MQPRIO
+#endif
+#ifndef HAVE_SETUP_TC
+#define HAVE_SETUP_TC
+#endif
+#ifdef CONFIG_DCB
+#ifndef HAVE_DCBNL_IEEE
+#define HAVE_DCBNL_IEEE
+#endif
+#endif /* CONFIG_DCB */
+#ifndef HAVE_NDO_SET_FEATURES
+#define HAVE_NDO_SET_FEATURES
+#endif
+#define HAVE_IRQ_AFFINITY_NOTIFY
+#endif /* < 2.6.39 */
+
+/*****************************************************************************/
+/* use < 2.6.40 because of a Fedora 15 kernel update where they
+ * updated the kernel version to 2.6.40.x and they back-ported 3.0 features
+ * like set_phys_id for ethtool.
+ */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,40) )
+#ifdef ETHTOOL_GRXRINGS
+#ifndef FLOW_EXT
+#define	FLOW_EXT	0x80000000
+union _kc_ethtool_flow_union {
+	struct ethtool_tcpip4_spec		tcp_ip4_spec;
+	struct ethtool_usrip4_spec		usr_ip4_spec;
+	__u8					hdata[60];
+};
+struct _kc_ethtool_flow_ext {
+	__be16	vlan_etype;
+	__be16	vlan_tci;
+	__be32	data[2];
+};
+struct _kc_ethtool_rx_flow_spec {
+	__u32		flow_type;
+	union _kc_ethtool_flow_union h_u;
+	struct _kc_ethtool_flow_ext h_ext;
+	union _kc_ethtool_flow_union m_u;
+	struct _kc_ethtool_flow_ext m_ext;
+	__u64		ring_cookie;
+	__u32		location;
+};
+#define ethtool_rx_flow_spec _kc_ethtool_rx_flow_spec
+#endif /* FLOW_EXT */
+#endif
+
+#define pci_disable_link_state_locked pci_disable_link_state
+
+#ifndef PCI_LTR_VALUE_MASK
+#define  PCI_LTR_VALUE_MASK	0x000003ff
+#endif
+#ifndef PCI_LTR_SCALE_MASK
+#define  PCI_LTR_SCALE_MASK	0x00001c00
+#endif
+#ifndef PCI_LTR_SCALE_SHIFT
+#define  PCI_LTR_SCALE_SHIFT	10
+#endif
+
+#else /* < 2.6.40 */
+#define HAVE_ETHTOOL_SET_PHYS_ID
+#endif /* < 2.6.40 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0) )
+#define USE_LEGACY_PM_SUPPORT
+#ifndef kfree_rcu
+#define kfree_rcu(_ptr, _rcu_head) kfree(_ptr)
+#endif /* kfree_rcu */
+#ifndef kstrtol_from_user
+#define kstrtol_from_user(s, c, b, r) _kc_kstrtol_from_user(s, c, b, r)
+static inline int _kc_kstrtol_from_user(const char __user *s, size_t count,
+					unsigned int base, long *res)
+{
+	/* sign, base 2 representation, newline, terminator */
+	char buf[1 + sizeof(long) * 8 + 1 + 1];
+
+	count = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, s, count))
+		return -EFAULT;
+	buf[count] = '\0';
+	return strict_strtol(buf, base, res);
+}
+#endif
+
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,0) || \
+     RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(5,7)))
+/* 20000base_blah_full Supported and Advertised Registers */
+#define SUPPORTED_20000baseMLD2_Full	BIT(21)
+#define SUPPORTED_20000baseKR2_Full	BIT(22)
+#define ADVERTISED_20000baseMLD2_Full	BIT(21)
+#define ADVERTISED_20000baseKR2_Full	BIT(22)
+#endif /* RHEL_RELEASE_CODE */
+#endif /* < 3.0.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0) )
+#ifndef __netdev_alloc_skb_ip_align
+#define __netdev_alloc_skb_ip_align(d,l,_g) netdev_alloc_skb_ip_align(d,l)
+#endif /* __netdev_alloc_skb_ip_align */
+#define dcb_ieee_setapp(dev, app) dcb_setapp(dev, app)
+#define dcb_ieee_delapp(dev, app) 0
+#define dcb_ieee_getapp_mask(dev, app) (1 << app->priority)
+
+/* 1000BASE-T Control register */
+#define CTL1000_AS_MASTER	0x0800
+#define CTL1000_ENABLE_MASTER	0x1000
+
+/* kernels less than 3.0.0 don't have this */
+#ifndef ETH_P_8021AD
+#define ETH_P_8021AD	0x88A8
+#endif
+
+/* Stub definition for !CONFIG_OF is introduced later */
+#ifdef CONFIG_OF
+static inline struct device_node *
+pci_device_to_OF_node(struct pci_dev __maybe_unused *pdev)
+{
+#ifdef HAVE_STRUCT_DEVICE_OF_NODE
+	return pdev ? pdev->dev.of_node : NULL;
+#else
+	return NULL;
+#endif /* !HAVE_STRUCT_DEVICE_OF_NODE */
+}
+#endif /* CONFIG_OF */
+#else /* < 3.1.0 */
+#ifndef HAVE_DCBNL_IEEE_DELAPP
+#define HAVE_DCBNL_IEEE_DELAPP
+#endif
+#endif /* < 3.1.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0) )
+#ifndef dma_zalloc_coherent
+#define dma_zalloc_coherent(d, s, h, f) _kc_dma_zalloc_coherent(d, s, h, f)
+static inline void *_kc_dma_zalloc_coherent(struct device *dev, size_t size,
+					    dma_addr_t *dma_handle, gfp_t flag)
+{
+	void *ret = dma_alloc_coherent(dev, size, dma_handle, flag);
+	if (ret)
+		memset(ret, 0, size);
+	return ret;
+}
+#endif
+#ifdef ETHTOOL_GRXRINGS
+#define HAVE_ETHTOOL_GET_RXNFC_VOID_RULE_LOCS
+#endif /* ETHTOOL_GRXRINGS */
+
+#ifndef skb_frag_size
+#define skb_frag_size(frag)	_kc_skb_frag_size(frag)
+static inline unsigned int _kc_skb_frag_size(const skb_frag_t *frag)
+{
+	return frag->size;
+}
+#endif /* skb_frag_size */
+
+#ifndef skb_frag_size_sub
+#define skb_frag_size_sub(frag, delta)	_kc_skb_frag_size_sub(frag, delta)
+static inline void _kc_skb_frag_size_sub(skb_frag_t *frag, int delta)
+{
+	frag->size -= delta;
+}
+#endif /* skb_frag_size_sub */
+
+#ifndef skb_frag_page
+#define skb_frag_page(frag)	_kc_skb_frag_page(frag)
+static inline struct page *_kc_skb_frag_page(const skb_frag_t *frag)
+{
+	return frag->page;
+}
+#endif /* skb_frag_page */
+
+#ifndef skb_frag_address
+#define skb_frag_address(frag)	_kc_skb_frag_address(frag)
+static inline void *_kc_skb_frag_address(const skb_frag_t *frag)
+{
+	return page_address(skb_frag_page(frag)) + frag->page_offset;
+}
+#endif /* skb_frag_address */
+
+#ifndef skb_frag_dma_map
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) )
+#include <linux/dma-mapping.h>
+#endif
+#define skb_frag_dma_map(dev,frag,offset,size,dir) \
+		_kc_skb_frag_dma_map(dev,frag,offset,size,dir)
+static inline dma_addr_t _kc_skb_frag_dma_map(struct device *dev,
+					      const skb_frag_t *frag,
+					      size_t offset, size_t size,
+					      enum dma_data_direction dir)
+{
+	return dma_map_page(dev, skb_frag_page(frag),
+			    frag->page_offset + offset, size, dir);
+}
+#endif /* skb_frag_dma_map */
+
+#ifndef __skb_frag_unref
+#define __skb_frag_unref(frag) __kc_skb_frag_unref(frag)
+static inline void __kc_skb_frag_unref(skb_frag_t *frag)
+{
+	put_page(skb_frag_page(frag));
+}
+#endif /* __skb_frag_unref */
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN	-1
+#endif
+#ifndef DUPLEX_UNKNOWN
+#define DUPLEX_UNKNOWN	0xff
+#endif
+#if ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,3)) ||\
+     (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0)))
+#ifndef HAVE_PCI_DEV_FLAGS_ASSIGNED
+#define HAVE_PCI_DEV_FLAGS_ASSIGNED
+#endif
+#endif
+#else /* < 3.2.0 */
+#ifndef HAVE_PCI_DEV_FLAGS_ASSIGNED
+#define HAVE_PCI_DEV_FLAGS_ASSIGNED
+#define HAVE_VF_SPOOFCHK_CONFIGURE
+#endif
+#ifndef HAVE_SKB_L4_RXHASH
+#define HAVE_SKB_L4_RXHASH
+#endif
+#define HAVE_IOMMU_PRESENT
+#define HAVE_PM_QOS_REQUEST_LIST_NEW
+#endif /* < 3.2.0 */
+
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE == RHEL_RELEASE_VERSION(6,2))
+#undef ixgbe_get_netdev_tc_txq
+#define ixgbe_get_netdev_tc_txq(dev, tc) (&netdev_extended(dev)->qos_data.tc_to_txq[tc])
+#endif
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0) )
+/* NOTE: the order of parameters to _kc_alloc_workqueue() is different than
+ * alloc_workqueue() to avoid compiler warning from -Wvarargs
+ */
+static inline struct workqueue_struct * __attribute__ ((format(printf, 3, 4)))
+_kc_alloc_workqueue(__maybe_unused int flags, __maybe_unused int max_active,
+		    const char *fmt, ...)
+{
+	struct workqueue_struct *wq;
+	va_list args, temp;
+	unsigned int len;
+	char *p;
+
+	va_start(args, fmt);
+	va_copy(temp, args);
+	len = vsnprintf(NULL, 0, fmt, temp);
+	va_end(temp);
+
+	p = kmalloc(len + 1, GFP_KERNEL);
+	if (!p) {
+		va_end(args);
+		return NULL;
+	}
+
+	vsnprintf(p, len + 1, fmt, args);
+	va_end(args);
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) )
+	wq = create_workqueue(p);
+#else
+	wq = alloc_workqueue(p, flags, max_active);
+#endif
+	kfree(p);
+
+	return wq;
+}
+#ifdef alloc_workqueue
+#undef alloc_workqueue
+#endif
+#define alloc_workqueue(fmt, flags, max_active, args...) \
+	_kc_alloc_workqueue(flags, max_active, fmt, ##args)
+
+#if !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,5))
+typedef u32 netdev_features_t;
+#endif
+#undef PCI_EXP_TYPE_RC_EC
+#define  PCI_EXP_TYPE_RC_EC	0xa	/* Root Complex Event Collector */
+#ifndef CONFIG_BQL
+#define netdev_tx_completed_queue(_q, _p, _b) do {} while (0)
+#define netdev_completed_queue(_n, _p, _b) do {} while (0)
+#define netdev_tx_sent_queue(_q, _b) do {} while (0)
+#define netdev_sent_queue(_n, _b) do {} while (0)
+#define netdev_tx_reset_queue(_q) do {} while (0)
+#define netdev_reset_queue(_n) do {} while (0)
+#endif
+#if (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0))
+#define HAVE_ETHTOOL_GRXFHINDIR_SIZE
+#endif /* SLE_VERSION(11,3,0) */
+#define netif_xmit_stopped(_q) netif_tx_queue_stopped(_q)
+#if !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,4,0))
+static inline int __kc_ipv6_skip_exthdr(const struct sk_buff *skb, int start,
+					u8 *nexthdrp,
+					__be16 __always_unused *frag_offp)
+{
+	return ipv6_skip_exthdr(skb, start, nexthdrp);
+}
+#undef ipv6_skip_exthdr
+#define ipv6_skip_exthdr(a,b,c,d) __kc_ipv6_skip_exthdr((a), (b), (c), (d))
+#endif /* !SLES11sp4 or greater */
+
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(11,3,0)))
+static inline u32 ethtool_rxfh_indir_default(u32 index, u32 n_rx_rings)
+{
+	return index % n_rx_rings;
+}
+#endif
+
+#else /* ! < 3.3.0 */
+#define HAVE_ETHTOOL_GRXFHINDIR_SIZE
+#define HAVE_INT_NDO_VLAN_RX_ADD_VID
+#ifdef ETHTOOL_SRXNTUPLE
+#undef ETHTOOL_SRXNTUPLE
+#endif
+#endif /* < 3.3.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0) )
+#ifndef NETIF_F_RXFCS
+#define NETIF_F_RXFCS	0
+#endif /* NETIF_F_RXFCS */
+#ifndef NETIF_F_RXALL
+#define NETIF_F_RXALL	0
+#endif /* NETIF_F_RXALL */
+
+#if !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0))
+#define NUMTCS_RETURNS_U8
+
+int _kc_simple_open(struct inode *inode, struct file *file);
+#define simple_open _kc_simple_open
+#endif /* !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0)) */
+
+#ifndef skb_add_rx_frag
+#define skb_add_rx_frag _kc_skb_add_rx_frag
+void _kc_skb_add_rx_frag(struct sk_buff * skb, int i, struct page *page,
+			 int off, int size, unsigned int truesize);
+#endif
+#ifdef NET_ADDR_RANDOM
+#define eth_hw_addr_random(N) do { \
+	eth_random_addr(N->dev_addr); \
+	N->addr_assign_type |= NET_ADDR_RANDOM; \
+	} while (0)
+#else /* NET_ADDR_RANDOM */
+#define eth_hw_addr_random(N) eth_random_addr(N->dev_addr)
+#endif /* NET_ADDR_RANDOM */
+
+#ifndef for_each_set_bit_from
+#define for_each_set_bit_from(bit, addr, size) \
+	for ((bit) = find_next_bit((addr), (size), (bit)); \
+			(bit) < (size); \
+			(bit) = find_next_bit((addr), (size), (bit) + 1))
+#endif /* for_each_set_bit_from */
+
+#else /* < 3.4.0 */
+#include <linux/kconfig.h>
+#endif /* >= 3.4.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) ) || \
+    ( RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4) )
+#if !defined(NO_PTP_SUPPORT) && IS_ENABLED(CONFIG_PTP_1588_CLOCK)
+#define HAVE_PTP_1588_CLOCK
+#endif /* !NO_PTP_SUPPORT && IS_ENABLED(CONFIG_PTP_1588_CLOCK) */
+#endif /* >= 3.0.0 || RHEL_RELEASE > 6.4 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0) )
+
+#ifndef SIZE_MAX
+#define SIZE_MAX (~(size_t)0)
+#endif
+
+#ifndef BITS_PER_LONG_LONG
+#define BITS_PER_LONG_LONG 64
+#endif
+
+#ifndef ether_addr_equal
+static inline bool __kc_ether_addr_equal(const u8 *addr1, const u8 *addr2)
+{
+	return !compare_ether_addr(addr1, addr2);
+}
+#define ether_addr_equal(_addr1, _addr2) __kc_ether_addr_equal((_addr1),(_addr2))
+#endif
+
+/* Definitions for !CONFIG_OF_NET are introduced in 3.10 */
+#ifdef CONFIG_OF_NET
+static inline int of_get_phy_mode(struct device_node __always_unused *np)
+{
+	return -ENODEV;
+}
+
+static inline const void *
+of_get_mac_address(struct device_node __always_unused *np)
+{
+	return NULL;
+}
+#endif
+#else
+#include <linux/of_net.h>
+#define HAVE_FDB_OPS
+#define HAVE_ETHTOOL_GET_TS_INFO
+#endif /* < 3.5.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0) )
+#define PCI_EXP_LNKCAP2		44	/* Link Capability 2 */
+
+#ifndef MDIO_EEE_100TX
+#define MDIO_EEE_100TX		0x0002	/* 100TX EEE cap */
+#endif
+#ifndef MDIO_EEE_1000T
+#define MDIO_EEE_1000T		0x0004	/* 1000T EEE cap */
+#endif
+#ifndef MDIO_EEE_10GT
+#define MDIO_EEE_10GT		0x0008	/* 10GT EEE cap */
+#endif
+#ifndef MDIO_EEE_1000KX
+#define MDIO_EEE_1000KX		0x0010	/* 1000KX EEE cap */
+#endif
+#ifndef MDIO_EEE_10GKX4
+#define MDIO_EEE_10GKX4		0x0020	/* 10G KX4 EEE cap */
+#endif
+#ifndef MDIO_EEE_10GKR
+#define MDIO_EEE_10GKR		0x0040	/* 10G KR EEE cap */
+#endif
+
+#ifndef __GFP_MEMALLOC
+#define __GFP_MEMALLOC 0
+#endif
+
+#ifndef eth_broadcast_addr
+#define eth_broadcast_addr _kc_eth_broadcast_addr
+static inline void _kc_eth_broadcast_addr(u8 *addr)
+{
+	memset(addr, 0xff, ETH_ALEN);
+}
+#endif
+
+#ifndef eth_random_addr
+#define eth_random_addr _kc_eth_random_addr
+static inline void _kc_eth_random_addr(u8 *addr)
+{
+        get_random_bytes(addr, ETH_ALEN);
+        addr[0] &= 0xfe; /* clear multicast */
+        addr[0] |= 0x02; /* set local assignment */
+}
+#endif /* eth_random_addr */
+
+#ifndef DMA_ATTR_SKIP_CPU_SYNC
+#define DMA_ATTR_SKIP_CPU_SYNC 0
+#endif
+#else /* < 3.6.0 */
+#define HAVE_STRUCT_PAGE_PFMEMALLOC
+#endif /* < 3.6.0 */
+
+/******************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0) )
+#include <linux/workqueue.h>
+#ifndef ADVERTISED_40000baseKR4_Full
+/* these defines were all added in one commit, so should be safe
+ * to trigger activiation on one define
+ */
+#define SUPPORTED_40000baseKR4_Full	BIT(23)
+#define SUPPORTED_40000baseCR4_Full	BIT(24)
+#define SUPPORTED_40000baseSR4_Full	BIT(25)
+#define SUPPORTED_40000baseLR4_Full	BIT(26)
+#define ADVERTISED_40000baseKR4_Full	BIT(23)
+#define ADVERTISED_40000baseCR4_Full	BIT(24)
+#define ADVERTISED_40000baseSR4_Full	BIT(25)
+#define ADVERTISED_40000baseLR4_Full	BIT(26)
+#endif
+
+#ifndef mmd_eee_cap_to_ethtool_sup_t
+/**
+ * mmd_eee_cap_to_ethtool_sup_t
+ * @eee_cap: value of the MMD EEE Capability register
+ *
+ * A small helper function that translates MMD EEE Capability (3.20) bits
+ * to ethtool supported settings.
+ */
+static inline u32 __kc_mmd_eee_cap_to_ethtool_sup_t(u16 eee_cap)
+{
+	u32 supported = 0;
+
+	if (eee_cap & MDIO_EEE_100TX)
+		supported |= SUPPORTED_100baseT_Full;
+	if (eee_cap & MDIO_EEE_1000T)
+		supported |= SUPPORTED_1000baseT_Full;
+	if (eee_cap & MDIO_EEE_10GT)
+		supported |= SUPPORTED_10000baseT_Full;
+	if (eee_cap & MDIO_EEE_1000KX)
+		supported |= SUPPORTED_1000baseKX_Full;
+	if (eee_cap & MDIO_EEE_10GKX4)
+		supported |= SUPPORTED_10000baseKX4_Full;
+	if (eee_cap & MDIO_EEE_10GKR)
+		supported |= SUPPORTED_10000baseKR_Full;
+
+	return supported;
+}
+#define mmd_eee_cap_to_ethtool_sup_t(eee_cap) \
+	__kc_mmd_eee_cap_to_ethtool_sup_t(eee_cap)
+#endif /* mmd_eee_cap_to_ethtool_sup_t */
+
+#ifndef mmd_eee_adv_to_ethtool_adv_t
+/**
+ * mmd_eee_adv_to_ethtool_adv_t
+ * @eee_adv: value of the MMD EEE Advertisement/Link Partner Ability registers
+ *
+ * A small helper function that translates the MMD EEE Advertisement (7.60)
+ * and MMD EEE Link Partner Ability (7.61) bits to ethtool advertisement
+ * settings.
+ */
+static inline u32 __kc_mmd_eee_adv_to_ethtool_adv_t(u16 eee_adv)
+{
+	u32 adv = 0;
+
+	if (eee_adv & MDIO_EEE_100TX)
+		adv |= ADVERTISED_100baseT_Full;
+	if (eee_adv & MDIO_EEE_1000T)
+		adv |= ADVERTISED_1000baseT_Full;
+	if (eee_adv & MDIO_EEE_10GT)
+		adv |= ADVERTISED_10000baseT_Full;
+	if (eee_adv & MDIO_EEE_1000KX)
+		adv |= ADVERTISED_1000baseKX_Full;
+	if (eee_adv & MDIO_EEE_10GKX4)
+		adv |= ADVERTISED_10000baseKX4_Full;
+	if (eee_adv & MDIO_EEE_10GKR)
+		adv |= ADVERTISED_10000baseKR_Full;
+
+	return adv;
+}
+
+#define mmd_eee_adv_to_ethtool_adv_t(eee_adv) \
+	__kc_mmd_eee_adv_to_ethtool_adv_t(eee_adv)
+#endif /* mmd_eee_adv_to_ethtool_adv_t */
+
+#ifndef ethtool_adv_to_mmd_eee_adv_t
+/**
+ * ethtool_adv_to_mmd_eee_adv_t
+ * @adv: the ethtool advertisement settings
+ *
+ * A small helper function that translates ethtool advertisement settings
+ * to EEE advertisements for the MMD EEE Advertisement (7.60) and
+ * MMD EEE Link Partner Ability (7.61) registers.
+ */
+static inline u16 __kc_ethtool_adv_to_mmd_eee_adv_t(u32 adv)
+{
+	u16 reg = 0;
+
+	if (adv & ADVERTISED_100baseT_Full)
+		reg |= MDIO_EEE_100TX;
+	if (adv & ADVERTISED_1000baseT_Full)
+		reg |= MDIO_EEE_1000T;
+	if (adv & ADVERTISED_10000baseT_Full)
+		reg |= MDIO_EEE_10GT;
+	if (adv & ADVERTISED_1000baseKX_Full)
+		reg |= MDIO_EEE_1000KX;
+	if (adv & ADVERTISED_10000baseKX4_Full)
+		reg |= MDIO_EEE_10GKX4;
+	if (adv & ADVERTISED_10000baseKR_Full)
+		reg |= MDIO_EEE_10GKR;
+
+	return reg;
+}
+#define ethtool_adv_to_mmd_eee_adv_t(adv) __kc_ethtool_adv_to_mmd_eee_adv_t(adv)
+#endif /* ethtool_adv_to_mmd_eee_adv_t */
+
+#ifndef pci_pcie_type
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24) )
+static inline u8 pci_pcie_type(struct pci_dev *pdev)
+{
+	int pos;
+	u16 reg16;
+
+	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
+	BUG_ON(!pos);
+	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &reg16);
+	return (reg16 & PCI_EXP_FLAGS_TYPE) >> 4;
+}
+#else /* < 2.6.24 */
+#define pci_pcie_type(x)	(x)->pcie_type
+#endif /* < 2.6.24 */
+#endif /* pci_pcie_type */
+
+#if ( ! ( RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,4) ) ) && \
+    ( ! ( SLE_VERSION_CODE >= SLE_VERSION(11,3,0) ) ) && \
+    ( LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0) )
+#define ptp_clock_register(caps, args...) ptp_clock_register(caps)
+#endif
+
+#ifndef pcie_capability_read_word
+int __kc_pcie_capability_read_word(struct pci_dev *dev, int pos, u16 *val);
+#define pcie_capability_read_word(d,p,v) __kc_pcie_capability_read_word(d,p,v)
+#endif /* pcie_capability_read_word */
+
+#ifndef pcie_capability_read_dword
+int __kc_pcie_capability_read_dword(struct pci_dev *dev, int pos, u32 *val);
+#define pcie_capability_read_dword(d,p,v) __kc_pcie_capability_read_dword(d,p,v)
+#endif
+
+#ifndef pcie_capability_write_word
+int __kc_pcie_capability_write_word(struct pci_dev *dev, int pos, u16 val);
+#define pcie_capability_write_word(d,p,v) __kc_pcie_capability_write_word(d,p,v)
+#endif /* pcie_capability_write_word */
+
+#ifndef pcie_capability_clear_and_set_word
+int __kc_pcie_capability_clear_and_set_word(struct pci_dev *dev, int pos,
+					    u16 clear, u16 set);
+#define pcie_capability_clear_and_set_word(d,p,c,s) \
+	__kc_pcie_capability_clear_and_set_word(d,p,c,s)
+#endif /* pcie_capability_clear_and_set_word */
+
+#ifndef pcie_capability_clear_word
+int __kc_pcie_capability_clear_word(struct pci_dev *dev, int pos,
+					     u16 clear);
+#define pcie_capability_clear_word(d, p, c) \
+	__kc_pcie_capability_clear_word(d, p, c)
+#endif /* pcie_capability_clear_word */
+
+#ifndef PCI_EXP_LNKSTA2
+#define PCI_EXP_LNKSTA2		50	/* Link Status 2 */
+#endif
+
+#if (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,3,0))
+#define USE_CONST_DEV_UC_CHAR
+#define HAVE_NDO_FDB_ADD_NLATTR
+#endif
+
+#if !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,8))
+#define napi_gro_flush(_napi, _flush_old) napi_gro_flush(_napi)
+#endif /* !RHEL6.8+ */
+
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,6))
+#include <linux/hashtable.h>
+#else
+
+#define DEFINE_HASHTABLE(name, bits)						\
+	struct hlist_head name[1 << (bits)] =					\
+			{ [0 ... ((1 << (bits)) - 1)] = HLIST_HEAD_INIT }
+
+#define DEFINE_READ_MOSTLY_HASHTABLE(name, bits)				\
+	struct hlist_head name[1 << (bits)] __read_mostly =			\
+			{ [0 ... ((1 << (bits)) - 1)] = HLIST_HEAD_INIT }
+
+#define DECLARE_HASHTABLE(name, bits)                                   	\
+	struct hlist_head name[1 << (bits)]
+
+#define HASH_SIZE(name) (ARRAY_SIZE(name))
+#define HASH_BITS(name) ilog2(HASH_SIZE(name))
+
+/* Use hash_32 when possible to allow for fast 32bit hashing in 64bit kernels. */
+#define hash_min(val, bits)							\
+	(sizeof(val) <= 4 ? hash_32(val, bits) : hash_long(val, bits))
+
+static inline void __hash_init(struct hlist_head *ht, unsigned int sz)
+{
+	unsigned int i;
+
+	for (i = 0; i < sz; i++)
+		INIT_HLIST_HEAD(&ht[i]);
+}
+
+#define hash_init(hashtable) __hash_init(hashtable, HASH_SIZE(hashtable))
+
+#define hash_add(hashtable, node, key)						\
+	hlist_add_head(node, &hashtable[hash_min(key, HASH_BITS(hashtable))])
+
+static inline bool hash_hashed(struct hlist_node *node)
+{
+	return !hlist_unhashed(node);
+}
+
+static inline bool __hash_empty(struct hlist_head *ht, unsigned int sz)
+{
+	unsigned int i;
+
+	for (i = 0; i < sz; i++)
+		if (!hlist_empty(&ht[i]))
+			return false;
+
+	return true;
+}
+
+#define hash_empty(hashtable) __hash_empty(hashtable, HASH_SIZE(hashtable))
+
+static inline void hash_del(struct hlist_node *node)
+{
+	hlist_del_init(node);
+}
+#endif /* RHEL >= 6.6 */
+
+/* We don't have @flags support prior to 3.7, so we'll simply ignore the flags
+ * parameter on these older kernels.
+ */
+#define __setup_timer(_timer, _fn, _data, _flags)	\
+	setup_timer((_timer), (_fn), (_data))		\
+
+#if ( ! ( RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,7) ) ) && \
+	( ! ( SLE_VERSION_CODE >= SLE_VERSION(12,0,0) ) )
+
+#ifndef mod_delayed_work
+/**
+ * __mod_delayed_work - modify delay or queue delayed work
+ * @wq: workqueue to use
+ * @dwork: delayed work to queue
+ * @delay: number of jiffies to wait before queueing
+ *
+ * Return: %true if @dwork was pending and was rescheduled;
+ *         %false if it wasn't pending
+ *
+ * Note: the dwork parameter was declared as a void*
+ *       to avoid comptibility problems with early 2.6 kernels
+ *       where struct delayed_work is not declared. Unlike the original
+ *       implementation flags are not preserved and it shouldn't be
+ *       used in the interrupt context.
+ */
+static inline bool __mod_delayed_work(struct workqueue_struct *wq,
+				    void *dwork,
+				    unsigned long delay)
+{
+	bool ret = cancel_delayed_work(dwork);
+	queue_delayed_work(wq, dwork, delay);
+	return ret;
+}
+#define mod_delayed_work(wq, dwork, delay) __mod_delayed_work(wq, dwork, delay)
+#endif /* mod_delayed_work */
+
+#endif /* !(RHEL >= 6.7) && !(SLE >= 12.0) */
+#else /* >= 3.7.0 */
+#include <linux/hashtable.h>
+#define HAVE_CONST_STRUCT_PCI_ERROR_HANDLERS
+#define USE_CONST_DEV_UC_CHAR
+#define HAVE_NDO_FDB_ADD_NLATTR
+#endif /* >= 3.7.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0) )
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,5)) && \
+     !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,4,0)))
+#ifndef pci_sriov_set_totalvfs
+static inline int __kc_pci_sriov_set_totalvfs(struct pci_dev __always_unused *dev, u16 __always_unused numvfs)
+{
+	return 0;
+}
+#define pci_sriov_set_totalvfs(a, b) __kc_pci_sriov_set_totalvfs((a), (b))
+#endif
+#endif /* !(RHEL_RELEASE_CODE >= 6.5 && SLE_VERSION_CODE >= 11.4) */
+#ifndef PCI_EXP_LNKCTL_ASPM_L0S
+#define  PCI_EXP_LNKCTL_ASPM_L0S  0x01	/* L0s Enable */
+#endif
+#ifndef PCI_EXP_LNKCTL_ASPM_L1
+#define  PCI_EXP_LNKCTL_ASPM_L1   0x02	/* L1 Enable */
+#endif
+#define HAVE_CONFIG_HOTPLUG
+/* Reserved Ethernet Addresses per IEEE 802.1Q */
+static const u8 eth_reserved_addr_base[ETH_ALEN] __aligned(2) = {
+	0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
+
+#ifndef is_link_local_ether_addr
+static inline bool __kc_is_link_local_ether_addr(const u8 *addr)
+{
+	__be16 *a = (__be16 *)addr;
+	static const __be16 *b = (const __be16 *)eth_reserved_addr_base;
+	static const __be16 m = cpu_to_be16(0xfff0);
+
+	return ((a[0] ^ b[0]) | (a[1] ^ b[1]) | ((a[2] ^ b[2]) & m)) == 0;
+}
+#define is_link_local_ether_addr(addr) __kc_is_link_local_ether_addr(addr)
+#endif /* is_link_local_ether_addr */
+
+#ifndef FLOW_MAC_EXT
+#define FLOW_MAC_EXT	0x40000000
+#endif /* FLOW_MAC_EXT */
+
+#if (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,4,0))
+#define HAVE_SRIOV_CONFIGURE
+#endif
+
+#ifndef PCI_EXP_LNKCAP_SLS_2_5GB
+#define PCI_EXP_LNKCAP_SLS_2_5GB 0x00000001 /* LNKCAP2 SLS Vector bit 0 */
+#endif
+
+#ifndef PCI_EXP_LNKCAP_SLS_5_0GB
+#define PCI_EXP_LNKCAP_SLS_5_0GB 0x00000002 /* LNKCAP2 SLS Vector bit 1 */
+#endif
+
+#undef PCI_EXP_LNKCAP2_SLS_2_5GB
+#define PCI_EXP_LNKCAP2_SLS_2_5GB 0x00000002 /* Supported Speed 2.5GT/s */
+
+#undef PCI_EXP_LNKCAP2_SLS_5_0GB
+#define PCI_EXP_LNKCAP2_SLS_5_0GB 0x00000004 /* Supported Speed 5GT/s */
+
+#undef PCI_EXP_LNKCAP2_SLS_8_0GB
+#define PCI_EXP_LNKCAP2_SLS_8_0GB 0x00000008 /* Supported Speed 8GT/s */
+
+#else /* >= 3.8.0 */
+#ifndef __devinit
+#define __devinit
+#endif
+
+#ifndef __devinitdata
+#define __devinitdata
+#endif
+
+#ifndef __devinitconst
+#define __devinitconst
+#endif
+
+#ifndef __devexit
+#define __devexit
+#endif
+
+#ifndef __devexit_p
+#define __devexit_p
+#endif
+
+#ifndef HAVE_ENCAP_CSUM_OFFLOAD
+#define HAVE_ENCAP_CSUM_OFFLOAD
+#endif
+
+#ifndef HAVE_GRE_ENCAP_OFFLOAD
+#define HAVE_GRE_ENCAP_OFFLOAD
+#endif
+
+#ifndef HAVE_SRIOV_CONFIGURE
+#define HAVE_SRIOV_CONFIGURE
+#endif
+
+#define HAVE_BRIDGE_ATTRIBS
+#ifndef BRIDGE_MODE_VEB
+#define BRIDGE_MODE_VEB		0	/* Default loopback mode */
+#endif /* BRIDGE_MODE_VEB */
+#ifndef BRIDGE_MODE_VEPA
+#define BRIDGE_MODE_VEPA	1	/* 802.1Qbg defined VEPA mode */
+#endif /* BRIDGE_MODE_VEPA */
+#endif /* >= 3.8.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0) )
+
+#undef BUILD_BUG_ON
+#ifdef __CHECKER__
+#define BUILD_BUG_ON(condition) (0)
+#else /* __CHECKER__ */
+#ifndef __compiletime_warning
+#if defined(__GNUC__) && ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) >= 40400)
+#define __compiletime_warning(message) __attribute__((warning(message)))
+#else /* __GNUC__ */
+#define __compiletime_warning(message)
+#endif /* __GNUC__ */
+#endif /* __compiletime_warning */
+#ifndef __compiletime_error
+#if defined(__GNUC__) && ((__GNUC__ * 10000 + __GNUC_MINOR__ * 100) >= 40400)
+#define __compiletime_error(message) __attribute__((error(message)))
+#define __compiletime_error_fallback(condition) do { } while (0)
+#else /* __GNUC__ */
+#define __compiletime_error(message)
+#define __compiletime_error_fallback(condition) \
+	do { ((void)sizeof(char[1 - 2 * condition])); } while (0)
+#endif /* __GNUC__ */
+#else /* __compiletime_error */
+#define __compiletime_error_fallback(condition) do { } while (0)
+#endif /* __compiletime_error */
+#define __compiletime_assert(condition, msg, prefix, suffix)		\
+	do {								\
+		bool __cond = !(condition);				\
+		extern void prefix ## suffix(void) __compiletime_error(msg); \
+		if (__cond)						\
+			prefix ## suffix();				\
+		__compiletime_error_fallback(__cond);			\
+	} while (0)
+
+#define _compiletime_assert(condition, msg, prefix, suffix) \
+	__compiletime_assert(condition, msg, prefix, suffix)
+#define compiletime_assert(condition, msg) \
+	_compiletime_assert(condition, msg, __compiletime_assert_, __LINE__)
+#define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)
+#ifndef __OPTIMIZE__
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
+#else /* __OPTIMIZE__ */
+#define BUILD_BUG_ON(condition) \
+	BUILD_BUG_ON_MSG(condition, "BUILD_BUG_ON failed: " #condition)
+#endif /* __OPTIMIZE__ */
+#endif /* __CHECKER__ */
+
+#undef hlist_entry
+#define hlist_entry(ptr, type, member) container_of(ptr,type,member)
+
+#undef hlist_entry_safe
+#define hlist_entry_safe(ptr, type, member) \
+	({ typeof(ptr) ____ptr = (ptr); \
+	   ____ptr ? hlist_entry(____ptr, type, member) : NULL; \
+	})
+
+#undef hlist_for_each_entry
+#define hlist_for_each_entry(pos, head, member)                             \
+	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member); \
+	     pos;                                                           \
+	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
+
+#undef hlist_for_each_entry_safe
+#define hlist_for_each_entry_safe(pos, n, head, member) 		    \
+	for (pos = hlist_entry_safe((head)->first, typeof(*pos), member);   \
+	     pos && ({ n = pos->member.next; 1; });			    \
+	     pos = hlist_entry_safe(n, typeof(*pos), member))
+
+#undef hlist_for_each_entry_continue
+#define hlist_for_each_entry_continue(pos, member)			\
+	for (pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member);\
+	     pos;							\
+	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
+
+#undef hlist_for_each_entry_from
+#define hlist_for_each_entry_from(pos, member)				\
+	for (; pos;							\
+	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
+
+#undef hash_for_each
+#define hash_for_each(name, bkt, obj, member)				\
+	for ((bkt) = 0, obj = NULL; obj == NULL && (bkt) < HASH_SIZE(name);\
+			(bkt)++)\
+		hlist_for_each_entry(obj, &name[bkt], member)
+
+#undef hash_for_each_safe
+#define hash_for_each_safe(name, bkt, tmp, obj, member)			\
+	for ((bkt) = 0, obj = NULL; obj == NULL && (bkt) < HASH_SIZE(name);\
+			(bkt)++)\
+		hlist_for_each_entry_safe(obj, tmp, &name[bkt], member)
+
+#undef hash_for_each_possible
+#define hash_for_each_possible(name, obj, member, key)			\
+	hlist_for_each_entry(obj, &name[hash_min(key, HASH_BITS(name))], member)
+
+#undef hash_for_each_possible_safe
+#define hash_for_each_possible_safe(name, obj, tmp, member, key)	\
+	hlist_for_each_entry_safe(obj, tmp,\
+		&name[hash_min(key, HASH_BITS(name))], member)
+
+#ifdef CONFIG_XPS
+int __kc_netif_set_xps_queue(struct net_device *, const struct cpumask *, u16);
+#define netif_set_xps_queue(_dev, _mask, _idx) __kc_netif_set_xps_queue((_dev), (_mask), (_idx))
+#else /* CONFIG_XPS */
+#define netif_set_xps_queue(_dev, _mask, _idx) do {} while (0)
+#endif /* CONFIG_XPS */
+
+#ifdef HAVE_NETDEV_SELECT_QUEUE
+#define _kc_hashrnd 0xd631614b /* not so random hash salt */
+u16 __kc_netdev_pick_tx(struct net_device *dev, struct sk_buff *skb);
+#define __netdev_pick_tx __kc_netdev_pick_tx
+#endif /* HAVE_NETDEV_SELECT_QUEUE */
+#else
+#define HAVE_BRIDGE_FILTER
+#define HAVE_FDB_DEL_NLATTR
+#endif /* < 3.9.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0) )
+#ifndef NAPI_POLL_WEIGHT
+#define NAPI_POLL_WEIGHT 64
+#endif
+#ifdef CONFIG_PCI_IOV
+int __kc_pci_vfs_assigned(struct pci_dev *dev);
+#else
+static inline int __kc_pci_vfs_assigned(struct pci_dev __always_unused *dev)
+{
+	return 0;
+}
+#endif
+#define pci_vfs_assigned(dev) __kc_pci_vfs_assigned(dev)
+
+#ifndef list_first_entry_or_null
+#define list_first_entry_or_null(ptr, type, member) \
+	(!list_empty(ptr) ? list_first_entry(ptr, type, member) : NULL)
+#endif
+
+#ifndef VLAN_TX_COOKIE_MAGIC
+static inline struct sk_buff *__kc__vlan_hwaccel_put_tag(struct sk_buff *skb,
+							 u16 vlan_tci)
+{
+#ifdef VLAN_TAG_PRESENT
+	vlan_tci |= VLAN_TAG_PRESENT;
+#endif
+	skb->vlan_tci = vlan_tci;
+        return skb;
+}
+#define __vlan_hwaccel_put_tag(skb, vlan_proto, vlan_tci) \
+	__kc__vlan_hwaccel_put_tag(skb, vlan_tci)
+#endif
+
+#ifdef HAVE_FDB_OPS
+#if defined(HAVE_NDO_FDB_ADD_NLATTR)
+int __kc_ndo_dflt_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
+			  struct net_device *dev,
+			  const unsigned char *addr, u16 flags);
+#elif defined(USE_CONST_DEV_UC_CHAR)
+int __kc_ndo_dflt_fdb_add(struct ndmsg *ndm, struct net_device *dev,
+			  const unsigned char *addr, u16 flags);
+#else
+int __kc_ndo_dflt_fdb_add(struct ndmsg *ndm, struct net_device *dev,
+			  unsigned char *addr, u16 flags);
+#endif /* HAVE_NDO_FDB_ADD_NLATTR */
+#if defined(HAVE_FDB_DEL_NLATTR)
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct nlattr *tb[],
+			  struct net_device *dev,
+			  const unsigned char *addr);
+#elif defined(USE_CONST_DEV_UC_CHAR)
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct net_device *dev,
+			  const unsigned char *addr);
+#else
+int __kc_ndo_dflt_fdb_del(struct ndmsg *ndm, struct net_device *dev,
+			  unsigned char *addr);
+#endif /* HAVE_FDB_DEL_NLATTR */
+#define ndo_dflt_fdb_add __kc_ndo_dflt_fdb_add
+#define ndo_dflt_fdb_del __kc_ndo_dflt_fdb_del
+#endif /* HAVE_FDB_OPS */
+
+#ifndef PCI_DEVID
+#define PCI_DEVID(bus, devfn)  ((((u16)(bus)) << 8) | (devfn))
+#endif
+
+/* The definitions for these functions when CONFIG_OF_NET is defined are
+ * pulled in from <linux/of_net.h>. For kernels older than 3.5 we already have
+ * backports for when CONFIG_OF_NET is true. These are separated and
+ * duplicated in order to cover all cases so that all kernels get either the
+ * real definitions (when CONFIG_OF_NET is defined) or the stub definitions
+ * (when CONFIG_OF_NET is not defined, or the kernel is too old to have real
+ * definitions).
+ */
+#ifndef CONFIG_OF_NET
+static inline int of_get_phy_mode(struct device_node __always_unused *np)
+{
+	return -ENODEV;
+}
+
+static inline const void *
+of_get_mac_address(struct device_node __always_unused *np)
+{
+	return NULL;
+}
+#endif
+
+#else /* >= 3.10.0 */
+#define HAVE_ENCAP_TSO_OFFLOAD
+#define USE_DEFAULT_FDB_DEL_DUMP
+#define HAVE_SKB_INNER_NETWORK_HEADER
+
+#if (RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,0)))
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,0))
+#define HAVE_RHEL7_PCI_DRIVER_RH
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2))
+#define HAVE_RHEL7_PCI_RESET_NOTIFY
+#endif /* RHEL >= 7.2 */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3))
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5))
+#define HAVE_GENEVE_RX_OFFLOAD
+#endif /* RHEL < 7.5 */
+#define HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+#define HAVE_RHEL7_NET_DEVICE_OPS_EXT
+#if !defined(HAVE_UDP_ENC_TUNNEL) && IS_ENABLED(CONFIG_GENEVE)
+#define HAVE_UDP_ENC_TUNNEL
+#endif /* !HAVE_UDP_ENC_TUNNEL && CONFIG_GENEVE */
+#endif /* RHEL >= 7.3 */
+
+/* new hooks added to net_device_ops_extended in RHEL7.4 */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define HAVE_RHEL7_NETDEV_OPS_EXT_NDO_SET_VF_VLAN
+#define HAVE_RHEL7_NETDEV_OPS_EXT_NDO_UDP_TUNNEL
+#define HAVE_UDP_ENC_RX_OFFLOAD
+#endif /* RHEL >= 7.4 */
+#else  /* RHEL >= 8.0 */
+#define HAVE_TCF_BLOCK_CB_REGISTER_EXTACK
+#define NO_NETDEV_BPF_PROG_ATTACHED
+#define HAVE_NDO_SELECT_QUEUE_SB_DEV
+#endif /* RHEL >= 8.0 */
+#endif /* RHEL >= 7.0 */
+#endif /* >= 3.10.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,11,0) )
+#define netdev_notifier_info_to_dev(ptr) ptr
+#ifndef time_in_range64
+#define time_in_range64(a, b, c) \
+	(time_after_eq64(a, b) && \
+	 time_before_eq64(a, c))
+#endif /* time_in_range64 */
+#if ((RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,6)) ||\
+     (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(11,4,0)))
+#define HAVE_NDO_SET_VF_LINK_STATE
+#endif
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))
+#define HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK
+#endif
+#else /* >= 3.11.0 */
+#define HAVE_NDO_SET_VF_LINK_STATE
+#define HAVE_SKB_INNER_PROTOCOL
+#define HAVE_MPLS_FEATURES
+#endif /* >= 3.11.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,12,0) )
+int __kc_pcie_get_minimum_link(struct pci_dev *dev, enum pci_bus_speed *speed,
+			       enum pcie_link_width *width);
+#ifndef pcie_get_minimum_link
+#define pcie_get_minimum_link(_p, _s, _w) __kc_pcie_get_minimum_link(_p, _s, _w)
+#endif
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(6,7))
+int _kc_pci_wait_for_pending_transaction(struct pci_dev *dev);
+#define pci_wait_for_pending_transaction _kc_pci_wait_for_pending_transaction
+#endif /* <RHEL6.7 */
+
+#else /* >= 3.12.0 */
+#if ( SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(12,0,0))
+#define HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK
+#endif
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0) )
+#define HAVE_VXLAN_RX_OFFLOAD
+#if !defined(HAVE_UDP_ENC_TUNNEL) && IS_ENABLED(CONFIG_VXLAN)
+#define HAVE_UDP_ENC_TUNNEL
+#endif
+#endif /* < 4.8.0 */
+#define HAVE_NDO_GET_PHYS_PORT_ID
+#define HAVE_NETIF_SET_XPS_QUEUE_CONST_MASK
+#endif /* >= 3.12.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0) )
+#define dma_set_mask_and_coherent(_p, _m) __kc_dma_set_mask_and_coherent(_p, _m)
+int __kc_dma_set_mask_and_coherent(struct device *dev, u64 mask);
+#ifndef u64_stats_init
+#define u64_stats_init(a) do { } while(0)
+#endif
+#undef BIT_ULL
+#define BIT_ULL(n) (1ULL << (n))
+
+#if (!(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(12,0,0)) && \
+     !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,0)))
+static inline struct pci_dev *pci_upstream_bridge(struct pci_dev *dev)
+{
+	dev = pci_physfn(dev);
+	if (pci_is_root_bus(dev->bus))
+		return NULL;
+
+	return dev->bus->self;
+}
+#endif
+
+#if (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(12,1,0))
+#undef HAVE_STRUCT_PAGE_PFMEMALLOC
+#define HAVE_DCBNL_OPS_SETAPP_RETURN_INT
+#endif
+#ifndef list_next_entry
+#define list_next_entry(pos, member) \
+	list_entry((pos)->member.next, typeof(*(pos)), member)
+#endif
+#ifndef list_prev_entry
+#define list_prev_entry(pos, member) \
+	list_entry((pos)->member.prev, typeof(*(pos)), member)
+#endif
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,6,20) )
+#define devm_kcalloc(dev, cnt, size, flags) \
+	devm_kzalloc(dev, cnt * size, flags)
+#endif /* > 2.6.20 */
+
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2)))
+#define list_last_entry(ptr, type, member) list_entry((ptr)->prev, type, member)
+#endif
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0))
+bool _kc_pci_device_is_present(struct pci_dev *pdev);
+#define pci_device_is_present _kc_pci_device_is_present
+#endif /* <RHEL7.0 */
+#else /* >= 3.13.0 */
+#define HAVE_VXLAN_CHECKS
+#if (UBUNTU_VERSION_CODE && UBUNTU_VERSION_CODE >= UBUNTU_VERSION(3,13,0,24))
+#define HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK
+#else
+#define HAVE_NDO_SELECT_QUEUE_ACCEL
+#endif
+#define HAVE_HWMON_DEVICE_REGISTER_WITH_GROUPS
+#endif
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0) )
+
+#ifndef U16_MAX
+#define U16_MAX ((u16)~0U)
+#endif
+
+#ifndef U32_MAX
+#define U32_MAX ((u32)~0U)
+#endif
+
+#ifndef U64_MAX
+#define U64_MAX ((u64)~0ULL)
+#endif
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2)))
+#define dev_consume_skb_any(x) dev_kfree_skb_any(x)
+#define dev_consume_skb_irq(x) dev_kfree_skb_irq(x)
+#endif
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,0)) && \
+     !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(12,0,0)))
+
+/* it isn't expected that this would be a #define unless we made it so */
+#ifndef skb_set_hash
+
+#define PKT_HASH_TYPE_NONE	0
+#define PKT_HASH_TYPE_L2	1
+#define PKT_HASH_TYPE_L3	2
+#define PKT_HASH_TYPE_L4	3
+
+enum _kc_pkt_hash_types {
+	_KC_PKT_HASH_TYPE_NONE = PKT_HASH_TYPE_NONE,
+	_KC_PKT_HASH_TYPE_L2 = PKT_HASH_TYPE_L2,
+	_KC_PKT_HASH_TYPE_L3 = PKT_HASH_TYPE_L3,
+	_KC_PKT_HASH_TYPE_L4 = PKT_HASH_TYPE_L4,
+};
+#define pkt_hash_types         _kc_pkt_hash_types
+
+#define skb_set_hash __kc_skb_set_hash
+static inline void __kc_skb_set_hash(struct sk_buff __maybe_unused *skb,
+				     u32 __maybe_unused hash,
+				     int __maybe_unused type)
+{
+#ifdef HAVE_SKB_L4_RXHASH
+	skb->l4_rxhash = (type == PKT_HASH_TYPE_L4);
+#endif
+#ifdef NETIF_F_RXHASH
+	skb->rxhash = hash;
+#endif
+}
+#endif /* !skb_set_hash */
+
+#else	/* RHEL_RELEASE_CODE >= 7.0 || SLE_VERSION_CODE >= 12.0 */
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)))
+#ifndef HAVE_VXLAN_RX_OFFLOAD
+#define HAVE_VXLAN_RX_OFFLOAD
+#endif /* HAVE_VXLAN_RX_OFFLOAD */
+#endif
+
+#if !defined(HAVE_UDP_ENC_TUNNEL) && IS_ENABLED(CONFIG_VXLAN)
+#define HAVE_UDP_ENC_TUNNEL
+#endif
+
+#ifndef HAVE_VXLAN_CHECKS
+#define HAVE_VXLAN_CHECKS
+#endif /* HAVE_VXLAN_CHECKS */
+#endif /* !(RHEL_RELEASE_CODE >= 7.0 && SLE_VERSION_CODE >= 12.0) */
+
+#if ((RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3)) ||\
+     (SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(12,0,0)))
+#define HAVE_NDO_DFWD_OPS
+#endif
+
+#ifndef pci_enable_msix_range
+int __kc_pci_enable_msix_range(struct pci_dev *dev, struct msix_entry *entries,
+			       int minvec, int maxvec);
+#define pci_enable_msix_range __kc_pci_enable_msix_range
+#endif
+
+#ifndef ether_addr_copy
+#define ether_addr_copy __kc_ether_addr_copy
+static inline void __kc_ether_addr_copy(u8 *dst, const u8 *src)
+{
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	*(u32 *)dst = *(const u32 *)src;
+	*(u16 *)(dst + 4) = *(const u16 *)(src + 4);
+#else
+	u16 *a = (u16 *)dst;
+	const u16 *b = (const u16 *)src;
+
+	a[0] = b[0];
+	a[1] = b[1];
+	a[2] = b[2];
+#endif
+}
+#endif /* ether_addr_copy */
+int __kc_ipv6_find_hdr(const struct sk_buff *skb, unsigned int *offset,
+		       int target, unsigned short *fragoff, int *flags);
+#define ipv6_find_hdr(a, b, c, d, e) __kc_ipv6_find_hdr((a), (b), (c), (d), (e))
+
+#ifndef OPTIMIZE_HIDE_VAR
+#ifdef __GNUC__
+#define OPTIMIZER_HIDE_VAR(var) __asm__ ("" : "=r" (var) : "0" (var))
+#else
+#include <linux/barrier.h>
+#define OPTIMIZE_HIDE_VAR(var)	barrier()
+#endif
+#endif
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,0)) && \
+     !(SLE_VERSION_CODE && SLE_VERSION_CODE >= SLE_VERSION(10,4,0)))
+static inline __u32 skb_get_hash_raw(const struct sk_buff *skb)
+{
+#ifdef NETIF_F_RXHASH
+	return skb->rxhash;
+#else
+	return 0;
+#endif /* NETIF_F_RXHASH */
+}
+#endif /* !RHEL > 5.9 && !SLES >= 10.4 */
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5))
+#define request_firmware_direct	request_firmware
+#endif /* !RHEL || RHEL < 7.5 */
+
+#else /* >= 3.14.0 */
+
+/* for ndo_dfwd_ ops add_station, del_station and _start_xmit */
+#ifndef HAVE_NDO_DFWD_OPS
+#define HAVE_NDO_DFWD_OPS
+#endif
+#define HAVE_NDO_SELECT_QUEUE_ACCEL_FALLBACK
+#endif /* 3.14.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0) )
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35) )
+#define HAVE_SKBUFF_RXHASH
+#endif /* >= 2.6.35 */
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,1)) && \
+     !(UBUNTU_VERSION_CODE && UBUNTU_VERSION_CODE >= UBUNTU_VERSION(3,13,0,30)))
+#define u64_stats_fetch_begin_irq u64_stats_fetch_begin_bh
+#define u64_stats_fetch_retry_irq u64_stats_fetch_retry_bh
+#endif
+
+char *_kc_devm_kstrdup(struct device *dev, const char *s, gfp_t gfp);
+#define devm_kstrdup(dev, s, gfp) _kc_devm_kstrdup(dev, s, gfp)
+
+#else /* >= 3.15.0 */
+#define HAVE_NET_GET_RANDOM_ONCE
+#define HAVE_PTP_1588_CLOCK_PINS
+#define HAVE_NETDEV_PORT
+#endif /* 3.15.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,16,0) )
+#ifndef smp_mb__before_atomic
+#define smp_mb__before_atomic() smp_mb()
+#define smp_mb__after_atomic()  smp_mb()
+#endif
+#ifndef __dev_uc_sync
+#ifdef HAVE_SET_RX_MODE
+#ifdef NETDEV_HW_ADDR_T_UNICAST
+int __kc_hw_addr_sync_dev(struct netdev_hw_addr_list *list,
+		struct net_device *dev,
+		int (*sync)(struct net_device *, const unsigned char *),
+		int (*unsync)(struct net_device *, const unsigned char *));
+void __kc_hw_addr_unsync_dev(struct netdev_hw_addr_list *list,
+		struct net_device *dev,
+		int (*unsync)(struct net_device *, const unsigned char *));
+#endif
+#ifndef NETDEV_HW_ADDR_T_MULTICAST
+int __kc_dev_addr_sync_dev(struct dev_addr_list **list, int *count,
+		struct net_device *dev,
+		int (*sync)(struct net_device *, const unsigned char *),
+		int (*unsync)(struct net_device *, const unsigned char *));
+void __kc_dev_addr_unsync_dev(struct dev_addr_list **list, int *count,
+		struct net_device *dev,
+		int (*unsync)(struct net_device *, const unsigned char *));
+#endif
+#endif /* HAVE_SET_RX_MODE */
+
+static inline int __kc_dev_uc_sync(struct net_device __maybe_unused *dev,
+				   int __maybe_unused (*sync)(struct net_device *, const unsigned char *),
+				   int __maybe_unused (*unsync)(struct net_device *, const unsigned char *))
+{
+#ifdef NETDEV_HW_ADDR_T_UNICAST
+	return __kc_hw_addr_sync_dev(&dev->uc, dev, sync, unsync);
+#elif defined(HAVE_SET_RX_MODE)
+	return __kc_dev_addr_sync_dev(&dev->uc_list, &dev->uc_count,
+				      dev, sync, unsync);
+#else
+	return 0;
+#endif
+}
+#define __dev_uc_sync __kc_dev_uc_sync
+
+static inline void __kc_dev_uc_unsync(struct net_device __maybe_unused *dev,
+				      int __maybe_unused (*unsync)(struct net_device *, const unsigned char *))
+{
+#ifdef HAVE_SET_RX_MODE
+#ifdef NETDEV_HW_ADDR_T_UNICAST
+	__kc_hw_addr_unsync_dev(&dev->uc, dev, unsync);
+#else /* NETDEV_HW_ADDR_T_MULTICAST */
+	__kc_dev_addr_unsync_dev(&dev->uc_list, &dev->uc_count, dev, unsync);
+#endif /* NETDEV_HW_ADDR_T_UNICAST */
+#endif /* HAVE_SET_RX_MODE */
+}
+#define __dev_uc_unsync __kc_dev_uc_unsync
+
+static inline int __kc_dev_mc_sync(struct net_device __maybe_unused *dev,
+				   int __maybe_unused (*sync)(struct net_device *, const unsigned char *),
+				   int __maybe_unused (*unsync)(struct net_device *, const unsigned char *))
+{
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+	return __kc_hw_addr_sync_dev(&dev->mc, dev, sync, unsync);
+#elif defined(HAVE_SET_RX_MODE)
+	return __kc_dev_addr_sync_dev(&dev->mc_list, &dev->mc_count,
+				      dev, sync, unsync);
+#else
+	return 0;
+#endif
+
+}
+#define __dev_mc_sync __kc_dev_mc_sync
+
+static inline void __kc_dev_mc_unsync(struct net_device __maybe_unused *dev,
+				      int __maybe_unused (*unsync)(struct net_device *, const unsigned char *))
+{
+#ifdef HAVE_SET_RX_MODE
+#ifdef NETDEV_HW_ADDR_T_MULTICAST
+	__kc_hw_addr_unsync_dev(&dev->mc, dev, unsync);
+#else /* NETDEV_HW_ADDR_T_MULTICAST */
+	__kc_dev_addr_unsync_dev(&dev->mc_list, &dev->mc_count, dev, unsync);
+#endif /* NETDEV_HW_ADDR_T_MULTICAST */
+#endif /* HAVE_SET_RX_MODE */
+}
+#define __dev_mc_unsync __kc_dev_mc_unsync
+#endif /* __dev_uc_sync */
+
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,1))
+#define HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
+#endif
+
+#ifndef NETIF_F_GSO_UDP_TUNNEL_CSUM
+/* if someone backports this, hopefully they backport as a #define.
+ * declare it as zero on older kernels so that if it get's or'd in
+ * it won't effect anything, therefore preventing core driver changes
+ */
+#define NETIF_F_GSO_UDP_TUNNEL_CSUM 0
+#define SKB_GSO_UDP_TUNNEL_CSUM 0
+#endif
+void *__kc_devm_kmemdup(struct device *dev, const void *src, size_t len,
+			gfp_t gfp);
+#define devm_kmemdup __kc_devm_kmemdup
+
+#else
+#if ( ( LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0) ) && \
+      ! ( SLE_VERSION_CODE && ( SLE_VERSION_CODE >= SLE_VERSION(12,4,0)) ) )
+#define HAVE_PCI_ERROR_HANDLER_RESET_NOTIFY
+#endif /* >= 3.16.0 && < 4.13.0 && !(SLES >= 12sp4) */
+#define HAVE_NDO_SET_VF_MIN_MAX_TX_RATE
+#endif /* 3.16.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,17,0) )
+#if !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,8) && \
+      RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)) && \
+    !(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2))
+#ifndef timespec64
+#define timespec64 timespec
+static inline struct timespec64 timespec_to_timespec64(const struct timespec ts)
+{
+	return ts;
+}
+static inline struct timespec timespec64_to_timespec(const struct timespec64 ts64)
+{
+	return ts64;
+}
+#define timespec64_equal timespec_equal
+#define timespec64_compare timespec_compare
+#define set_normalized_timespec64 set_normalized_timespec
+#define timespec64_add_safe timespec_add_safe
+#define timespec64_add timespec_add
+#define timespec64_sub timespec_sub
+#define timespec64_valid timespec_valid
+#define timespec64_valid_strict timespec_valid_strict
+#define timespec64_to_ns timespec_to_ns
+#define ns_to_timespec64 ns_to_timespec
+#define ktime_to_timespec64 ktime_to_timespec
+#define ktime_get_ts64 ktime_get_ts
+#define ktime_get_real_ts64 ktime_get_real_ts
+#define timespec64_add_ns timespec_add_ns
+#endif /* timespec64 */
+#endif /* !(RHEL6.8<RHEL7.0) && !RHEL7.2+ */
+
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,8) && \
+     RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0))
+static inline void ktime_get_real_ts64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get_real());
+}
+
+static inline void ktime_get_ts64(struct timespec64 *ts)
+{
+	*ts = ktime_to_timespec64(ktime_get());
+}
+#endif
+
+#if !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define hlist_add_behind(_a, _b) hlist_add_after(_b, _a)
+#endif
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5))
+#endif /* RHEL_RELEASE_CODE < RHEL7.5 */
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,3))
+static inline u64 ktime_get_ns(void)
+{
+	return ktime_to_ns(ktime_get());
+}
+
+static inline u64 ktime_get_real_ns(void)
+{
+	return ktime_to_ns(ktime_get_real());
+}
+
+static inline u64 ktime_get_boot_ns(void)
+{
+	return ktime_to_ns(ktime_get_boottime());
+}
+#endif /* RHEL < 7.3 */
+
+#else
+#define HAVE_DCBNL_OPS_SETAPP_RETURN_INT
+#include <linux/time64.h>
+#define HAVE_RHASHTABLE
+#endif /* 3.17.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,18,0) )
+#ifndef NO_PTP_SUPPORT
+#include <linux/errqueue.h>
+struct sk_buff *__kc_skb_clone_sk(struct sk_buff *skb);
+void __kc_skb_complete_tx_timestamp(struct sk_buff *skb,
+				    struct skb_shared_hwtstamps *hwtstamps);
+#define skb_clone_sk __kc_skb_clone_sk
+#define skb_complete_tx_timestamp __kc_skb_complete_tx_timestamp
+#endif
+#if (!(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2))))
+u32 __kc_eth_get_headlen(const struct net_device *dev, unsigned char *data,
+			 unsigned int max_len);
+#else
+unsigned int __kc_eth_get_headlen(unsigned char *data, unsigned int max_len);
+#endif /* !RHEL >= 8.2 */
+
+#define eth_get_headlen __kc_eth_get_headlen
+#ifndef ETH_P_XDSA
+#define ETH_P_XDSA 0x00F8
+#endif
+/* RHEL 7.1 backported csum_level, but SLES 12 and 12-SP1 did not */
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,1))
+#define HAVE_SKBUFF_CSUM_LEVEL
+#endif /* >= RH 7.1 */
+
+/* RHEL 7.3 backported xmit_more */
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3))
+#define HAVE_SKB_XMIT_MORE
+#endif /* >= RH 7.3 */
+
+#undef GENMASK
+#define GENMASK(h, l) \
+	(((~0UL) << (l)) & (~0UL >> (BITS_PER_LONG - 1 - (h))))
+#undef GENMASK_ULL
+#define GENMASK_ULL(h, l) \
+	(((~0ULL) << (l)) & (~0ULL >> (BITS_PER_LONG_LONG - 1 - (h))))
+
+#else /*  3.18.0 */
+#define HAVE_SKBUFF_CSUM_LEVEL
+#define HAVE_SKB_XMIT_MORE
+#define HAVE_SKB_INNER_PROTOCOL_TYPE
+#endif /* 3.18.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,18,4) )
+#else
+#define HAVE_NDO_FEATURES_CHECK
+#endif /* 3.18.4 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,18,13) )
+#ifndef WRITE_ONCE
+#define WRITE_ONCE(x, val) ({ ACCESS_ONCE(x) = (val); })
+#endif
+#endif /* 3.18.13 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) )
+/* netdev_phys_port_id renamed to netdev_phys_item_id */
+#define netdev_phys_item_id netdev_phys_port_id
+
+static inline void _kc_napi_complete_done(struct napi_struct *napi,
+					  int __always_unused work_done) {
+	napi_complete(napi);
+}
+/* don't use our backport if the distro kernels already have it */
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE < SLE_VERSION(12,3,0))) || \
+    (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5)))
+#define napi_complete_done _kc_napi_complete_done
+#endif
+
+int _kc_bitmap_print_to_pagebuf(bool list, char *buf,
+				const unsigned long *maskp, int nmaskbits);
+#define bitmap_print_to_pagebuf _kc_bitmap_print_to_pagebuf
+
+#ifndef NETDEV_RSS_KEY_LEN
+#define NETDEV_RSS_KEY_LEN (13 * 4)
+#endif
+#if (!(RHEL_RELEASE_CODE && \
+      ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,7) && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)) || \
+       (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2)))))
+#define netdev_rss_key_fill(buffer, len) __kc_netdev_rss_key_fill(buffer, len)
+#endif /* RHEL_RELEASE_CODE */
+void __kc_netdev_rss_key_fill(void *buffer, size_t len);
+#define SPEED_20000 20000
+#define SPEED_40000 40000
+#ifndef dma_rmb
+#define dma_rmb() rmb()
+#endif
+#ifndef dev_alloc_pages
+#ifndef NUMA_NO_NODE
+#define NUMA_NO_NODE -1
+#endif
+#define dev_alloc_pages(_order) alloc_pages_node(NUMA_NO_NODE, (GFP_ATOMIC | __GFP_COLD | __GFP_COMP | __GFP_MEMALLOC), (_order))
+#endif
+#ifndef dev_alloc_page
+#define dev_alloc_page() dev_alloc_pages(0)
+#endif
+#if !defined(eth_skb_pad) && !defined(skb_put_padto)
+/**
+ *     __kc_skb_put_padto - increase size and pad an skbuff up to a minimal size
+ *     @skb: buffer to pad
+ *     @len: minimal length
+ *
+ *     Pads up a buffer to ensure the trailing bytes exist and are
+ *     blanked. If the buffer already contains sufficient data it
+ *     is untouched. Otherwise it is extended. Returns zero on
+ *     success. The skb is freed on error.
+ */
+static inline int __kc_skb_put_padto(struct sk_buff *skb, unsigned int len)
+{
+	unsigned int size = skb->len;
+
+	if (unlikely(size < len)) {
+		len -= size;
+		if (skb_pad(skb, len))
+			return -ENOMEM;
+		__skb_put(skb, len);
+	}
+	return 0;
+}
+#define skb_put_padto(skb, len) __kc_skb_put_padto(skb, len)
+
+static inline int __kc_eth_skb_pad(struct sk_buff *skb)
+{
+	return __kc_skb_put_padto(skb, ETH_ZLEN);
+}
+#define eth_skb_pad(skb) __kc_eth_skb_pad(skb)
+#endif /* eth_skb_pad && skb_put_padto */
+
+#ifndef SKB_ALLOC_NAPI
+/* RHEL 7.2 backported napi_alloc_skb and friends */
+static inline struct sk_buff *__kc_napi_alloc_skb(struct napi_struct *napi, unsigned int length)
+{
+	return netdev_alloc_skb_ip_align(napi->dev, length);
+}
+#define napi_alloc_skb(napi,len) __kc_napi_alloc_skb(napi,len)
+#define __napi_alloc_skb(napi,len,mask) __kc_napi_alloc_skb(napi,len)
+#endif /* SKB_ALLOC_NAPI */
+#define HAVE_CONFIG_PM_RUNTIME
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,7)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)))
+#define HAVE_RXFH_HASHFUNC
+#endif /* 6.7 < RHEL < 7.0 */
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,1))
+#define HAVE_RXFH_HASHFUNC
+#define NDO_DFLT_BRIDGE_GETLINK_HAS_BRFLAGS
+#endif /* RHEL > 7.1 */
+#ifndef napi_schedule_irqoff
+#define napi_schedule_irqoff	napi_schedule
+#endif
+#ifndef READ_ONCE
+#define READ_ONCE(_x) ACCESS_ONCE(_x)
+#endif
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))
+#define HAVE_NDO_FDB_ADD_VID
+#endif
+#ifndef ETH_MODULE_SFF_8636
+#define ETH_MODULE_SFF_8636		0x3
+#endif
+#ifndef ETH_MODULE_SFF_8636_LEN
+#define ETH_MODULE_SFF_8636_LEN		256
+#endif
+#ifndef ETH_MODULE_SFF_8436
+#define ETH_MODULE_SFF_8436		0x4
+#endif
+#ifndef ETH_MODULE_SFF_8436_LEN
+#define ETH_MODULE_SFF_8436_LEN		256
+#endif
+#ifndef writel_relaxed
+#define writel_relaxed	writel
+#endif
+#else /* 3.19.0 */
+#define HAVE_NDO_FDB_ADD_VID
+#define HAVE_RXFH_HASHFUNC
+#define NDO_DFLT_BRIDGE_GETLINK_HAS_BRFLAGS
+#endif /* 3.19.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,20,0) )
+/* vlan_tx_xx functions got renamed to skb_vlan */
+#ifndef skb_vlan_tag_get
+#define skb_vlan_tag_get vlan_tx_tag_get
+#endif
+#ifndef skb_vlan_tag_present
+#define skb_vlan_tag_present vlan_tx_tag_present
+#endif
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,1))
+#define HAVE_INCLUDE_LINUX_TIMECOUNTER_H
+#endif
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))
+#define HAVE_NDO_BRIDGE_SET_DEL_LINK_FLAGS
+#endif
+#else
+#define HAVE_INCLUDE_LINUX_TIMECOUNTER_H
+#define HAVE_NDO_BRIDGE_SET_DEL_LINK_FLAGS
+#endif /* 3.20.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0) )
+/* Definition for CONFIG_OF was introduced earlier */
+#if !defined(CONFIG_OF) && \
+    !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))
+static inline struct device_node *
+pci_device_to_OF_node(const struct pci_dev __always_unused *pdev) { return NULL; }
+#else /* !CONFIG_OF && RHEL < 7.3 */
+#define HAVE_DDP_PROFILE_UPLOAD_SUPPORT
+#endif /* !CONFIG_OF && RHEL < 7.3 */
+#else /* < 4.0 */
+#define HAVE_DDP_PROFILE_UPLOAD_SUPPORT
+#endif /* < 4.0 */
+
+/*****************************************************************************/
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0) )
+#ifndef NO_PTP_SUPPORT
+#ifdef HAVE_INCLUDE_LINUX_TIMECOUNTER_H
+#include <linux/timecounter.h>
+#else
+#include <linux/clocksource.h>
+#endif
+static inline void __kc_timecounter_adjtime(struct timecounter *tc, s64 delta)
+{
+	tc->nsec += delta;
+}
+
+static inline struct net_device *
+of_find_net_device_by_node(struct device_node __always_unused *np)
+{
+	return NULL;
+}
+
+#define timecounter_adjtime __kc_timecounter_adjtime
+#endif
+#if ((RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2))) || \
+     (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,2,0))))
+#define HAVE_NDO_SET_VF_RSS_QUERY_EN
+#endif
+#if RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))
+#define HAVE_NDO_BRIDGE_GETLINK_NLFLAGS
+#endif
+#if !((RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(6,8) && RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)) && \
+      (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2)) && \
+      (SLE_VERSION_CODE > SLE_VERSION(12,1,0)))
+unsigned int _kc_cpumask_local_spread(unsigned int i, int node);
+#define cpumask_local_spread _kc_cpumask_local_spread
+#endif
+#ifdef HAVE_RHASHTABLE
+#define rhashtable_loopup_fast(ht, key, params)		\
+	do {						\
+		(void)params;				\
+		rhashtable_lookup((ht), (key));		\
+	} while (0)
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0) )
+#define rhashtable_insert_fast(ht, obj, params)			\
+	do {							\
+		(void)params;					\
+		rhashtable_insert((ht), (obj), GFP_KERNEL);	\
+	} while (0)
+
+#define rhashtable_remove_fast(ht, obj, params)			\
+	do {							\
+		(void)params;					\
+		rhashtable_remove((ht), (obj), GFP_KERNEL);	\
+	} while (0)
+
+#else /* >= 3,19,0 */
+#define rhashtable_insert_fast(ht, obj, params)			\
+	do {							\
+		(void)params;					\
+		rhashtable_insert((ht), (obj));			\
+	} while (0)
+
+#define rhashtable_remove_fast(ht, obj, params)			\
+	do {							\
+		(void)params;					\
+		rhashtable_remove((ht), (obj));			\
+	} while (0)
+
+#endif /* 3,19,0 */
+#endif /* HAVE_RHASHTABLE */
+#else /* >= 4,1,0 */
+#define HAVE_NDO_GET_PHYS_PORT_NAME
+#define HAVE_PTP_CLOCK_INFO_GETTIME64
+#define HAVE_NDO_BRIDGE_GETLINK_NLFLAGS
+#define HAVE_PASSTHRU_FEATURES_CHECK
+#define HAVE_NDO_SET_VF_RSS_QUERY_EN
+#define HAVE_NDO_SET_TX_MAXRATE
+#endif /* 4,1,0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,9))
+#if (!(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2)) && \
+     !((SLE_VERSION_CODE == SLE_VERSION(11,3,0)) && \
+       (SLE_LOCALVERSION_CODE >= SLE_LOCALVERSION(0,47,71))) && \
+     !((SLE_VERSION_CODE == SLE_VERSION(11,4,0)) && \
+       (SLE_LOCALVERSION_CODE >= SLE_LOCALVERSION(65,0,0))) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,1,0)))
+static inline bool page_is_pfmemalloc(struct page __maybe_unused *page)
+{
+#ifdef HAVE_STRUCT_PAGE_PFMEMALLOC
+	return page->pfmemalloc;
+#else
+	return false;
+#endif
+}
+#endif /* !RHEL7.2+ && !SLES11sp3(3.0.101-0.47.71+ update) && !SLES11sp4(3.0.101-65+ update) & !SLES12sp1+ */
+#else
+#undef HAVE_STRUCT_PAGE_PFMEMALLOC
+#endif /* 4.1.9 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,1,0)))
+#define ETHTOOL_RX_FLOW_SPEC_RING	0x00000000FFFFFFFFULL
+#define ETHTOOL_RX_FLOW_SPEC_RING_VF	0x000000FF00000000ULL
+#define ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF 32
+static inline __u64 ethtool_get_flow_spec_ring(__u64 ring_cookie)
+{
+	return ETHTOOL_RX_FLOW_SPEC_RING & ring_cookie;
+};
+
+static inline __u64 ethtool_get_flow_spec_ring_vf(__u64 ring_cookie)
+{
+	return (ETHTOOL_RX_FLOW_SPEC_RING_VF & ring_cookie) >>
+				ETHTOOL_RX_FLOW_SPEC_RING_VF_OFF;
+};
+#endif /* ! RHEL >= 7.2 && ! SLES >= 12.1 */
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define HAVE_NDO_DFLT_BRIDGE_GETLINK_VLAN_SUPPORT
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,27))
+#if (!((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,8) && \
+	RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,0)) || \
+       RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2)))
+static inline bool pci_ari_enabled(struct pci_bus *bus)
+{
+	return bus->self && bus->self->ari_enabled;
+}
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,2))
+#define HAVE_VF_STATS
+#endif /* (RHEL7.2+) */
+#endif /* !(RHEL6.8+ || RHEL7.2+) */
+#else
+static inline bool pci_ari_enabled(struct pci_bus *bus)
+{
+	return false;
+}
+#endif /* 2.6.27 */
+#else
+#define HAVE_NDO_DFLT_BRIDGE_GETLINK_VLAN_SUPPORT
+#define HAVE_VF_STATS
+#endif /* 4.2.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,3,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,2,0)))
+/**
+ * _kc_flow_dissector_key_ipv4_addrs:
+ * @src: source ip address
+ * @dst: destination ip address
+ */
+struct _kc_flow_dissector_key_ipv4_addrs {
+	__be32 src;
+	__be32 dst;
+};
+
+/**
+ * _kc_flow_dissector_key_ipv6_addrs:
+ * @src: source ip address
+ * @dst: destination ip address
+ */
+struct _kc_flow_dissector_key_ipv6_addrs {
+	struct in6_addr src;
+	struct in6_addr dst;
+};
+
+/**
+ * _kc_flow_dissector_key_addrs:
+ * @v4addrs: IPv4 addresses
+ * @v6addrs: IPv6 addresses
+ */
+struct _kc_flow_dissector_key_addrs {
+	union {
+		struct _kc_flow_dissector_key_ipv4_addrs v4addrs;
+		struct _kc_flow_dissector_key_ipv6_addrs v6addrs;
+	};
+};
+
+/**
+ * _kc_flow_dissector_key_tp_ports:
+ *	@ports: port numbers of Transport header
+ *		src: source port number
+ *		dst: destination port number
+ */
+struct _kc_flow_dissector_key_ports {
+	union {
+		__be32 ports;
+		struct {
+			__be16 src;
+			__be16 dst;
+		};
+	};
+};
+
+/**
+ * _kc_flow_dissector_key_basic:
+ * @n_proto: Network header protocol (eg. IPv4/IPv6)
+ * @ip_proto: Transport header protocol (eg. TCP/UDP)
+ * @padding: padding for alignment
+ */
+struct _kc_flow_dissector_key_basic {
+	__be16	n_proto;
+	u8	ip_proto;
+	u8	padding;
+};
+
+struct _kc_flow_keys {
+	struct _kc_flow_dissector_key_basic basic;
+	struct _kc_flow_dissector_key_ports ports;
+	struct _kc_flow_dissector_key_addrs addrs;
+};
+
+/* These are all the include files for kernels inside this #ifdef block that
+ * have any reference to the in kernel definition of struct flow_keys. The
+ * reason for putting them here is to make 100% sure that these files do not get
+ * included after re-defining flow_keys to _kc_flow_keys. This is done to
+ * prevent any possible ABI issues that this structure re-definition could case.
+ */
+#if ((LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(4,2,0)) || \
+      RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(6,7) || \
+      SLE_VERSION_CODE >= SLE_VERSION(11,4,0))
+#include <net/flow_keys.h>
+#endif /* (>= 3.3.0 && < 4.2.0) || >= RHEL 6.7  || >= SLE 11.4 */
+#if (LINUX_VERSION_CODE == KERNEL_VERSION(4,2,0))
+#include <net/flow_dissector.h>
+#endif /* 4.2.0 */
+#include <linux/skbuff.h>
+#include <net/ip.h>
+#include <net/ipv6.h>
+#include <net/flow.h>
+
+#define flow_keys _kc_flow_keys
+bool
+_kc_skb_flow_dissect_flow_keys(const struct sk_buff *skb,
+			       struct flow_keys *flow,
+			       unsigned int __always_unused flags);
+#define skb_flow_dissect_flow_keys	_kc_skb_flow_dissect_flow_keys
+#endif /* ! >= RHEL 7.4 && ! >= SLES 12.2 */
+#endif /* 4.3.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,4,0))
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3))
+#define HAVE_NDO_SET_VF_TRUST
+#endif /* (RHEL_RELEASE >= 7.3) */
+#ifndef CONFIG_64BIT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,3,0))
+#include <asm-generic/io-64-nonatomic-lo-hi.h>	/* 32-bit readq/writeq */
+#else /* 3.3.0 => 4.3.x */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26))
+#include <asm-generic/int-ll64.h>
+#endif /* 2.6.26 => 3.3.0 */
+#ifndef readq
+static inline __u64 readq(const volatile void __iomem *addr)
+{
+	const volatile u32 __iomem *p = addr;
+	u32 low, high;
+
+	low = readl(p);
+	high = readl(p + 1);
+
+	return low + ((u64)high << 32);
+}
+#define readq readq
+#endif
+
+#ifndef writeq
+static inline void writeq(__u64 val, volatile void __iomem *addr)
+{
+	writel(val, addr);
+	writel(val >> 32, addr + 4);
+}
+#define writeq writeq
+#endif
+#endif /* < 3.3.0 */
+#endif /* !CONFIG_64BIT */
+#else /* < 4.4.0 */
+#define HAVE_NDO_SET_VF_TRUST
+
+#ifndef CONFIG_64BIT
+#include <linux/io-64-nonatomic-lo-hi.h>	/* 32-bit readq/writeq */
+#endif /* !CONFIG_64BIT */
+#endif /* 4.4.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,5,0))
+/* protect against a likely backport */
+#ifndef NETIF_F_CSUM_MASK
+#define NETIF_F_CSUM_MASK NETIF_F_ALL_CSUM
+#endif /* NETIF_F_CSUM_MASK */
+#ifndef NETIF_F_SCTP_CRC
+#define NETIF_F_SCTP_CRC NETIF_F_SCTP_CSUM
+#endif /* NETIF_F_SCTP_CRC */
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3)))
+#define eth_platform_get_mac_address _kc_eth_platform_get_mac_address
+int _kc_eth_platform_get_mac_address(struct device *dev __maybe_unused,
+				     u8 *mac_addr __maybe_unused);
+#endif /* !(RHEL_RELEASE >= 7.3) */
+#else /* 4.5.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0) )
+#define HAVE_GENEVE_RX_OFFLOAD
+#if !defined(HAVE_UDP_ENC_TUNNEL) && IS_ENABLED(CONFIG_GENEVE)
+#define HAVE_UDP_ENC_TUNNEL
+#endif
+#endif /* < 4.8.0 */
+#define HAVE_NETIF_NAPI_ADD_CALLS_NAPI_HASH_ADD
+#define HAVE_NETDEV_UPPER_INFO
+#endif /* 4.5.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0))
+#if !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,3))
+static inline unsigned char *skb_checksum_start(const struct sk_buff *skb)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22))
+	return skb->head + skb->csum_start;
+#else /* < 2.6.22 */
+	return skb_transport_header(skb);
+#endif
+}
+#endif
+
+#if !(UBUNTU_VERSION_CODE && \
+		UBUNTU_VERSION_CODE >= UBUNTU_VERSION(4,4,0,21)) && \
+	!(RHEL_RELEASE_CODE && \
+		(RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))) && \
+	!(SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0)))
+static inline void napi_consume_skb(struct sk_buff *skb,
+				    int __always_unused budget)
+{
+	dev_consume_skb_any(skb);
+}
+
+#endif /* UBUNTU 4,4,0,21, RHEL 7.2, SLES12 SP3 */
+#if !(SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0))) && \
+	!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+static inline void csum_replace_by_diff(__sum16 *sum, __wsum diff)
+{
+	* sum = csum_fold(csum_add(diff, ~csum_unfold(*sum)));
+}
+#endif
+#if !(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(7,2))) && \
+	!(SLE_VERSION_CODE && (SLE_VERSION_CODE > SLE_VERSION(12,3,0)))
+static inline void page_ref_inc(struct page *page)
+{
+	get_page(page);
+}
+#else
+#define HAVE_PAGE_COUNT_BULK_UPDATE
+#endif
+#ifndef IPV4_USER_FLOW
+#define	IPV4_USER_FLOW	0x0d	/* spec only (usr_ip4_spec) */
+#endif
+
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define HAVE_TC_SETUP_CLSFLOWER
+#define HAVE_TC_FLOWER_ENC
+#endif
+
+#if ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,7)) || \
+     (SLE_VERSION_CODE >= SLE_VERSION(12,2,0)))
+#define HAVE_TC_SETUP_CLSU32
+#endif
+
+#if (SLE_VERSION_CODE >= SLE_VERSION(12,2,0))
+#define HAVE_TC_SETUP_CLSFLOWER
+#endif
+
+#else /* >= 4.6.0 */
+#define HAVE_PAGE_COUNT_BULK_UPDATE
+#define HAVE_ETHTOOL_FLOW_UNION_IP6_SPEC
+#define HAVE_PTP_CROSSTIMESTAMP
+#define HAVE_TC_SETUP_CLSFLOWER
+#define HAVE_TC_SETUP_CLSU32
+#endif /* 4.6.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0))
+#if ((SLE_VERSION_CODE >= SLE_VERSION(12,3,0)) ||\
+     (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4)))
+#define HAVE_NETIF_TRANS_UPDATE
+#endif /* SLES12sp3+ || RHEL7.4+ */
+#if ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3)) ||\
+     (SLE_VERSION_CODE >= SLE_VERSION(12,3,0)))
+#define HAVE_ETHTOOL_25G_BITS
+#define HAVE_ETHTOOL_50G_BITS
+#define HAVE_ETHTOOL_100G_BITS
+#endif /* RHEL7.3+ || SLES12sp3+ */
+#else /* 4.7.0 */
+#define HAVE_NETIF_TRANS_UPDATE
+#define HAVE_ETHTOOL_CONVERT_U32_AND_LINK_MODE
+#define HAVE_ETHTOOL_25G_BITS
+#define HAVE_ETHTOOL_50G_BITS
+#define HAVE_ETHTOOL_100G_BITS
+#define HAVE_TCF_MIRRED_REDIRECT
+#endif /* 4.7.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,8,0))
+#if !(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+enum udp_parsable_tunnel_type {
+	UDP_TUNNEL_TYPE_VXLAN,
+	UDP_TUNNEL_TYPE_GENEVE,
+};
+struct udp_tunnel_info {
+	unsigned short type;
+	sa_family_t sa_family;
+	__be16 port;
+};
+#endif
+
+#if (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5))
+#define HAVE_TCF_EXTS_TO_LIST
+#endif
+
+#if (UBUNTU_VERSION_CODE && UBUNTU_VERSION_CODE < UBUNTU_VERSION(4,8,0,0))
+#define tc_no_actions(_exts) true
+#define tc_for_each_action(_a, _exts) while (0)
+#endif
+#if !(SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0))) &&\
+	!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+static inline int
+#ifdef HAVE_NON_CONST_PCI_DRIVER_NAME
+pci_request_io_regions(struct pci_dev *pdev, char *name)
+#else
+pci_request_io_regions(struct pci_dev *pdev, const char *name)
+#endif
+{
+	return pci_request_selected_regions(pdev,
+			    pci_select_bars(pdev, IORESOURCE_IO), name);
+}
+
+static inline void
+pci_release_io_regions(struct pci_dev *pdev)
+{
+	return pci_release_selected_regions(pdev,
+			    pci_select_bars(pdev, IORESOURCE_IO));
+}
+
+static inline int
+#ifdef HAVE_NON_CONST_PCI_DRIVER_NAME
+pci_request_mem_regions(struct pci_dev *pdev, char *name)
+#else
+pci_request_mem_regions(struct pci_dev *pdev, const char *name)
+#endif
+{
+	return pci_request_selected_regions(pdev,
+			    pci_select_bars(pdev, IORESOURCE_MEM), name);
+}
+
+static inline void
+pci_release_mem_regions(struct pci_dev *pdev)
+{
+	return pci_release_selected_regions(pdev,
+			    pci_select_bars(pdev, IORESOURCE_MEM));
+}
+#endif /* !SLE_VERSION(12,3,0) */
+#if ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4)) ||\
+     (SLE_VERSION_CODE >= SLE_VERSION(12,3,0)))
+#define HAVE_ETHTOOL_NEW_50G_BITS
+#endif /* RHEL7.4+ || SLES12sp3+ */
+#else
+#define HAVE_UDP_ENC_RX_OFFLOAD
+#define HAVE_TCF_EXTS_TO_LIST
+#define HAVE_ETHTOOL_NEW_50G_BITS
+#endif /* 4.8.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,9,0))
+#ifdef HAVE_TC_SETUP_CLSFLOWER
+#if (!(RHEL_RELEASE_CODE) && !(SLE_VERSION_CODE) || \
+    (SLE_VERSION_CODE && (SLE_VERSION_CODE < SLE_VERSION(12,3,0))))
+#define HAVE_TC_FLOWER_VLAN_IN_TAGS
+#endif /* !RHEL_RELEASE_CODE && !SLE_VERSION_CODE || <SLE_VERSION(12,3,0) */
+#endif /* HAVE_TC_SETUP_CLSFLOWER */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define HAVE_ETHTOOL_NEW_1G_BITS
+#define HAVE_ETHTOOL_NEW_10G_BITS
+#endif /* RHEL7.4+ */
+#if (!(SLE_VERSION_CODE) && !(RHEL_RELEASE_CODE)) || \
+     SLE_VERSION_CODE && (SLE_VERSION_CODE <= SLE_VERSION(12,3,0)) || \
+     RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE <= RHEL_RELEASE_VERSION(7,5))
+#define time_is_before_jiffies64(a)	time_after64(get_jiffies_64(), a)
+#endif /* !SLE_VERSION_CODE && !RHEL_RELEASE_CODE || (SLES <= 12.3.0) || (RHEL <= 7.5) */
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,4))
+static inline void bitmap_from_u64(unsigned long *dst, u64 mask)
+{
+	dst[0] = mask & ULONG_MAX;
+
+	if (sizeof(mask) > sizeof(unsigned long))
+		dst[1] = mask >> 32;
+}
+#endif /* <RHEL7.4 */
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,3,0)) && \
+     !(UBUNTU_VERSION_CODE >= UBUNTU_VERSION(4,13,0,16)))
+static inline bool eth_type_vlan(__be16 ethertype)
+{
+	switch (ethertype) {
+	case htons(ETH_P_8021Q):
+#ifdef ETH_P_8021AD
+	case htons(ETH_P_8021AD):
+#endif
+		return true;
+	default:
+		return false;
+	}
+}
+#endif /* Linux < 4.9 || RHEL < 7.4 || SLES < 12.3 || Ubuntu < 4.3.0-16 */
+#else /* >=4.9 */
+#define HAVE_FLOW_DISSECTOR_KEY_VLAN_PRIO
+#define HAVE_ETHTOOL_NEW_1G_BITS
+#define HAVE_ETHTOOL_NEW_10G_BITS
+#endif /* KERNEL_VERSION(4.9.0) */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0))
+/* SLES 12.3 and RHEL 7.5 backported this interface */
+#if (!SLE_VERSION_CODE && !RHEL_RELEASE_CODE) || \
+    (SLE_VERSION_CODE && (SLE_VERSION_CODE < SLE_VERSION(12,3,0))) || \
+    (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,5)))
+static inline bool _kc_napi_complete_done2(struct napi_struct *napi,
+					   int __always_unused work_done)
+{
+	/* it was really hard to get napi_complete_done to be safe to call
+	 * recursively without running into our own kcompat, so just use
+	 * napi_complete
+	 */
+	napi_complete(napi);
+
+	/* true means that the stack is telling the driver to go-ahead and
+	 * re-enable interrupts
+	 */
+	return true;
+}
+
+#ifdef napi_complete_done
+#undef napi_complete_done
+#endif
+#define napi_complete_done _kc_napi_complete_done2
+#endif /* sles and rhel exclusion for < 4.10 */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,4))
+#define HAVE_DEV_WALK_API
+#define HAVE_ETHTOOL_NEW_2500MB_BITS
+#define HAVE_ETHTOOL_5G_BITS
+#endif /* RHEL7.4+ */
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE == SLE_VERSION(12,3,0)))
+#define HAVE_STRUCT_DMA_ATTRS
+#endif /* (SLES == 12.3.0) */
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0)))
+#define HAVE_NETDEVICE_MIN_MAX_MTU
+#endif /* (SLES >= 12.3.0) */
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)))
+#define HAVE_STRUCT_DMA_ATTRS
+#define HAVE_RHEL7_EXTENDED_MIN_MAX_MTU
+#define HAVE_NETDEVICE_MIN_MAX_MTU
+#endif
+#if (!(SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0))) && \
+     !(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5))))
+#ifndef dma_map_page_attrs
+#define dma_map_page_attrs __kc_dma_map_page_attrs
+static inline dma_addr_t __kc_dma_map_page_attrs(struct device *dev,
+						 struct page *page,
+						 size_t offset, size_t size,
+						 enum dma_data_direction dir,
+						 unsigned long __always_unused attrs)
+{
+	return dma_map_page(dev, page, offset, size, dir);
+}
+#endif
+
+#ifndef dma_unmap_page_attrs
+#define dma_unmap_page_attrs __kc_dma_unmap_page_attrs
+static inline void __kc_dma_unmap_page_attrs(struct device *dev,
+					     dma_addr_t addr, size_t size,
+					     enum dma_data_direction dir,
+					     unsigned long __always_unused attrs)
+{
+	dma_unmap_page(dev, addr, size, dir);
+}
+#endif
+
+static inline void __page_frag_cache_drain(struct page *page,
+					   unsigned int count)
+{
+#ifdef HAVE_PAGE_COUNT_BULK_UPDATE
+	if (!page_ref_sub_and_test(page, count))
+		return;
+
+	init_page_count(page);
+#else
+	BUG_ON(count > 1);
+	if (!count)
+		return;
+#endif
+	__free_pages(page, compound_order(page));
+}
+#endif /* !SLE_VERSION(12,3,0) && !RHEL_VERSION(7,5) */
+#if ((SLE_VERSION_CODE && (SLE_VERSION_CODE > SLE_VERSION(12,3,0))) ||\
+     (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)))
+#define HAVE_SWIOTLB_SKIP_CPU_SYNC
+#endif
+
+#if ((SLE_VERSION_CODE && (SLE_VERSION_CODE < SLE_VERSION(15,0,0))) ||\
+     (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE <= RHEL_RELEASE_VERSION(7,4))))
+#define page_frag_free __free_page_frag
+#endif
+#ifndef ETH_MIN_MTU
+#define ETH_MIN_MTU 68
+#endif /* ETH_MIN_MTU */
+#else /* >= 4.10 */
+#define HAVE_TC_FLOWER_ENC
+#define HAVE_NETDEVICE_MIN_MAX_MTU
+#define HAVE_SWIOTLB_SKIP_CPU_SYNC
+#define HAVE_NETDEV_TC_RESETS_XPS
+#define HAVE_XPS_QOS_SUPPORT
+#define HAVE_DEV_WALK_API
+#define HAVE_ETHTOOL_NEW_2500MB_BITS
+#define HAVE_ETHTOOL_5G_BITS
+/* kernel 4.10 onwards, as part of busy_poll rewrite, new state were added
+ * which is part of NAPI:state. If NAPI:state=NAPI_STATE_IN_BUSY_POLL,
+ * it means napi_poll is invoked in busy_poll context
+ */
+#define HAVE_NAPI_STATE_IN_BUSY_POLL
+#define HAVE_TCF_MIRRED_EGRESS_REDIRECT
+#endif /* 4.10.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0))
+#ifdef CONFIG_NET_RX_BUSY_POLL
+#define HAVE_NDO_BUSY_POLL
+#endif /* CONFIG_NET_RX_BUSY_POLL */
+#if ((SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,3,0))) || \
+     (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5))))
+#define HAVE_VOID_NDO_GET_STATS64
+#endif /* (SLES >= 12.3.0) && (RHEL >= 7.5) */
+
+static inline void _kc_dev_kfree_skb_irq(struct sk_buff *skb)
+{
+	if (!skb)
+		return;
+	dev_kfree_skb_irq(skb);
+}
+
+#undef dev_kfree_skb_irq
+#define dev_kfree_skb_irq _kc_dev_kfree_skb_irq
+
+static inline void _kc_dev_consume_skb_irq(struct sk_buff *skb)
+{
+	if (!skb)
+		return;
+	dev_consume_skb_irq(skb);
+}
+
+#undef dev_consume_skb_irq
+#define dev_consume_skb_irq _kc_dev_consume_skb_irq
+
+static inline void _kc_dev_kfree_skb_any(struct sk_buff *skb)
+{
+	if (!skb)
+		return;
+	dev_kfree_skb_any(skb);
+}
+
+#undef dev_kfree_skb_any
+#define dev_kfree_skb_any _kc_dev_kfree_skb_any
+
+static inline void _kc_dev_consume_skb_any(struct sk_buff *skb)
+{
+	if (!skb)
+		return;
+	dev_consume_skb_any(skb);
+}
+
+#undef dev_consume_skb_any
+#define dev_consume_skb_any _kc_dev_consume_skb_any
+
+#else /* > 4.11 */
+#define HAVE_VOID_NDO_GET_STATS64
+#define HAVE_VM_OPS_FAULT_NO_VMA
+#endif /* 4.11.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0))
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,7) && \
+     RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,0))
+/* The RHEL 7.7+ NL_SET_ERR_MSG_MOD triggers unused parameter warnings */
+#undef NL_SET_ERR_MSG_MOD
+#endif
+#ifndef NL_SET_ERR_MSG_MOD
+#define NL_SET_ERR_MSG_MOD(extack, msg)						\
+	do {									\
+		uninitialized_var(extack);					\
+		pr_err(KBUILD_MODNAME ": " msg);				\
+	} while (0)
+#endif /* !NL_SET_ERR_MSG_MOD */
+#endif /* 4.12 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0))
+#if ((SLE_VERSION_CODE && (SLE_VERSION_CODE > SLE_VERSION(12,3,0))) || \
+     (RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)))
+#define HAVE_TCF_EXTS_HAS_ACTION
+#endif
+#define  PCI_EXP_LNKCAP_SLS_8_0GB 0x00000003 /* LNKCAP2 SLS Vector bit 2 */
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,4,0)))
+#define HAVE_PCI_ERROR_HANDLER_RESET_PREPARE
+#endif /* SLES >= 12sp4 */
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,4,0)))
+#define UUID_SIZE 16
+typedef struct {
+	__u8 b[UUID_SIZE];
+} uuid_t;
+#define UUID_INIT(a, b, c, d0, d1, d2, d3, d4, d5, d6, d7)		\
+((uuid_t)								\
+{{ ((a) >> 24) & 0xff, ((a) >> 16) & 0xff, ((a) >> 8) & 0xff, (a) & 0xff, \
+   ((b) >> 8) & 0xff, (b) & 0xff,					\
+   ((c) >> 8) & 0xff, (c) & 0xff,					\
+   (d0), (d1), (d2), (d3), (d4), (d5), (d6), (d7) }})
+
+static inline bool uuid_equal(const uuid_t *u1, const uuid_t *u2)
+{
+	return memcmp(u1, u2, sizeof(uuid_t)) == 0;
+}
+#else
+#define HAVE_METADATA_PORT_INFO
+#endif /* !(RHEL >= 7.5) && !(SLES >= 12.4) */
+#else /* > 4.13 */
+#define HAVE_METADATA_PORT_INFO
+#define HAVE_HWTSTAMP_FILTER_NTP_ALL
+#define HAVE_NDO_SETUP_TC_CHAIN_INDEX
+#define HAVE_PCI_ERROR_HANDLER_RESET_PREPARE
+#define HAVE_PTP_CLOCK_DO_AUX_WORK
+#endif /* 4.13.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0))
+#ifdef ETHTOOL_GLINKSETTINGS
+#ifndef ethtool_link_ksettings_del_link_mode
+#define ethtool_link_ksettings_del_link_mode(ptr, name, mode)		\
+	__clear_bit(ETHTOOL_LINK_MODE_ ## mode ## _BIT, (ptr)->link_modes.name)
+#endif
+#endif /* ETHTOOL_GLINKSETTINGS */
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,4,0)))
+#define HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+#endif
+
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,5)))
+#define HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+#define HAVE_RHEL7_NETDEV_OPS_EXT_NDO_SETUP_TC
+#endif
+
+#define TIMER_DATA_TYPE		unsigned long
+#define TIMER_FUNC_TYPE		void (*)(TIMER_DATA_TYPE)
+
+#define timer_setup(timer, callback, flags)				\
+	__setup_timer((timer), (TIMER_FUNC_TYPE)(callback),		\
+		      (TIMER_DATA_TYPE)(timer), (flags))
+
+#define from_timer(var, callback_timer, timer_fieldname) \
+	container_of(callback_timer, typeof(*var), timer_fieldname)
+
+#ifndef xdp_do_flush_map
+#define xdp_do_flush_map() do {} while (0)
+#endif
+struct _kc_xdp_buff {
+	void *data;
+	void *data_end;
+	void *data_hard_start;
+};
+#define xdp_buff _kc_xdp_buff
+struct _kc_bpf_prog {
+};
+#define bpf_prog _kc_bpf_prog
+#ifndef DIV_ROUND_DOWN_ULL
+#define DIV_ROUND_DOWN_ULL(ll, d) \
+	({ unsigned long long _tmp = (ll); do_div(_tmp, d); _tmp; })
+#endif /* DIV_ROUND_DOWN_ULL */
+#else /* > 4.14 */
+#define HAVE_XDP_SUPPORT
+#define HAVE_NDO_SETUP_TC_REMOVE_TC_TO_NETDEV
+#define HAVE_TCF_EXTS_HAS_ACTION
+#endif /* 4.14.0 */
+
+/*****************************************************************************/
+#ifndef ETHTOOL_GLINKSETTINGS
+
+#define __ETHTOOL_LINK_MODE_MASK_NBITS 32
+#define ETHTOOL_LINK_MASK_SIZE BITS_TO_LONGS(__ETHTOOL_LINK_MODE_MASK_NBITS)
+
+/**
+ * struct ethtool_link_ksettings
+ * @link_modes: supported and advertising, single item arrays
+ * @link_modes.supported: bitmask of supported link speeds
+ * @link_modes.advertising: bitmask of currently advertised speeds
+ * @base: base link details
+ * @base.speed: current link speed
+ * @base.port: current port type
+ * @base.duplex: current duplex mode
+ * @base.autoneg: current autonegotiation settings
+ *
+ * This struct and the following macros provide a way to support the old
+ * ethtool get/set_settings API on older kernels, but in the style of the new
+ * GLINKSETTINGS API.  In this way, the same code can be used to support both
+ * APIs as seemlessly as possible.
+ *
+ * It should be noted the old API only has support up to the first 32 bits.
+ */
+struct ethtool_link_ksettings {
+	struct {
+		u32 speed;
+		u8 port;
+		u8 duplex;
+		u8 autoneg;
+	} base;
+	struct {
+		unsigned long supported[ETHTOOL_LINK_MASK_SIZE];
+		unsigned long advertising[ETHTOOL_LINK_MASK_SIZE];
+	} link_modes;
+};
+
+#define ETHTOOL_LINK_NAME_advertising(mode) ADVERTISED_ ## mode
+#define ETHTOOL_LINK_NAME_supported(mode) SUPPORTED_ ## mode
+#define ETHTOOL_LINK_NAME(name) ETHTOOL_LINK_NAME_ ## name
+#define ETHTOOL_LINK_CONVERT(name, mode) ETHTOOL_LINK_NAME(name)(mode)
+
+/**
+ * ethtool_link_ksettings_zero_link_mode
+ * @ptr: ptr to ksettings struct
+ * @name: supported or advertising
+ */
+#define ethtool_link_ksettings_zero_link_mode(ptr, name)\
+	(*((ptr)->link_modes.name) = 0x0)
+
+/**
+ * ethtool_link_ksettings_add_link_mode
+ * @ptr: ptr to ksettings struct
+ * @name: supported or advertising
+ * @mode: link mode to add
+ */
+#define ethtool_link_ksettings_add_link_mode(ptr, name, mode)\
+	(*((ptr)->link_modes.name) |= (typeof(*((ptr)->link_modes.name)))ETHTOOL_LINK_CONVERT(name, mode))
+
+/**
+ * ethtool_link_ksettings_del_link_mode
+ * @ptr: ptr to ksettings struct
+ * @name: supported or advertising
+ * @mode: link mode to delete
+ */
+#define ethtool_link_ksettings_del_link_mode(ptr, name, mode)\
+	(*((ptr)->link_modes.name) &= ~(typeof(*((ptr)->link_modes.name)))ETHTOOL_LINK_CONVERT(name, mode))
+
+/**
+ * ethtool_link_ksettings_test_link_mode
+ * @ptr: ptr to ksettings struct
+ * @name: supported or advertising
+ * @mode: link mode to add
+ */
+#define ethtool_link_ksettings_test_link_mode(ptr, name, mode)\
+	(!!(*((ptr)->link_modes.name) & ETHTOOL_LINK_CONVERT(name, mode)))
+
+/**
+ * _kc_ethtool_ksettings_to_cmd - Convert ethtool_link_ksettings to ethtool_cmd
+ * @ks: ethtool_link_ksettings struct
+ * @cmd: ethtool_cmd struct
+ *
+ * Convert an ethtool_link_ksettings structure into the older ethtool_cmd
+ * structure. We provide this in kcompat.h so that drivers can easily
+ * implement the older .{get|set}_settings as wrappers around the new api.
+ * Hence, we keep it prefixed with _kc_ to make it clear this isn't actually
+ * a real function in the kernel.
+ */
+static inline void
+_kc_ethtool_ksettings_to_cmd(struct ethtool_link_ksettings *ks,
+			     struct ethtool_cmd *cmd)
+{
+	cmd->supported = (u32)ks->link_modes.supported[0];
+	cmd->advertising = (u32)ks->link_modes.advertising[0];
+	ethtool_cmd_speed_set(cmd, ks->base.speed);
+	cmd->duplex = ks->base.duplex;
+	cmd->autoneg = ks->base.autoneg;
+	cmd->port = ks->base.port;
+}
+
+#endif /* !ETHTOOL_GLINKSETTINGS */
+
+/*****************************************************************************/
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)) || \
+     (SLE_VERSION_CODE && (SLE_VERSION_CODE <= SLE_VERSION(12,3,0))) || \
+     (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE <= RHEL_RELEASE_VERSION(7,5))))
+#define phy_speed_to_str _kc_phy_speed_to_str
+const char *_kc_phy_speed_to_str(int speed);
+#else /* (LINUX >= 4.14.0) || (SLES > 12.3.0) || (RHEL > 7.5) */
+#include <linux/phy.h>
+#endif /* (LINUX < 4.14.0) || (SLES <= 12.3.0) || (RHEL <= 7.5) */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0))
+#if ((RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,6))) || \
+     (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(15,1,0))))
+#define HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO
+#define HAVE_TCF_BLOCK
+#else /* RHEL >= 7.6 || SLES >= 15.1 */
+#define TC_SETUP_QDISC_MQPRIO TC_SETUP_MQPRIO
+#endif /* !(RHEL >= 7.6) && !(SLES >= 15.1) */
+void _kc_ethtool_intersect_link_masks(struct ethtool_link_ksettings *dst,
+				      struct ethtool_link_ksettings *src);
+#define ethtool_intersect_link_masks _kc_ethtool_intersect_link_masks
+#else /* >= 4.15 */
+#define HAVE_NDO_BPF
+#define HAVE_XDP_BUFF_DATA_META
+#define HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO
+#define HAVE_TCF_BLOCK
+#endif /* 4.15.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,7)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(12,4,0) && \
+       SLE_VERSION_CODE < SLE_VERSION(15,0,0)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(15,1,0)))
+/* The return value of the strscpy() and strlcpy() functions is different.
+ * This could be potentially hazard for the future.
+ * To avoid this the void result is forced.
+ * So it is not possible use this function with the return value.
+ * Return value is required in kernel 4.3 through 4.15
+ */
+#define strscpy(...) (void)(strlcpy(__VA_ARGS__))
+#endif /* !RHEL >= 7.7 && !SLES12sp4+ && !SLES15sp1+ */
+
+#define pci_printk(level, pdev, fmt, arg...) \
+	dev_printk(level, &(pdev)->dev, fmt, ##arg)
+#define pci_emerg(pdev, fmt, arg...)	dev_emerg(&(pdev)->dev, fmt, ##arg)
+#define pci_alert(pdev, fmt, arg...)	dev_alert(&(pdev)->dev, fmt, ##arg)
+#define pci_crit(pdev, fmt, arg...)	dev_crit(&(pdev)->dev, fmt, ##arg)
+#define pci_err(pdev, fmt, arg...)	dev_err(&(pdev)->dev, fmt, ##arg)
+#define pci_warn(pdev, fmt, arg...)	dev_warn(&(pdev)->dev, fmt, ##arg)
+#define pci_notice(pdev, fmt, arg...)	dev_notice(&(pdev)->dev, fmt, ##arg)
+#define pci_info(pdev, fmt, arg...)	dev_info(&(pdev)->dev, fmt, ##arg)
+#define pci_dbg(pdev, fmt, arg...)	dev_dbg(&(pdev)->dev, fmt, ##arg)
+
+#ifndef array_index_nospec
+static inline unsigned long _kc_array_index_mask_nospec(unsigned long index,
+							unsigned long size)
+{
+	/*
+	 * Always calculate and emit the mask even if the compiler
+	 * thinks the mask is not needed. The compiler does not take
+	 * into account the value of @index under speculation.
+	 */
+	OPTIMIZER_HIDE_VAR(index);
+	return ~(long)(index | (size - 1UL - index)) >> (BITS_PER_LONG - 1);
+}
+
+#define array_index_nospec(index, size)					\
+({									\
+	typeof(index) _i = (index);					\
+	typeof(size) _s = (size);					\
+	unsigned long _mask = _kc_array_index_mask_nospec(_i, _s);	\
+									\
+	BUILD_BUG_ON(sizeof(_i) > sizeof(long));			\
+	BUILD_BUG_ON(sizeof(_s) > sizeof(long));			\
+									\
+	(typeof(_i)) (_i & _mask);					\
+})
+#endif /* array_index_nospec */
+#if (!(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,6))) && \
+     !(SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(15,1,0))))
+#ifdef HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO
+#include <net/pkt_cls.h>
+static inline bool
+tc_cls_can_offload_and_chain0(const struct net_device *dev,
+			      struct tc_cls_common_offload *common)
+{
+	if (!tc_can_offload(dev))
+		return false;
+	if (common->chain_index)
+		return false;
+
+	return true;
+}
+#endif /* HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO */
+#endif /* !(RHEL >= 7.6) && !(SLES >= 15.1) */
+#ifndef sizeof_field
+#define sizeof_field(TYPE, MEMBER) (sizeof((((TYPE *)0)->MEMBER)))
+#endif /* sizeof_field */
+#else /* >= 4.16 */
+#include <linux/nospec.h>
+#define HAVE_XDP_BUFF_RXQ
+#define HAVE_TC_FLOWER_OFFLOAD_COMMON_EXTACK
+#define HAVE_TCF_MIRRED_DEV
+#define HAVE_VF_STATS_DROPPED
+#endif /* 4.16.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,17,0))
+#include <linux/pci_regs.h>
+#include <linux/pci.h>
+#define PCIE_SPEED_16_0GT 0x17
+#define PCI_EXP_LNKCAP_SLS_16_0GB 0x00000004 /* LNKCAP2 SLS Vector bit 3 */
+#define PCI_EXP_LNKSTA_CLS_16_0GB 0x0004 /* Current Link Speed 16.0GT/s */
+#define PCI_EXP_LNKCAP2_SLS_16_0GB 0x00000010 /* Supported Speed 16GT/s */
+void _kc_pcie_print_link_status(struct pci_dev *dev);
+#define pcie_print_link_status _kc_pcie_print_link_status
+#else /* >= 4.17.0 */
+#define HAVE_XDP_BUFF_IN_XDP_H
+#endif /* 4.17.0 */
+
+/*****************************************************************************/
+#if IS_ENABLED(CONFIG_NET_DEVLINK) && \
+    (LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0))
+#include <net/devlink.h>
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,18,0)) && \
+     (SLE_VERSION_CODE < SLE_VERSION(15,1,0)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,7)))
+enum devlink_port_flavour {
+	DEVLINK_PORT_FLAVOUR_PHYSICAL,
+	DEVLINK_PORT_FLAVOUR_CPU,
+	DEVLINK_PORT_FLAVOUR_DSA,
+	DEVLINK_PORT_FLAVOUR_PCI_PF,
+	DEVLINK_PORT_FLAVOUR_PCI_VF,
+};
+#endif /* <4.18.0 && <SLES15sp1 && <RHEL7.7 */
+
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(5,3,0)) && \
+     (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,2)))
+struct devlink_port_phys_attrs {
+	u32 port_number; /* Same value as "split group".
+			  * A physical port which is visible to the user
+			  * for a given port flavour.
+			  */
+	u32 split_subport_number; /* If the port is split, this is the number
+				   * of subport. */
+};
+
+struct devlink_port_pci_pf_attrs {
+	u16 pf; /* Associated PCI PF for this port. */
+};
+
+struct devlink_port_pci_vf_attrs {
+	u16 pf; /* Associated PCI PF for this port. */
+	u16 vf; /* Associated PCI VF for of the PCI PF for this port. */
+};
+#endif /* <5.3.0 && <RHEL8.2*/
+
+struct _kc_devlink_port_attrs {
+	u8 split:1,
+	   splittable:1;
+	u32 lanes;
+	enum devlink_port_flavour flavour;
+	struct netdev_phys_item_id switch_id;
+	union {
+		struct devlink_port_phys_attrs phys;
+		struct devlink_port_pci_pf_attrs pci_pf;
+		struct devlink_port_pci_vf_attrs pci_vf;
+	};
+};
+#define devlink_port_attrs _kc_devlink_port_attrs
+#endif /* CONFIG_NET_DEVLINK && <5.9.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,18,0))
+#ifdef NETIF_F_HW_L2FW_DOFFLOAD
+#include <linux/if_macvlan.h>
+#ifndef macvlan_supports_dest_filter
+#define macvlan_supports_dest_filter _kc_macvlan_supports_dest_filter
+static inline bool _kc_macvlan_supports_dest_filter(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	return macvlan->mode == MACVLAN_MODE_PRIVATE ||
+	       macvlan->mode == MACVLAN_MODE_VEPA ||
+	       macvlan->mode == MACVLAN_MODE_BRIDGE;
+}
+#endif
+
+#if (!SLE_VERSION_CODE || (SLE_VERSION_CODE < SLE_VERSION(15,1,0)))
+#ifndef macvlan_accel_priv
+#define macvlan_accel_priv _kc_macvlan_accel_priv
+static inline void *_kc_macvlan_accel_priv(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	return macvlan->fwd_priv;
+}
+#endif
+
+#ifndef macvlan_release_l2fw_offload
+#define macvlan_release_l2fw_offload _kc_macvlan_release_l2fw_offload
+static inline int _kc_macvlan_release_l2fw_offload(struct net_device *dev)
+{
+	struct macvlan_dev *macvlan = netdev_priv(dev);
+
+	macvlan->fwd_priv = NULL;
+	return dev_uc_add(macvlan->lowerdev, dev->dev_addr);
+}
+#endif
+#endif /* !SLES || SLES < 15.1 */
+#endif /* NETIF_F_HW_L2FW_DOFFLOAD */
+#include "kcompat_overflow.h"
+
+#if (SLE_VERSION_CODE < SLE_VERSION(15,1,0))
+#define firmware_request_nowarn	request_firmware_direct
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(7,7))
+#if IS_ENABLED(CONFIG_NET_DEVLINK) && !defined(devlink_port_attrs_set)
+static inline void
+_kc_devlink_port_attrs_set(struct devlink_port *devlink_port,
+			   struct _kc_devlink_port_attrs *attrs)
+{
+	if (attrs->split)
+		devlink_port_split_set(devlink_port, attrs->phys.port_number);
+}
+
+#define devlink_port_attrs_set _kc_devlink_port_attrs_set
+#endif /* CONFIG_NET_DEVLINK && !devlink_port_attrs_set */
+#endif /* <RHEL7.7 */
+#endif /* SLES < 15.1 */
+
+#else
+#include <linux/overflow.h>
+#include <net/xdp_sock.h>
+#define HAVE_XDP_FRAME_STRUCT
+#define HAVE_XDP_SOCK
+#define HAVE_NDO_XDP_XMIT_BULK_AND_FLAGS
+#define NO_NDO_XDP_FLUSH
+#define HAVE_AF_XDP_SUPPORT
+#endif /* 4.18.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,19,0))
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,0)) && \
+    (RHEL_RELEASE_CODE <= RHEL_RELEASE_VERSION(8,2)))
+#define HAVE_DEVLINK_REGIONS
+#endif
+#define bitmap_alloc(nbits, flags) \
+	kmalloc_array(BITS_TO_LONGS(nbits), sizeof(unsigned long), flags)
+#define bitmap_zalloc(nbits, flags) bitmap_alloc(nbits, ((flags) | __GFP_ZERO))
+#define bitmap_free(bitmap) kfree(bitmap)
+#ifdef ETHTOOL_GLINKSETTINGS
+#define ethtool_ks_clear(ptr, name) \
+	ethtool_link_ksettings_zero_link_mode(ptr, name)
+#define ethtool_ks_add_mode(ptr, name, mode) \
+	ethtool_link_ksettings_add_link_mode(ptr, name, mode)
+#define ethtool_ks_del_mode(ptr, name, mode) \
+	ethtool_link_ksettings_del_link_mode(ptr, name, mode)
+#define ethtool_ks_test(ptr, name, mode) \
+	ethtool_link_ksettings_test_link_mode(ptr, name, mode)
+#endif /* ETHTOOL_GLINKSETTINGS */
+#define HAVE_NETPOLL_CONTROLLER
+#define REQUIRE_PCI_CLEANUP_AER_ERROR_STATUS
+#if (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(15,1,0)))
+#define HAVE_TCF_MIRRED_DEV
+#define HAVE_NDO_SELECT_QUEUE_SB_DEV
+#define HAVE_TCF_BLOCK_CB_REGISTER_EXTACK
+#endif
+#if ((RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,0)) ||\
+     (SLE_VERSION_CODE >= SLE_VERSION(15,1,0)))
+#define HAVE_TCF_EXTS_FOR_EACH_ACTION
+#undef HAVE_TCF_EXTS_TO_LIST
+#endif /* RHEL8.0+ */
+#if ((RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,3))) || \
+     (SLE_VERSION_CODE && (SLE_VERSION_CODE >= SLE_VERSION(12,2,0))))
+#ifndef metadata_dst_free
+#include <net/dst_metadata.h>
+
+static inline void __kc_metadata_dst_free(struct metadata_dst *md_dst)
+{
+	kfree(md_dst);
+}
+
+#define metadata_dst_free(md_dst) __kc_metadata_dst_free(md_dst)
+#endif /* !metadata_dst_free */
+#endif /* RHEL >= 7.3 || SLES >= 12.2 */
+#else /* >= 4.19.0 */
+#define HAVE_TCF_BLOCK_CB_REGISTER_EXTACK
+#define NO_NETDEV_BPF_PROG_ATTACHED
+#define HAVE_NDO_SELECT_QUEUE_SB_DEV
+#define HAVE_NETDEV_SB_DEV
+#undef HAVE_TCF_EXTS_TO_LIST
+#define HAVE_TCF_EXTS_FOR_EACH_ACTION
+#define HAVE_TCF_VLAN_TPID
+#define HAVE_RHASHTABLE_TYPES
+#define HAVE_DEVLINK_REGIONS
+#define HAVE_DEVLINK_PARAMS
+#endif /* 4.19.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,20,0))
+#define HAVE_XDP_UMEM_PROPS
+#ifdef HAVE_AF_XDP_SUPPORT
+#ifndef napi_if_scheduled_mark_missed
+static inline bool __kc_napi_if_scheduled_mark_missed(struct napi_struct *n)
+{
+	unsigned long val, new;
+
+	do {
+		val = READ_ONCE(n->state);
+		if (val & NAPIF_STATE_DISABLE)
+			return true;
+
+		if (!(val & NAPIF_STATE_SCHED))
+			return false;
+
+		new = val | NAPIF_STATE_MISSED;
+	} while (cmpxchg(&n->state, val, new) != val);
+
+	return true;
+}
+
+#define napi_if_scheduled_mark_missed __kc_napi_if_scheduled_mark_missed
+#endif /* !napi_if_scheduled_mark_missed */
+#endif /* HAVE_AF_XDP_SUPPORT */
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,0)))
+#define HAVE_DEVLINK_ESWITCH_OPS_EXTACK
+#endif /* RHEL >= 8.0 */
+#if ((SLE_VERSION_CODE >= SLE_VERSION(12,5,0) && \
+      SLE_VERSION_CODE < SLE_VERSION(15,0,0)) || \
+     (SLE_VERSION_CODE >= SLE_VERSION(15,1,0)))
+#define HAVE_DEVLINK_ESWITCH_OPS_EXTACK
+#endif /* SLE == 12sp5 || SLE >= 15sp1 */
+#else /* >= 4.20.0 */
+#define HAVE_AF_XDP_NETDEV_UMEM
+#define HAVE_DEVLINK_ESWITCH_OPS_EXTACK
+#define HAVE_AF_XDP_ZC_SUPPORT
+#define HAVE_VXLAN_TYPE
+#define HAVE_ETF_SUPPORT /* Earliest TxTime First */
+#endif /* 4.20.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0))
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE > RHEL_RELEASE_VERSION(8,0)))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,12,0))
+#define NETLINK_MAX_COOKIE_LEN	20
+struct netlink_ext_ack {
+	const char *_msg;
+	const struct nlattr *bad_attr;
+	u8 cookie[NETLINK_MAX_COOKIE_LEN];
+	u8 cookie_len;
+};
+
+#endif /* < 4.12 */
+static inline int _kc_dev_open(struct net_device *netdev,
+			       struct netlink_ext_ack __always_unused *extack)
+{
+	return dev_open(netdev);
+}
+
+#define dev_open _kc_dev_open
+
+static inline int
+_kc_dev_change_flags(struct net_device *netdev, unsigned int flags,
+		     struct netlink_ext_ack __always_unused *extack)
+{
+	return dev_change_flags(netdev, flags);
+}
+
+#define dev_change_flags _kc_dev_change_flags
+#endif /* !(RHEL_RELEASE_CODE && RHEL > RHEL(8,0)) */
+#if (RHEL_RELEASE_CODE && \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(7,7) && \
+      RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,0)) || \
+     (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,1)))
+#define HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL
+#else /* RHEL >= 7.7 && RHEL < 8.0 || RHEL >= 8.1 */
+struct ptp_system_timestamp {
+	struct timespec64 pre_ts;
+	struct timespec64 post_ts;
+};
+
+static inline void
+ptp_read_system_prets(struct ptp_system_timestamp __always_unused *sts)
+{
+	;
+}
+
+static inline void
+ptp_read_system_postts(struct ptp_system_timestamp __always_unused *sts)
+{
+	;
+}
+#endif /* !(RHEL >= 7.7 && RHEL != 8.0) */
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,1)))
+#define HAVE_NDO_BRIDGE_SETLINK_EXTACK
+#endif /* RHEL 8.1 */
+#if (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2))
+#define HAVE_TC_INDIR_BLOCK
+#endif /* RHEL 8.2 */
+#else /* >= 5.0.0 */
+#define HAVE_PTP_SYS_OFFSET_EXTENDED_IOCTL
+#define HAVE_NDO_BRIDGE_SETLINK_EXTACK
+#define HAVE_DMA_ALLOC_COHERENT_ZEROES_MEM
+#define HAVE_GENEVE_TYPE
+#define HAVE_TC_INDIR_BLOCK
+#endif /* 5.0.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0))
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,1)))
+#define HAVE_TC_FLOW_RULE_INFRASTRUCTURE
+#define HAVE_NDO_FDB_ADD_EXTACK
+#define HAVE_DEVLINK_INFO_GET
+#define HAVE_DEVLINK_FLASH_UPDATE
+#else /* RHEL < 8.1 */
+#ifdef HAVE_TC_SETUP_CLSFLOWER
+#include <net/pkt_cls.h>
+
+struct flow_match {
+	struct flow_dissector	*dissector;
+	void			*mask;
+	void			*key;
+};
+
+struct flow_match_basic {
+	struct flow_dissector_key_basic *key, *mask;
+};
+
+struct flow_match_control {
+	struct flow_dissector_key_control *key, *mask;
+};
+
+struct flow_match_eth_addrs {
+	struct flow_dissector_key_eth_addrs *key, *mask;
+};
+
+#ifdef HAVE_TC_FLOWER_ENC
+struct flow_match_enc_keyid {
+	struct flow_dissector_key_keyid *key, *mask;
+};
+#endif
+
+#ifndef HAVE_TC_FLOWER_VLAN_IN_TAGS
+struct flow_match_vlan {
+	struct flow_dissector_key_vlan *key, *mask;
+};
+#endif
+
+struct flow_match_ipv4_addrs {
+	struct flow_dissector_key_ipv4_addrs *key, *mask;
+};
+
+struct flow_match_ipv6_addrs {
+	struct flow_dissector_key_ipv6_addrs *key, *mask;
+};
+
+struct flow_match_ports {
+	struct flow_dissector_key_ports *key, *mask;
+};
+
+struct flow_rule {
+	struct flow_match	match;
+#if 0
+	/* In 5.1+ kernels, action is a member of struct flow_rule but is
+	 * not compatible with how we kcompat tc_cls_flower_offload_flow_rule
+	 * below.  By not declaring it here, any driver that attempts to use
+	 * action as an element of struct flow_rule will fail to compile
+	 * instead of silently trying to access memory that shouldn't be.
+	 */
+	struct flow_action	action;
+#endif
+};
+
+void flow_rule_match_basic(const struct flow_rule *rule,
+			   struct flow_match_basic *out);
+void flow_rule_match_control(const struct flow_rule *rule,
+			     struct flow_match_control *out);
+void flow_rule_match_eth_addrs(const struct flow_rule *rule,
+			       struct flow_match_eth_addrs *out);
+#ifndef HAVE_TC_FLOWER_VLAN_IN_TAGS
+void flow_rule_match_vlan(const struct flow_rule *rule,
+			  struct flow_match_vlan *out);
+#endif
+void flow_rule_match_ipv4_addrs(const struct flow_rule *rule,
+				struct flow_match_ipv4_addrs *out);
+void flow_rule_match_ipv6_addrs(const struct flow_rule *rule,
+				struct flow_match_ipv6_addrs *out);
+void flow_rule_match_ports(const struct flow_rule *rule,
+			   struct flow_match_ports *out);
+#ifdef HAVE_TC_FLOWER_ENC
+void flow_rule_match_enc_ports(const struct flow_rule *rule,
+			       struct flow_match_ports *out);
+void flow_rule_match_enc_control(const struct flow_rule *rule,
+				 struct flow_match_control *out);
+void flow_rule_match_enc_ipv4_addrs(const struct flow_rule *rule,
+				    struct flow_match_ipv4_addrs *out);
+void flow_rule_match_enc_ipv6_addrs(const struct flow_rule *rule,
+				    struct flow_match_ipv6_addrs *out);
+void flow_rule_match_enc_keyid(const struct flow_rule *rule,
+			       struct flow_match_enc_keyid *out);
+#endif
+
+static inline struct flow_rule *
+tc_cls_flower_offload_flow_rule(struct tc_cls_flower_offload *tc_flow_cmd)
+{
+	return (struct flow_rule *)&tc_flow_cmd->dissector;
+}
+
+static inline bool flow_rule_match_key(const struct flow_rule *rule,
+				       enum flow_dissector_key_id key)
+{
+	return dissector_uses_key(rule->match.dissector, key);
+}
+#endif /* HAVE_TC_SETUP_CLSFLOWER */
+
+#endif /* RHEL < 8.1 */
+
+#if (!(RHEL_RELEASE_CODE && RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,1)))
+#define devlink_params_publish(devlink) do { } while (0)
+#define devlink_params_unpublish(devlink) do { } while (0)
+#endif
+
+#else /* >= 5.1.0 */
+#define HAVE_NDO_FDB_ADD_EXTACK
+#define NO_XDP_QUERY_XSK_UMEM
+#define HAVE_TC_FLOW_RULE_INFRASTRUCTURE
+#define HAVE_TC_FLOWER_ENC_IP
+#define HAVE_DEVLINK_INFO_GET
+#define HAVE_DEVLINK_FLASH_UPDATE
+#define HAVE_DEVLINK_PORT_PARAMS
+#endif /* 5.1.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,2,0))
+#if (defined HAVE_SKB_XMIT_MORE) && \
+(!(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2))))
+#define netdev_xmit_more()	(skb->xmit_more)
+#else
+#define netdev_xmit_more()	(0)
+#endif
+
+#if (!(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2))))
+#ifndef eth_get_headlen
+static inline u32
+__kc_eth_get_headlen(const struct net_device __always_unused *dev, void *data,
+		     unsigned int len)
+{
+	return eth_get_headlen(data, len);
+}
+
+#define eth_get_headlen(dev, data, len) __kc_eth_get_headlen(dev, data, len)
+#endif /* !eth_get_headlen */
+#endif /* !RHEL >= 8.2 */
+
+#ifndef mmiowb
+#ifdef CONFIG_IA64
+#define mmiowb() asm volatile ("mf.a" ::: "memory")
+#else
+#define mmiowb()
+#endif
+#endif /* mmiowb */
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,2))
+#if IS_ENABLED(CONFIG_NET_DEVLINK) && !defined(devlink_port_attrs_set)
+static inline void
+_kc_devlink_port_attrs_set(struct devlink_port *devlink_port,
+			   struct _kc_devlink_port_attrs *attrs)
+{
+	devlink_port_attrs_set(devlink_port, attrs->flavour,
+			       attrs->phys.port_number, attrs->split,
+			       attrs->phys.split_subport_number);
+}
+
+#define devlink_port_attrs_set _kc_devlink_port_attrs_set
+#endif /* CONFIG_NET_DEVLINK && !devlink_port_attrs_set */
+#endif /* <RHEL8.2 */
+
+#else /* >= 5.2.0 */
+#define HAVE_NDO_SELECT_QUEUE_FALLBACK_REMOVED
+#define SPIN_UNLOCK_IMPLIES_MMIOWB
+#endif /* 5.2.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,3,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2)))
+#define flow_block_offload tc_block_offload
+#define flow_block_command tc_block_command
+#define flow_cls_offload tc_cls_flower_offload
+#define flow_block_binder_type tcf_block_binder_type
+#define flow_cls_common_offload tc_cls_common_offload
+#define flow_cls_offload_flow_rule tc_cls_flower_offload_flow_rule
+#define FLOW_CLS_REPLACE TC_CLSFLOWER_REPLACE
+#define FLOW_CLS_DESTROY TC_CLSFLOWER_DESTROY
+#define FLOW_CLS_STATS TC_CLSFLOWER_STATS
+#define FLOW_CLS_TMPLT_CREATE TC_CLSFLOWER_TMPLT_CREATE
+#define FLOW_CLS_TMPLT_DESTROY TC_CLSFLOWER_TMPLT_DESTROY
+#define FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS \
+		TCF_BLOCK_BINDER_TYPE_CLSACT_INGRESS
+#define FLOW_BLOCK_BIND TC_BLOCK_BIND
+#define FLOW_BLOCK_UNBIND TC_BLOCK_UNBIND
+
+#ifdef HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO
+#include <net/pkt_cls.h>
+
+int _kc_flow_block_cb_setup_simple(struct flow_block_offload *f,
+				   struct list_head *driver_list,
+				   tc_setup_cb_t *cb,
+				   void *cb_ident, void *cb_priv,
+				   bool ingress_only);
+
+#define flow_block_cb_setup_simple(f, driver_list, cb, cb_ident, cb_priv, \
+				   ingress_only) \
+	_kc_flow_block_cb_setup_simple(f, driver_list, cb, cb_ident, cb_priv, \
+				       ingress_only)
+#endif /* HAVE_TC_CB_AND_SETUP_QDISC_MQPRIO */
+#else /* RHEL >= 8.2 */
+#define HAVE_FLOW_BLOCK_API
+#endif /* RHEL >= 8.2 */
+
+#ifndef ETH_P_LLDP
+#define ETH_P_LLDP	0x88CC
+#endif /* !ETH_P_LLDP */
+
+#if (RHEL_RELEASE_CODE < RHEL_RELEASE_VERSION(8,2))
+#if IS_ENABLED(CONFIG_NET_DEVLINK)
+static inline void
+devlink_flash_update_begin_notify(struct devlink __always_unused *devlink)
+{
+}
+
+static inline void
+devlink_flash_update_end_notify(struct devlink __always_unused *devlink)
+{
+}
+
+static inline void
+devlink_flash_update_status_notify(struct devlink __always_unused *devlink,
+				   const char __always_unused *status_msg,
+				   const char __always_unused *component,
+				   unsigned long __always_unused done,
+				   unsigned long __always_unused total)
+{
+}
+#endif /* CONFIG_NET_DEVLINK */
+#endif /* <RHEL8.2 */
+#else /* >= 5.3.0 */
+#define XSK_UMEM_RETURNS_XDP_DESC
+#define HAVE_XSK_UMEM_HAS_ADDRS
+#define HAVE_FLOW_BLOCK_API
+#endif /* 5.3.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0))
+#if (!(RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,2)) && \
+     !(SLE_VERSION_CODE >= SLE_VERSION(15,2,0)))
+static inline unsigned int skb_frag_off(const skb_frag_t *frag)
+{
+	return frag->page_offset;
+}
+
+static inline void skb_frag_off_add(skb_frag_t *frag, int delta)
+{
+	frag->page_offset += delta;
+}
+#define __flow_indr_block_cb_register __tc_indr_block_cb_register
+#define __flow_indr_block_cb_unregister __tc_indr_block_cb_unregister
+#endif /* !(RHEL >= 8.2) && !(SLES >= 15sp2) */
+#if (SLE_VERSION_CODE >= SLE_VERSION(15,2,0))
+#define HAVE_NDO_XSK_WAKEUP
+#endif /* SLES15sp2 */
+#else /* >= 5.4.0 */
+#define HAVE_NDO_XSK_WAKEUP
+#endif /* 5.4.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,5,0))
+static inline unsigned long _kc_bitmap_get_value8(const unsigned long *map,
+						  unsigned long start)
+{
+	const size_t index = BIT_WORD(start);
+	const unsigned long offset = start % BITS_PER_LONG;
+
+	return (map[index] >> offset) & 0xFF;
+}
+#define bitmap_get_value8 _kc_bitmap_get_value8
+
+static inline void _kc_bitmap_set_value8(unsigned long *map,
+					 unsigned long value,
+					 unsigned long start)
+{
+	const size_t index = BIT_WORD(start);
+	const unsigned long offset = start % BITS_PER_LONG;
+
+	map[index] &= ~(0xFFUL << offset);
+	map[index] |= value << offset;
+}
+#define bitmap_set_value8 _kc_bitmap_set_value8
+
+#endif /* 5.5.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,6,0))
+#ifdef HAVE_AF_XDP_SUPPORT
+#define xsk_umem_release_addr		xsk_umem_discard_addr
+#define xsk_umem_release_addr_rq	xsk_umem_discard_addr_rq
+#endif /* HAVE_AF_XDP_SUPPORT */
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,3)))
+#define HAVE_TX_TIMEOUT_TXQUEUE
+#endif
+#else /* >= 5.6.0 */
+#define HAVE_TX_TIMEOUT_TXQUEUE
+#endif /* 5.6.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,7,0))
+u64 _kc_pci_get_dsn(struct pci_dev *dev);
+#define pci_get_dsn(dev) _kc_pci_get_dsn(dev)
+#if !(SLE_VERSION_CODE > SLE_VERSION(15,2,0)) && \
+    !((LINUX_VERSION_CODE == KERNEL_VERSION(5,3,18)) && \
+      (SLE_LOCALVERSION_CODE >= KERNEL_VERSION(14,0,0))) && \
+    !(RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,3)))
+#define pci_aer_clear_nonfatal_status	pci_cleanup_aer_uncorrect_error_status
+#endif
+
+#define cpu_latency_qos_update_request pm_qos_update_request
+#define cpu_latency_qos_add_request(arg1, arg2) pm_qos_add_request(arg1, PM_QOS_CPU_DMA_LATENCY, arg2)
+#define cpu_latency_qos_remove_request pm_qos_remove_request
+
+#ifndef DEVLINK_INFO_VERSION_GENERIC_FW_BUNDLE_ID
+#define DEVLINK_INFO_VERSION_GENERIC_FW_BUNDLE_ID "fw.bundle_id"
+#endif
+
+#ifdef HAVE_DEVLINK_REGIONS
+#if IS_ENABLED(CONFIG_NET_DEVLINK)
+struct devlink_region_ops {
+	const char *name;
+	void (*destructor)(const void *data);
+};
+
+#ifndef devlink_region_create
+static inline struct devlink_region *
+_kc_devlink_region_create(struct devlink *devlink,
+			  const struct devlink_region_ops *ops,
+			  u32 region_max_snapshots, u64 region_size)
+{
+	return devlink_region_create(devlink, ops->name, region_max_snapshots,
+				     region_size);
+}
+
+#define devlink_region_create _kc_devlink_region_create
+#endif /* devlink_region_create */
+#endif /* CONFIG_NET_DEVLINK */
+#define HAVE_DEVLINK_SNAPSHOT_CREATE_DESTRUCTOR
+#endif /* HAVE_DEVLINK_REGIONS */
+#else /* >= 5.7.0 */
+#define HAVE_DEVLINK_REGION_OPS_SNAPSHOT
+#define HAVE_ETHTOOL_COALESCE_PARAMS_SUPPORT
+#endif /* 5.7.0 */
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,8,0))
+#define xdp_convert_buff_to_frame convert_to_xdp_frame
+#else /* >= 5.8.0 */
+#undef HAVE_AF_XDP_ZC_SUPPORT
+#define HAVE_TC_FLOW_INDIR_DEV
+#define HAVE_TC_FLOW_INDIR_BLOCK_CLEANUP
+#endif /* 5.8.0 */
+#if (RHEL_RELEASE_CODE && (RHEL_RELEASE_CODE >= RHEL_RELEASE_VERSION(8,3)))
+#define HAVE_TC_FLOW_INDIR_DEV
+#endif
+
+/*****************************************************************************/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5,9,0))
+#if IS_ENABLED(CONFIG_NET_DEVLINK) && !defined(devlink_port_attrs_set)
+static inline void
+_kc_devlink_port_attrs_set(struct devlink_port *devlink_port,
+			   struct _kc_devlink_port_attrs *attrs)
+{
+	devlink_port_attrs_set(devlink_port, attrs->flavour,
+			       attrs->phys.port_number, attrs->split,
+			       attrs->phys.split_subport_number,
+			       attrs->switch_id.id, attrs->switch_id.id_len);
+}
+
+#define devlink_port_attrs_set _kc_devlink_port_attrs_set
+#endif /* CONFIG_NET_DEVLINK && !devlink_port_attrs_set */
+#define HAVE_XDP_QUERY_PROG
+#else /* >= 5.9.0 */
+#define HAVE_FLOW_INDIR_BLOCK_QDISC
+#endif /* 5.9.0 */
+
+#endif /* _KCOMPAT_H_ */
diff --git a/drivers/net/ethernet/intel/ixgbe/kcompat_ethtool.c b/drivers/net/ethernet/intel/ixgbe/kcompat_ethtool.c
new file mode 100644
index 000000000000..2c3d84d3b545
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/kcompat_ethtool.c
@@ -0,0 +1,1148 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+/*
+ * net/core/ethtool.c - Ethtool ioctl handler
+ * Copyright (c) 2003 Matthew Wilcox <matthew@wil.cx>
+ *
+ * This file is where we call all the ethtool_ops commands to get
+ * the information ethtool needs.  We fall back to calling do_ioctl()
+ * for drivers which haven't been converted to ethtool_ops yet.
+ *
+ * It's GPL, stupid.
+ *
+ * Modification by sfeldma@pobox.com to work as backward compat
+ * solution for pre-ethtool_ops kernels.
+ * 	- copied struct ethtool_ops from ethtool.h
+ * 	- defined SET_ETHTOOL_OPS
+ * 	- put in some #ifndef NETIF_F_xxx wrappers
+ * 	- changes refs to dev->ethtool_ops to ethtool_ops
+ * 	- changed dev_ethtool to ethtool_ioctl
+ *      - remove EXPORT_SYMBOL()s
+ *      - added _kc_ prefix in built-in ethtool_op_xxx ops.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/netdevice.h>
+#include <asm/uaccess.h>
+
+#include "kcompat.h"
+
+#undef SUPPORTED_10000baseT_Full
+#define SUPPORTED_10000baseT_Full	(1 << 12)
+#undef ADVERTISED_10000baseT_Full
+#define ADVERTISED_10000baseT_Full	(1 << 12)
+#undef SPEED_10000
+#define SPEED_10000		10000
+
+#undef ethtool_ops
+#define ethtool_ops _kc_ethtool_ops
+
+struct _kc_ethtool_ops {
+	int  (*get_settings)(struct net_device *, struct ethtool_cmd *);
+	int  (*set_settings)(struct net_device *, struct ethtool_cmd *);
+	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+	int  (*get_regs_len)(struct net_device *);
+	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+	int  (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+	u32  (*get_msglevel)(struct net_device *);
+	void (*set_msglevel)(struct net_device *, u32);
+	int  (*nway_reset)(struct net_device *);
+	u32  (*get_link)(struct net_device *);
+	int  (*get_eeprom_len)(struct net_device *);
+	int  (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+	int  (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+	int  (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
+	int  (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
+	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
+	int  (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
+	void (*get_pauseparam)(struct net_device *,
+	                       struct ethtool_pauseparam*);
+	int  (*set_pauseparam)(struct net_device *,
+	                       struct ethtool_pauseparam*);
+	u32  (*get_rx_csum)(struct net_device *);
+	int  (*set_rx_csum)(struct net_device *, u32);
+	u32  (*get_tx_csum)(struct net_device *);
+	int  (*set_tx_csum)(struct net_device *, u32);
+	u32  (*get_sg)(struct net_device *);
+	int  (*set_sg)(struct net_device *, u32);
+	u32  (*get_tso)(struct net_device *);
+	int  (*set_tso)(struct net_device *, u32);
+	int  (*self_test_count)(struct net_device *);
+	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+	void (*get_strings)(struct net_device *, u32 stringset, u8 *);
+	int  (*phys_id)(struct net_device *, u32);
+	int  (*get_stats_count)(struct net_device *);
+	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *,
+	                          u64 *);
+} *ethtool_ops = NULL;
+
+#undef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev, ops) (ethtool_ops = (ops))
+
+/*
+ * Some useful ethtool_ops methods that are device independent. If we find that
+ * all drivers want to do the same thing here, we can turn these into dev_()
+ * function calls.
+ */
+
+#undef ethtool_op_get_link
+#define ethtool_op_get_link _kc_ethtool_op_get_link
+u32 _kc_ethtool_op_get_link(struct net_device *dev)
+{
+	return netif_carrier_ok(dev) ? 1 : 0;
+}
+
+#undef ethtool_op_get_tx_csum
+#define ethtool_op_get_tx_csum _kc_ethtool_op_get_tx_csum
+u32 _kc_ethtool_op_get_tx_csum(struct net_device *dev)
+{
+#ifdef NETIF_F_IP_CSUM
+	return (dev->features & NETIF_F_IP_CSUM) != 0;
+#else
+	return 0;
+#endif
+}
+
+#undef ethtool_op_set_tx_csum
+#define ethtool_op_set_tx_csum _kc_ethtool_op_set_tx_csum
+int _kc_ethtool_op_set_tx_csum(struct net_device *dev, u32 data)
+{
+#ifdef NETIF_F_IP_CSUM
+	if (data)
+#ifdef NETIF_F_IPV6_CSUM
+		dev->features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+	else
+		dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+#else
+		dev->features |= NETIF_F_IP_CSUM;
+	else
+		dev->features &= ~NETIF_F_IP_CSUM;
+#endif
+#endif
+
+	return 0;
+}
+
+#undef ethtool_op_get_sg
+#define ethtool_op_get_sg _kc_ethtool_op_get_sg
+u32 _kc_ethtool_op_get_sg(struct net_device *dev)
+{
+#ifdef NETIF_F_SG
+	return (dev->features & NETIF_F_SG) != 0;
+#else
+	return 0;
+#endif
+}
+
+#undef ethtool_op_set_sg
+#define ethtool_op_set_sg _kc_ethtool_op_set_sg
+int _kc_ethtool_op_set_sg(struct net_device *dev, u32 data)
+{
+#ifdef NETIF_F_SG
+	if (data)
+		dev->features |= NETIF_F_SG;
+	else
+		dev->features &= ~NETIF_F_SG;
+#endif
+
+	return 0;
+}
+
+#undef ethtool_op_get_tso
+#define ethtool_op_get_tso _kc_ethtool_op_get_tso
+u32 _kc_ethtool_op_get_tso(struct net_device *dev)
+{
+#ifdef NETIF_F_TSO
+	return (dev->features & NETIF_F_TSO) != 0;
+#else
+	return 0;
+#endif
+}
+
+#undef ethtool_op_set_tso
+#define ethtool_op_set_tso _kc_ethtool_op_set_tso
+int _kc_ethtool_op_set_tso(struct net_device *dev, u32 data)
+{
+#ifdef NETIF_F_TSO
+	if (data)
+		dev->features |= NETIF_F_TSO;
+	else
+		dev->features &= ~NETIF_F_TSO;
+#endif
+
+	return 0;
+}
+
+/* Handlers for each ethtool command */
+
+static int ethtool_get_settings(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_cmd cmd = { ETHTOOL_GSET };
+	int err;
+
+	if (!ethtool_ops->get_settings)
+		return -EOPNOTSUPP;
+
+	err = ethtool_ops->get_settings(dev, &cmd);
+	if (err < 0)
+		return err;
+
+	if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_settings(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_cmd cmd;
+
+	if (!ethtool_ops->set_settings)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+		return -EFAULT;
+
+	return ethtool_ops->set_settings(dev, &cmd);
+}
+
+static int ethtool_get_drvinfo(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_drvinfo info;
+	struct ethtool_ops *ops = ethtool_ops;
+
+	if (!ops->get_drvinfo)
+		return -EOPNOTSUPP;
+
+	memset(&info, 0, sizeof(info));
+	info.cmd = ETHTOOL_GDRVINFO;
+	ops->get_drvinfo(dev, &info);
+
+	if (ops->self_test_count)
+		info.testinfo_len = ops->self_test_count(dev);
+	if (ops->get_stats_count)
+		info.n_stats = ops->get_stats_count(dev);
+	if (ops->get_regs_len)
+		info.regdump_len = ops->get_regs_len(dev);
+	if (ops->get_eeprom_len)
+		info.eedump_len = ops->get_eeprom_len(dev);
+
+	if (copy_to_user(useraddr, &info, sizeof(info)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_get_regs(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_regs regs;
+	struct ethtool_ops *ops = ethtool_ops;
+	void *regbuf;
+	int reglen, ret;
+
+	if (!ops->get_regs || !ops->get_regs_len)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&regs, useraddr, sizeof(regs)))
+		return -EFAULT;
+
+	reglen = ops->get_regs_len(dev);
+	if (regs.len > reglen)
+		regs.len = reglen;
+
+	regbuf = kmalloc(reglen, GFP_USER);
+	if (!regbuf)
+		return -ENOMEM;
+
+	ops->get_regs(dev, &regs, regbuf);
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &regs, sizeof(regs)))
+		goto out;
+	useraddr += offsetof(struct ethtool_regs, data);
+	if (copy_to_user(useraddr, regbuf, reglen))
+		goto out;
+	ret = 0;
+
+out:
+	kfree(regbuf);
+	return ret;
+}
+
+static int ethtool_get_wol(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+	if (!ethtool_ops->get_wol)
+		return -EOPNOTSUPP;
+
+	ethtool_ops->get_wol(dev, &wol);
+
+	if (copy_to_user(useraddr, &wol, sizeof(wol)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_wol(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_wolinfo wol;
+
+	if (!ethtool_ops->set_wol)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&wol, useraddr, sizeof(wol)))
+		return -EFAULT;
+
+	return ethtool_ops->set_wol(dev, &wol);
+}
+
+static int ethtool_get_msglevel(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+
+	if (!ethtool_ops->get_msglevel)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_msglevel(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_msglevel(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata;
+
+	if (!ethtool_ops->set_msglevel)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&edata, useraddr, sizeof(edata)))
+		return -EFAULT;
+
+	ethtool_ops->set_msglevel(dev, edata.data);
+	return 0;
+}
+
+static int ethtool_nway_reset(struct net_device *dev)
+{
+	if (!ethtool_ops->nway_reset)
+		return -EOPNOTSUPP;
+
+	return ethtool_ops->nway_reset(dev);
+}
+
+static int ethtool_get_link(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GLINK };
+
+	if (!ethtool_ops->get_link)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_link(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_get_eeprom(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_eeprom eeprom;
+	struct ethtool_ops *ops = ethtool_ops;
+	u8 *data;
+	int ret;
+
+	if (!ops->get_eeprom || !ops->get_eeprom_len)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+		return -EFAULT;
+
+	/* Check for wrap and zero */
+	if (eeprom.offset + eeprom.len <= eeprom.offset)
+		return -EINVAL;
+
+	/* Check for exceeding total eeprom len */
+	if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+		return -EINVAL;
+
+	data = kmalloc(eeprom.len, GFP_USER);
+	if (!data)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+		goto out;
+
+	ret = ops->get_eeprom(dev, &eeprom, data);
+	if (ret)
+		goto out;
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))
+		goto out;
+	if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+		goto out;
+	ret = 0;
+
+out:
+	kfree(data);
+	return ret;
+}
+
+static int ethtool_set_eeprom(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_eeprom eeprom;
+	struct ethtool_ops *ops = ethtool_ops;
+	u8 *data;
+	int ret;
+
+	if (!ops->set_eeprom || !ops->get_eeprom_len)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+		return -EFAULT;
+
+	/* Check for wrap and zero */
+	if (eeprom.offset + eeprom.len <= eeprom.offset)
+		return -EINVAL;
+
+	/* Check for exceeding total eeprom len */
+	if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+		return -EINVAL;
+
+	data = kmalloc(eeprom.len, GFP_USER);
+	if (!data)
+		return -ENOMEM;
+
+	ret = -EFAULT;
+	if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+		goto out;
+
+	ret = ops->set_eeprom(dev, &eeprom, data);
+	if (ret)
+		goto out;
+
+	if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+		ret = -EFAULT;
+
+out:
+	kfree(data);
+	return ret;
+}
+
+static int ethtool_get_coalesce(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_coalesce coalesce = { ETHTOOL_GCOALESCE };
+
+	if (!ethtool_ops->get_coalesce)
+		return -EOPNOTSUPP;
+
+	ethtool_ops->get_coalesce(dev, &coalesce);
+
+	if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_coalesce(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_coalesce coalesce;
+
+	if (!ethtool_ops->get_coalesce)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))
+		return -EFAULT;
+
+	return ethtool_ops->set_coalesce(dev, &coalesce);
+}
+
+static int ethtool_get_ringparam(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_ringparam ringparam = { ETHTOOL_GRINGPARAM };
+
+	if (!ethtool_ops->get_ringparam)
+		return -EOPNOTSUPP;
+
+	ethtool_ops->get_ringparam(dev, &ringparam);
+
+	if (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_ringparam(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_ringparam ringparam;
+
+	if (!ethtool_ops->get_ringparam)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))
+		return -EFAULT;
+
+	return ethtool_ops->set_ringparam(dev, &ringparam);
+}
+
+static int ethtool_get_pauseparam(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_pauseparam pauseparam = { ETHTOOL_GPAUSEPARAM };
+
+	if (!ethtool_ops->get_pauseparam)
+		return -EOPNOTSUPP;
+
+	ethtool_ops->get_pauseparam(dev, &pauseparam);
+
+	if (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_pauseparam(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_pauseparam pauseparam;
+
+	if (!ethtool_ops->get_pauseparam)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))
+		return -EFAULT;
+
+	return ethtool_ops->set_pauseparam(dev, &pauseparam);
+}
+
+static int ethtool_get_rx_csum(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+	if (!ethtool_ops->get_rx_csum)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_rx_csum(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_rx_csum(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata;
+
+	if (!ethtool_ops->set_rx_csum)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&edata, useraddr, sizeof(edata)))
+		return -EFAULT;
+
+	ethtool_ops->set_rx_csum(dev, edata.data);
+	return 0;
+}
+
+static int ethtool_get_tx_csum(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+	if (!ethtool_ops->get_tx_csum)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_tx_csum(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_tx_csum(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata;
+
+	if (!ethtool_ops->set_tx_csum)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&edata, useraddr, sizeof(edata)))
+		return -EFAULT;
+
+	return ethtool_ops->set_tx_csum(dev, edata.data);
+}
+
+static int ethtool_get_sg(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GSG };
+
+	if (!ethtool_ops->get_sg)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_sg(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_sg(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata;
+
+	if (!ethtool_ops->set_sg)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&edata, useraddr, sizeof(edata)))
+		return -EFAULT;
+
+	return ethtool_ops->set_sg(dev, edata.data);
+}
+
+static int ethtool_get_tso(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata = { ETHTOOL_GTSO };
+
+	if (!ethtool_ops->get_tso)
+		return -EOPNOTSUPP;
+
+	edata.data = ethtool_ops->get_tso(dev);
+
+	if (copy_to_user(useraddr, &edata, sizeof(edata)))
+		return -EFAULT;
+	return 0;
+}
+
+static int ethtool_set_tso(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_value edata;
+
+	if (!ethtool_ops->set_tso)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&edata, useraddr, sizeof(edata)))
+		return -EFAULT;
+
+	return ethtool_ops->set_tso(dev, edata.data);
+}
+
+static int ethtool_self_test(struct net_device *dev, char *useraddr)
+{
+	struct ethtool_test test;
+	struct ethtool_ops *ops = ethtool_ops;
+	u64 *data;
+	int ret;
+
+	if (!ops->self_test || !ops->self_test_count)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&test, useraddr, sizeof(test)))
+		return -EFAULT;
+
+	test.len = ops->self_test_count(dev);
+	data = kmalloc(test.len * sizeof(u64), GFP_USER);
+	if (!data)
+		return -ENOMEM;
+
+	ops->self_test(dev, &test, data);
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &test, sizeof(test)))
+		goto out;
+	useraddr += sizeof(test);
+	if (copy_to_user(useraddr, data, test.len * sizeof(u64)))
+		goto out;
+	ret = 0;
+
+out:
+	kfree(data);
+	return ret;
+}
+
+static int ethtool_get_strings(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_gstrings gstrings;
+	struct ethtool_ops *ops = ethtool_ops;
+	u8 *data;
+	int ret;
+
+	if (!ops->get_strings)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))
+		return -EFAULT;
+
+	switch (gstrings.string_set) {
+	case ETH_SS_TEST:
+		if (!ops->self_test_count)
+			return -EOPNOTSUPP;
+		gstrings.len = ops->self_test_count(dev);
+		break;
+	case ETH_SS_STATS:
+		if (!ops->get_stats_count)
+			return -EOPNOTSUPP;
+		gstrings.len = ops->get_stats_count(dev);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	data = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);
+	if (!data)
+		return -ENOMEM;
+
+	ops->get_strings(dev, gstrings.string_set, data);
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))
+		goto out;
+	useraddr += sizeof(gstrings);
+	if (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))
+		goto out;
+	ret = 0;
+
+out:
+	kfree(data);
+	return ret;
+}
+
+static int ethtool_phys_id(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_value id;
+
+	if (!ethtool_ops->phys_id)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&id, useraddr, sizeof(id)))
+		return -EFAULT;
+
+	return ethtool_ops->phys_id(dev, id.data);
+}
+
+static int ethtool_get_stats(struct net_device *dev, void *useraddr)
+{
+	struct ethtool_stats stats;
+	struct ethtool_ops *ops = ethtool_ops;
+	u64 *data;
+	int ret;
+
+	if (!ops->get_ethtool_stats || !ops->get_stats_count)
+		return -EOPNOTSUPP;
+
+	if (copy_from_user(&stats, useraddr, sizeof(stats)))
+		return -EFAULT;
+
+	stats.n_stats = ops->get_stats_count(dev);
+	data = kmalloc(stats.n_stats * sizeof(u64), GFP_USER);
+	if (!data)
+		return -ENOMEM;
+
+	ops->get_ethtool_stats(dev, &stats, data);
+
+	ret = -EFAULT;
+	if (copy_to_user(useraddr, &stats, sizeof(stats)))
+		goto out;
+	useraddr += sizeof(stats);
+	if (copy_to_user(useraddr, data, stats.n_stats * sizeof(u64)))
+		goto out;
+	ret = 0;
+
+out:
+	kfree(data);
+	return ret;
+}
+
+/* The main entry point in this file.  Called from net/core/dev.c */
+
+#define ETHTOOL_OPS_COMPAT
+int ethtool_ioctl(struct ifreq *ifr)
+{
+	struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+	void *useraddr = (void *) ifr->ifr_data;
+	u32 ethcmd;
+
+	/*
+	 * XXX: This can be pushed down into the ethtool_* handlers that
+	 * need it.  Keep existing behavior for the moment.
+	 */
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	if (!dev || !netif_device_present(dev))
+		return -ENODEV;
+
+	if (copy_from_user(&ethcmd, useraddr, sizeof (ethcmd)))
+		return -EFAULT;
+
+	switch (ethcmd) {
+	case ETHTOOL_GSET:
+		return ethtool_get_settings(dev, useraddr);
+	case ETHTOOL_SSET:
+		return ethtool_set_settings(dev, useraddr);
+	case ETHTOOL_GDRVINFO:
+		return ethtool_get_drvinfo(dev, useraddr);
+	case ETHTOOL_GREGS:
+		return ethtool_get_regs(dev, useraddr);
+	case ETHTOOL_GWOL:
+		return ethtool_get_wol(dev, useraddr);
+	case ETHTOOL_SWOL:
+		return ethtool_set_wol(dev, useraddr);
+	case ETHTOOL_GMSGLVL:
+		return ethtool_get_msglevel(dev, useraddr);
+	case ETHTOOL_SMSGLVL:
+		return ethtool_set_msglevel(dev, useraddr);
+	case ETHTOOL_NWAY_RST:
+		return ethtool_nway_reset(dev);
+	case ETHTOOL_GLINK:
+		return ethtool_get_link(dev, useraddr);
+	case ETHTOOL_GEEPROM:
+		return ethtool_get_eeprom(dev, useraddr);
+	case ETHTOOL_SEEPROM:
+		return ethtool_set_eeprom(dev, useraddr);
+	case ETHTOOL_GCOALESCE:
+		return ethtool_get_coalesce(dev, useraddr);
+	case ETHTOOL_SCOALESCE:
+		return ethtool_set_coalesce(dev, useraddr);
+	case ETHTOOL_GRINGPARAM:
+		return ethtool_get_ringparam(dev, useraddr);
+	case ETHTOOL_SRINGPARAM:
+		return ethtool_set_ringparam(dev, useraddr);
+	case ETHTOOL_GPAUSEPARAM:
+		return ethtool_get_pauseparam(dev, useraddr);
+	case ETHTOOL_SPAUSEPARAM:
+		return ethtool_set_pauseparam(dev, useraddr);
+	case ETHTOOL_GRXCSUM:
+		return ethtool_get_rx_csum(dev, useraddr);
+	case ETHTOOL_SRXCSUM:
+		return ethtool_set_rx_csum(dev, useraddr);
+	case ETHTOOL_GTXCSUM:
+		return ethtool_get_tx_csum(dev, useraddr);
+	case ETHTOOL_STXCSUM:
+		return ethtool_set_tx_csum(dev, useraddr);
+	case ETHTOOL_GSG:
+		return ethtool_get_sg(dev, useraddr);
+	case ETHTOOL_SSG:
+		return ethtool_set_sg(dev, useraddr);
+	case ETHTOOL_GTSO:
+		return ethtool_get_tso(dev, useraddr);
+	case ETHTOOL_STSO:
+		return ethtool_set_tso(dev, useraddr);
+	case ETHTOOL_TEST:
+		return ethtool_self_test(dev, useraddr);
+	case ETHTOOL_GSTRINGS:
+		return ethtool_get_strings(dev, useraddr);
+	case ETHTOOL_PHYS_ID:
+		return ethtool_phys_id(dev, useraddr);
+	case ETHTOOL_GSTATS:
+		return ethtool_get_stats(dev, useraddr);
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+#define mii_if_info _kc_mii_if_info
+struct _kc_mii_if_info {
+	int phy_id;
+	int advertising;
+	int phy_id_mask;
+	int reg_num_mask;
+
+	unsigned int full_duplex : 1;	/* is full duplex? */
+	unsigned int force_media : 1;	/* is autoneg. disabled? */
+
+	struct net_device *dev;
+	int (*mdio_read) (struct net_device *dev, int phy_id, int location);
+	void (*mdio_write) (struct net_device *dev, int phy_id, int location, int val);
+};
+
+struct ethtool_cmd;
+struct mii_ioctl_data;
+
+#undef mii_link_ok
+#define mii_link_ok _kc_mii_link_ok
+#undef mii_nway_restart
+#define mii_nway_restart _kc_mii_nway_restart
+#undef mii_ethtool_gset
+#define mii_ethtool_gset _kc_mii_ethtool_gset
+#undef mii_ethtool_sset
+#define mii_ethtool_sset _kc_mii_ethtool_sset
+#undef mii_check_link
+#define mii_check_link _kc_mii_check_link
+extern int _kc_mii_link_ok (struct mii_if_info *mii);
+extern int _kc_mii_nway_restart (struct mii_if_info *mii);
+extern int _kc_mii_ethtool_gset(struct mii_if_info *mii,
+                                struct ethtool_cmd *ecmd);
+extern int _kc_mii_ethtool_sset(struct mii_if_info *mii,
+                                struct ethtool_cmd *ecmd);
+extern void _kc_mii_check_link (struct mii_if_info *mii);
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,4,6) )
+#undef generic_mii_ioctl
+#define generic_mii_ioctl _kc_generic_mii_ioctl
+extern int _kc_generic_mii_ioctl(struct mii_if_info *mii_if,
+                                 struct mii_ioctl_data *mii_data, int cmd,
+                                 unsigned int *duplex_changed);
+#endif /* > 2.4.6 */
+
+
+struct _kc_pci_dev_ext {
+	struct pci_dev *dev;
+	void *pci_drvdata;
+	struct pci_driver *driver;
+};
+
+struct _kc_net_dev_ext {
+	struct net_device *dev;
+	unsigned int carrier;
+};
+
+
+/**************************************/
+/* mii support */
+
+int _kc_mii_ethtool_gset(struct mii_if_info *mii, struct ethtool_cmd *ecmd)
+{
+	struct net_device *dev = mii->dev;
+	u32 advert, bmcr, lpa, nego;
+
+	ecmd->supported =
+	    (SUPPORTED_10baseT_Half | SUPPORTED_10baseT_Full |
+	     SUPPORTED_100baseT_Half | SUPPORTED_100baseT_Full |
+	     SUPPORTED_Autoneg | SUPPORTED_TP | SUPPORTED_MII);
+
+	/* only supports twisted-pair */
+	ecmd->port = PORT_MII;
+
+	/* only supports internal transceiver */
+	ecmd->transceiver = XCVR_INTERNAL;
+
+	/* this isn't fully supported at higher layers */
+	ecmd->phy_address = mii->phy_id;
+
+	ecmd->advertising = ADVERTISED_TP | ADVERTISED_MII;
+	advert = mii->mdio_read(dev, mii->phy_id, MII_ADVERTISE);
+	if (advert & ADVERTISE_10HALF)
+		ecmd->advertising |= ADVERTISED_10baseT_Half;
+	if (advert & ADVERTISE_10FULL)
+		ecmd->advertising |= ADVERTISED_10baseT_Full;
+	if (advert & ADVERTISE_100HALF)
+		ecmd->advertising |= ADVERTISED_100baseT_Half;
+	if (advert & ADVERTISE_100FULL)
+		ecmd->advertising |= ADVERTISED_100baseT_Full;
+
+	bmcr = mii->mdio_read(dev, mii->phy_id, MII_BMCR);
+	lpa = mii->mdio_read(dev, mii->phy_id, MII_LPA);
+	if (bmcr & BMCR_ANENABLE) {
+		ecmd->advertising |= ADVERTISED_Autoneg;
+		ecmd->autoneg = AUTONEG_ENABLE;
+
+		nego = mii_nway_result(advert & lpa);
+		if (nego == LPA_100FULL || nego == LPA_100HALF)
+			ecmd->speed = SPEED_100;
+		else
+			ecmd->speed = SPEED_10;
+		if (nego == LPA_100FULL || nego == LPA_10FULL) {
+			ecmd->duplex = DUPLEX_FULL;
+			mii->full_duplex = 1;
+		} else {
+			ecmd->duplex = DUPLEX_HALF;
+			mii->full_duplex = 0;
+		}
+	} else {
+		ecmd->autoneg = AUTONEG_DISABLE;
+
+		ecmd->speed = (bmcr & BMCR_SPEED100) ? SPEED_100 : SPEED_10;
+		ecmd->duplex = (bmcr & BMCR_FULLDPLX) ? DUPLEX_FULL : DUPLEX_HALF;
+	}
+
+	/* ignore maxtxpkt, maxrxpkt for now */
+
+	return 0;
+}
+
+int _kc_mii_ethtool_sset(struct mii_if_info *mii, struct ethtool_cmd *ecmd)
+{
+	struct net_device *dev = mii->dev;
+
+	if (ecmd->speed != SPEED_10 && ecmd->speed != SPEED_100)
+		return -EINVAL;
+	if (ecmd->duplex != DUPLEX_HALF && ecmd->duplex != DUPLEX_FULL)
+		return -EINVAL;
+	if (ecmd->port != PORT_MII)
+		return -EINVAL;
+	if (ecmd->transceiver != XCVR_INTERNAL)
+		return -EINVAL;
+	if (ecmd->phy_address != mii->phy_id)
+		return -EINVAL;
+	if (ecmd->autoneg != AUTONEG_DISABLE && ecmd->autoneg != AUTONEG_ENABLE)
+		return -EINVAL;
+
+	/* ignore supported, maxtxpkt, maxrxpkt */
+
+	if (ecmd->autoneg == AUTONEG_ENABLE) {
+		u32 bmcr, advert, tmp;
+
+		if ((ecmd->advertising & (ADVERTISED_10baseT_Half |
+					  ADVERTISED_10baseT_Full |
+					  ADVERTISED_100baseT_Half |
+					  ADVERTISED_100baseT_Full)) == 0)
+			return -EINVAL;
+
+		/* advertise only what has been requested */
+		advert = mii->mdio_read(dev, mii->phy_id, MII_ADVERTISE);
+		tmp = advert & ~(ADVERTISE_ALL | ADVERTISE_100BASE4);
+		if (ADVERTISED_10baseT_Half)
+			tmp |= ADVERTISE_10HALF;
+		if (ADVERTISED_10baseT_Full)
+			tmp |= ADVERTISE_10FULL;
+		if (ADVERTISED_100baseT_Half)
+			tmp |= ADVERTISE_100HALF;
+		if (ADVERTISED_100baseT_Full)
+			tmp |= ADVERTISE_100FULL;
+		if (advert != tmp) {
+			mii->mdio_write(dev, mii->phy_id, MII_ADVERTISE, tmp);
+			mii->advertising = tmp;
+		}
+
+		/* turn on autonegotiation, and force a renegotiate */
+		bmcr = mii->mdio_read(dev, mii->phy_id, MII_BMCR);
+		bmcr |= (BMCR_ANENABLE | BMCR_ANRESTART);
+		mii->mdio_write(dev, mii->phy_id, MII_BMCR, bmcr);
+
+		mii->force_media = 0;
+	} else {
+		u32 bmcr, tmp;
+
+		/* turn off auto negotiation, set speed and duplexity */
+		bmcr = mii->mdio_read(dev, mii->phy_id, MII_BMCR);
+		tmp = bmcr & ~(BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX);
+		if (ecmd->speed == SPEED_100)
+			tmp |= BMCR_SPEED100;
+		if (ecmd->duplex == DUPLEX_FULL) {
+			tmp |= BMCR_FULLDPLX;
+			mii->full_duplex = 1;
+		} else
+			mii->full_duplex = 0;
+		if (bmcr != tmp)
+			mii->mdio_write(dev, mii->phy_id, MII_BMCR, tmp);
+
+		mii->force_media = 1;
+	}
+	return 0;
+}
+
+int _kc_mii_link_ok (struct mii_if_info *mii)
+{
+	/* first, a dummy read, needed to latch some MII phys */
+	mii->mdio_read(mii->dev, mii->phy_id, MII_BMSR);
+	if (mii->mdio_read(mii->dev, mii->phy_id, MII_BMSR) & BMSR_LSTATUS)
+		return 1;
+	return 0;
+}
+
+int _kc_mii_nway_restart (struct mii_if_info *mii)
+{
+	int bmcr;
+	int r = -EINVAL;
+
+	/* if autoneg is off, it's an error */
+	bmcr = mii->mdio_read(mii->dev, mii->phy_id, MII_BMCR);
+
+	if (bmcr & BMCR_ANENABLE) {
+		bmcr |= BMCR_ANRESTART;
+		mii->mdio_write(mii->dev, mii->phy_id, MII_BMCR, bmcr);
+		r = 0;
+	}
+
+	return r;
+}
+
+void _kc_mii_check_link (struct mii_if_info *mii)
+{
+	int cur_link = mii_link_ok(mii);
+	int prev_link = netif_carrier_ok(mii->dev);
+
+	if (cur_link && !prev_link)
+		netif_carrier_on(mii->dev);
+	else if (prev_link && !cur_link)
+		netif_carrier_off(mii->dev);
+}
+
+#if ( LINUX_VERSION_CODE > KERNEL_VERSION(2,4,6) )
+int _kc_generic_mii_ioctl(struct mii_if_info *mii_if,
+                          struct mii_ioctl_data *mii_data, int cmd,
+                          unsigned int *duplex_chg_out)
+{
+	int rc = 0;
+	unsigned int duplex_changed = 0;
+
+	if (duplex_chg_out)
+		*duplex_chg_out = 0;
+
+	mii_data->phy_id &= mii_if->phy_id_mask;
+	mii_data->reg_num &= mii_if->reg_num_mask;
+
+	switch(cmd) {
+	case SIOCDEVPRIVATE:	/* binary compat, remove in 2.5 */
+	case SIOCGMIIPHY:
+		mii_data->phy_id = mii_if->phy_id;
+		/* fall through */
+
+	case SIOCDEVPRIVATE + 1:/* binary compat, remove in 2.5 */
+	case SIOCGMIIREG:
+		mii_data->val_out =
+			mii_if->mdio_read(mii_if->dev, mii_data->phy_id,
+					  mii_data->reg_num);
+		break;
+
+	case SIOCDEVPRIVATE + 2:/* binary compat, remove in 2.5 */
+	case SIOCSMIIREG: {
+		u16 val = mii_data->val_in;
+
+		if (!capable(CAP_NET_ADMIN))
+			return -EPERM;
+
+		if (mii_data->phy_id == mii_if->phy_id) {
+			switch(mii_data->reg_num) {
+			case MII_BMCR: {
+				unsigned int new_duplex = 0;
+				if (val & (BMCR_RESET|BMCR_ANENABLE))
+					mii_if->force_media = 0;
+				else
+					mii_if->force_media = 1;
+				if (mii_if->force_media &&
+				    (val & BMCR_FULLDPLX))
+					new_duplex = 1;
+				if (mii_if->full_duplex != new_duplex) {
+					duplex_changed = 1;
+					mii_if->full_duplex = new_duplex;
+				}
+				break;
+			}
+			case MII_ADVERTISE:
+				mii_if->advertising = val;
+				break;
+			default:
+				/* do nothing */
+				break;
+			}
+		}
+
+		mii_if->mdio_write(mii_if->dev, mii_data->phy_id,
+				   mii_data->reg_num, val);
+		break;
+	}
+
+	default:
+		rc = -EOPNOTSUPP;
+		break;
+	}
+
+	if ((rc == 0) && (duplex_chg_out) && (duplex_changed))
+		*duplex_chg_out = 1;
+
+	return rc;
+}
+#endif /* > 2.4.6 */
+
diff --git a/drivers/net/ethernet/intel/ixgbe/kcompat_overflow.h b/drivers/net/ethernet/intel/ixgbe/kcompat_overflow.h
new file mode 100644
index 000000000000..3a306462a24e
--- /dev/null
+++ b/drivers/net/ethernet/intel/ixgbe/kcompat_overflow.h
@@ -0,0 +1,319 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 1999 - 2020 Intel Corporation. */
+
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+#ifndef __LINUX_OVERFLOW_H
+#define __LINUX_OVERFLOW_H
+
+#include <linux/compiler.h>
+
+/*
+ * In the fallback code below, we need to compute the minimum and
+ * maximum values representable in a given type. These macros may also
+ * be useful elsewhere, so we provide them outside the
+ * COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW block.
+ *
+ * It would seem more obvious to do something like
+ *
+ * #define type_min(T) (T)(is_signed_type(T) ? (T)1 << (8*sizeof(T)-1) : 0)
+ * #define type_max(T) (T)(is_signed_type(T) ? ((T)1 << (8*sizeof(T)-1)) - 1 : ~(T)0)
+ *
+ * Unfortunately, the middle expressions, strictly speaking, have
+ * undefined behaviour, and at least some versions of gcc warn about
+ * the type_max expression (but not if -fsanitize=undefined is in
+ * effect; in that case, the warning is deferred to runtime...).
+ *
+ * The slightly excessive casting in type_min is to make sure the
+ * macros also produce sensible values for the exotic type _Bool. [The
+ * overflow checkers only almost work for _Bool, but that's
+ * a-feature-not-a-bug, since people shouldn't be doing arithmetic on
+ * _Bools. Besides, the gcc builtins don't allow _Bool* as third
+ * argument.]
+ *
+ * Idea stolen from
+ * https://mail-index.netbsd.org/tech-misc/2007/02/05/0000.html -
+ * credit to Christian Biere.
+ */
+/* The is_signed_type macro is redefined in a few places in various kernel
+ * headers. If this header is included at the same time as one of those, we
+ * will generate compilation warnings. Since we can't fix every old kernel,
+ * rename is_signed_type for this file to _kc_is_signed_type. This prevents
+ * the macro name collision, and should be safe since our drivers do not
+ * directly call the macro.
+ */
+#define _kc_is_signed_type(type)       (((type)(-1)) < (type)1)
+#define __type_half_max(type) ((type)1 << (8*sizeof(type) - 1 - _kc_is_signed_type(type)))
+#define type_max(T) ((T)((__type_half_max(T) - 1) + __type_half_max(T)))
+#define type_min(T) ((T)((T)-type_max(T)-(T)1))
+
+
+#ifdef COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW
+/*
+ * For simplicity and code hygiene, the fallback code below insists on
+ * a, b and *d having the same type (similar to the min() and max()
+ * macros), whereas gcc's type-generic overflow checkers accept
+ * different types. Hence we don't just make check_add_overflow an
+ * alias for __builtin_add_overflow, but add type checks similar to
+ * below.
+ */
+#define check_add_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_add_overflow(__a, __b, __d);	\
+})
+
+#define check_sub_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_sub_overflow(__a, __b, __d);	\
+})
+
+#define check_mul_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	__builtin_mul_overflow(__a, __b, __d);	\
+})
+
+#else
+
+
+/* Checking for unsigned overflow is relatively easy without causing UB. */
+#define __unsigned_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a + __b;			\
+	*__d < __a;				\
+})
+#define __unsigned_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = __a - __b;			\
+	__a < __b;				\
+})
+/*
+ * If one of a or b is a compile-time constant, this avoids a division.
+ */
+#define __unsigned_mul_overflow(a, b, d) ({		\
+	typeof(a) __a = (a);				\
+	typeof(b) __b = (b);				\
+	typeof(d) __d = (d);				\
+	(void) (&__a == &__b);				\
+	(void) (&__a == __d);				\
+	*__d = __a * __b;				\
+	__builtin_constant_p(__b) ?			\
+	  __b > 0 && __a > type_max(typeof(__a)) / __b : \
+	  __a > 0 && __b > type_max(typeof(__b)) / __a;	 \
+})
+
+/*
+ * For signed types, detecting overflow is much harder, especially if
+ * we want to avoid UB. But the interface of these macros is such that
+ * we must provide a result in *d, and in fact we must produce the
+ * result promised by gcc's builtins, which is simply the possibly
+ * wrapped-around value. Fortunately, we can just formally do the
+ * operations in the widest relevant unsigned type (u64) and then
+ * truncate the result - gcc is smart enough to generate the same code
+ * with and without the (u64) casts.
+ */
+
+/*
+ * Adding two signed integers can overflow only if they have the same
+ * sign, and overflow has happened iff the result has the opposite
+ * sign.
+ */
+#define __signed_add_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a + (u64)__b;		\
+	(((~(__a ^ __b)) & (*__d ^ __a))	\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Subtraction is similar, except that overflow can now happen only
+ * when the signs are opposite. In this case, overflow has happened if
+ * the result has the opposite sign of a.
+ */
+#define __signed_sub_overflow(a, b, d) ({	\
+	typeof(a) __a = (a);			\
+	typeof(b) __b = (b);			\
+	typeof(d) __d = (d);			\
+	(void) (&__a == &__b);			\
+	(void) (&__a == __d);			\
+	*__d = (u64)__a - (u64)__b;		\
+	((((__a ^ __b)) & (*__d ^ __a))		\
+		& type_min(typeof(__a))) != 0;	\
+})
+
+/*
+ * Signed multiplication is rather hard. gcc always follows C99, so
+ * division is truncated towards 0. This means that we can write the
+ * overflow check like this:
+ *
+ * (a > 0 && (b > MAX/a || b < MIN/a)) ||
+ * (a < -1 && (b > MIN/a || b < MAX/a) ||
+ * (a == -1 && b == MIN)
+ *
+ * The redundant casts of -1 are to silence an annoying -Wtype-limits
+ * (included in -Wextra) warning: When the type is u8 or u16, the
+ * __b_c_e in check_mul_overflow obviously selects
+ * __unsigned_mul_overflow, but unfortunately gcc still parses this
+ * code and warns about the limited range of __b.
+ */
+
+#define __signed_mul_overflow(a, b, d) ({				\
+	typeof(a) __a = (a);						\
+	typeof(b) __b = (b);						\
+	typeof(d) __d = (d);						\
+	typeof(a) __tmax = type_max(typeof(a));				\
+	typeof(a) __tmin = type_min(typeof(a));				\
+	(void) (&__a == &__b);						\
+	(void) (&__a == __d);						\
+	*__d = (u64)__a * (u64)__b;					\
+	(__b > 0   && (__a > __tmax/__b || __a < __tmin/__b)) ||	\
+	(__b < (typeof(__b))-1  && (__a > __tmin/__b || __a < __tmax/__b)) || \
+	(__b == (typeof(__b))-1 && __a == __tmin);			\
+})
+
+
+#define check_add_overflow(a, b, d)					\
+	__builtin_choose_expr(_kc_is_signed_type(typeof(a)),		\
+			__signed_add_overflow(a, b, d),			\
+			__unsigned_add_overflow(a, b, d))
+
+#define check_sub_overflow(a, b, d)					\
+	__builtin_choose_expr(_kc_is_signed_type(typeof(a)),		\
+			__signed_sub_overflow(a, b, d),			\
+			__unsigned_sub_overflow(a, b, d))
+
+#define check_mul_overflow(a, b, d)					\
+	__builtin_choose_expr(_kc_is_signed_type(typeof(a)),		\
+			__signed_mul_overflow(a, b, d),			\
+			__unsigned_mul_overflow(a, b, d))
+
+
+#endif /* COMPILER_HAS_GENERIC_BUILTIN_OVERFLOW */
+
+/** check_shl_overflow() - Calculate a left-shifted value and check overflow
+ *
+ * @a: Value to be shifted
+ * @s: How many bits left to shift
+ * @d: Pointer to where to store the result
+ *
+ * Computes *@d = (@a << @s)
+ *
+ * Returns true if '*d' cannot hold the result or when 'a << s' doesn't
+ * make sense. Example conditions:
+ * - 'a << s' causes bits to be lost when stored in *d.
+ * - 's' is garbage (e.g. negative) or so large that the result of
+ *   'a << s' is guaranteed to be 0.
+ * - 'a' is negative.
+ * - 'a << s' sets the sign bit, if any, in '*d'.
+ *
+ * '*d' will hold the results of the attempted shift, but is not
+ * considered "safe for use" if false is returned.
+ */
+#define check_shl_overflow(a, s, d) ({					\
+	typeof(a) _a = a;						\
+	typeof(s) _s = s;						\
+	typeof(d) _d = d;						\
+	u64 _a_full = _a;						\
+	unsigned int _to_shift =					\
+		_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;		\
+	*_d = (_a_full << _to_shift);					\
+	(_to_shift != _s || *_d < 0 || _a < 0 ||			\
+		(*_d >> _to_shift) != _a);				\
+})
+
+/**
+ * array_size() - Calculate size of 2-dimensional array.
+ *
+ * @a: dimension one
+ * @b: dimension two
+ *
+ * Calculates size of 2-dimensional array: @a * @b.
+ *
+ * Returns: number of bytes needed to represent the array or SIZE_MAX on
+ * overflow.
+ */
+static inline __must_check size_t array_size(size_t a, size_t b)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(a, b, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+/**
+ * array3_size() - Calculate size of 3-dimensional array.
+ *
+ * @a: dimension one
+ * @b: dimension two
+ * @c: dimension three
+ *
+ * Calculates size of 3-dimensional array: @a * @b * @c.
+ *
+ * Returns: number of bytes needed to represent the array or SIZE_MAX on
+ * overflow.
+ */
+static inline __must_check size_t array3_size(size_t a, size_t b, size_t c)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(a, b, &bytes))
+		return SIZE_MAX;
+	if (check_mul_overflow(bytes, c, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+static inline __must_check size_t __ab_c_size(size_t n, size_t size, size_t c)
+{
+	size_t bytes;
+
+	if (check_mul_overflow(n, size, &bytes))
+		return SIZE_MAX;
+	if (check_add_overflow(bytes, c, &bytes))
+		return SIZE_MAX;
+
+	return bytes;
+}
+
+/**
+ * struct_size() - Calculate size of structure with trailing array.
+ * @p: Pointer to the structure.
+ * @member: Name of the array member.
+ * @n: Number of elements in the array.
+ *
+ * Calculates size of memory needed for structure @p followed by an
+ * array of @n @member elements.
+ *
+ * Return: number of bytes needed or SIZE_MAX on overflow.
+ */
+#define struct_size(p, member, n)					\
+	__ab_c_size(n,							\
+		    sizeof(*(p)->member) + __must_be_array((p)->member),\
+		    sizeof(*(p)))
+
+#endif /* __LINUX_OVERFLOW_H */
